<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="OC,iOS,">










<meta name="description" content="最近看了李刚的疯狂系列书籍之疯狂iOS，基本将整个iOS知识体系涵盖在内，本篇主要将《疯狂iOS讲义》上册的第一部分的重点知识列举一下，包括 iOS应用与开发环境、数据类型和运算符、流程控制与数组、C语言特性、面向对象（上）、面向对象（下）、Foundation框架详解、文件I/O、iOS应用开发入门 这几章知识点。 iOS应用与开发环境OC与iOS简介搭建iOS开发环境第一个OC程序熟悉Xcod">
<meta name="keywords" content="OC,iOS">
<meta property="og:type" content="article">
<meta property="og:title" content="疯狂iOS上册第一部分">
<meta property="og:url" content="https://frandfeng.github.io/2014/03/28/疯狂iOS上册-第一部分/index.html">
<meta property="og:site_name" content="Frand Feng">
<meta property="og:description" content="最近看了李刚的疯狂系列书籍之疯狂iOS，基本将整个iOS知识体系涵盖在内，本篇主要将《疯狂iOS讲义》上册的第一部分的重点知识列举一下，包括 iOS应用与开发环境、数据类型和运算符、流程控制与数组、C语言特性、面向对象（上）、面向对象（下）、Foundation框架详解、文件I/O、iOS应用开发入门 这几章知识点。 iOS应用与开发环境OC与iOS简介搭建iOS开发环境第一个OC程序熟悉Xcod">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-11-25T07:51:06.649Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="疯狂iOS上册第一部分">
<meta name="twitter:description" content="最近看了李刚的疯狂系列书籍之疯狂iOS，基本将整个iOS知识体系涵盖在内，本篇主要将《疯狂iOS讲义》上册的第一部分的重点知识列举一下，包括 iOS应用与开发环境、数据类型和运算符、流程控制与数组、C语言特性、面向对象（上）、面向对象（下）、Foundation框架详解、文件I/O、iOS应用开发入门 这几章知识点。 iOS应用与开发环境OC与iOS简介搭建iOS开发环境第一个OC程序熟悉Xcod">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://frandfeng.github.io/2014/03/28/疯狂iOS上册-第一部分/">





  <title>疯狂iOS上册第一部分 | Frand Feng</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?033e49e2955598a86e6aef7bb5784a98";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Frand Feng</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Win yourself to succeed!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://frandfeng.github.io/2014/03/28/疯狂iOS上册-第一部分/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frand Feng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frand Feng">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">疯狂iOS上册第一部分</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-03-28T00:00:00+08:00">
                2014-03-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>最近看了李刚的疯狂系列书籍之疯狂iOS，基本将整个iOS知识体系涵盖在内，本篇主要将《疯狂iOS讲义》上册的第一部分的重点知识列举一下，包括 iOS应用与开发环境、数据类型和运算符、流程控制与数组、C语言特性、面向对象（上）、面向对象（下）、Foundation框架详解、文件I/O、iOS应用开发入门 这几章知识点。</p>
<h2 id="iOS应用与开发环境"><a href="#iOS应用与开发环境" class="headerlink" title="iOS应用与开发环境"></a>iOS应用与开发环境</h2><h3 id="OC与iOS简介"><a href="#OC与iOS简介" class="headerlink" title="OC与iOS简介"></a>OC与iOS简介</h3><h3 id="搭建iOS开发环境"><a href="#搭建iOS开发环境" class="headerlink" title="搭建iOS开发环境"></a>搭建iOS开发环境</h3><h3 id="第一个OC程序"><a href="#第一个OC程序" class="headerlink" title="第一个OC程序"></a>第一个OC程序</h3><h3 id="熟悉Xcode"><a href="#熟悉Xcode" class="headerlink" title="熟悉Xcode"></a>熟悉Xcode</h3><blockquote>
<p>左边导航面板从左到右依次是：项目导航、符号导航、搜索导航、问题导航、测试导航、调试导航、断点导航、日志导航，快捷键是<code>command+1/2</code></p>
<p>右边检查器面板包括：文件检查器、快速帮助检查器、身份检查器、属性检查器、大小检查器、连接检查器,快捷键是<code>command+option+1/2</code></p>
<p>右下端库面板包括：文件模板库、代码片段库、对象库、媒体库，快捷键是<code>control+option+command+1</code>;</p>
<p>Xcode的帮助系统：1，利用快速帮助面板 2，直接利用搜索 3，利用编辑区的快速帮助（按住option键）</p>
</blockquote>
<h2 id="数据类型和运算符"><a href="#数据类型和运算符" class="headerlink" title="数据类型和运算符"></a>数据类型和运算符</h2><p>OC是一门强类型的语言，强类型的含义包含两个方面</p>
<ol>
<li>所有变量必须先声明后使用</li>
<li>指定类型的变量只能接收类型与之匹配的值</li>
</ol>
<p>强类型的语言可以在编译过程中发现源代码的错误，从而保证程序更加健壮</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>在编写程序时，应该为程序添加一些注释，用以说明某段代码的作用，或者说明某个类的用途，某个方法的功能，以及该方法的参数和返回值的数据类型和意义等，对于一份规范的程序源代码而言，注释应该占到源代码的1/3以上，注释包括两种，单行注释(//abc)和多行注释(/*abc*/)</p>
<h3 id="标识符和变量"><a href="#标识符和变量" class="headerlink" title="标识符和变量"></a>标识符和变量</h3><p>分隔符包括分号(;)、花括号({})、方括号([])、圆括号(())、空格( )、圆点(.)</p>
<p>标识符就是用于给程序中变量、类、方法命名的符号，OC语言的标识符必须以字母、下划线、美元符开头、后面可以跟任意数目的字母、数字、下划线和美元符</p>
<h3 id="数据类型分类"><a href="#数据类型分类" class="headerlink" title="数据类型分类"></a>数据类型分类</h3><p>OC数据类型包括:</p>
<ul>
<li>基本类型(包括整型、字符型、浮点型（float/double类型）</li>
<li>枚举型(定义类型：enum season {spring, summer, fall, winter} 定义变量 enum season myLove,yourLove))</li>
<li>构造类型(包括数组类型、结构体类型、共用体类型)</li>
<li>指针类型 type varName;</li>
</ul>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>OC程序中，不同的基本类型的值经常需要相互转换，一般有两种转换方式</p>
<ul>
<li>自动类型转换（系统支持）</li>
<li>强制类型转换(运算符是圆括号)</li>
</ul>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>运算符是一种特殊的符号，用于表示数据的运算、赋值和比较。OC运算符包括：</p>
<ul>
<li>算数运算符</li>
<li>赋值运算符</li>
<li>比较运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>类型相关运算符</li>
</ul>
<blockquote>
<p>运算符的优先级：分隔符(各种括号)&gt;单目运算符&gt;强制类型转换符&gt;乘除求余&gt;加减法&gt;移位运算符&gt;关系运算符&gt;等价运算符&gt;按位与&gt;按位异或&gt;按位或&gt;条件与&gt;条件或&gt;三目运算符&gt;赋值&gt;逗号运算符</p>
<ul>
<li>不要把一个表达式写得过于复杂，如果比较复杂，则应该分成几步来处理</li>
<li>不要过多依赖运算符的优先级来控制表达式的执行顺序，这会降低程序的可读性，应尽量使用()来控制表达式的执行顺序</li>
</ul>
</blockquote>
<h2 id="流程控制与数组"><a href="#流程控制与数组" class="headerlink" title="流程控制与数组"></a>流程控制与数组</h2><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><p>顺序结构就是程序从上到下一行一行地执行，中间没有任何判断和跳转</p>
<h3 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h3><ul>
<li><p>if语句使用布尔表达式或布尔值作为分支条件来进行分支控制</p>
<pre><code>if () {

} else if () {

} else {

}
</code></pre></li>
<li><p>switch语句则用于对多个值进行匹配（byte、short、char、int），从而实现分支控制</p>
<pre><code>switch() {
    case:condition1 {
        ***;
        break；
    }
    case:condition2 {
        ***;
        break；
    }
    default: {
        ***;
    }
}
</code></pre></li>
</ul>
<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><p>循环结构包含如下4个部分</p>
<ul>
<li>初始化语句</li>
<li>循环条件</li>
<li>循环体</li>
<li>迭代语句</li>
</ul>
<pre><code>[init_statements];
while(test_expression) {
    statements;
    [iteration_statements];
}

[init_statements];
do {
    statements;
    [iteration_statements;
} while(test_expression)

for([init_statements];[test_expression];[iteration_statement]) {
    statements;
}
</code></pre><h3 id="控制循环结构"><a href="#控制循环结构" class="headerlink" title="控制循环结构"></a>控制循环结构</h3><p>OC提供了continue和break来控制循环语句，除此之外，return可以结束整个方法，当然也就结束了一次循环</p>
<p>break用于完全结束一个循环，continue的功能和break有点类似，区别是continue只是终止本次循环，接着开始下一次循环，而return是结束整个循环体并结束整个函数，效果范围从小到大依次是continue-&gt;break-&gt;return</p>
<h3 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h3><p>goto语句功能非常强大，它被称为无条件跳转，但由于goto语句功能太强大，而且这种跳转是随心所欲的，因此过度使用会导致程序的可读性大幅度降低，所以建议尽量少用goto语句</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组定义 type arrayName[length] 元素的地址, = 首地址 + 数组变量所占的内存大小 * 索引</p>
<h2 id="C语言特性"><a href="#C语言特性" class="headerlink" title="C语言特性"></a>C语言特性</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数返回值 函数名(形参列表){//由零条到多条可执行性语句组成的函数}函数的传值一般都是值传递，将实参的值拷贝一份传入函数</p>
<p>根据函数能否被其他源文件调用，可以将函数分为内部函数和外部函数，内部函数由static修饰，外部函数由extern修饰</p>
<h3 id="局部变量与全局变量"><a href="#局部变量与全局变量" class="headerlink" title="局部变量与全局变量"></a>局部变量与全局变量</h3><p>函数内部定义的变量是局部变量，局部变量在该函数内部有效；函数外部定义的变量是全局变量，全局变量可以被该源文件中的所有函数访问</p>
<ul>
<li>局部变量根据定义的形式不同又分三种：1，形参 2，函数局部变量 3，代码块局部变量</li>
<li>在函数内部，如果局部变量和全局变量同名，则局部变量会覆盖全局变量，即在函数内部，全局变量会失效</li>
<li>extern 修饰的变量称外部全局变量 static 修饰的变量称内部全局变量</li>
<li>从变量的存储机制来看，C语言的变量可分为动态存储变量和静态存储变量，动态：程序运行时动态分配内存 静态：运行开始就分配了固定内存</li>
</ul>
<p>就C语言程序运行的内存来说，大致分为五部分：</p>
<ul>
<li>程序区(存放函数体的二进制代码)</li>
<li>栈(由编译器自动分配释放 ，存放函数的参数值，局部变量的值等)</li>
<li>堆区(一般由程序员alloc/malloc分配释放， 若程序员不释放，程序结束时可能由OS回收)</li>
<li>全局区(全局/静态变量)</li>
<li>文字常量区(常量字符串就是放在这里的。 程序结束后由系统释放)</li>
</ul>
<blockquote>
<p>静态存储区存放：全局变量和static修饰的局部变量</p>
<p>动态存储区存放：函数的形参变量，非static修饰的局部变量，函数执行现场数据</p>
</blockquote>
<p>为了指定变量的存储类型，可以在定义变量时指定存储类别</p>
<ul>
<li>auto自动存储动态存储区</li>
<li>static静态存储区</li>
<li>register寄存器内</li>
<li>extern外部变量声明</li>
</ul>
<p>静态局部变量会一直占据固定的内存，所有通常应该慎重使用，一般有两种情况</p>
<ul>
<li>需要变量能保留上一次调用结束时的值</li>
<li>希望变量只是被初始化一次，以后只是被引用，而不希望对其重新赋值</li>
</ul>
<h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>在编译器对程序进行编译之前，编译器会对这些预处理命令进行处理，然后将这些预处理的结果与源程序一起进行编译，预处理命令通常有两个特征</p>
<ul>
<li>预处理命令都必须以#开头</li>
<li>预处理命令通常位于程序开头部分</li>
</ul>
<p><code>#define</code> 的作用就是为字符串起一个名字，宏名称通常会全大写，宏定义不是变量，也不是常量，没有=，也没有；，其实质是查找替换的过程，如果希望提前结束宏定义，则可以使用如下语句 #undef 宏名称</p>
<p><code>#ifdef</code>、<code>#ifndef</code>、<code>#else</code>、<code>#endif</code>可执行条件编译 <code>#if</code>、<code>#elif</code>、<code>#else</code>、<code>#endif</code>可执行条件编译</p>
<p><code>#import</code>比<code>#include</code>更加智能，可判断并且避免重复导入。</p>
<ul>
<li><code>#import “”</code>先搜索当前路径，再搜索Xcode项目设置的预处理程序的搜索路径</li>
<li><code>#import &lt;&gt;</code>直接去搜索特定系统头文件路径中找，而不是在当前路径搜索</li>
</ul>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>系统需要为内存中的每个单元格编号，32位操作系统最大只能支持4GB的内存，这是因为2的32次方等于4 294 967 296</p>
<p>定义指针变量的语法格式如下：类型 *变量名 整个语法代表定义一个指向特定类型的变量的指针变量，他保存的不是普通的值，而是一个地址</p>
<p>&amp;：取地址运算符 *：取变量运算符</p>
<h3 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h3><p>数组变量的本质就是一个指针常量</p>
<h3 id="字符串与指针"><a href="#字符串与指针" class="headerlink" title="字符串与指针"></a>字符串与指针</h3><h3 id="函数与指针"><a href="#函数与指针" class="headerlink" title="函数与指针"></a>函数与指针</h3><p>C语言允许定义一个指针变量来指向函数，然后通过该指针变量来调用函数</p>
<ol>
<li>定义 函数返回值 (* 指针变量名)();</li>
<li>赋值 指针变量名=函数名</li>
<li><p>调用 (*函数指针变量)(参数)</p>
<pre><code>int (*fnPt)() = max;
int a = (*fnPt)(data, params);
</code></pre></li>
</ol>
<p>当函数返回指针时需要注意，如果返回的指针指向的是函数中的局部变量，这将非常危险，因为函数调用结束后，该函数中局部变量所占用的内存已经释放了，那么该指针指向的内存单元格中存储的数据是不确定的</p>
<h3 id="指针数组和指向指针变量的指针"><a href="#指针数组和指向指针变量的指针" class="headerlink" title="指针数组和指向指针变量的指针"></a>指针数组和指向指针变量的指针</h3><p>指针数组的定义 类型 *数组变量[长度]，主要不要写成 类型 (*数组变量)[长度] 此表示指向一个一维数组的指针</p>
<p>指向指针的指针 类型 **变量名</p>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>定义结构体 <code>struct 结构体类型名{//成员列表}</code> 定义结构体变量 struct 结构体类型名 变量名；</p>
<p>struct 结构体类型名{//成员列表}结构体变量1，结构体变量2；</p>
<p>每次定义结构体变量都会很繁琐</p>
<ul>
<li>可以使用<code>#define POINT struct 结构体类型名</code> 来预编译</li>
<li>也可以使用typedef来为已有的结构体类型定义新的名词 <code>typedef struct 结构体类名 POINT</code></li>
</ul>
<p>C语言要求在定义结构体变量时执行初始化，一旦初始化完成，或定义结构体变量时没有执行初始化，那么程序以后就不能对结构体变量整体赋值了，但可以将一个结构体变量赋值给另一个结构体变量</p>
<h3 id="块-Block"><a href="#块-Block" class="headerlink" title="块(Block)"></a>块(Block)</h3><p>块(Block)是OC对C语言做的扩展，使用块可以更好地简化OC编程，而且OC的很多API都依赖于块</p>
<p>块的定义语法：^[块返回值类型](形参类型1 形参1，形参类型2 形参2，…){//块执行体}</p>
<p>块定义与函数定义的区别</p>
<ul>
<li>^开头</li>
<li>返回值类型可省略</li>
<li>无需指定块名</li>
<li>参数部分的括号不可省略，如果没参数，用void代替</li>
</ul>
<p>可以定义块变量：块返回值类型 (^块变量名)(形参类型1，形参类型2，…);</p>
<p>_block修饰的局部变量表示，无论何时，块都会直接使用该局部变量本身，而不是将局部变量的值赋值到块范围内</p>
<p>可以直接使用块作为函数的参数</p>
<p>使用typedef可以定义块类型，用途主要有二 1，复用块类型，可以定义出多个块变量 2，使用块类型定义函数参数</p>
<p>定义块类型的语法格式：typedef 块返回值类型 (^块类型)(形参类型1 形参1， 形参类型2 形参2，…);</p>
<h2 id="面向对象（上）"><a href="#面向对象（上）" class="headerlink" title="面向对象（上）"></a>面向对象（上）</h2><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>我们可以把类当成一种自定义数据类型，可以使用类来定义变量，这种类型的变量相当于指针类型的变量。OC中定义类分为两个步骤：</p>
<ol>
<li>接口部分：定义该类包含的成员变量和方法</li>
<li>实现部分：为该类的方法提供实现</li>
</ol>
<p>OC将类分为接口部分和实现部分体现了良好的封装意识，在接口部分定义的内容(包括成员变量和方法)都是可以暴露且可供用户调用的部分，实现部分则属于类的内部实现，对于外界而言是隐藏的，不能供外界调用</p>
<p>OC语言关于方法调用有两种说法，调用方法和发送消息，对于[person abc]语句，可以说成person对象调用abc方法，此时person是方法调用者，也可以说成向person发送abc消息，此时person是消息接收者</p>
<p>类是一种指针类型的变量，因此，程序中定义的FKPerson类型只是存放一个地址值，被保存在动态存储区，它指向实际的FKPerson对象，而真正的FKPerson存放在堆内存中</p>
<p>OC提供了一个id类型，这个类型可以代表所有的对象的类型，程序在编译时不需要确定类型，而在运行时才确定变量类型和调用的方法</p>
<h3 id="方法详解"><a href="#方法详解" class="headerlink" title="方法详解"></a>方法详解</h3><p>如果在定义方法时，在最后一个形参名后增加逗号和三点，则表明该形参可以接受多个参数值</p>
<blockquote>
<p>va_list 这是一个类型，用于定义指向可变参数列表的指针变量 va_list argList;</p>
<p>va_start 这是一个函数，该函数指定开始处理可变形参的列表，并让指针变量指向可变形参的第一个参数 va_start(argList, name);</p>
<p>va_arg 这是一个函数，该函数返回指针当前指向的参数的值，并将指针移动到指向下一个参数 NSString *arg = va_arg(argList, id);</p>
<p>va_end 结束处理可变形参，释放指针变量</p>
</blockquote>
<pre><code>va_list argList;
va_start(argList, name);//name为传入的第一个参数名
NSString *arg=va_arg(argList, id);
while(arg) {
    NSLog(@“arg=%@”,arg);
    arg=va_arg(argList, id);
}
va_end(argList);
</code></pre><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>OC中根据定义变量位置不同，可以将变量分成三大类，成员变量，局部变量和全局变量，成员变量是指在类的接口部分或实现部分定义的变量</p>
<p>虽然OC也提供了static关键字，但这个static关键字不能用于修饰成员变量，它只能修饰局部变量、全局变量和函数</p>
<ul>
<li>static修改局部变量表示将该局部变量存储到静态存储区</li>
<li>static修改全局变量用于限制改全局变量只能在当前文件源中访问</li>
<li>static修饰函数用于限制该函数只能在当前源文件中调用</li>
</ul>
<p>为了模拟类变量，可以在类实现部分定义一个static修改的全局变量，并提供一个类方法来暴露该全局变量</p>
<blockquote>
<p>在某些时候，程序多次创建某个类的对象没有任何意义，还可能造成系统性能下降，此时程序需要保证该类只有一个实例</p>
</blockquote>
<pre><code>static id instance;
+ (id)instance {
    if(!instance) {
        instance=[[super alloc] init];
    }
    return instance;
}
</code></pre><h3 id="隐藏和封装"><a href="#隐藏和封装" class="headerlink" title="隐藏和封装"></a>隐藏和封装</h3><p>封装(Encapsulation)是面向对象的三大特征之一(另外两种是继承和多态),它指的是对象的状态信息隐藏在对象内部</p>
<ol>
<li>不允许外部程序直接访问对象内部信息</li>
<li>而是通过该类所提供的方法来实现对内部信息的操作和访问</li>
</ol>
<p>OC提供了4个访问控制符：@private当前类访问权限 @package相同映像访问权限 @protected子类访问权限 @public公共访问权限</p>
<blockquote>
<p>所谓相同映像，简单的说，就是编译后生成的同一个框架或同一个执行文件(.out文件)</p>
<p>每个类常常就是一个小的模块，模块的设计需要遵循高内聚，低耦合的原则</p>
</blockquote>
<h3 id="键值编码-KVC-与键值监听-KVO"><a href="#键值编码-KVC-与键值监听-KVO" class="headerlink" title="键值编码(KVC)与键值监听(KVO)"></a>键值编码(KVC)与键值监听(KVO)</h3><p>KVC(key Value Coding)键值编码，允许以字符串形式间接操作对象的属性</p>
<ul>
<li><p><code>-setValue:forKey:/-valueForKey:</code>程序先考虑调用<code>SetName:</code>方法，再找_name的成员变量，然后再找name的成员变量，最后调用<code>setValue:forUndefinedKey:</code>方法返回异常</p>
<pre><code>-(void)setValue:(id) value forUndefinedKey:(id)key  {
    NSLog(@“您尝试设置的key值不存在”);
}

-(id)valueForUndefinedKey:(id)key {
    NSLog(@“您尝试访问的key并不存在”);
}
</code></pre></li>
<li><p>如果为基本类型设置属性为nil，会出现异常，同样需要通过</p>
<pre><code>-(void)setNilValueForKey:(id)key {
    if([key isEqualToString:@“price”]) {
        _price=0;
    } else {
        [super setNilValueForKey:key];
    }
}
</code></pre></li>
</ul>
<p>KVO(Key Value Observing)键值监听，iOS应用将程序组件分开成数据模型组件和视图组件，当数据模型组件发送变化时，可通过KVO监听其变化从而修改视图组件的属性</p>
<p><code>-(Object \*)addObserver:forKeyPath:options:context:/-removeObserver:forKeyPath:/context:</code>添加、删除监听</p>
<p><code>-(void)observeValueForKeyPath:ofObject:change:context:</code></p>
<h3 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h3><p>alloc分配内存，init完成初始化，还可以提供更多的便利初始化，如<code>-(id)initWithBrand:(NSString \*)brand</code>;</p>
<h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>OC只能单继承，每个子类最多只有一个直接父类，方法的重写必须注意方法签名关键字要完全相同，也就是方法名和方法签名中的形参标签都需要完全相同，否则就不能算方法重写或方法覆盖</p>
<p>无论父类接口部分的成员变量使用何种访问控制符限制，子类接口部分定义的成员变量都不允许与父类接口部分定义的成员变量重名</p>
<p>在类实现部分定义的成员变量将被限制在该类内部，因此，父类在类实现部分定义的成员变量对子类没有任何影响，子类此时会隐藏父类的变量</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>OC指针类型的变量有两个，一个是编译时类型，一个是运行时类型。编译时的类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。如果编译时类型和运行时类型不一致，就可能出现所谓的多态(Polymorphism)，即相同类型的变量调用同一个方法呈现出多种不同的行为特征。指针变量在编译阶段只能调用其编译时类型所具有的方法，但运行时则执行其运行时类型所具有的方法</p>
<p>指针变量的强制类型转换：<code>(type \*)variable;</code></p>
<p>当把子类对象赋值给父类指针变量时，被称为向上转型(upcasting)，这种转型总是可以成功的，执行方法时，依然表现出子类对象的行为模式，但把一个父对象赋值给子类指针变量时，就需要进行强制类型转换，而且还可能运行时产生错误，所以在强制转换之前需要先判断</p>
<ul>
<li><code>-isMemberOfClass:</code>(是否为实例)</li>
<li><code>-isKindOfClass:</code>(是否为类或子类)</li>
<li><code>-isSubClassOfClass:</code>(子类)</li>
</ul>
<h2 id="面向对象-下"><a href="#面向对象-下" class="headerlink" title="面向对象(下)"></a>面向对象(下)</h2><h3 id="OC的包装类"><a href="#OC的包装类" class="headerlink" title="OC的包装类"></a>OC的包装类</h3><p>在开发iOS时，可能会遇到NSInteger、NSUInteger、CGFloat类型，它的存在是为了更好的兼容不同的平台</p>
<pre><code>#if \_LP64\_
    typedef long NSInteger
#else
    typedef int NSInteger
#endif
</code></pre><ul>
<li>[NSNumber numberWithXXX]</li>
<li>[number initWithXXX]</li>
<li>[number XXXValue]</li>
</ul>
<h3 id="处理对象"><a href="#处理对象" class="headerlink" title="处理对象"></a>处理对象</h3><p><code>NSLog(@“%@”, p)</code>输出的是p类的description方法返回值 <code>-(NSString \*)description{return @“”}</code>;</p>
<p>== 如果是判断基本类型，只要两个变量的值相等即可，如果是两个指针类型的变量，他们必须指向同一个对象</p>
<p>isEqual默认也是比较地址，但一般需要重写才用，重写后要满足下列条件</p>
<ul>
<li>自反性[x isEqual:x]返回真</li>
<li>对称性[y isEqual:x]则[x isEqual:y]</li>
<li>传递性若[x isEqual:y][y isEqual:z]则[x isEqual:z]</li>
<li>一致性，判断多次结果一定</li>
<li>[x isEqual:nil]假</li>
</ul>
<h3 id="扩展与类别"><a href="#扩展与类别" class="headerlink" title="扩展与类别"></a>扩展与类别</h3><p>由于OC并没有提供抽象类的语法支持，而在实际项目开发中，总需要有抽象类的时候，此时就会定义一个父类，并以该父类派生多个子类，其他程序使用这些类时，总是面向父类编程，当程序调用父类的初始化方法、类方法来返回对象时，实际上返回的是子类的实例，这一系列的类被称为一个类簇(cluster)，这个父类也就模拟了抽象类的功能。</p>
<p>OC的动态特征允许使用类别为现有的类添加新方法，并且不需要创建子类，不需要访问原有类的源代码</p>
<pre><code>@interface 已有类 (类别名)

@end

@impletation 已有类 (类别名)

@end
</code></pre><p>类别可以重写原有类中的方法，但通常并不推荐这么做，如果需要重写原有类方法，一般通过原有类派生子类，在子类中重写父类原有的方法</p>
<p>通过类别为指定类添加新方法后，这个新方法还会添加到这个类的子类当中去，一个类可以增加多个类别，这些类别都可增加原有类的方法</p>
<p>类别的用法：</p>
<ol>
<li>对类进行模块化设计</li>
<li>使用类别调用私有方法</li>
<li>使用类别实现非正式协议</li>
</ol>
<p>扩展与类别相似，扩展相当于匿名类别</p>
<pre><code>@interface 已有类()

@end
</code></pre><p>但就用法来看，类别通常有单独的.h和.m文件，扩展则用于临时对某个类的接口进行扩展，类实现部分同时实现类接口部分定义的方法和扩展中定义的方法，在定义类的扩展时，可以额外增加实例变量，也可以使用@property来合成属性，但定义类的类别时，则不允许额外定义实例变量，也不能用@property合成属性</p>
<h3 id="协议-protocol-与委托-delegate"><a href="#协议-protocol-与委托-delegate" class="headerlink" title="协议(protocol)与委托(delegate)"></a>协议(protocol)与委托(delegate)</h3><p>协议定义的是多个类共同的公共行为规范，这些行为是与外部交流的通道，这就意味着协议里通常是定义一组公共方法，但不会为这些方法提供实现，方法的实现交给类去完成，即委托该类去调用方法完成任务。</p>
<p>利用类别可以实现非正式协议，这种类别以NSObject为基础，为NSObject创建类别，创建类别即可指定该类别应该新增的方法。当某个类实现NSObject的该类别时，就需要实现该类别下的所有方法，这种基于NSObject定义的类别即可认为是非正式协议。需要指出的是，对于实现非正式协议的类而言，OC编译器并不强制实现该协议中的所有方法，但如果不实现，运行时该程序就会引起错误</p>
<p>正式协议不再使用<code>@interface</code>、<code>@implementation</code>关键字，而是使用<code>@protocol</code>关键字<code>@protocol协议名&lt;父协议1，父协议2&gt;{}</code></p>
<p>协议名应与类名有相同的命名规则，一个协议可以有多个直接父协议，协议定义的方法只有方法签名，没有方法实现，可包含类方法和实例方法</p>
<p>如果需要使用协议来定义变量，则有如下两种语法：</p>
<ol>
<li><code>NSObject&lt;协议1，协议2&gt; \*变量=\*\*\*;</code></li>
<li><code>id&lt;协议1，协议2&gt; 变量=\*\*\*;</code></li>
</ol>
<p>对比正式协议和非正式协议，不难发现存在如下差异</p>
<ul>
<li>非正式协议通过NSObject创建类别来实现，而正式协议则直接使用@protocol创建</li>
<li>遵守非正式协议通过继承带特定类别的NSObject来实现，而遵守正式协议则有专门的OC语法</li>
<li>遵守非正式协议不要求实现协议中定义的所有方法，而遵守正式协议则必须实现协议中定义的所有方法</li>
</ul>
<blockquote>
<p>为了弥补正式协议必须实现协议的所有方法造成的灵活性不足，OC2.0新增了optional和required两个关键字</p>
</blockquote>
<h3 id="使用-try处理异常"><a href="#使用-try处理异常" class="headerlink" title="使用@try处理异常"></a>使用@try处理异常</h3><p>OC的异常机制并不作为常规的编程实践，通常只是作为一种程序调试排错机制</p>
<pre><code>@try {
    代码操作;
} @catch (异常1 ex) {
    ex.name;
    ex.reason;
    ex.userInfo;
} @catch (异常2 ex) {

} @finally {
    回收资源;
}
</code></pre><p>如果在某些时候，某些数据与业务规则不匹配，系统无法抛出这种异常，则需要在程序中使用@throw语句自行抛出异常，也可以抛出继承于NSException的自定义异常来@catch</p>
<h3 id="OC反射机制"><a href="#OC反射机制" class="headerlink" title="OC反射机制"></a>OC反射机制</h3><p>OC提供了3种编程方式与运行环境交互</p>
<ul>
<li>直接通过OC的源代码</li>
<li>通过NSObject类中定义的方法进行动态编程</li>
<li>直接调用运行时函数进行动态编程</li>
</ul>
<p>在OC中获得Class的方式有3种</p>
<ul>
<li>使用<code>Class NSClassFromString(NSString \*className)</code></li>
<li>调用某个类的class方法来获取该类对应的Class</li>
<li>调用某个对象的Class方法来获取该类对应的class</li>
</ul>
<p>检查继承关系：</p>
<ul>
<li><code>-isKindOfClass</code></li>
<li><code>-isMemberOfClass</code></li>
<li><code>conformsProtocol:@protocol(ProtocolName)/NSProtocolFromString(ProtocolName)</code></li>
</ul>
<blockquote>
<p>如果需要调用类中的变量，则可根据KVC机制来设置，访问</p>
<p>如果程序需要判断某个对象是否可调用某个方法，可通<code>respondsToSelector:@selector(selectorName)/NSSelectorFromString(selectorName)</code>来判断</p>
<p>如果程序需要动态调用对象的普通方法，则可通过几种方式来实现</p>
<ul>
<li><code>[self performSelector:@selector(selectorName)/NSSelectorFromString(selectorName) withObject:]</code></li>
<li><code>objc_msgSend(self, @selector(selectorName)/NSSelectorFromString(selectorName), …)</code></li>
<li>IMP方法的函数指针 <code>-(IMP)methodForSelector:@selector(selectorName)/NSSelectorFromString(selectorName)</code></li>
</ul>
</blockquote>
<pre><code>double (*addSpeed)(id, SEL, double);
返回值类型 (*指针变量名)(方法调用者, 方法， 方法参数);

addSpeed = (double(*)(id, SEL, double))[car methodForSelector:NSSelectorForString(@“addSpeed:”)];

double speed = addSpeed(car, @selector(addSpeed:), 2.4);
</code></pre><p>在开发了大量iOS项目之后，就会发现有大量代码是类似的，如果把这些通用的代码抽取成为更通用的框架，那么程序将会拥有更好的架构，当需要开发出那些具有通用性质的框架时，这些框架代码无法预先知道被调用组件的实现类，以及具有哪些方法，这些信息可能是通过配置文件给的，而这些框架必须动态地根据字符串来创建对象，根据字符来决定要初始化哪个类，调用哪个方法，这些功能都必须借助OC的反射、动态机制来实现。</p>
<h3 id="手动内存管理"><a href="#手动内存管理" class="headerlink" title="手动内存管理"></a>手动内存管理</h3><p>如果一直在分配内存，而没有回收他们，就会出现内存泄露。OC的内存回收机制有3种</p>
<ul>
<li>手动引用计数和自动释放池</li>
<li>自动引用计数(ARC)</li>
<li>自动垃圾回收(Mac应用独有)</li>
</ul>
<p>OC采用一种被称为引用计数（Reference Counting）的机制来跟踪对象的状态，每个对象都有一个与之关联的整数，被称为引用计数</p>
<p>当程序调用方法名以alloc、new、copy、mutableCopy开头的方法来创建对象时，该对象的引用计数加1</p>
<p>调用对象的retain方法时，该对象的引用计数加1，调用对象的release方法时，引用计数减1，当引用计数为0时，系统自动dealloc销毁</p>
<ul>
<li><code>-autorelease</code>：不改变该对象的引用计数的值，只是将该对象添加到自动释放池中</li>
<li><code>-retainCount</code>返回该对象的引用计数的值</li>
</ul>
<p>所谓自动释放池，就是一个存放对象的容器，自动释放池会保证延迟释放该池中所有的对象。<code>-(id)autorelease:</code>添加到自动释放池中</p>
<pre><code>NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
[pool release];
</code></pre><p>对于Foundation框架中的类而言，当调用方法创建对象时，只要这些方法不是以alloc，new，copy，mutableCopy（本来不会自动释放）开头的，系统就会默认创建自动释放对象，当自动释放池释放时，该对象就被自动释放，可称之为临时对象</p>
<p>在iOS的事件循环时，步骤1，创建自动释放池 2创建事件处理方法 3销毁自动释放池 4处理完成，所以在iOS事件循环中，应避免临时对象的出现，或通过如下方式避免事件结束时对象被回收</p>
<ul>
<li>在将临时对象赋值之前，先调用临时对象的retain方法将它的引用计数加1</li>
<li>把临时对象赋值给retain、strong或copy指示符修饰的属性</li>
</ul>
<p>手动内存管理的规则总结：</p>
<ol>
<li>调用对象的release方法并不是销毁该对象，而是将该对象的引用计数减1，当一个对象的引用计数为0时，系统自动调用dealloc来销毁</li>
<li>当自动释放池被回收时，自动释放池会依次调用每个对象的release方法，如果release后引用计数为0则销毁，否则该对象可以活下来</li>
<li>程序使用以alloc，new，copy，mutableCopy开头的方法创建对象，该对象引用计数为1，当不再使用，需release或autorelease</li>
<li>如果使用retain方法为对象增加过引用计数，则需要调用release来减少该对象的引用计数，并保证retain次数和release次数相等</li>
<li>如果在自动释放池中创建了一个临时对象，则系统会自动回收该对象，如果程序需要保留此对象，则需手动调用retain来增加引用计数</li>
</ol>
<h2 id="Foundation框架详解"><a href="#Foundation框架详解" class="headerlink" title="Foundation框架详解"></a>Foundation框架详解</h2><h3 id="字符串-NSString与NSMutableString"><a href="#字符串-NSString与NSMutableString" class="headerlink" title="字符串(NSString与NSMutableString)"></a>字符串(NSString与NSMutableString)</h3><p><code>- (NSString *)substringFromIndex:(NSUInteger)from;</code><br><code>- (void)getCharacters:(unichar *)buffer range:(NSRange)range;</code><br><code>- (BOOL)hasSuffix:(NSString *)str;</code><br><code>- (NSRange)rangeOfString:(NSString *)searchString;</code><br><code>- (NSString *)stringByAppendingString:(NSString *)aString;</code><br><code>- (NSString *)uppercaseStringWithLocale:(nullable NSLocale *)locale;</code><br><code>- (NSArray&lt;NSString *&gt; *)componentsSeparatedByString:(NSString *)separator;</code><br><code>- (void)replaceCharactersInRange:(NSRange)range withString:(NSString *)aString;</code><br><code>- (nullable id)initWithContentsOfFile:(NSString *)path;</code>  </p>
<h3 id="日期与时间"><a href="#日期与时间" class="headerlink" title="日期与时间"></a>日期与时间</h3><p>NSDate:</p>
<p><code>- [NSDate date]</code><br><code>- [[NSDate alloc] initWithTimeIntervalSinceNow:]</code><br><code>- [NSDate dateWithTimeIntervalSince1970]</code><br><code>- [date timeIntervalSinceDate:]</code><br><code>- [date timeIntervalSinceNow:]</code>  </p>
<p>NSDateFormatter:</p>
<p><code>- [NSDateFormatter setDateFormat:]</code><br><code>- [NSDateFormatter stringFromDate:]</code><br><code>- [NSDateFormatter dateFromString:]</code>  </p>
<p>NSDateComponents(日期组件)和NSDate之间可以通过NSCalendar进行相互转换，它包括如下两个方法：</p>
<p><code>- (NSDateComponents \*)components:</code>(指定年月日)fromDate:<br><code>- (NSDate \*)dateFromComponents:</code>  </p>
<p>NSTimer:</p>
<p><code>- [NSTimer scheduledTimerWithTimeInterval:invocation:repeats:]</code><br><code>- [NSTimer scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:]</code>  </p>
<blockquote>
<p>NSInvocation对象也是封装target和selector的</p>
</blockquote>
<h3 id="对象复制"><a href="#对象复制" class="headerlink" title="对象复制"></a>对象复制</h3><p>NSObject类提供了copy和mutableCopy方法来复制已有对象的副本，copy方法返回该对象的不可修改的副本，mutableCopy返回该对象可修改的副本，如果是自定义类，则必须实现NSCopying或NSMutableCopying协议的<code>copyWithZone:</code>或<code>mutableCopyWithZone:</code>方法</p>
<p>如果程序只复制指针的地址而不是复制指针所指的对象，称之为浅度复制，深度复制不仅会复制对象本身，且会递归复制每个指针类型的属性，直到两个对象没有任何共用的部分，一般来说，深度复制的实现难度大很多，Foundation框架中的类大部分都只实现了浅复制。</p>
<p>setter方法的复制选项可以使用copy指示符，即</p>
<pre><code>- (void)setName:(NSMutableString \*)name {
    name = [name copy];
}
</code></pre><h3 id="OC集合概述"><a href="#OC集合概述" class="headerlink" title="OC集合概述"></a>OC集合概述</h3><p>OC集合大致分为NSArray，NSSet和NSDictionary</p>
<h3 id="数组-NSArray与NSMutableArray"><a href="#数组-NSArray与NSMutableArray" class="headerlink" title="数组(NSArray与NSMutableArray)"></a>数组(NSArray与NSMutableArray)</h3><p>数组代表元素有序、可重复的一个集合，集合中每个元素都有其对应的顺序索引</p>
<p><code>- array:</code><br><code>- arrayWithContentsOfFile:</code><br><code>- initWithContentsOfFile:</code><br><code>- arrayWithObject/s:</code><br><code>- initWithObject/s:</code>  </p>
<blockquote>
<p>NSArray如何判定集合是否包含指定元素？只有某个集合元素与被查找元素通过isEqual方法比较返回YES时，认为包含该元素</p>
</blockquote>
<p>NSArray可以对集合中所有的元素或部分元素整体调用方法</p>
<p><code>- [array makeObjectsPerformSelector:]</code><br><code>- [array makeObjectsPerformSelector:withObject:]</code><br><code>- [array enumerateObjects/WithOptions:UsingBlock:]</code><br><code>- [array enumerateObjectsAtIndexes:options:usingBlock:]</code><br><code>- [array sortedArrayUsingFunction:context:/UsingSelector:/UsingComparator:]</code>  </p>
<p>使用枚举器遍历</p>
<p><code>- [array objectEnumerator]</code><br><code>- [array reverseObjectEnumerator]</code><br><code>- [en allObjects]</code><br><code>- [en nextObject]</code>  </p>
<p>NSArray允许KVC编码</p>
<p><code>- setValue:forKey:(全部修改)</code><br><code>- (NSArray *)valueForKey:</code>  </p>
<p>NSArray支持KVO监听</p>
<p><code>- addObserver:forKeyPath:options:context:</code><br><code>- removeObserver:forKeyPath:</code><br><code>- addObserver:toObjectsAtIndexPath:forKeyPath:options:context:</code><br><code>- removeObserver:fromObjectsAtIndexes:forKeyPath:</code>  </p>
<h3 id="集合-NSSet与NSMutableSet"><a href="#集合-NSSet与NSMutableSet" class="headerlink" title="集合(NSSet与NSMutableSet)"></a>集合(NSSet与NSMutableSet)</h3><p>NSSet集合里多个对象之间没有明显的顺序，且每个元素不会相同</p>
<p><code>- setByAddingObject:</code><br><code>- setByAddingObjectsFromSet:</code><br><code>- setByAddingObjectsFromArray:</code><br><code>- allObject:</code><br><code>- anyObject:</code><br><code>- containsObject:</code><br><code>- member:</code>(判断该集合是否包含与该参数相等的元素)<br><code>- objectsPassingTest:</code>(参数为一个代码块，选出满足该代码块条件的集合元素)<br><code>- objectsWithOptions:passingTest:</code>(与前者功能相似，只是额外传入一个NSEnumerationOptions迭代参数选项，NSArray也提供了这两个方法，只不过这些方法返回的是符合条件的集合元素的索引组成的NSIndexSet集合)<br><code>- isSubsetOfSet:</code><br><code>- intersectsSet:</code><br><code>- isEqualToSet:</code>  </p>
<p>NSSet判断两个元素相等的标准</p>
<ul>
<li>两个对象通过isEqual方法比较返回YES</li>
<li>两个对象的hash方法返回值相等</li>
</ul>
<p>hash方法的基本规则</p>
<ol>
<li>同一个对象多次调用hash方法返回相同的值</li>
<li>如果isEqual方法返回YES，则hash返回值也应该相等</li>
<li>对象中作为isEqual方法比较标准的成员变量，都应该用来计算hashcode值</li>
</ol>
<p>NSSet 包含的常用方法有：</p>
<p><code>- addObject:</code><br><code>- removeObject:</code><br><code>- removeAllObjects:</code><br><code>- addObjectsFromArray:</code><br><code>- unionSet:</code><br><code>- minusSet:</code><br><code>- intersectSet:</code>  </p>
<p>NSCountedSet 是 NSMutableSet 的子类，它为每个元素额外维护一个添加次数的标记</p>
<p><code>- countForObject:</code>  </p>
<h3 id="有序集合-NSOrderedSet与NSMutableOrderedSet"><a href="#有序集合-NSOrderedSet与NSMutableOrderedSet" class="headerlink" title="有序集合(NSOrderedSet与NSMutableOrderedSet)"></a>有序集合(NSOrderedSet与NSMutableOrderedSet)</h3><p>NSOrderedSet既不允许元素重复，又可以保持顺序添加</p>
<h3 id="字典-NSDictionary与NSMutableDictionary"><a href="#字典-NSDictionary与NSMutableDictionary" class="headerlink" title="字典(NSDictionary与NSMutableDictionary)"></a>字典(NSDictionary与NSMutableDictionary)</h3><p>NSDictionary用于保持具有映射关系的数据，因此，NSDictionary集合里保存着两组值，一组用于保存NSDictionary里的key，另一组用户保存NSDictionary里的value，key和value都可以是任何引用类型的数组，Map的key不允许重复</p>
<p><code>- dictionary:</code><br><code>- dictionaryWithContentsOfFile:</code><br><code>- initWithContentsOfFile:</code><br><code>- dictionaryWithDictionary:</code><br><code>- dictionaryWithObject:forKey:</code><br><code>- dictionaryWithObjects:forKeys:</code><br><code>- dictionaryWithObjectsAndKeys:</code><br><code>- count:</code><br><code>- allKeys:</code><br><code>- allKeysForObject:</code>(指定该对象对应的全部key)<br><code>- allValues:</code><br><code>- objectForKey:</code><br><code>- objectForKeyedSubscript:</code>(允许NSDictionary通过下标方法来获取指定key对应的value)<br><code>- valueForKey:</code><br><code>- keyEnumerator:</code><br><code>- objectEnumerator:</code><br><code>- enumerateKeysAndObjectsUsingBlock:</code>迭代执行集合中的所有键值对<br><code>- enumerateKeysAndObjectsWithOptions:usingBlock:</code><br><code>- writeToFile:atomically</code><br><code>- (NSArray *)keysSortedByValueUsingSelector:</code><br><code>- keysSortedByValue/WithOptions:UsingComparator:</code><br><code>- (NSSet *)keysOfEntriesPassingTest:(key, value, isEnumerator)</code>使用代码块处理，对key过滤，第一个是key，第二个是value，第三个是是否还需要继续迭代，如果为NO，则会立即停止迭代<br><code>- (NSSet *)keysOfEntriesWithOptions:passingTest:</code>  </p>
<p>如果使用自定义类作为NSDictionary的key值，则自定义类必须满足两个要求</p>
<ol>
<li>正确重写过isEqual:和hash方法</li>
<li>实现了copyWithZone方法，即继承了NSCopying协议，因为为了保持NSDictionary的键值不被破坏，NSDictionary总会先调用该key的copy方法来复制该对象的不可变副本</li>
</ol>
<p>NSMutableDictionary中常用的方法有:</p>
<p><code>- setObject:forKey:</code><br><code>- setObject:forKeyedSubscript:</code><br><code>- addEntriesFromDictionary:</code><br><code>- setDictionary:</code><br><code>- removeObjectForKey:</code><br><code>- removeAllObjects:</code><br><code>- removeObjectsForKeys:</code>  </p>
<h3 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h3><p>NSPredicate用于定义一个逻辑条件，通过该条件可以执行搜索或内存中的过滤操作</p>
<p>三个子类：<code>NSComparisonPredicate/NSCompoundPredicate/NSExpresion</code></p>
<p><code>- [NSPredicate predicateWithFormat:]</code><br><code>- [predicate predicateWithSubstitutionVariables:]</code>//为占位符参数设置参数值<br><code>- [predicate evaluateWithObject:]</code>  </p>
<blockquote>
<p>使用谓词过滤不可变集合时，方法将会返回符合条件的集合元素组成的新集合，过滤可变集合时，方法直接删除不符合谓词条件的元素</p>
</blockquote>
<p>在NSArray中的用法: <code>(NSArray)filteredArrayUsingPredicate:</code>(返回符合条件的元素组成的心数组)</p>
<p>NSMutableArray: <code>-filterUsingPredicate:</code>使用指定的谓词过滤NSArray集合，删除不符合条件的元素</p>
<p>NSSet: <code>-(NSSet)filteredSetUsingPredicate:</code></p>
<p>NSMutableSet: <code>-filterUsingPredicate:</code></p>
<p>如果需要在谓词表达式中使用变量,则可以在谓词表达式中使用占位符参数,参数支持三个占位符参数</p>
<ol>
<li>%K动态传入属性名</li>
<li>%@动态设置属性值</li>
<li><p>$SUBSTR设置变量</p>
<pre><code>[NSPredicate predicateWithFormat:@“%K contains %@”, @“name”, @“value”];
[NSPredicate predicateWithFormat:@“%K contains $SUBSTR”, @“name”];
[predicate predicateWithSubstitutionVariables:[NSDictionary dictionaryWithObjectsAndKeys:@“1”,@“SUBSTR”];
[predicate evaluateWithObject:substitutionVariables:[NSDictionary dictionaryWithObjectsAndKeys:];
</code></pre></li>
</ol>
<p>谓词表达式由表达式、运算符和值组成</p>
<ul>
<li>比较运算符： <code>=/==/&gt;=/=&gt;/&lt;=/=&lt;/&gt;/&lt;/!=/&lt;&gt;/BETWEEN</code></li>
<li>逻辑运算符： <code>AND/&amp;&amp;/OR/||/NOT/!</code></li>
<li>字符串比较运算符： <code>BeginWith/EndWith/CONTAINS/LIKE(\*代表任意多个字符，?代表一个字符)/MATCHES</code></li>
<li>操作集合运算符 <code>ANY/SOME/ALL/NONE/IN</code></li>
<li>直接量 <code>FALSE/NO/TRUE/YES/NULL/NIL/SELF</code></li>
<li>保留字 <code>FIRST/LAST/SIZE/ANYKEY/CAST/TruePredicate/FalsePredicate</code></li>
</ul>
<h2 id="文件I-O"><a href="#文件I-O" class="headerlink" title="文件I/O"></a>文件I/O</h2><h3 id="使用NSData与NSMutableData"><a href="#使用NSData与NSMutableData" class="headerlink" title="使用NSData与NSMutableData"></a>使用NSData与NSMutableData</h3><p>NSData与NSMutableData代表OC的数据缓冲区，可以通过类的方法来创建，也可以通过实例的方法来创建</p>
<p><code>- [NSData data]</code><br><code>- [NSData dataWithBytes:length:]</code><br><code>- [[NSData alloc] initWithBytes:length:]</code><br><code>- [NSData dataWithBytesNoCopy:length:]</code><br><code>- [[NSData alloc] initWithBytesNoCopy:length]</code> //NSData销毁自己时程序会释放该数组<br><code>- [NSData dataWithBytesNoCopy:length:freeWhenDone]</code> freeWhenDone为YES，销毁自己时程序会释放该数组<br><code>- [NSData dataWithContentsOfFile:]</code><br><code>- [[NSData alloc] initWithContentsOfFile]</code> 根据文件内容来初始化NSData<br><code>- [NSData dataWithContentsOfURL:]</code><br><code>- [[NSData alloc] initWithContentsOfURL]</code> 根据URL关联的内容初始化NSData<br><code>- [NSData dataWithData:]</code><br><code>- [[NSData alloc] initWithData:]</code> 使用NSData初始化另一个NSData<br><code>- bytes</code> 返回NSData所包含的数据<br><code>- getBytes:length</code> 获取NSData所包含的指定长度的数据并将其写入byte数组<br><code>- getBytes:range</code> 获取NSData所包含的指定范围的数据并将其写入byte数组<br><code>- subdataWithRange</code> 获取指定范围的NSData对象<br><code>- writeToFile:atomically</code> 将NSData的数据写入文件<br><code>- writeToURL:atomically</code> 将NSData的数据写入URL对应的资源  </p>
<h3 id="使用NSFileManager管理文件和目录"><a href="#使用NSFileManager管理文件和目录" class="headerlink" title="使用NSFileManager管理文件和目录"></a>使用NSFileManager管理文件和目录</h3><p>绝对路径：以斜线开头的路径 相对路径：不以斜线开头的路径 ~代表当前用户的home路径 .代表当前目录 ..代表上一级目录</p>
<p><code>- fileExistsAtPath:</code> 文件是否存在<br><code>- fileExistsAtPath:isDirectory:</code> 后一个参数返回是否为目录<br><code>- isReadable/Writable/Executable/DeletableFileAtPath:</code> 判断文件是否可读，可写，可执行，可删除<br><code>- componentsToDisplayForPath:</code> 获取文件的各个路径组件<br><code>- displayNameAtPath:</code> 获取文件的简单文件名<br><code>- attributesOfItemAtPath:error:</code> 获取文件属性<br><code>- attributesOfFileSystemForPath:error:</code> 获取文件系统的属性<br><code>- contentsAtPath:</code> 获取指定的路径的NSData内容<br><code>- contentsEqualAtPath:andPath:</code> 判断两个文件内容是否相同<br><code>- createDirectoryAtURL:withIntermediateDirectories:attributes:error:</code>根据指定的URL创建目录<br><code>- createDirectoryAtPath:withIntermediateDirectories:attributes:error:</code> 根据路径创建目录，父目录不存在则创建<br><code>- createFileAtPath:content:attributes:</code> 根据指定的路径、内容、属性创建文件<br><code>- removeItemAtURL:error:</code><br><code>- removeItemAtPath:error:</code><br><code>- copyItemAtURL:toURL:error:</code><br><code>- copyItemAtPath:toPath:error:</code><br><code>- moveItemAtURL:toURL:error:</code><br><code>- moveItemAtPath:toPath:error:</code><br><code>- (NSArray&lt;NSString&gt;)contentsOfDirectoryAtPath:error:</code> 获取指定目录下的所有文件和子目录，对于子目录，不会递归枚举<br><code>- (NSDirectoryEnumerator)enumeratorAtPath:</code> 获取指定目录下的文件和子目录枚举器，调用skipDescendants阻止递归子目录<br><code>- (NSArray&lt;NSString&gt;)subpathsOfDirectoryAtPath:error:</code> 递归获取指定路径包含的所有目录及子目录<br><code>- subpathsAtPath:</code>  </p>
<h3 id="使用NSPathUtilities-h管理路径"><a href="#使用NSPathUtilities-h管理路径" class="headerlink" title="使用NSPathUtilities.h管理路径"></a>使用NSPathUtilities.h管理路径</h3><p>NSPathUtilities.h对NSString类扩展了如下方法:</p>
<p><code>- +pathWithComponents:components:</code> 根据components中的元素构造有效的路径<br><code>- pathComponents:</code><br><code>- isAbsolutePath:</code><br><code>- lastPathComponent:</code><br><code>- pathExtension:</code><br><code>- stringByAbbreviatingWithTildeInPath:</code> 将路径中当前用户的home路径替换为~，将路径中用户的home路径替换为~user形式,Abbreviating简写，Tilde波浪符<br><code>- stringByAppendingPathComponent:path:</code><br><code>- stringByAppendingPathExtension:ext:</code><br><code>- stringByDeletingLastPathComponent:</code><br><code>- stringByDeletingPathExtension:</code><br><code>- stringByExpandingTildeInPath:</code> 将~和~user替换为绝对路径<br><code>- stringByResolvingSymlinksInPath:</code> 解析路径中的符号链接，返回解析后的路径<br><code>- stringByStandardisingPath</code> 解析路径中的~/./..，返回解析后的路经，standardising解析<br><code>- NSUserName()</code><br><code>- NSFullUserName()</code><br><code>- NSHomeDirectory()</code><br><code>- NSHomeDirectoryForUser(user)</code><br><code>- NSTemporaryDirectory()</code>  </p>
<h3 id="使用NSProcessInfo获取进程信息"><a href="#使用NSProcessInfo获取进程信息" class="headerlink" title="使用NSProcessInfo获取进程信息"></a>使用NSProcessInfo获取进程信息</h3><p><code>NSProcessInfo info = [NSProcessInfo processInfo];</code>  </p>
<p><code>- info.arguments</code> 程序运行时传入的参数<br><code>- environment</code> 环境变量<br><code>- processIdentifier</code> 进程标识符<br><code>- globallyUniqueString</code> 进程的全局唯一子串<br><code>- processName</code> 进程名<br><code>- hostName</code> 主机名<br><code>- operatingSystemVersion</code> 操作系统版本<br><code>- operatingSystemVersionString</code> 操作系统版本号<br><code>- isOperatingSystemAtLeastVersion</code> 操作系统版本是否不低于给定版本<br><code>- physicalMemory</code> 系统物理内存<br><code>- processorCount</code> CPU数量<br><code>- activeProcessorCount</code> 激活状态的CPU数量<br><code>- systemUptime</code> 系统已运行的时间  </p>
<h3 id="使用NSFileHandle处理文件IO"><a href="#使用NSFileHandle处理文件IO" class="headerlink" title="使用NSFileHandle处理文件IO"></a>使用NSFileHandle处理文件IO</h3><p>NSFileHandle没有创建文件的功能，它提供了处理文件IO的相关方法</p>
<ul>
<li><code>+fileHandleForReadingAtPath:</code>  </li>
<li><code>+fileHandleForReadingFromURL:error:</code>  </li>
<li><code>+fileHandleForWritingAtPath:</code>  </li>
<li><code>+fileHandleForWritingToURL:error:</code>  </li>
<li><code>+fileHandleForUpdatingAtPath:</code>  </li>
<li><code>+fileHandleForUpdatingURL:error:</code>  </li>
<li>`+fileHandleWithStandardError/Input/Output/NullDevice:1 (标准输入，即键盘，标准输出，即屏幕)  </li>
<li><code>-fileDescriptor:</code>  </li>
<li><code>-availableData:</code>  </li>
<li><code>-readDataToEndOfFile:</code>  </li>
<li><code>-readDataOfLength:length:</code>  </li>
<li><code>-writeData:</code>  </li>
<li><code>-offsetInFile:</code>  </li>
<li><code>-seekToEndOfFile:</code>  </li>
<li><code>-seekToFileOffset:offset:</code>  </li>
<li><code>-closeFile:</code>  </li>
<li><code>-truncateFileAtOffset:offset</code>  </li>
</ul>
<h3 id="使用NSURL读取网络资源"><a href="#使用NSURL读取网络资源" class="headerlink" title="使用NSURL读取网络资源"></a>使用NSURL读取网络资源</h3><p>URL(Uniform Resource Locator)对象代表统一资源定位器，它是指向互联网资源的指针.通常为<code>scheme://host:port/path</code></p>
<h3 id="使用NSBundle处理项目相关资源"><a href="#使用NSBundle处理项目相关资源" class="headerlink" title="使用NSBundle处理项目相关资源"></a>使用NSBundle处理项目相关资源</h3><p>如果应用使用绝对或相对路径地址去访问文件，则会导致程序的可移植性降低，可以把项目资源文件放在应用中，让应用自己包含这些资源文件，接下来就可以使用NSBundle来访问这种应用包含的资源文件了。NSBundle *bundle = [NSBundle mainBundle];</p>
<p><code>- URLForResource:withExtension:subdirectory:</code><br><code>- URLForResource:withExtension:</code><br><code>- pathForResource:ofType:</code><br><code>- URLsForResourcesWithExtension:subdirectory:</code><br><code>- pathForResource:ofType:inDirectory:</code><br><code>- pathsForResource:ofType:inDirectory:</code><br><code>- resourcePath: 返回该NSBundle的子目录所包含资源的完整路径</code>  </p>
<h3 id="对象归档"><a href="#对象归档" class="headerlink" title="对象归档"></a>对象归档</h3><p>所谓对象归档，就是类似于其他语言的序列化机制，归档就是用某种格式把一个或多个对象保存到指定文件中，方便以后从文件中恢复他们。</p>
<ul>
<li><code>+(NSData \*)archivedDataWithRootObject:</code></li>
<li><code>+(BOOL)archiveRootObject:toFile:</code></li>
<li><code>+(id)unarchiveObjectWithData:</code></li>
<li><code>+(id)unarchiveObjectWithFile:</code></li>
</ul>
<p>如果需要将自定义的类进行归档和解档操作，则自定义类必须实现NSCoding协议，两个方法</p>
<ul>
<li><code>-encodeWithCoder:</code></li>
<li><code>-initWithCoder:</code></li>
</ul>
<blockquote>
<p>可以结合NSData完成很多对象的自定义归档</p>
</blockquote>
<pre><code>NSKeyArchiver \*arch = [NSKeyArchiver alloc] initForWritingWithMutableData:[NSMutableData data]];
[arch encodeObject:forKey:];
[arch finishEncoding];
[data writeToFile:];

NSKeyUnarchiver \*un = [[NSKeyUnarchiver alloc] initForReadingWithData:[NSData dataWithContentsOfFile:]]
[un decodeObjectForKey:];
[un finishDecoding];
</code></pre><p>可以利用归档来完成对象的深度复制</p>
<pre><code>NSData *data = [NSKeyedArchiver archiveDataWithRootObject:dict];
NSDictionary *dicCopy = [NSKeyedArchiver unarchiveObjectWithData:data];
</code></pre><h2 id="iOS应用开发入门"><a href="#iOS应用开发入门" class="headerlink" title="iOS应用开发入门"></a>iOS应用开发入门</h2><h3 id="从iOS项目开始"><a href="#从iOS项目开始" class="headerlink" title="从iOS项目开始"></a>从iOS项目开始</h3><ul>
<li>Xcode工作区左侧的导航图标的快捷键是<code>command+1/2;</code></li>
<li>工作区右侧的视图图标的快捷键是<code>command+option+1/2;</code></li>
<li>对象库面板的快捷键是<code>control+option+command+1;</code></li>
</ul>
<blockquote>
<p>每个Scene下边都有first response和View controller</p>
</blockquote>
<h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>MVC是所有面向对象程序设计语言都应该遵守的规范，MVC思想将一个应用分成三个基本部分：Model(模型),View(视图)和Controller(控制器)，这三个部分以最少的耦合协同工作，从而提高应用的可扩展性和可维护性。</p>
<h3 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h3><p>程序获取控件的两种方式：1，通过IBOutlet获取 2，通过Tag属性获取</p>
<p>iOS应用常见的事件处理机制有三种</p>
<ul>
<li>通过IBAction绑定控件的特定事件</li>
<li>通过程序为UI控件绑定事件</li>
<li>自带的delegate回调事件</li>
</ul>
<h3 id="storyboard控制UI界面"><a href="#storyboard控制UI界面" class="headerlink" title="storyboard控制UI界面"></a>storyboard控制UI界面</h3><h3 id="代码控制UI界面"><a href="#代码控制UI界面" class="headerlink" title="代码控制UI界面"></a>代码控制UI界面</h3><ul>
<li><code>-initWithFrame</code></li>
<li><code>-initWithCoder</code></li>
<li><code>-drawRect</code></li>
<li><code>-layoutSubviews</code></li>
<li><code>-didAddSubview</code></li>
<li><code>-willRemoveSubview</code></li>
<li><code>-willMoveToSuperview</code></li>
<li><code>-didMoveToSuperview</code></li>
<li><code>-willMoveToWindow</code></li>
<li><code>-didMoveToWindow</code></li>
<li><code>-touchesBegan:withEvent</code></li>
<li><code>-touchesMoved:withEvent</code></li>
<li><code>-touchesEnded:withEvent</code></li>
<li><code>-touchesCancelled:withEvent</code></li>
</ul>
<h3 id="美化iOS应用"><a href="#美化iOS应用" class="headerlink" title="美化iOS应用"></a>美化iOS应用</h3>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/OC/" rel="tag"># OC</a>
          
            <a href="/tags/iOS/" rel="tag"># iOS</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2014/02/28/git的基本使用/" rel="next" title="git的基本使用">
                <i class="fa fa-chevron-left"></i> git的基本使用
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2014/04/25/疯狂iOS上册-第二部分/" rel="prev" title="疯狂iOS上册第二部分">
                疯狂iOS上册第二部分 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        
<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC80MTIxOC8xNzc2Ng=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="Frand Feng">
            
              <p class="site-author-name" itemprop="name">Frand Feng</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">90</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">58</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/frandfeng" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:frandfeng@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#iOS应用与开发环境"><span class="nav-number">1.</span> <span class="nav-text">iOS应用与开发环境</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#OC与iOS简介"><span class="nav-number">1.1.</span> <span class="nav-text">OC与iOS简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#搭建iOS开发环境"><span class="nav-number">1.2.</span> <span class="nav-text">搭建iOS开发环境</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第一个OC程序"><span class="nav-number">1.3.</span> <span class="nav-text">第一个OC程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#熟悉Xcode"><span class="nav-number">1.4.</span> <span class="nav-text">熟悉Xcode</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据类型和运算符"><span class="nav-number">2.</span> <span class="nav-text">数据类型和运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#注释"><span class="nav-number">2.1.</span> <span class="nav-text">注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标识符和变量"><span class="nav-number">2.2.</span> <span class="nav-text">标识符和变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据类型分类"><span class="nav-number">2.3.</span> <span class="nav-text">数据类型分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本数据类型"><span class="nav-number">2.4.</span> <span class="nav-text">基本数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型转换"><span class="nav-number">2.5.</span> <span class="nav-text">类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运算符"><span class="nav-number">2.6.</span> <span class="nav-text">运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#流程控制与数组"><span class="nav-number">3.</span> <span class="nav-text">流程控制与数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#顺序结构"><span class="nav-number">3.1.</span> <span class="nav-text">顺序结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分支结构"><span class="nav-number">3.2.</span> <span class="nav-text">分支结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#循环结构"><span class="nav-number">3.3.</span> <span class="nav-text">循环结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#控制循环结构"><span class="nav-number">3.4.</span> <span class="nav-text">控制循环结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#goto语句"><span class="nav-number">3.5.</span> <span class="nav-text">goto语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组"><span class="nav-number">3.6.</span> <span class="nav-text">数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C语言特性"><span class="nav-number">4.</span> <span class="nav-text">C语言特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数"><span class="nav-number">4.1.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#局部变量与全局变量"><span class="nav-number">4.2.</span> <span class="nav-text">局部变量与全局变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#预处理"><span class="nav-number">4.3.</span> <span class="nav-text">预处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指针"><span class="nav-number">4.4.</span> <span class="nav-text">指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指针与数组"><span class="nav-number">4.5.</span> <span class="nav-text">指针与数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串与指针"><span class="nav-number">4.6.</span> <span class="nav-text">字符串与指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数与指针"><span class="nav-number">4.7.</span> <span class="nav-text">函数与指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指针数组和指向指针变量的指针"><span class="nav-number">4.8.</span> <span class="nav-text">指针数组和指向指针变量的指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结构体"><span class="nav-number">4.9.</span> <span class="nav-text">结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#块-Block"><span class="nav-number">4.10.</span> <span class="nav-text">块(Block)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象（上）"><span class="nav-number">5.</span> <span class="nav-text">面向对象（上）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类和对象"><span class="nav-number">5.1.</span> <span class="nav-text">类和对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法详解"><span class="nav-number">5.2.</span> <span class="nav-text">方法详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#成员变量"><span class="nav-number">5.3.</span> <span class="nav-text">成员变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#隐藏和封装"><span class="nav-number">5.4.</span> <span class="nav-text">隐藏和封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#键值编码-KVC-与键值监听-KVO"><span class="nav-number">5.5.</span> <span class="nav-text">键值编码(KVC)与键值监听(KVO)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象初始化"><span class="nav-number">5.6.</span> <span class="nav-text">对象初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类的继承"><span class="nav-number">5.7.</span> <span class="nav-text">类的继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多态"><span class="nav-number">5.8.</span> <span class="nav-text">多态</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象-下"><span class="nav-number">6.</span> <span class="nav-text">面向对象(下)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#OC的包装类"><span class="nav-number">6.1.</span> <span class="nav-text">OC的包装类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理对象"><span class="nav-number">6.2.</span> <span class="nav-text">处理对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#扩展与类别"><span class="nav-number">6.3.</span> <span class="nav-text">扩展与类别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#协议-protocol-与委托-delegate"><span class="nav-number">6.4.</span> <span class="nav-text">协议(protocol)与委托(delegate)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-try处理异常"><span class="nav-number">6.5.</span> <span class="nav-text">使用@try处理异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OC反射机制"><span class="nav-number">6.6.</span> <span class="nav-text">OC反射机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#手动内存管理"><span class="nav-number">6.7.</span> <span class="nav-text">手动内存管理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Foundation框架详解"><span class="nav-number">7.</span> <span class="nav-text">Foundation框架详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串-NSString与NSMutableString"><span class="nav-number">7.1.</span> <span class="nav-text">字符串(NSString与NSMutableString)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#日期与时间"><span class="nav-number">7.2.</span> <span class="nav-text">日期与时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象复制"><span class="nav-number">7.3.</span> <span class="nav-text">对象复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OC集合概述"><span class="nav-number">7.4.</span> <span class="nav-text">OC集合概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组-NSArray与NSMutableArray"><span class="nav-number">7.5.</span> <span class="nav-text">数组(NSArray与NSMutableArray)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合-NSSet与NSMutableSet"><span class="nav-number">7.6.</span> <span class="nav-text">集合(NSSet与NSMutableSet)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有序集合-NSOrderedSet与NSMutableOrderedSet"><span class="nav-number">7.7.</span> <span class="nav-text">有序集合(NSOrderedSet与NSMutableOrderedSet)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字典-NSDictionary与NSMutableDictionary"><span class="nav-number">7.8.</span> <span class="nav-text">字典(NSDictionary与NSMutableDictionary)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#谓词"><span class="nav-number">7.9.</span> <span class="nav-text">谓词</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件I-O"><span class="nav-number">8.</span> <span class="nav-text">文件I/O</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用NSData与NSMutableData"><span class="nav-number">8.1.</span> <span class="nav-text">使用NSData与NSMutableData</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用NSFileManager管理文件和目录"><span class="nav-number">8.2.</span> <span class="nav-text">使用NSFileManager管理文件和目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用NSPathUtilities-h管理路径"><span class="nav-number">8.3.</span> <span class="nav-text">使用NSPathUtilities.h管理路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用NSProcessInfo获取进程信息"><span class="nav-number">8.4.</span> <span class="nav-text">使用NSProcessInfo获取进程信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用NSFileHandle处理文件IO"><span class="nav-number">8.5.</span> <span class="nav-text">使用NSFileHandle处理文件IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用NSURL读取网络资源"><span class="nav-number">8.6.</span> <span class="nav-text">使用NSURL读取网络资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用NSBundle处理项目相关资源"><span class="nav-number">8.7.</span> <span class="nav-text">使用NSBundle处理项目相关资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象归档"><span class="nav-number">8.8.</span> <span class="nav-text">对象归档</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iOS应用开发入门"><span class="nav-number">9.</span> <span class="nav-text">iOS应用开发入门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#从iOS项目开始"><span class="nav-number">9.1.</span> <span class="nav-text">从iOS项目开始</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MVC"><span class="nav-number">9.2.</span> <span class="nav-text">MVC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件机制"><span class="nav-number">9.3.</span> <span class="nav-text">事件机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#storyboard控制UI界面"><span class="nav-number">9.4.</span> <span class="nav-text">storyboard控制UI界面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码控制UI界面"><span class="nav-number">9.5.</span> <span class="nav-text">代码控制UI界面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#美化iOS应用"><span class="nav-number">9.6.</span> <span class="nav-text">美化iOS应用</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2011 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Frand Feng</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
