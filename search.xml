<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[KVO原理解析]]></title>
    <url>%2F2018%2F12%2F28%2FKVO%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[基本使用先引用刘小壮同学的博客 概述KVO全称KeyValueObserving，是苹果提供的一套事件通知机制。允许对象监听另一个对象特定属性的改变，并在改变时接收到事件。由于KVO的实现机制，所以对属性才会发生作用，一般继承自NSObject的对象都默认支持KVO。 KVO和NSNotificationCenter都是iOS中观察者模式的一种实现。区别在于，相对于被观察者和观察者之间的关系，KVO是一对一的，而不一对多的。KVO对被监听对象无侵入性，不需要修改其内部代码即可实现监听。 KVO可以监听单个属性的变化，也可以监听集合对象的变化。通过KVC的mutableArrayValueForKey:等方法获得代理对象，当代理对象的内部对象发生改变时，会回调KVO监听的方法。集合对象包含NSArray和NSSet。 [kvoObject1 addObserver:self forKeyPath:@&quot;array&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:nil]; //打出来的地址不同 NSLog(@&quot;array %p, array %p&quot;, kvoObject1.array, [kvoObject1 mutableArrayValueForKey:@&quot;array&quot;]); //只有第二个触发了KVO，第一个未触发KVO [kvoObject1.array addObject:@&quot;item1&quot;]; [[kvoObject1 mutableArrayValueForKey:@&quot;array&quot;] addObject:@&quot;item2&quot;]; 基础使用使用KVO分为三个步骤： 通过addObserver:forKeyPath:options:context:方法注册观察者，观察者可以接收keyPath属性的变化事件。 在观察者中实现observeValueForKeyPath:ofObject:change:context:方法，当keyPath属性发生改变后，KVO会回调这个方法来通知观察者。 当观察者不需要监听时，可以调用removeObserver:forKeyPath:方法将KVO移除。需要注意的是，调用removeObserver需要在观察者消失之前，否则会导致Crash。 注册方法在注册观察者时，可以传入options参数，参数是一个枚举类型。如果传入NSKeyValueObservingOptionNew和NSKeyValueObservingOptionOld表示接收新值和旧值，默认为只接收新值。如果想在注册观察者后，立即接收一次回调，则可以加入NSKeyValueObservingOptionInitial枚举。 还可以通过方法context传入任意类型的对象，在接收消息回调的代码中可以接收到这个对象，是KVO中的一种传值方式。 在调用addObserver方法后，KVO并不会对观察者进行强引用，所以需要注意观察者的生命周期，否则会导致观察者被释放带来的Crash。 监听方法观察者需要实现observeValueForKeyPath:ofObject:change:context:方法，当KVO事件到来时会调用这个方法，如果没有实现会导致Crash。change字典中存放KVO属性相关的值，根据options时传入的枚举来返回。枚举会对应相应key来从字典中取出值，例如有NSKeyValueChangeOldKey字段，存储改变之前的旧值。 change中还有NSKeyValueChangeKindKey字段，和NSKeyValueChangeOldKey是平级的关系，来提供本次更改的信息，对应NSKeyValueChange枚举类型的value。例如被观察属性发生改变时，字段为NSKeyValueChangeSetting。 如果被观察对象是集合对象，在NSKeyValueChangeKindKey字段中会包含NSKeyValueChangeInsertion、NSKeyValueChangeRemoval、NSKeyValueChangeReplacement的信息，表示集合对象的操作方式。 移除方法KVO的addObserver和removeObserver需要是成对的，如果重复remove则会导致NSRangeException类型的Crash，如果忘记remove则会在观察者释放后再次接收到KVO回调时Crash。 苹果官方推荐的方式是，在init的时候进行addObserver，在dealloc时removeObserver，这样可以保证add和remove是成对出现的，是一种比较理想的使用方式。 KVO兼容自动调用KVO调用KVO属性对象时，不仅可以通过点语法和set语法进行调用，KVO兼容很多种调用方式。 // 直接调用set方法，或者通过属性的点语法间接调用 [account setName:@&quot;Savings&quot;]; // 使用KVC的setValue:forKey:方法 [account setValue:@&quot;Savings&quot; forKey:@&quot;name&quot;]; // 使用KVC的setValue:forKeyPath:方法 [document setValue:@&quot;Savings&quot; forKeyPath:@&quot;account.name&quot;]; // 通过mutableArrayValueForKey:方法获取到代理对象，并使用代理对象进行操作 Transaction *newTransaction = &lt;#Create a new transaction for the account#&gt;; NSMutableArray *transactions = [account mutableArrayValueForKey:@&quot;transactions&quot;]; [transactions addObject:newTransaction]; 手动调用KVO手动变化通知在当通知被发送给观察者的时候提供了更多精细的控制。对于减少不必要的触发通知，或者一大波变化给一个通知，都很有帮助。 实现手动通知的类必须重写 NSObject 实现的方法 automaticallyNotifiesObserversForKey: 。有可能在相同的类中使用自动和手动的观察通知。对于执行手动通知的属性，子类的 automaticallyNotifiesObserversForKey: 方法实现应该返回 NO。子类实现中对于任何为确认的 key，应该调用父类。清单2的例子对于 openingBalance 属性启用了手动通知，允许父类来决定所有其他 key 的通知。 //当调用set改变openingBalance属性时，不会触发KVO，因为[automaticallyNotifiesObserversForKey: openingBalance]返回NO + (BOOL)automaticallyNotifiesObserversForKey:(NSString *)theKey { BOOL automatic = NO; if ([theKey isEqualToString:@&quot;openingBalance&quot;]) { automatic = NO; } else { automatic = [super automaticallyNotifiesObserversForKey:theKey]; } return automatic; } 要实现手动观察通知，在值变化之前要调用 willChangeValueForKey:，值变化之后要调用 didChangeValueForKey: 。清单3的例子，对于 openingBalance 属性实现了手动通知。 //因为调用了will/didChangeValueForKey方法，所以在调用set时会手动触发KVO - (void)setOpeningBalance:(double)theBalance { [self willChangeValueForKey:@&quot;openingBalance&quot;]; _openingBalance = theBalance; [self didChangeValueForKey:@&quot;openingBalance&quot;]; } 因此，你可以先检查值是否改变，来将不必要发送的通知最小化。清单3的例子测试了 openingBalance 的值，并且只提供了如果它改变的通知。 - (void)setOpeningBalance:(double)theBalance { if (theBalance != _openingBalance) { [self willChangeValueForKey:@&quot;openingBalance&quot;]; _openingBalance = theBalance; [self didChangeValueForKey:@&quot;openingBalance&quot;]; } } 如果一个操作导致多个 key 的变化，你必须像清单5 一样将变化通知进行嵌套。 - (void)setOpeningBalance:(double)theBalance { [self willChangeValueForKey:@&quot;openingBalance&quot;]; [self willChangeValueForKey:@&quot;itemChanged&quot;]; _openingBalance = theBalance; _itemChanged = _itemChanged+1; [self didChangeValueForKey:@&quot;itemChanged&quot;]; [self didChangeValueForKey:@&quot;openingBalance&quot;]; } KVO的setter方法的伪代码如下：注意：will/didChangeValueForKey会自动触发KVO - (void) setBalance:(double)theBalance { if (+automaticallyNotifiesObserversForKey) { [self willChangeValueForKey:@&quot;balance&quot;]; _balance = theBalance; [self didChangeValueForKey:@&quot;balance&quot;]; //will/didChangeValueForKey会触发KVO } } 在有序，一对多关系的情况下，你必须指出不仅 key 发生了变化，还要指出变化的类型以及被调用对象的下标。变换的类型是 NSKeyValueChange ，可以指定 NSKeyValueChangeInsertion，NSKeyValueChangeRemoval或者 NSKeyValueChangeReplacement 。受影响对象的索引作为 NSIndexSet 对象被传递。 - (void)removeTransactionsAtIndexes:(NSIndexSet *)indexes { [self willChange:NSKeyValueChangeRemoval valuesAtIndexes:indexes forKey:@&quot;transactions&quot;]; // Remove the transaction objects at the specified indexes. [self didChange:NSKeyValueChangeRemoval valuesAtIndexes:indexes forKey:@&quot;transactions&quot;]; } Key值依赖一对一关系对于一对一关系，为了自动触发通知，你应该重写 keyPathsForValuesAffectingValueForKey: 方法，或者实现一个合适的方法，遵循一种模式，它定义取决于注册相关的key。例如，一个人的全名依赖于人的姓和名。一个返回全名的方法可以写成下面形式： - (NSString *)fullName { return [NSString stringWithFormat:@&quot;%@ %@&quot;,firstName, lastName]; } 应用观察 fullName 属性，必须注意到当 firstName 或者 lastName 属性变化时，会影响到 fullName属性的值。 一种解决方法是重写 keyPathsForValuesAffectingValueForKey: ，指定人的 fullName 属性依赖于 lastName 和 firstName 属性。清单1 展示了这样一个例子： + (NSSet *)keyPathsForValuesAffectingValueForKey:(NSString *)key { NSSet *keyPaths = [super keyPathsForValuesAffectingValueForKey:key]; if ([key isEqualToString:@&quot;fullName&quot;]) { NSArray *affectingKeys = @[@&quot;lastName&quot;, @&quot;firstName&quot;]; keyPaths = [keyPaths setByAddingObjectsFromArray:affectingKeys]; } return keyPaths; } 重写，通常应该调用 super ，并且返回一个 set ，包括这样做的导致结果的任何成员。（在父类中不要因为这个方法的重写造成干扰）。 你也可以通过实现一个类方法达到同样的结果，遵循命名约定 keyPathsForValuesAffecting， 是属性名（首字母大写），依赖于值。清单1中使用这种模式的代码，可以像在清单2中被重写为一个类方法 keyPathsForValuesAffectingFullName 。 + (NSSet *)keyPathsForValuesAffectingFullName { return [NSSet setWithObjects:@&quot;lastName&quot;, @&quot;firstName&quot;, nil]; } 当你使用一个 category 给一个现有的类添加一个计算属性的时候，你不能重写 keyPathsForValuesAffectingValueForKey: 方法，因为不允许重写分类（categories）中的方法。这种情况下，实现一个匹配的 keyPathsForValuesAffecting 类方法，体现了这种机制的优势。 一对多关系keyPathsForValuesAffectingValueForKey: 方法不支持包含一对多关系的 key-path。例如，Department 对象有一个一对多的关系 对于 Employee，Employee 有 salary 属性。你希望 Department 对象有一个 totalSalary 属性，这个属性依赖于所有 Employees。你不能像下面这样，keyPathsForValuesAffectingTotalSalary 并且将 employees.salary 作为一个 key 返回。 在两种情况中有两个可能的解决方法： 可以使用键值观察注册 parent(例子中就是 Department) 作为所有 children（Employees） 相关属性的观察者。你必须添加和移除 parent 。在 observeValueForKeyPath:ofObject:change:context: 方法中，在响应变化中更新相关的值，就像下面的代码所示： - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context { if (context == totalSalaryContext) { [self updateTotalSalary]; } else // deal with other observations and/or invoke super... } - (void)updateTotalSalary { [self setTotalSalary:[self valueForKeyPath:@&quot;employees.@sum.salary&quot;]]; } - (void)setTotalSalary:(NSNumber *)newTotalSalary { if (totalSalary != newTotalSalary) { [self willChangeValueForKey:@&quot;totalSalary&quot;]; _totalSalary = newTotalSalary; [self didChangeValueForKey:@&quot;totalSalary&quot;]; } } - (NSNumber *)totalSalary { return _totalSalary; } 如果使用Core Data，你可以在应用程序的通知中心注册 parent 作为它管理的对象 context 的观察者。parent 应该响应 与键值观察类似方式被 children 发出的的变化通知。 实现原理实现原理引用DeerRun的博客 KVO 是基于运行时实现的 isa Class NSKVONotifying_Person。基本的原理：当观察某对象A时，KVO机制动态创建一个对象A当前类的子类，并为这个新的子类重写了被观察属性keyPath的setter 方法。setter 方法随后负责通知观察对象属性的改变状况。 Apple 使用了 isa 混写（isa-swizzling）来实现 KVO 。当观察对象A时，KVO机制动态创建一个新的名为： NSKVONotifying_A的新类，该类继承自对象A的本类，且KVO为NSKVONotifying_A重写观察属性的setter 方法，setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象属性值的更改情况。（备注： isa 混写（isa-swizzling）isa：is a kind of ； swizzling：混合，搅合；） NSKVONotifying_A类剖析：在这个过程，被观察对象的 isa 指针从指向原来的A类，被KVO机制修改为指向系统新创建的子类 NSKVONotifying_A类，来实现当前类属性值改变的监听。所以当我们从应用层面上看来，完全没有意识到有新的类出现，这是系统“隐瞒”了对KVO的底层实现过程，让我们误以为还是原来的类。但是此时如果我们创建一个新的名为“NSKVONotifying_A”的类()，就会发现系统运行到注册KVO的那段代码时程序就崩溃，因为系统在注册监听的时候动态创建了名为NSKVONotifying_A的中间类，并指向这个中间类了。（isa 指针的作用：每个对象都有isa 指针，指向该对象的类，它告诉 Runtime 系统这个对象的类是什么。所以对象注册为观察者时，isa指针指向新子类，那么这个被观察的对象就神奇地变成新子类的对象（或实例）了。） 因而在该对象上对 setter 的调用就会调用已重写的 setter，从而激活键值通知机制。我猜，这也是KVO回调机制，为什么都俗称KVO技术为黑魔法的原因之一吧：内部神秘、外观简洁。 子类setter方法剖析：KVO的键值观察通知调用了 NSObject 的两个方法:willChangeValueForKey:和 didChangevlueForKey:，在存取数值的前后分别调用2个方法：被观察属性发生改变之前，willChangeValueForKey:被调用，通知系统该 keyPath 的属性值即将变更；当改变发生后， didChangeValueForKey: 被调用，通知系统该 keyPath 的属性值已经变更；之后observeValueForKey:ofObject:change:context: 也会被调用。且重写观察属性的setter 方法这种继承方式的注入是在运行时而不是编译时实现的。 测试代码@implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; KVOObject *kvoObject1 = [[KVOObject alloc] init]; [kvoObject1 description]; KVOObject *kvoObject2 = [[KVOObject alloc] init]; [kvoObject2 description]; [kvoObject1 addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:nil]; [kvoObject1 addObserver:self forKeyPath:@&quot;age&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:nil]; [kvoObject1 description]; [kvoObject2 description]; kvoObject1.name = @&quot;frand&quot;; kvoObject1.age = 22; } - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context { if (context == nil) { if ([keyPath isEqualToString:@&quot;name&quot;]) { NSLog(@&quot;name changed to %@&quot;, change); } else if ([keyPath isEqualToString:@&quot;age&quot;]) { NSLog(@&quot;age changed to %@&quot;, change); } } else { [super observeValueForKeyPath:keyPath ofObject:object change:change context:context]; } } @end @implementation KVOObject - (NSString *)description { NSLog(@&quot;object address : %p \n&quot;, self); IMP nameIMP = class_getMethodImplementation(object_getClass(self), @selector(setName:)); IMP ageIMP = class_getMethodImplementation(object_getClass(self), @selector(setAge:)); NSLog(@&quot;object setName: IMP %p； object setAge: IMP %p \n&quot;, nameIMP, ageIMP); //objc_getClass参数是类名的字符串，返回的就是这个类的类对象； //object_getClass参数是id类型，它返回的是这个id的isa指针所指向的Class，如果传参是Class，则返回该Class的metaClass //self.class:当self是实例对象的时候，返回的是类对象，否则则返回自身 Class objectMethodClass = [self class]; //object_getClass:获得的是isa的指向 Class objectRuntimeClass = object_getClass(self); Class isaClass = object_getClass(objectRuntimeClass); Class superClass = class_getSuperclass(objectRuntimeClass); NSLog(@&quot;objectMethodClass : %@, ObjectRuntimeClass : %@, isaClass : %@, superClass : %@ \n&quot;, objectMethodClass, objectRuntimeClass, isaClass, superClass); NSLog(@&quot;object method list \n&quot;); unsigned int count; Method *methodList = class_copyMethodList(objectRuntimeClass, &amp;count); for (NSInteger i = 0; i &lt; count; i++) { Method method = methodList[i]; NSString *methodName = NSStringFromSelector(method_getName(method)); NSLog(@&quot;method Name = %@\n&quot;, methodName); } return @&quot;&quot;; } - (void)willChangeValueForKey:(NSString *)key { [super willChangeValueForKey:key]; NSLog(@&quot;willChangeValueForKey %@&quot;, key); } - (void)didChangeValueForKey:(NSString *)key { [super didChangeValueForKey:key]; NSLog(@&quot;didChangeValueForKey %@&quot;, key); } @end 2018-11-26 18:11:00.584925+0800 KVO原理[3014:120655] objectMethodClass : KVOObject, ObjectRuntimeClass : KVOObject, isaClass : KVOObject, superClass : NSObject 2018-11-26 18:11:00.594078+0800 KVO原理[3014:120655] objectMethodClass : KVOObject, ObjectRuntimeClass : NSKVONotifying_KVOObject, isaClass : NSKVONotifying_KVOObject, superClass : KVOObject 2018-11-26 18:11:00.601868+0800 KVO原理[3014:120655] name changed to { kind = 1; new = frand; old = &quot;&lt;null&gt;&quot;; } 我们发现对象被KVO后，其真正类型变为了NSKVONotifying_KVOObject类，已经不是之前的类了。KVO会在运行时动态创建一个新类，将对象的isa指向新创建的类，新类是原类的子类，命名规则是NSKVONotifying_xxx的格式。KVO为了使其更像之前的类，还会将对象的class实例方法重写，使其更像原类。 在上面的代码中还发现了_isKVOA方法，这个方法可以当做使用了KVO的一个标记，系统可能也是这么用的。如果我们想判断当前类是否是KVO动态生成的类，就可以从方法列表中搜索这个方法。 原理分析为什么上面调用runtime的object_getClass函数，就可以获取到真正的类呢？ 调用object_getClass函数后其返回的是一个Class类型，Class是objc_class定义的一个typedef别名，通过objc_class就可以获取到对象的isa指针指向的Class，也就是对象的类对象。 由此可以推测，object_getClass函数内部返回的是对象的isa指针。 typedef struct objc_class *Class; struct objc_class { Class _Nonnull isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE; #endif } 缺点苹果提供的KVO自身存在很多问题，首要问题在于，KVO如果使用不当很容易崩溃。例如重复add和remove导致的Crash，Observer被释放导致的崩溃，keyPath传错导致的崩溃等。除了上面的缺点，KVO还不支持block语法，需要单独重写父类方法，这样加上add和remove方法就会导致代码很分散。 在调用KVO时需要传入一个keyPath，由于keyPath是字符串的形式，所以其对应的属性发生改变后，字符串没有改变容易导致Crash。我们可以利用系统的反射机制将keyPath反射出来，这样编译器可以在@selector()中进行合法性检查。 NSStringFromSelector(@selector(isFinished)) KVO是一种事件绑定机制的实现，在keyPath对应的值发生改变后会回调对应的方法。这种数据绑定机制，在对象关系很复杂的情况下，很容易导致不好排查的bug。例如keyPath对应的属性被调用的关系很复杂，就不太建议对这个属性进行KVO，可以想一下RAC的信号脑补一下。 自己实现KVO@implementation NSObject (KVOBlock) /** 和 NSObject 的方法- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;功能相似 1. 通过Method判断是否有这个key对应的selector，如果没有则Crash。 2. 判断当前类是否是KVO子类，如果不是则创建，并设置其isa指针。 3. 如果没有实现，则添加Key对应的setter方法。 4. 将调用对象添加到数组中。 */ - (void)lxz_addObserver:(NSObject *)observer originalSelector:(SEL)originalSelector callback:(lxz_KVOObserverBlock)callback { // 1. SEL originalSetter = NSSelectorFromString(lxz_setterForGetter(originalSelector)); Method originalMethod = class_getInstanceMethod(object_getClass(self), originalSetter); if (!originalMethod) { NSString *exceptionReason = [NSString stringWithFormat:@&quot;%@ Class %@ setter SEL not found.&quot;, NSStringFromClass([self class]), NSStringFromSelector(originalSelector)]; NSException *exception = [NSException exceptionWithName:@&quot;NotExistKeyExceptionName&quot; reason:exceptionReason userInfo:nil]; [exception raise]; } // 2. Class kvoClass = object_getClass(self); NSString *kvoClassString = NSStringFromClass(kvoClass); if (![kvoClassString hasPrefix:lxz_KVOClassPrefix]) { kvoClass = [self lxz_makeKVOClassWithName:kvoClassString]; object_setClass(self, kvoClass); } // 3. if (![self lxz_hasMethodWithKey:originalSetter]) { class_addMethod(kvoClass, originalSetter, (IMP)lxz_kvoSetter, method_getTypeEncoding(originalMethod)); } // 4. KVOObserverItem *observerItem = [[KVOObserverItem alloc] initWithObserver:observer key:NSStringFromSelector(originalSelector) block:callback]; NSMutableArray&lt;KVOObserverItem *&gt; *observers = objc_getAssociatedObject(self, lxz_KVOObserverAssociatedKey); if (observers == nil) { observers = [NSMutableArray array]; } [observers addObject:observerItem]; objc_setAssociatedObject(self, lxz_KVOObserverAssociatedKey, observers, OBJC_ASSOCIATION_RETAIN); } - (void)lxz_removeObserver:(NSObject *)observer originalSelector:(SEL)originalSelector { NSMutableArray &lt;KVOObserverItem *&gt;* observers = objc_getAssociatedObject(self, lxz_KVOObserverAssociatedKey); [observers enumerateObjectsUsingBlock:^(KVOObserverItem * _Nonnull mapTable, NSUInteger idx, BOOL * _Nonnull stop) { SEL selector = NSSelectorFromString(mapTable.key); if (mapTable.observer == observer &amp;&amp; selector == originalSelector) { [observers removeObject:mapTable]; } }]; } #pragma mark - ----- Private Method Or Funcation ------ /** 1. 获取旧值。 2. 创建super的结构体，并向super发送属性的消息。 3. 遍历调用block。 */ static void lxz_kvoSetter(id self, SEL selector, id value) { // 1. id (*getterMsgSend) (id, SEL) = (void *)objc_msgSend; NSString *getterString = lxz_getterForSetter(selector); SEL getterSelector = NSSelectorFromString(getterString); id oldValue = getterMsgSend(self, getterSelector); [self willChangeValueForKey:key]; // 2. id (*msgSendSuper) (void *, SEL, id) = (void *)objc_msgSendSuper; struct objc_super objcSuper = { .receiver = self, .super_class = class_getSuperclass(object_getClass(self)) }; msgSendSuper(&amp;objcSuper, selector, value); // 3. NSMutableArray &lt;KVOObserverItem *&gt;* observers = objc_getAssociatedObject(self, lxz_KVOObserverAssociatedKey); [observers enumerateObjectsUsingBlock:^(KVOObserverItem * _Nonnull mapTable, NSUInteger idx, BOOL * _Nonnull stop) { if ([mapTable.key isEqualToString:getterString] &amp;&amp; mapTable.block) { mapTable.block(self, NSStringFromSelector(selector), oldValue, value); } }]; [self didChangeValueForKey:key]; } - (BOOL)lxz_hasMethodWithKey:(SEL)key { NSString *setterName = NSStringFromSelector(key); unsigned int count; Method *methodList = class_copyMethodList(object_getClass(self), &amp;count); for (NSInteger i = 0; i &lt; count; i++) { Method method = methodList[i]; NSString *methodName = NSStringFromSelector(method_getName(method)); if ([methodName isEqualToString:setterName]) { return YES; } } return NO; } static NSString * lxz_getterForSetter(SEL setter) { NSString *setterString = NSStringFromSelector(setter); if (![setterString hasPrefix:@&quot;set&quot;]) { return nil; } NSString *getterString = [setterString substringWithRange:NSMakeRange(4, setterString.length - 5)]; NSString *firstString = [setterString substringWithRange:NSMakeRange(3, 1)]; firstString = [firstString lowercaseString]; getterString = [NSString stringWithFormat:@&quot;%@%@&quot;, firstString, getterString]; return getterString; } static NSString * lxz_setterForGetter(SEL getter) { NSString *getterString = NSStringFromSelector(getter); NSString *firstString = [getterString substringToIndex:1]; firstString = [firstString uppercaseString]; NSString *setterString = [getterString substringFromIndex:1]; setterString = [NSString stringWithFormat:@&quot;set%@%@:&quot;, firstString, setterString]; return setterString; } /** 1. 判断是否存在KVO类，如果存在则返回。 2. 如果不存在，则创建KVO类。 3. 重写KVO类的class方法，指向自定义的IMP。 */ - (Class)lxz_makeKVOClassWithName:(NSString *)name { // 1. NSString *className = [NSString stringWithFormat:@&quot;%@%@&quot;, lxz_KVOClassPrefix, name]; Class kvoClass = objc_getClass(className.UTF8String); if (kvoClass) { return kvoClass; } // 2. kvoClass = objc_allocateClassPair(object_getClass(self), className.UTF8String, 0); objc_registerClassPair(kvoClass); // 3. const char * types = NSStringFromSelector(@selector(class)).UTF8String; class_addMethod(kvoClass, @selector(class), (IMP)lxz_kvoClass, types); return kvoClass; } static Class lxz_kvoClass(id self, SEL selector) { return class_getSuperclass(object_getClass(self)); } @end //使用 self.object1 = [[KVOObject alloc] init]; [self.object1 lxz_addObserver:self originalSelector:@selector(name) callback:^(id observedObject, NSString *observedKey, id oldValue, id newValue) { // callback }]; self.object1.name = @&quot;lxz&quot;; [self.object1 lxz_removeObserver:self originalSelector:@selector(name)]; 调用代码很简单，直接通过lxz_addObserver:originalSelector:callback:方法就可以添加KVO的监听，可以通过callback的block接收属性发生改变后的回调，而且方法的keyPath接收的是一个SEL类型参数，所以可以通过@selector()传入参数时进行方法合法性检查，如果是未实现的方法直接就会报警告。 通过lxz_removeObserver:originalSelector:方法传入观察者和keyPath，当观察者所有keyPath都移除后则从KVO中移除观察者对象。 如果重复addObserver和removeObserver也没事，内部有判断逻辑。EasyKVO内部通过weak对观察者做引用，并不会影响观察者的生命周期，并且在观察者释放后不会导致Crash。一次add方法调用对应一个block，如果观察者监听多个keyPath属性，不需要在block回调中判断keyPath。 注意:需要注意的是，EasyKVO只是做技术交流，不建议在项目中使用。因为KVO实现需要考虑很多情况，继承关系、多个观察者等很多问题。想在项目中安全便捷的使用KVO的话，推荐Facebook的一个KVO开源第三方框架-KVOController。KVOController本质上是对系统KVO的封装，具有原生KVO所有的功能，而且规避了原生KVO的很多问题，兼容block和action两种回调方式。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>iOS</tag>
        <tag>KVO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVC原理解析]]></title>
    <url>%2F2018%2F11%2F30%2FKVC%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[概述键值编码是一种由NSKeyValueCoding非正式协议启用的机制，对象采用该机制提供对其属性的间接访问。当对象符合键值编码时，其属性可通过字符串参数通过简洁，统一的消息传递接口寻址。这种间接访问机制补充了实例变量及其相关访问​​器方法提供的直接访问。 您通常使用访问器方法来访问对象的属性。get访问器（或getter）返回属性的值。set访问器（或setter）设置属性的值。在Objective-C中，您还可以直接访问属性的基础实例变量。以任何这些方式访问对象属性都很简单，但需要调用特定于属性的方法或变量名称。随着属性列表的增长或变化，访问这些属性的代码也必须如此。相反，符合键值编码的对象提供了一个简单的消息传递接口，该接口在其所有属性中都是一致的。 键值编码是一个基本概念，是许多其他Cocoa技术的基础，例如键值观察(key-value observing)，Cocoa绑定(Cocoa bindings)，Core Data和AppleScript-ability。在某些情况下，键值编码还有助于简化代码。 使用键值编码可以干什么？对象通常在NSObject（直接或间接）继承时采用键值编码，它们都采用NSKeyValueCoding协议并为基本方法提供默认实现。这样的对象通过紧凑的消息传递接口使其他对象能够执行以下操作： 访问对象属性。 该协议指定方法，例如getter valueForKey: 和setter setValue:forKey:，用于通过名称或键访问对象属性，参数为字符串。这些和相关方法的默认实现使用键来定位基础数据并与其交互，如Accessing Object Properties 操纵集合属性。 访问方法的默认实现和对象的集合属性（如NSArray对象）一样，也和任何其他属性一样。此外，如果对象定义属性的集合访问器方法，则它允许对集合内容进行键值访问。这通常比直接访问更有效，并允许您通过标准化界面使用自定义集合对象，如Accessing Collection Properties 在集合对象上调用集合运算符。 在符合键值编码的对象中访问集合属性时，可以将集合运算符插入到键字符串中，如Using Collection Operators。集合运算符根据默认的NSKeyValueCodinggetter实现对集合执行操作，然后返回集合的新的过滤版本或表示集合的某些特征的单个值。 访问基本类型属性。 协议默认实现检测非对象属性，包括标量和结构体，并自动将它们包装和解包为协议接口上使用的对象，如Representing Non-Object Values。此外，该协议声明了一种方法，该方法允许兼容对象nil通过键值编码接口在非对象属性上设置值时为该情况提供合适的作用。 key path访问属性。 如果具有符合键值编码的对象层次结构，则可以使用基于key path的方法调用，使用单个调用在层次结构内深入查看，获取或设置值。 如何使用键值编码？为了使您自己的对象键值编码符合要求，您需要确保它们采用NSKeyValueCoding非正式协议并实现相应的方法，例如作为valueForKey: 通用getter和setValue:forKey: 通用setter。幸运的是，如上所述，NSObject 采用此协议并为这些和其他基本方法提供默认实现。因此，如果您从NSObject（或其许多子类中的任何一个）派生对象，那么大部分工作已经完成。 为了使默认方法完成其工作，您需要确保对象的访问器方法和实例变量遵循某些明确定义的模式。这允许默认实现找到对象的属性以响应键值编码消息。然后，您可以选择通过提供验证方法和处理某些特殊情况来扩展和自定义键值编码。 如何使用Swift进行键值编码NSObject从其子类或其子类之一 继承的Swift对象默认情况下是符合其属性的键值编码。而在Objective-C中，属性的访问器和实例变量必须遵循某些模式，Swift中的标准属性声明会自动保证这一点。另一方面，协议的许多功能要么不相关，要么使用Objective-C中不存在的本机Swift构造或技术来更好地处理。例如，因为所有Swift属性都是对象，所以您永远不会使用默认实现对非对象属性的特殊处理。 因此，虽然键值编码协议方法直接转换为Swift，但本指南主要关注Objective-C，您需要做更多工作以确保合规性，以及键值编码通常最有用的地方。整个指南中都提到了需要在Swift中采用明显不同方法的情况。 有关使用Swift和Cocoa技术的更多信息，请阅读将Swift与Cocoa和Objective-C一起使用（Swift 3）。有关Swift的完整描述，请阅读Swift编程语言（Swift 3） 哪些技术用到了KVO？符合键值编码的对象可以参与依赖于此类访问的各种Cocoa技术，包括： 键值观察(Key-value observing)。 此机制使对象能够注册异步通知监听另一个对象属性的改变，如“ Key-Value Observing Programming Cocoa绑定(Cocoa bindings)。 这一系列技术完全实现了Model-View-Controller范例，其中模型(Model)用于封装应用程序数据，视图(View)用于显示和编辑数据，控制器(Controller)在两者之​​间进行调解。阅读Cocoa Bindings Programming Topics以了解有关Cocoa绑定的更多信息 核心数据(Core Data)。 该框架为与对象生命周期和对象图形化管理相关的常见任务（包括持久性）提供通用和自动化解决方案。您可以在Core Data Programming Guide阅读Core Data AppleScript。 这种脚本语言可以直接控制脚本化应用程序和macOS的许多部分。Cocoa的脚本支持利用键值编码来获取和设置脚本化对象中的信息。NSScriptKeyValueCoding非正式协议中的方法提供了使用键值编码的附加功能，包括通过多值键中的索引获取和设置键值，以及将键值强制（或转换）为适当的数据类型。AppleScript Overview提供了AppleScript及其相关技术的高级概述。 详解访问对象属性对象通常在其接口声明中指定属性, 这些属性属于以下几种类别之一: 属性. 指简单值, 例如标量(scalars)、字符串或布尔值。值对象(如NSNumber)和其他不可变类型(如NSColor) 也被视为属性。 一对一关系. 指具有自己属性的可变对象。对象的属性可以在对象本身不变的情况下更改。例如，银行帐户对象(bank account object)可能具有owner属性，该属性是Person对象的实例，该Person对象具有address属性。owner的address可能会更改，而不会更改银行帐户持有的owner。银行帐户的owner没有变更。只有Person的address 发生改变。 一对多关系. 指集合对象。你通常使用NSArray或NSSet保存此类集合的实例，但也可以使用自定义集合类。 @interface BankAccount : NSObject @property (nonatomic) NSNumber* currentBalance;// An attribute @property (nonatomic) Person* owner;// A to-one relation @property (nonatomic) NSArray&lt;Transaction*&gt;* transactions;// A to-many relation @end 为了保持封装，对象通常为其接口上的属性提供访问器方法。对象的作者可以显式地编写这些方法，也可以依赖编译器自动合成它们。无论哪种方式，使用这些访问器之一的代码的作者必须在编译之前将属性名称写入代码中。访问器方法的名称成为使用它的代码的静态部分。例如，编译器会合成一个可以为myAccount实例调用的setter ：[myAccount setCurrentBalance:@(100.0)];这是直接的，但缺乏灵活性。另一方面，符合键值编码的对象提供了使用字符串标识符访问对象属性的更通用机制。 使用Keys 和 Key Paths标识对象的属性键(key)是标识特定属性的字符串。通常, 按照惯例, 表示属性的键(key)是代码中显示的属性名。键(key)必须使用 ASCII 编码, 不能包含空格, 并且通常以小写字母开头 (尽管有例外, 如在许多类中的URL属性)。 BankAccount类是符合键值编码的, 所以它能识别键(即它的属性的名称)owner、currentBalance和transactions 。您也可以通过其键来设置值, 而不是调用setCurrentBalance:方法:[myAccount setValue:@(100.0) forKey:@&quot;currentBalance&quot;];实际上, 您可以使用不同的键参数通过相同方法来设置myAccount对象的所有属性。因为参数是字符串类型, 所以它可以在运行时操作变量。 键路径Key path是一个用点操作符.来分隔键的字符串, 用于指定要遍历的对象属性序列。序列中第一个键的属性是相对于接收者的, 每个后续键相对于上一个属性的值进行计算。键路径(Key path)对于使用单个方法深入调用对象的层次结构很有用。 例如, 应用于银行帐户实例的键路径owner.address.street是指存储在银行帐户所有者地址中的街道字符串的值, 假设Person和Address类也符合的键值编码。 注意: 在 Swift 中, 您可以使用#keyPath表达式, 而不是使用字符串来指示键或键路径。这提供了编译时检查的优点, 详见Using Swift with Cocoa and Objective-C (Swift 4.2) 中的Keys and Key Paths章节。 使用键获取属性值对象在遵循NSKeyValueCoding协议时符合键值编码。继承自的对象（NSObject提供协议的基本方法的默认实现）会自动采用此协议的某些默认行为。这样的对象至少实现了以下基于键的基本getter： valueForKey: - 返回由key参数指定的属性的值。如果根据访问者搜索模式中描述的规则无法找到key命名的属性，则该对象会向自身发送valueForUndefinedKey:消息。valueForUndefinedKey:引发的默认实现抛出NSUndefinedKeyException异常，但是子类可以覆盖此方法并更优雅地处理这种情况。 valueForKeyPath: - 返回相对于接收器的指定键路径的值。keyPath序列中的任何对象都不符合特定key的键值编码 - 即，默认实现valueForKey:无法找到访问器方法 - -那么就会接收valueForUndefinedKey:消息。 dictionaryWithValuesForKeys: - 返回相对于接收器的一组键所对应的值。该方法为数组中的每个键调用valueForKey:。返回的NSDictionary包含数组中所有键的值。 注意: 集合对象 (如NSArray、 NSSet和NSDictionary) 不能包含nil的值。而是使用NSNull对象表示nil值。NSNull提供一个表示对象属性的nil值的单个实例。dictionaryWithValuesForKeys:的默认实现和相关的setValuesForKeysWithDictionary:会在NSNull (在字典参数中) 和nil(在存储的属性中)之间进行自动转换 。 当您使用KeyPath来寻找属性时, 如果键路径中的最后一个键是一对多关系 (即引用集合), 则在多对键的右侧,返回的值是一个包含键的所有值的集合。例如, 请求键路径 “transactions.payee” 的值返回包含所有transaction对象中payee对象的数组。这也适用于KeyPath中的多个数组。KeyPath accounts.transactions.payee返回一个数组，其中包含所有帐户中所有交易的所有收款人对象。 使用键设置属性值与 getter一样, 符合键值编码的对象也提供了一小组通用setter，其默认行为基于以下NSKeyValueCoding协议的实现NSObject: setValue:forKey: - 将指定键设置为给定值。setValue:forKey:的默认实现会自动对表示标量和结构体的NSNumber和NSValue对象执行解包操作，并将它们设置到相应的属性中。有关包装(warp)和解包(unwarp)语义的详细信息，请参阅Representing Non-Object Values。如果接收setter调用的对象中没有对应指定键的属性，该对象将给自己发送一个[setValue:forUndefinedKey:]消息。setValue:forUndefinedKey:的默认实现将抛出NSUndefinedKeyException异常。但是, 子类可以重写此方法以自定义方式处理请求。 setValue:forKeyPath: 在相对于接收者的指定键路径上设置给定值。键路径序列中指定键所对应的对象如果不是键值编码兼容的，将会收到setValue:forUndefinedKey:消息。 setValuesForKeysWithDictionary: 将指定字典中的值设置到接收者的属性中, 使用字典键标识属性。默认实现调用每个键值对的setValue:forKey: , 根据需要用nil替换NSNull对象。 在默认实现中, 当您尝试将非对象属性设置为nil值时, 符合键值编码兼容对象将自己发送一个setNilValueForKey:消息。setNilValueForKey:的默认实现将抛出[NSInvalidArgumentException]异常, 但对象可以重写此方法以替换默认值或标记值, 详见处理非对象值。 使用键简化对象访问想知道基于key的 getter 和 setter 如何简化代码, 请查看下面的示例。在 macOS 中, NSTableView和NSOutlineView对象的标识符字符串与每个它们的列相关联。如果表的模型对象不是符合键值编码的, 则表的数据源方法将强制检查每个列标识符, 依次查找要返回的正确属性, 如清单 2-2所示。此外, 在将来, 当您向模型中添加另一个属性时, 在本例中为Person 对象, 还必须重新访问数据源方法, 添加另一个条件来测试新属性并返回相关值. //清单 2-2 不基于键值编码的数据源方法的实现 - (id)tableView:(NSTableView *)tableview objectValueForTableColumn:(id)column row:(NSInteger)row { id result = nil; Person *person = [self.people objectAtIndex:row]; if ([[column identifier] isEqualToString:@&quot;name&quot;]) { result = [person name]; } else if ([[column identifier] isEqualToString:@&quot;age&quot;]) { result = @([person age]); // Wrap age, a scalar, as an NSNumber } else if ([[column identifier] isEqualToString:@&quot;favoriteColor&quot;]) { result = [person favoriteColor]; } // And so on... return result; } 另一方面,清单 2-3展示了相同数据源的方法的一个更紧凑的实现, 该数据源方法使用的是键值编码兼容的Person对象。仅使用valueForKey: getter, 数据源方法将使用列标识符作为键返回适当的值。除了更短的时间外, 它还更通用, 因为在以后添加新列时, 只要列标识符始终与模型对象的属性名称匹配, 它就会继续保持不变。 //清单 2-3基于键值编码的数据源方法的实现 - (id)tableView:(NSTableView *)tableview objectValueForTableColumn:(id)column row:(NSInteger)row { return [[self.people objectAtIndex:row] valueForKey:[column identifier]]; } 访问集合属性符合键值编码的对象以与公开其他属性相同的方式公开其多对多属性。您可以像使用任何其他对象valueForKey:和setValue:forKey: (或它们的键路径等同方法) 一样获取或设置集合对象。但是, 当您要操作这些集合的内容时, 使用协议定义的可变代理方法通常是最有效的。该协议为集合对象访问定义了三种不同的代理方法, 每个都具有一个键和一个键路径变体方法: mutableArrayValueForKey: 和 mutableArrayValueForKeyPath:这两个方法返回一个类似于NSMutableArray对象的代理对象。 mutableSetValueForKey: 和 mutableSetValueForKeyPath:这两个方法返回一个类似于NSMutableSet对象的代理对象。 mutableOrderedSetValueForKey: 和 mutableOrderedSetValueForKeyPath:这两个方法返回一个类似于NSMutableOrderedSet对象的代理对象。 当您对代理对象进行操作，向对象添加对象，从中删除对象或替换对象时, 协议的默认实现将相应地修改基础属性。这比使用valueForKey:得到一个不可变集合对象更有效，创建一个修改了内容的可变集合对象，然后使用setValue:forKey:消息将其存储回对象。在许多情况下, 它也比直接使用可变属性更有效。这些方法提供了对集合对象中保存的对象保持键值观察遵从性的额外好处 (有关详细信息，请参阅Key-Value Observing Programming Guide 使用集合运算符当你向符合键值编码的对象发送valueForKeyPath:消息时, 可以在键路径中嵌入集合运算符。集合运算符是一个小的关键字列表，前面带一个at符号（@）, 它指定了getter应该执行的操作，以便在返回之前以某种方式操作数据。valueForKeyPath:由NSObject默认实现。 当键路径包含集合运算符时, 运算符前面的键路径的任何部分 (称为左键路径) 指向相对于消息接收者操作的集合。如果将消息直接发送到集合对象 (例如NSArray实例), 则可以省略左键路径。操作符之后的键路径部分（称为右键路径）指定操作符应处理的集合中的属性。除了@count需要正确的键路径之外，所有集合运算符。 `keypathToCollection.@collectionOperator.keypathToProperty` 集合运算符展示了三种基本行为类型: 聚合运算符以某种方式合并集合的对象，并返回通常与右键路径中指定的属性的数据类型匹配的单个对象。该@count运算符是一个例外，它没有右键路径并始终将返回一个NSNumber实例。 数组运算符返回一个NSArray实例，该实例包含命名集合中保存的对象的某个子集。 嵌套操作符处理包含其他集合的集合，并根据操作符返回一个NSArray或NSSet实例，它以某种方式组合嵌套集合的对象。 示例数据 下面描述包括演示如何调用每个运算符的代码段，以及执行此操作的结果。这依赖于BankAccount类 (在[列表 2-1]中显示), 它是一个保存Transaction对象的数组。其中每一个都代表一个简单的checkbook条目, 如清单 4-1中所声明的那样。 //清单 4-1Transaction对象的接口声明 @interface Transaction : NSObject @property (nonatomic) NSString* payee; // To whom @property (nonatomic) NSNumber* amount; // How much @property (nonatomic) NSDate* date; // When @end 为了便于讨论, 假定BankAccount实例具有很多交易数组, 并且您可以从BankAccount对象内部进行调用。 聚合运算符：聚合运算符处理array或set属性, 从而生成反映集合某些方面的单个值。 @avg：当指定@avg运算符时, valueForKeyPath:读取集合中每个元素的右键路径指定的属性, 将其转换为double (nil值用0替代), 并计算这些值的算术平均值。然后它返回存储在NSNumber实例中的结果。 //数据之间的平均交易记录金额 NSNumber *transactionAverage = [self.transactions valueForKeyPath:@&quot;@avg.amount&quot;]; @count：指定@count运算符时, valueForKeyPath:返回一个包含集合中的对象个数的NSNumber实例。右键路径 (如果存在) 将被忽略。 //在transactions中获取Transaction对象的数目: NSNumber *numberOfTransactions = [self.transactions valueForKeyPath:@&quot;@count&quot;]; @max:指定@max运算符时, valueForKeyPath:在由右键路径命名的集合项之间进行搜索, 并返回最大值。搜索使用compare:方法进行比较, 该方法由许多Foundation类（例如NSNumber类）定义。因此, 由右键路径指示的属性必须包含一个对此消息有意义响应的对象。搜索忽略值为nil的集合项。 //获取日期值 (即最新交易记录的日期) 的最大数量: NSDate *latestDate = [self.transactions valueForKeyPath:@&quot;@max.date&quot;]; @min:指定@min运算符时, valueForKeyPath:在由右键路径命名的集合项之间进行搜索, 并返回最小值。搜索使用compare:方法进行比较, 许多基础类 (如NSNumber类) 中都有定义。因此, 由右键路径指示的属性必须持有对此消息有意义响应的对象。搜索忽略值为nil的集合项。 //获取日期值 (即最早的事务的日期) 的最短时间。 NSDate *earliestDate = [self.transactions valueForKeyPath:@&quot;@min.date&quot;]; @sum:指定@sum运算符时, valueForKeyPath:读取集合中每个元素的右键路径指定的属性, 将其转换为double (nil值替换为 0), 并计算总和。然后返回存储在NSNumber实例中的结果。 //数据之间的交易记录金额的总和: NSNumber *amountSum = [self.transactions valueForKeyPath:@&quot;@sum.amount&quot;]; 数组运算符数组运算符使valueForKeyPath:返回与右键路径指示的特定对象集相对应的对象数组。注意：在使用数组运算符时, 如果有任何叶(leaf)对象为nil, 则valueForKeyPath:方法将引发异常。 @distinctUnionOfObjects：指定@distinctUnionOfObjects运算符时, valueForKeyPath:将创建并返回一个数组, 该数组包含与右键路径指定的属性对应的集合的不同对象。 //获取transactions中的交易记录的payee属性值的集合, 并省略重复值: NSArray *distinctPayees = [self.transactions valueForKeyPath:@&quot;@distinctUnionOfObjects.payee&quot;]; @unionOfObjects:指定@unionOfObjects运算符时, valueForKeyPath:将创建并返回一个数组, 该数组包含与由右键路径指定的属性对应的集合的所有对象。与@distinctUnionOfObjects不同, 不会删除重复对象。 //获取transactions中的交易记录的payee属性值的集合: NSArray *payees = [self.transactions valueForKeyPath:@&quot;@unionOfObjects.payee&quot;]; 嵌套运算符嵌套运算符对嵌套集合进行操作, 集合本身的每个条目都包含一个集合。注意：如果在使用嵌套运算符时, 有任何叶(leaf)对象为nil, 则valueForKeyPath:方法将引发异常。 NSArray* moreTransactions = @[&lt;# transaction data #&gt;];NSArray* arrayOfArrays = @[self.transactions, moreTransactions]; @distinctUnionOfArrays:指定@distinctUnionOfArrays运算符时, valueForKeyPath:创建并返回一个数组, 其中包含与右键路径指定的属性相对应的所有集合的组合的不同对象。在arrayOfArrays中的所有数组中获取payee属性的不同值:NSArray *collectedDistinctPayees = [arrayOfArrays valueForKeyPath:@”@distinctUnionOfArrays.payee”]; @unionOfArrays:指定@unionOfArrays运算符时, valueForKeyPath:创建并返回一个数组, 其中包含与由右键路径指定的属性相对应的所有集合的组合的所有对象, 而不删除重复项。 //在arrayOfArrays中的所有数组中获取payee属性的值: NSArray *collectedPayees = [arrayOfArrays valueForKeyPath:@&quot;@unionOfArrays.payee&quot;]; @distinctUnionOfSets:当指定@distinctUnionOfSets运算符时, valueForKeyPath:创建并返回一个NSSet对象, 其中包含与由右键路径所指定的属性相对应的所有集合组合的不同对象。此运算符的行为与@distinctUnionOfArrays类似, 只是它需要一个包含NSSet实例的NSSet实例对象, 其中, 而不是包含NSArray实例的NSArray实例对象。此外, 它还返回一个NSSet实例。假设示例数据已存储在集合而不是数组中, 则示例调用和结果与@distinctUnionOfArrays中显示的相同。 标量类型的处理通过NSObject使用对象和非对象属性提供的键值编码协议方法的默认实现。 默认实现自动在对象参数或返回值以及非对象属性之间进行转换。 这允许即使存储的属性是标量或结构体，基于key的getter和setter的命名也保持一致。注意：因为Swift中的所有属性都是对象，所以本节仅适用于Objective-C属性。 当你调用协议的其中一个getter时，valueForKey：，默认实现根据Accessor Search Patterns中描述的规则 确定为指定键提供值的特定访问器方法或实例变量。 如果返回值不是对象，则getter使用此值初始化NSNumber对象（对于标量）或NSValue对象（对于结构体）并返回该值。同样，默认情况下，像setValue：forKey:这样的setter在给定特定键的情况下确定属性的访问器或实例变量所需的数据类型。 如果数据类型不是对象，则setter首先向传入值对象发送适当的 Value消息以提取基础数据，并存储该数据。 注意:当您使用非对象属性的nil值调用其中一个KVC协议setter时，setter没有明显的一般操作过程。 因此，它向接收setter调用的对象发送setNilValueForKey：消息。 此方法的默认实现引发NSInvalidArgumentException异常，但子类可能会覆盖此行为，如Handling Non-Object Values中所述，例如设置标记值或提供有意义的默认值。 包装和解包标量类型 BOOL/char/double/float等基本类型包含在NSNumber对象中 NSPoint/NSRange/NSRect/NSSize等结构体类型和自定义的结构体类型包含在NSValue对象中 验证属性键值编码协议定义了支持属性验证的方法。就像使用基于键的访问器来读取和写入符合键值编码的对象的属性一样，您也可以按键（或键路径）验证属性。手动调用方法validateValue:forKey:error:(或validateValue:forKeyPath:error:)即可，如果我们需要对验证属性进行自定义，则需在对象中自定义方法validate&lt;Key&gt;:error:。如果对象没有此类方法， 则默认情况下验证成功, 默认实现返回YES`。当存在属性特定的验证方法时， 默认实现将返回调用该方法的结果。 注意:您通常仅在Objective-C中使用此处描述的验证。在 Swift 中, 通过依赖 optionals 和强类型检查的编译器支持, 可以更便捷地处理属性验证, 同时使用内置的 willSet 和 didSet 属性观察器来测试任何运行时 API 协定, 详见The Swift Programming Language (Swift 4.2)中Property Observers章节对willSet didSet的描述。 由于属性特定的验证方法通过引用的方式接收值和错误参数, 因此验证有三种可能的结果: 验证方法判断值对象有效并返回YES而不改变值或错误。 验证方法判断值对象无效, 但选择不更改它。在这种情况下, 该方法返回NO并将错误引用 (如果调用方提供) 设置到NSError指示失败原因的对象。 验证方法判断值对象无效, 但创建一个新的、有效的对象作为替换。在这种情况下, 该方法返回YES同时保持错误对象不变。返回之前, 该方法修改值引用以指向新值对象。当它进行修改时, 该方法总是创建一个新对象, 而不是修改旧值, 即使 value 对象是可变的。 自动验证：通常, 键值编码协议及其默认实现都不定义任何自动执行验证的机制。但是, 您可以在您的应用程序中使用适合的验证方法。某些其他Cocoa技术在某些情况下会自动进行验证。例如, Core Data会在保存托管对象上下文时自动执行验证 (详见Core Data Programming Guide)。此外, 在 macOS 中, Cocoa Bindings 允许您指定验证是否自动进行 (请阅读Cocoa Bindings Programming Topics了解有关Cocoa Bindings的更多信息。)。 搜索规则NSObject默认实现NSKeyValueCoding协议提供的基于键的访问器，使用一组明确定义的规则来调用对象的基础属性。这些协议方法使用键参数在其自己的对象实例中搜索访问器，实例变量以及遵循某些命名约定的相关方法。尽管您很少修改此默认搜索， 但了解它的工作方式会有所帮助，对于跟踪键值编码对象的行为，也可以使您自己的对象兼容。 注意：本节中的描述使用或作为键字符串的占位符，该键字符串在一个键值编码协议方法中作为参数出现，然后该方法将该键字符串用作间接方法调用或变量名称查找的一部分。映射的属性名称遵循占位符大小写的情况。例如，对于getter和is，名为 hidden 的属性映射为hidden和isHidden .。 基本的Getter搜索模式valueForKey：的默认实现，给定一个key参数作为输入，在接收valueForKey：调用的类实例中操作，执行以下过程。 搜索实例与名称，按照该顺序，搜索找到的名称为get、、is或的第一个访问器方法。如果找到，调用它并继续到步骤5。否则请继续执行下一步。 如果找不到简单取值方法, 则在实例中搜索其方法名形如 countOf和objectInAtIndex: （相当于NSArray类中定义的基本方法）和AtIndexes:（相当于NSArray类中的objectsAtIndexes:方法）的方法。如果第一个方法和后边两个方法中的至少一个方法被实现了, 则创建一个能够响应所有NSArray方法并返回该方法的集合代理对象。否则, 继续执行步骤3。代理对象随后将它接收的任何NSArray消息转换为countOf ，objectIn AtIndex：和 AtIndexes：的消息，并将其发送给创建它的键值编码兼容对象。如果原始对象还实现了一个名为get ：range：的可选方法，则代理对象也会在适当时使用该方法。实际上，与符合键值编码的对象一起工作的代理对象允许底层属性的行为就像它是一样NSArray，即使它不是。 如果没有找到简单的访问器方法或数组访问方法组，请查找名为countOf ，enumeratorOf 和memberOf ：的方法的三个方法（对应于NSSet类定义的原始方法）。如果找到所有三个方法，请创建一个响应所有NSSet方法并返回该方法的集合代理对象。 否则，请继续执行步骤4。这个代理对象随后将它接收的任何NSSet消息转换为count Of ，enumeration of 和member Of ：消息到创建它的对象。实际上，与符合键值编码的对象一起工作的代理对象允许底层属性的行为就像它是一样NSSet，即使它不是。 如果找不到简单访问器方法或集合访问方法组, 并且消息接收者的类方法accessInstanceVariablesDirectly返回YES, 则系统按以下顺序搜索名为:_、 _is、 或is的实例变量。如果找到, 则直接获取实例变量的值, 然后继续执行步骤5。否则, 继续跳转到步骤6。 如果获取到的属性值是对象指针,即获取的是对象, 则直接将对象返回。如果获取到的属性值是NSNumber支持的数据类型, 则将其存储在NSNumber实例并返回。如果获取到的属性值不是 NSNumber 支持的类型, 则转换为NSValue对象, 然后返回。 如果上述所有方法都没有执行，则调用valueForUndefinedKey：。 默认情况下，这会引发异常，但NSObject的子类可以通过重载并根据特定key做一些特殊处理。 基本的Setter搜索方式setValue:forKey:的默认实现, 给定key和value参数作为输入, 在接收调用的对象内尝试将名为key的属性设置为value(或者, 对于非对象属性, 则为unwarp value, 详见Representing Non-Object Values), 使用以下过程: 按照顺序查找第一个名为set:或_set的方法。如果找到, 传入输入值 (或根据需要展开值) 调用它, 然后完成。 如果找不到简单访问器, 并且类方法accessInstanceVariablesDirectly返回YES, 则按以下顺序查找实例变量: _、 _is、、is 。如果找到, 则直接使用输入值 (或展开值) 设置变量并完成。 如果找不到以上方法或实例变量, 则调用setValue:forUndefinedKey:。默认情况下，这会引发异常，但NSObject的子类可以通过重载并根据特定key做一些特殊处理。 可变数组的搜索方式mutableArrayValueForKey：的默认实现，给定一个key参数作为输入，使用以下过程为接收访问者调用的对象内的一个名为key的属性返回一个可变代理数组： 查找一对方法, 名为insertObject：in AtIndex：和removeObjectFrom AtIndex：的方法（分别对应于NSMutableArray原始方法insertObject：atIndex：和removeObjectAtIndex：） ，或者名称类似于insert ：atIndexes：和remove AtIndexes：（对应于NSMutableArrayinsertObjects：atIndexes：和removeObjectsAtIndexes：方法）。如果对象至少实现一个插入方法和至少一个删除方法，则返回一个响应NSMutableArray消息的代理对象，方法是发送insertObject：in AtIndex：，removeObjectFrom AtIndex：，insert ：atIndexes：，和remove AtIndexes：消息到mutableArrayValueForKey：的原始接收者。当接收mutableArrayValueForKey：消息的对象也实现了一个可选的替换对象方法，其名称如replaceObjectIn AtIndex：withObject：或replace AtIndexes：with ：，代理对象在适合最佳性能时会自动调用该可选方法。 如果对象没有可变数组方法，则查找名称与模式set ：匹配的访问器方法。 在这种情况下，通过向mutableArrayValueForKey：的原始接收者发出set ：消息，返回响应NSMutableArray消息的代理对象。注意:此步骤中描述的机制比上一步的效率要低得多, 因为它可能涉及重复创建新的集合对象, 而不是修改现有的。因此, 在设计自己的键值编码兼容对象时, 通常应避免这种情况。 如果既没有找到可变数组方法，也没有找到访问器，并且接收者的类对accessInstanceVariablesDirectly响应’YES，则按照顺序搜索名为_ 或`的实例变量。如果找到这样的实例变量，则返回一个代理对象，该对象将它接收的每个NSMutableArray消息转发给实例变量的值，该值通常是NSMutableArray的实例或其子类之一。 如果所有其他方法都失败了，只要收到NSMutableArray消息，就返回一个可变集合代理对象，该对象向mutableArrayValueForKey：消息的原始接收者发出setValue：forUndefinedKey：消息。setValue:forUndefinedKey:的默认实现会抛出NSUndefinedKeyException异常, 但子类可能会重写此行为。 可变有序集的搜索方式mutableOrderedSetValueForKey的默认实现：将相同的简单访问器方法和有序集访问器方法识别为valueForKey:(请参阅 Default Search Pattern for the Basic Getter），并遵循相同的直接访问实例变量策略，但始终返回可变集合代理对象 valueForKey：返回的不可变集合。 此外，它还执行以下操作： 搜索名称类似于以下形式的方法: insertObject：in AtIndex：和removeObjectFrom AtIndex：（对应于NSMutableOrderedSet类定义的两个最原始方法），以及insert ： atIndexes：和remove AtIndexes：（对应于insertObjects：atIndexes：和removeObjectsAtIndexes：）。如果找到至少一个insert方法和至少一个remove方法，返回的代理对象每次接收到 NSMutableOrderedSet的消息后， 会通过以下组合方法给mutableOrderedSetValueForKey的原始对象 发送消息: mutableOrderedSetValueForKey: insertObject:inAtIndex:, removeObjectFrom AtIndex :, insert ：atIndexes： removeAtIndexes:代理对象还使用方法名为 replaceObjectIn AtIndex：withObject： 的方法，或replaceAtIndexes:with: ,当这些方法存在于原始对象中时。 如果找不到可变的set方法，请搜索名为set ：的访问器方法。 在这种情况下，返回的代理对象每次收到NSMutableOrderedSet消息时都会向mutableOrderedSetValueForKey：的原始接收者发送一个set ：消息。注意：此步骤中描述的机制比前一步骤的效率低得多，因为它可能涉及重复创建新的集合对象而不是修改现有的集合对象。 因此，在设计自己的符合键值编码的对象时，通常应该避免使用它。 如果找不到可变集消息和访问器，并且接收者的accessInstanceVariablesDirectly类方法返回YES，则按顺序搜索名称如_ 或的实例变量。 如果找到这样的实例变量，则返回的代理对象将它接收的任何NSMutableOrderedSet消息转发给实例变量的值，该值通常是NSMutableOrderedSet或其子类之一的实例。 如果所有其他方法都失败了，那么只要收到一个可变的set消息，返回的代理对象就会向mutableOrderedSetValueForKey：的原始接收者发送一个setValue：forUndefinedKey：消息。setValue：forUndefinedKey：的默认实现引发了一个NSUndefinedKeyException，但是对象可能会覆盖此行为。 可变集的搜索方式mutableSetValueForKey：的默认实现，给定一个key参数作为输入，使用以下过程为接收访问者调用的对象内的一个名为key的数组属性返回一个可变代理集： 搜索方法名称为addObject:和 remove Object 的方法：（分别对应于NSMutableSet原始方法addObject:和removeObject:）以及add：和remove:（对应于NSMutableSet 方法unionSet:和minusSet: ）。如果找到至少一个添加方法和至少一个删除方法，则返回一个NSMutableSet代理对象，该代理对象发送add Object：，remove Object：，add ：的某种组合， 和remove ：对于它收到的每个NSMutableSet消息的mutableSetValueForKey：的原始接收者的消息。代理对象还使用名称为“cross：”或“set：”的方法来提高性能（如果可用的话）。 如果mutableSetValueForKey：调用的接收者是托管对象，则搜索模式不会像非托管对象那样继续。 有关更多信息，请参阅“Core Data Programming Guide”中的托管对象访问器方法。 如果找不到可变集合方法，并且对象不是托管对象，则搜索名为set ：的访问器方法。 如果找到这样的方法，则返回的代理对象将set ：消息发送给它接收的每个NSMutableSet消息的mutableSetValueForKey：的原始接收者。注意：此步骤中描述的机制的效率远低于第一步的机制，因为它可能涉及重复创建新的集合对象而不是修改现有的集合对象。 因此，在设计自己的符合键值编码的对象时，通常应该避免使用它。 如果找不到可变的set方法和accessor方法，并且accessInstanceVariablesDirectly类方法返回YES，则按照顺序搜索名为_ 或的实例变量。 如果找到这样的实例变量，则代理对象将它接收的每个NSMutableSet消息转发给实例变量的值，该值通常是NSMutableSet的实例或其子类之一。 如果所有其他方法都失败了，返回的代理对象通过向mutableSetValueForKey：’的原始接收者发送setValue：forUndefinedKey：消息来响应它收到的任何NSMutableSet`消息。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>iOS</tag>
        <tag>KVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARKit增强现实]]></title>
    <url>%2F2018%2F10%2F26%2FARKit%E5%A2%9E%E5%BC%BA%E7%8E%B0%E5%AE%9E%2F</url>
    <content type="text"><![CDATA[概念VR：Virtual Reality 虚拟现实，是一种仿真技术，模拟周围的环境、人物、动物等，让用户完全沉浸到该环境中，并在该环境中进行各种交互，现在一般会通过外设（头盔、眼镜等）。 AR：Augmented Reality 增强现实，是一种在摄像机捕捉到真实世界，增加虚拟化物品，并能进行互动，主要以真实世界为主。 核心点ARKit和ARCore的三大核心点：运动追踪、环境识别和光线感应 运动追踪（Motion tracking）:视觉惯性测量(Visual Inertial Odometry)，ARKit使用视觉惯性测距技术获取手机的位置和方向，其原理是，对摄像头采集到的图像序列进行视觉分析，找出其特征点在连续的图像帧之间的位置变化，再通过设备的运动传感器，最终得到设备的位置和方向，因此使用时可以将虚拟对象固定在一个位置，并围绕它移动。 环境识别（Environmental understanding）：使用相机检测到平坦的表面（比如桌面、地板或天花板），可以让用户将 AR 物体精准的” 放置 “在平面上。 光线感应（Light estimation）：ARCore 可以感知所处环境中的环境光，使开发人员可以通过与周围环境相匹配光线塑造虚拟形象，使其外观更加逼真。 详解核心类 ARSession：前面三大核心点的实现 ARCamera：通过手机摄像头抓取图片 ARSCNView：展示场景 ARSession通过ARCamera抓取的图片，做识别，识别出特征点在哪，平面在哪，光线的情况是怎么样的，然后将图片传给ARSCNView进行渲染，再根据交互，来添加虚拟物品 SceneKit SCNNode：虚拟物品节点 SCNScene：场景，虚拟物品在添加到view上之前，需加到Scene里，添加到Scene之后才能展示 SCNMaterial：物体材质 除了用苹果的3D引擎SceneKit之外，还可以用其他引擎，如SpriteKit，Matal自己来写虚拟物品渲染逻辑、Unity3D、unreal4(UE4)等 如果你要做纯粹的AR app，更多的技术公司还是会通过Unity或者UE4来开发，因为这些引擎生态更好，并且可以跨平台；但是这样的话app体积必然是很大的。 ARKit运行机制 ARConfiguration：ARSession的配置信息，配置它是检测水平平面还是垂直平面等。 ARFrame：从ARCamera获取的视频，来获取的一帧帧图片 ARAnchor：你的虚拟物品放在哪个位置，由它来决定 用法创建一个ARKit工程： @interface ViewController () &lt;ARSCNViewDelegate&gt; @property (nonatomic, strong) IBOutlet ARSCNView *sceneView; @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; self.sceneView.delegate = self; self.sceneView.showsStatistics = YES; SCNScene *scene = [SCNScene sceneNamed:@&quot;art.scnassets/ship.scn&quot;]; self.sceneView.scene = scene; } - (void)viewWillAppear:(BOOL)animated { [super viewWillAppear:animated]; ARWorldTrackingConfiguration *configuration = [ARWorldTrackingConfiguration new]; [self.sceneView.session runWithConfiguration:configuration]; } - (void)viewWillDisappear:(BOOL)animated { [super viewWillDisappear:animated]; [self.sceneView.session pause]; } #pragma mark - ARSCNViewDelegate - (void)session:(ARSession *)session didFailWithError:(NSError *)error { } - (void)sessionWasInterrupted:(ARSession *)session { } - (void)sessionInterruptionEnded:(ARSession *)session { } @end 手动点击屏幕时，添加物品 @interface ARKitViewControllerOne () { ARSCNView *_scnView; } @end @implementation ARKitViewControllerOne - (void)viewDidLoad { [super viewDidLoad]; _scnView = [[ARSCNView alloc] initWithFrame:[UIScreen mainScreen].bounds]; _scnView.debugOptions = ARSCNDebugOptionShowFeaturePoints; [self.view addSubview:_scnView]; } - (void)viewDidAppear:(BOOL)animated { [super viewDidAppear:animated]; //跳转到另外一个页面，然后返回时，重新配置 ARWorldTrackingConfiguration *config = [ARWorldTrackingConfiguration new]; config.planeDetection = ARPlaneDetectionHorizontal; [_scnView.session runWithConfiguration:config]; } - (void)viewDidDisappear:(BOOL)animated { [_scnView.session pause]; } - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event { //添加画布 SCNScene *scnScene = [SCNScene sceneNamed:@&quot;art.scnassets/ship.scn&quot;]; //移动画布内节点的位置 SCNNode *node = scnScene.rootNode.childNodes[0]; node.position = SCNVector3Make(0, 0, -0.3); _scnView.scene = scnScene; } @end 设置自动识别平面，然后自动添加物品 ARSessionDelegate-&gt;didUpdateFrame ARSessionDelegate-&gt;didAddAnchors ARSCNViewDelegate-&gt;nodeForAnchor ARSCNViewDelegate-&gt;didAddNode:forAnchor: @interface ARKitViewControllerTwo () &lt;ARSCNViewDelegate, ARSessionDelegate&gt; { ARSCNView *_scnView; } @end @implementation ARKitViewControllerTwo - (void)viewDidLoad { [super viewDidLoad]; _scnView = [[ARSCNView alloc] initWithFrame:[UIScreen mainScreen].bounds]; _scnView.delegate = self; _scnView.session.delegate = self; _scnView.debugOptions = ARSCNDebugOptionShowFeaturePoints; [self.view addSubview:_scnView]; } - (void)viewDidAppear:(BOOL)animated { [super viewDidAppear:animated]; //跳转到另外一个页面，然后返回时，重新配置 ARWorldTrackingConfiguration *config = [ARWorldTrackingConfiguration new]; config.planeDetection = ARPlaneDetectionHorizontal; [_scnView.session runWithConfiguration:config]; } - (void)viewDidDisappear:(BOOL)animated { [_scnView.session pause]; } //在检测到平面的时候，来添加虚拟物品 # pragma mark -- ARSCNViewDelegate //- (nullable SCNNode *)renderer:(id &lt;SCNSceneRenderer&gt;)renderer nodeForAnchor:(ARAnchor *)anchor { // //} - (void)renderer:(id &lt;SCNSceneRenderer&gt;)renderer didAddNode:(SCNNode *)node forAnchor:(ARAnchor *)anchor { NSLog(@&quot;didAddNode&quot;); if ([anchor isMemberOfClass:[ARPlaneAnchor class]]) { ARPlaneAnchor *planAnchor = (ARPlaneAnchor *)anchor; SCNBox *box = [SCNBox boxWithWidth:planAnchor.extent.x*0.3 height:0 length:planAnchor.extent.x*0.3 chamferRadius:0]; SCNNode *planNode = [SCNNode nodeWithGeometry:box]; planNode.position = SCNVector3Make(planAnchor.center.x, 0, planAnchor.center.z); [node addChildNode:planNode]; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ SCNScene *scnScene = [SCNScene sceneNamed:@&quot;art.scnassets/ship.scn&quot;]; //移动画布内节点的位置 SCNNode *planeNode = scnScene.rootNode.childNodes[0]; planeNode.position = SCNVector3Make(planAnchor.center.x, 0, planAnchor.center.z); [node addChildNode:planeNode]; }); } } - (void)renderer:(id &lt;SCNSceneRenderer&gt;)renderer willUpdateNode:(SCNNode *)node forAnchor:(ARAnchor *)anchor { NSLog(@&quot;willUpdateNode&quot;); } - (void)renderer:(id &lt;SCNSceneRenderer&gt;)renderer didUpdateNode:(SCNNode *)node forAnchor:(ARAnchor *)anchor { NSLog(@&quot;didUpdateNode&quot;); } - (void)renderer:(id &lt;SCNSceneRenderer&gt;)renderer didRemoveNode:(SCNNode *)node forAnchor:(ARAnchor *)anchor { NSLog(@&quot;didRemoveNode&quot;); } # pragma mark -- ARSessionDelegate - (void)session:(ARSession *)session didUpdateFrame:(ARFrame *)frame { NSLog(@&quot;didUpdateFrame&quot;); } - (void)session:(ARSession *)session didAddAnchors:(NSArray&lt;ARAnchor*&gt;*)anchors { NSLog(@&quot;didAddAnchors&quot;); } - (void)session:(ARSession *)session didUpdateAnchors:(NSArray&lt;ARAnchor*&gt;*)anchors { NSLog(@&quot;didUpdateAnchors&quot;); } - (void)session:(ARSession *)session didRemoveAnchors:(NSArray&lt;ARAnchor*&gt;*)anchors { NSLog(@&quot;didRemoveAnchors&quot;); } @end 点击屏幕，添加屏幕快照 - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event { CGRect bounds = [UIScreen mainScreen].bounds; //默认是垂直的，计量单位是按米来计算的，所以值设置小一点 SCNPlane *plane = [SCNPlane planeWithWidth:bounds.size.width/6000 height:bounds.size.height/6000]; plane.firstMaterial.diffuse.contents = _scnView.snapshot; SCNNode *node = [SCNNode nodeWithGeometry:plane]; [_scnView.scene.rootNode addChildNode:node]; //node跟随着camera的位置的改变而改变 node.simdTransform = _scnView.session.currentFrame.camera.transform; } 自动识别水平面，保存并动态配置其大小 - (void)renderer:(id &lt;SCNSceneRenderer&gt;)renderer didAddNode:(SCNNode *)node forAnchor:(ARAnchor *)anchor { NSLog(@&quot;didAddNode&quot;); if ([anchor isMemberOfClass:[ARPlaneAnchor class]]) { ARPlaneAnchor *planAnchor = (ARPlaneAnchor *)anchor; if (!_planeDict[[anchor identifier]]) { SCNPlane *plane = [SCNPlane planeWithWidth:planAnchor.extent.x height:planAnchor.extent.z]; plane.firstMaterial.diffuse.contents = [UIImage imageNamed:@&quot;art.scnassets/texture.png&quot;]; SCNNode *planNode = [SCNNode nodeWithGeometry:plane]; planNode.position = SCNVector3Make(planAnchor.center.x, 0, planAnchor.center.z); planNode.transform = SCNMatrix4MakeRotation(-M_PI_2, 1, 0, 0); [node addChildNode:planNode]; NSArray *array = @[plane, planNode]; _planeDict[[anchor identifier]] = array; } } } - (void)renderer:(id &lt;SCNSceneRenderer&gt;)renderer willUpdateNode:(SCNNode *)node forAnchor:(ARAnchor *)anchor { NSLog(@&quot;willUpdateNode&quot;); if ([anchor isMemberOfClass:[ARPlaneAnchor class]]) { ARPlaneAnchor *planAnchor = (ARPlaneAnchor *)anchor; if (_planeDict[[planAnchor identifier]]) { SCNPlane *plane = _planeDict[[planAnchor identifier]][0]; SCNNode *planeNode = _planeDict[[planAnchor identifier]][1]; plane.width = planAnchor.extent.x; plane.height = planAnchor.extent.z; planeNode.position = SCNVector3Make(planAnchor.center.x, 0, planAnchor.center.z); } } } 添加公转物体 - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event { SCNScene *scnScene = [SCNScene sceneNamed:@&quot;art.scnassets/ship.scn&quot;]; //移动画布内节点的位置 SCNNode *node = scnScene.rootNode.childNodes[0]; node.position = SCNVector3Make(0, 0, -0.3); [_scnView.scene.rootNode addChildNode:node]; CABasicAnimation *anim = [CABasicAnimation animationWithKeyPath:@&quot;rotation&quot;]; anim.duration = 20; anim.toValue = [NSValue valueWithSCNVector4:SCNVector4Make(0, 1, 0, M_PI_2*2)]; [node addAnimation:anim forKey:nil]; } 点击添加物品到第一个识别到的平面上 - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event { UITouch *touch = [touches anyObject]; CGPoint point = [touch locationInView:self.view]; //1. ARHitTestResultTypeExistingPlane 从检测到的平面 无限扩展 //2. ARHitTestResultTypeExistingPlaneUsingExtent 从检测到的平面 有边界 //3. ARHitTestResultTypeFeaturePoint 从特征点 //4. ARHitTestResultTypeEstimatedHorizontalPlane 从估算出来的水平面 //5. ARHitTestResultTypeEstimatedVerticalPlane 从估算出来的垂直面 //6. ARHitTestResultTypeExistingPlaneUsingGeometry 从几何图形上的平面 NSArray&lt;ARHitTestResult *&gt; * hitTestResult = [_scnView hitTest:point types:ARHitTestResultTypeExistingPlane]; [self addNodeToHitTestResult:[hitTestResult firstObject]]; } - (void)addNodeToHitTestResult:(ARHitTestResult *)result { SCNScene *scnScene = [SCNScene sceneNamed:@&quot;art.scnassets/ship.scn&quot;]; //移动画布内节点的位置 SCNNode *node = scnScene.rootNode.childNodes[0]; node.position = SCNVector3Make(result.worldTransform.columns[3].x, result.worldTransform.columns[3].y, result.worldTransform.columns[3].z); [_scnView.scene.rootNode addChildNode:node]; } 检测情况提示 # pragma mark -- ARSessionDelegate - (void)session:(ARSession *)session cameraDidChangeTrackingState:(ARCamera *)camera { if (camera.trackingState == ARTrackingStateNormal) { _label.text = @&quot;检测正常&quot;; } else if (camera.trackingState == ARTrackingStateNotAvailable) { _label.text = @&quot;不可用&quot;; } else if (camera.trackingState == ARTrackingStateLimited &amp;&amp; camera.trackingStateReason == ARTrackingStateReasonInitializing) { _label.text = @&quot;正在初始化&quot;; } else if (camera.trackingState == ARTrackingStateLimited &amp;&amp; camera.trackingStateReason == ARTrackingStateReasonExcessiveMotion) { _label.text = @&quot;速度过快&quot;; } else if (camera.trackingState == ARTrackingStateLimited &amp;&amp; camera.trackingStateReason == ARTrackingStateReasonInsufficientFeatures) { _label.text = @&quot;特征点过少&quot;; } }]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>ARKit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[支付宝框架解析]]></title>
    <url>%2F2018%2F09%2F28%2F%E6%94%AF%E4%BB%98%E5%AE%9D%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[App膨胀过程手机天猫解耦之路原文 总结：一个APP的开发模式一般有这么几个过程 当主程搭建框架时：一个简单的MVC工程，缺点是不同的人开发没有功能分层 当几人协同开发时：模块化（先按功能把工程做横向分层，在业务层再做纵向梳理。把不同的模块代码简单的放在一个文件夹里），缺点是花大量的时间解决编译不过的问题 当几个团队协同开发时：插件化，我们引入依赖管理设施（iOS引入了Cocoa Pods，Android使用Maven）；把此前的模块进一步剥离成独立工程，单独做版本管理；每个独立的插件对发布的版本号负责，不论是其他插件还是主工程都依赖插件发布的稳定版本（插件是可以独立开发，独立发布，独立运行的，而模块则必须依赖主工程的环境） 开发到一定的代码量时：由于主工程是通过各插件的源码组合起来的，当源码量达到十万级以上时每一次重新索引和编译，都要消耗大量的时间。每次发布不再是一个稳定版本号，而是一个稳定的二进制包。要解决这个问题，就是要把插件化进行到底，实现插件的另外两个独立——独立开发和独立运行。最重要的工作就是我们今天的主题解耦，梳理各个插件之间的依赖关系。每次发布不再是一个稳定版本号，而是一个稳定的二进制包。 耦合在这个工程膨胀过程里，我把耦合分成三类： 界面耦合，就是用户操作流程里，从首页-到搜索-到详情-再进店，这些界面的跳转是硬编码的 依赖耦合，顾名思义，两个模块之间的有依赖，就是耦合 工程耦合，每个模块有自己的生命周期和运行时，每个模块在生产环境里又需要依赖主工程的运行时 模块之间的解耦思路 EOCNetFrame工程:(由基础组件团队开发，封装HTTP模块，实现和服务器交互) EOCNetFrame Framework:(模块主代码，EOCNetFrame.h头文件及其他类实现) EOCNetFrameTest:(对EOCNetFrame框架测试，测试稳定后发布版本供其他组调用) TicketFrame工程:(由票吧业务团队开发，基于基础组件团队的模块实现买票业务) TicketFrame Framework:(业务主代码，TicketFrame.h头文件及其他类实现) TickeFrameTest:(对TicketFrame框架测试，测试稳定后发布版本供其他组调用) Project主工程:(由主工程业务团队开发，基于基础组件团队和其他业务组件团队开发主业务) 加入基础团队的各个组件包framework 加入各个业务团队的功能包framework 解耦代码//Net层 //EOCNetFrame.h #import &lt;UIKit/UIKit.h&gt; #import &quot;EOCRequestManager.h&quot; //EOCRequestManager.h + (nonnull instancetype)sharedInstance; + - (AFHTTPRequestOperation *)HttpRequestPostWithURLString:(NSString *)URLString parameters:(NSDictionary *)parameters startImmediately:(BOOL)startImmediately ignoreCache:(BOOL)ignoreCache resultCacheDuration:(NSTimeInterval)resultCacheDuration extend:(__nullable EOCExtendBlock)extendBlock completionHandler:(__nullable EOCRequestCompletionHandler)completionHandler; //Ticket层 //TicketFrame.h #import &lt;UIKit/UIKit.h&gt; #import &quot;TicketRoute.h&quot; //TicketRoute.h @interface TicketRoute : NSObject + (UIViewController*)ticketRootView; @end @implementation TicketRoute + (UIViewController*)ticketRootView{ return [TicketViewCtr new]; } @end //TicketViewCtr @implementation TicketViewCtr - (void)viewDidLoad { [super viewDidLoad]; self.title = @&quot;飞机票&quot;; self.view.backgroundColor = [UIColor blueColor]; [self eocNet]; } - (void)eocNet{ NSString* urlStr = URLPath; NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; [parameters setObject:@&quot;1&quot; forKey:@&quot;versions_id&quot;]; [parameters setObject:@&quot;1&quot; forKey:@&quot;system_type&quot;]; [[EOCRequestManager sharedInstance] HttpRequestPostWithURLString:urlStr parameters:parameters startImmediately:YES ignoreCache:NO resultCacheDuration:3 extend:nil completionHandler:^(NSEOCError *error, id result, BOOL isFromCache, AFHTTPRequestOperation *operation){ if (error) { NSLog(@&quot;%@&quot;, error); }else{ NSLog(@&quot;%@&quot;, result); } }]; } @end //主工程层 UIViewController *homePageViewCtr = [self routeTargetName:@&quot;FindRoute&quot; actionName:@&quot;controllerWithMainTabbar&quot;]; UIViewController *communitViewCtr = [self routeTargetName:@&quot;CommuniteRoute&quot; actionName:@&quot;controllerWithMainTabbar&quot;]; UIViewController *finPlatformVCtr = [self routeTargetName:@&quot;PlatformRoute&quot; actionName:@&quot;controllerWithMainTabbar&quot;]; UIViewController *personViewCtr = [self routeTargetName:@&quot;PersonRoute&quot; actionName:@&quot;controllerWithMainTabbar&quot;]; UINavigationController *baseNavOne = [[UINavigationController alloc] initWithRootViewController:homePageViewCtr]; UINavigationController *baseNavTwo = [[UINavigationController alloc] initWithRootViewController:communitViewCtr]; UINavigationController *baseNavThree = [[UINavigationController alloc] initWithRootViewController:finPlatformVCtr]; UINavigationController *baseNavFour = [[UINavigationController alloc] initWithRootViewController:personViewCtr]; self.viewControllers = [[NSArray alloc] initWithObjects:baseNavOne, baseNavTwo, baseNavThree, baseNavFour, nil]; @interface FindRoute : NSObject - (UIViewController*)controllerWithMainTabbar; @end @implementation FindRoute - (UIViewController*)controllerWithMainTabbar{ HomePageViewCtr *homePageViewCtr = [HomePageViewCtr new]; return homePageViewCtr; } @end //HomePageViewCtr - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event { UIViewController *vc = [TicketRoute ticketRootView]; [self.navigationController pushViewController:vc animated:YES]; } NSObject+RouteRoot - (id)routeTargetName:(NSString*)targetName actionName:(NSString*)actionName param:(id)param { Class targetClass = NSClassFromString(targetName); SEL actionSel = NSSelectorFromString(actionName); NSObject *targetObj = [targetClass new]; if ([targetObj respondsToSelector:actionSel]) { NSMethodSignature *signture = [targetObj methodSignatureForSelector:actionSel]; NSString *returnType = [NSString stringWithUTF8String:signture.methodReturnType]; #pragma clang diagnostic push #pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; if([returnType isEqualToString:@&quot;@&quot;]){ return [targetObj performSelector:actionSel withObject:param]; } else if ([returnType isEqualToString:@&quot;v&quot;]||[returnType isEqualToString:@&quot;V&quot;]) { [targetObj performSelector:actionSel withObject:param]; return nil; } else { [targetObj performSelector:actionSel withObject:param]; return nil; } #pragma clang diagnostic pop } else { NSLog(@&quot;error:%@没有%@方法&quot;, targetName, actionName); return nil; } } 从上面代码可看出，主工程的编译链接运行不依赖于某个业务的内部代码是否完成，因为只要编译出来了framework，即说明子框架及业务是正常链接的 安全问题 hook 非越狱 函数和参数安全 越狱 通过终端来直接操作你的app 运行时 runtime hook的你方法。安全隐患 运行时导致，方法名和参数都能看到 解决方法： define重定义函数的方法名和参数名#define LoginMethod xggedsagegawegga #define loginName kashdfkjhasdf - (void)LoginMethod:(NSString*)loginName{ NSLog(@&quot;loginMethod %@&quot;, loginName); } c的方法@interface SafeCategory : NSObject @end /* 把函数名隐藏在结构体里，以函数指针成员的形式存储。 编译后，只有留下地址，去掉了名字和参数表，提高了逆向成本和攻击门槛 */ typedef struct SafeCatey{ void(*resetPassword)(NSString* password); } SafeCategoryOC; static void _resetPassword(NSString* password){ NSLog(@&quot;设置密码&quot;); } #define SafeUnit ([SafeCategory shareSafeCategory]) @implementation SafeCategory + (SafeCategoryOC*)shareSafeCategory{ static SafeCategoryOC *__safetCategory = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ __safetCategory = malloc(sizeof(SafeCategoryOC)); __safetCategory-&gt;resetPassword = _resetPassword; }); return __safetCategory; } - (void)testSafe:(NSString*)pswd{ SafeUnit-&gt;resetPassword(pswd); } @end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>APPInflation</tag>
        <tag>Optimization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS中的数据结构和算法]]></title>
    <url>%2F2018%2F08%2F31%2FiOS%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[算法三原则： 有穷性：能在有限步骤，有限时间内完成 确定性：对相同的输入，产生唯一的输出，没有歧义 可行性：算法是可行的，在当前设备，经济水平等条件下是可用的 算法分析： 时间复杂度：大O：最坏情况下的时间复杂度（如快排：O(n^2)，期望nlogn）。忽略常数，用来描述随着问题规模的增长，所需时间增长的速率/数量级 空间复杂度：同时间复杂度 对数公式是数学中的一种常见公式，如果a^x=N(a&gt;0,且a≠1)，则x叫做以a为底N的对数,记做x=log(a)(N)，其中a要写于log右下。其中a叫做对数的底，N叫做真数。通常我们将以10为底的对数叫做常用对数，以e为底的对数称为自然对数。 常见分析方法 输入输出，输入输出有时候也是算法的一部分，需要考虑到复杂度内，例如：输入N个元素，则时间复杂度必定大于等于O(n) 数循环次数 均摊分析，注意是否需要均摊，整个算法为O(n)，均摊后每一步可能实际只有O(1) 常见时间复杂度： O(n)：线性查找 O(n^2)：冒泡、插入、选择排序等，每个元素都要与其他所有元素进行一次比较 O(nlogn)：归并排序、快速排序的期望复杂度、基于比较排序的算法下界 基础知识二分查找 查找原理 输入一个长度为N的有序数组a[N]，以及待查找数字b 每次取数组长度N/2位置的元素与b比较，如果相等则返回位置N/2，如果大于，则查找范围缩小到0至(N/2 - 1)，如果小于，则查找范围缩小到(N/2 - 1)至N 重复上述步骤，直到查找范围缩小为1或找到该元素 代码实现 + (int)indexOf:(int)value atCArray:(int [])a start:(int)start end:(int)end { static int recusionCount = 0; recusionCount ++; BOOL needReturn = false; int ret = -1; if (start &gt; end) { ret = -1; needReturn = true; } else if (start == end) { needReturn = true; //数组只有一个元素 if (a[start] == value) { ret = start; }else { ret = -1; } } if (needReturn) { NSLog(@&quot;递归了%d次&quot;,recusionCount); recusionCount = 0; return ret; } int middle = start + (end - start)/2; if (a[middle] == value) { NSLog(@&quot;递归了%d次&quot;,recusionCount); recusionCount = 0; return middle; } else if (a[middle] &gt; value) { //从0 至 middle - 1的区间去找 return [self indexOf:value atCArray:a start:start end:middle-1]; } else { //从middle 至 n-1 的区间查找 return [self indexOf:value atCArray:a start:middle+1 end:end]; } } 算法分析 时间复杂度:O(logn) 附加空间复杂度：O(1) 递归 递归原理（n的阶乘） 每一个f(n-k)，都将向内存栈push一个变量n-k。 当push到n==1时，开始pop，每pop一个k，计算sum=k*sum，直到k==n递归的空间复杂度 n个元素需要n个内存空间存储，所以空间复杂度为O(n) 小心使用，或者不用(所有递归均可转为while循环)，所占内存与问题规模n成正比，容易造成内存不够 常用数据结构栈和队列： 栈：先进后出，push,pop时间复杂度O(1) 问题：设计一个栈有push，pop，最大值操作，且时间复杂度均为O(1)？解决方案：以空间换时间，新开一个栈，栈中保存对应最大值 问题：出入栈合法性判断？解决方案：遵循先进后出原则 问题：用两个队列实现一个栈？解决方案：每次入队之前，出队存入另外一个队列，放入之后，将另外一个队列全部出队，放入现在队列 队列：先进先出，in，out时间复杂度O(1) 问题：用两个栈实现一个队列？解决方案：每次入栈之前，出栈存入另外一个栈，放入之后，将另外一个栈全部出栈，放入现在的栈 数组与链表 数组 通过下标随机存取 一片连续的空间，通过下标查取复杂度O(1)，插入，删除O(n) 查找O(1)，修改时间复杂度O(1)，新增/删除时间复杂度O(n) 链表 使用链表数据结构，分为单向链表，双向链表，环链表等 查找时间复杂度O(n)，新增/删除时间复杂度O(1) 问题：判断链表中是否有环？解决方案：两个指针，一个移动速度是另一个的两倍，如果在结束之前没有相遇，则说明链表中没有环 完全二叉树 概念：完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树 排序：二叉排序树或者是一棵空树，或者是具有下列性质的二叉树 若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值； 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值； 左、右子树也分别为二叉排序树； 存储： 链表：链表中每一个节点，包含两个指针leftchild，rightchild，分别指向左右子树 数组：利用平衡二叉树平衡的特性，使用数组来存储完全二叉树，a[n]的左右子节点分别为a[2n+1]，a[2n+2] 二叉树遍历二叉树遍历以根节点位置命名 * 中序遍历：中根遍历，左中右 * 前序遍历/先序遍历：根在最前面，根左右 * 后序遍历：根在最后面，坐右根 堆 堆实质上是满足如下性质的完全二叉树（堆中某个节点的值总是不大于或不小于其父节点的值；） 一个数组a共N个元素，设2k+2&lt;N,如果a[k]&gt;=a[2k+1]且a[k]&gt;=2[k+2]，则该堆为大顶堆/小顶堆 排序类型：冒泡排序：排序原理： 假设有n个未排序元素a[n] 从第一个元素i=0开始，a[i]与下一个元素a[i+1]比较，如果a[i+1]元素小于a[i]，则交换a[i]与a[i+1]，每一次比较后，i往后移动一位至i+1，直到i==n-1，一趟冒泡结束。 每一趟比较都会将未排序元素中最大的一位浮动到未排序元素的最末尾，因此每走完一趟冒泡，未排序元素减一。 代码实现+ (void)sortCArray:(int [])a length:(int)length { int recusionCount = 0; BOOL needSort = false; int n = length; //n 趟冒泡 for (int i = 0; i &lt; n; i++) { //每趟排序 n 次比较 for (int j = 0; j &lt; n-1-i; j++) { if (a[j] &gt; a[j+1]) { [self swap:&amp;a[j] with:&amp;a[j+1]]; needSort = true; } recusionCount++; } //执行完一趟 if (needSort == false) { break; } } NSLog(@&quot;总共循环了%d次&quot;,recusionCount); } 优化方案 已排序数组提前退出，不需要再继续。参见needSort变量作用 每次排序后最后一个已最大，不需要再排。参见j &lt; n-1-i的作用 算法分析 时间复杂度：O(n^2) 空间复杂度：O(n)，附加空间复杂度为O(1) 快速排序排序原理 创建两个数组下标变量low = 0，high = N-1 创建关键字a[keyIndex]下标keyIndex = 0，以第一个元素做为关键字（实际上可以指定为0-N-1的任意位置） high向前搜索，找到第一个小于a[keyIndex]的元素，交换a[hight],a[keyIndex] low向后搜索，找到第一个大于a[keyIndex]的元素，交换a[low],a[keyIndex] 重复3，4步，直到low==high(==keyIndex)，此时keyIndex将数组分成了两部分0至keyIndex以及keyIndex+1至N-1，分别对两个部分继续使用快速排序 代码实现//期望时间复杂度O(n*logn，底是2) + (int)sortCArray:(int [])a start:(int)start end:(int)end { if (start &gt;= end) { return 0; } int low = start; int high = end; int keyIndex = start; int recusionCout = 0; while (low &lt; high) { //交换 。。。 //从右往左找比keyindex的值小/相等的元素的index，并赋值给high，同时，high必须大于keyIndex while (a[high] &gt;= a[keyIndex] &amp;&amp; high &gt; keyIndex) { high --; recusionCout ++; } //如果从右边往左边找到了比key小的元素，则交换key与该元素 if (a[high] &lt; a[keyIndex]) { [self swap:&amp;a[high] with:&amp;a[keyIndex]]; keyIndex = high; recusionCout ++; } //从左往又找比keyindex的值大/相等的元素的index，并赋值给low，同时，low必须小于/等于keyIndex while (a[low] &lt;= a[keyIndex] &amp;&amp; low &lt; keyIndex) { low++; recusionCout ++; } if (a[low] &gt; a[keyIndex]) { [self swap:&amp;a[low] with:&amp;a[keyIndex]]; keyIndex = low; recusionCout ++; } } //如果low == high == keyindex，说明key的位置被确定了，key分治递归了 if (low == high) { //分治，递归 //以keyIndex为分界线 //递归左边部分 recusionCout += [self sortCArray:a start:start end:keyIndex-1]; //递归右边部分 recusionCout += [self sortCArray:a start:keyIndex+1 end:end]; } return recusionCout; } 插入排序 将数组分成前后两部分，前部分有序，后部分无序，等待排序 每次取后部分的第一个元素，插入前部分数组，并保持前部分数组依然有序 如此循环，直到后部分数组全部插入前部分，整个数组有序 折半插入排序 在插入排序的基础上 插入前部分有序数组的时候，插入位置的选择采用二分查找 选择排序 每次选取待排序中最小元素与第一个元素交换，交换后 待排序数组的起始位置加1，因此长度相应减1，直到待排序数组长度为0，排序结束 堆排序 建堆步骤 一个有n个节点的完全二叉树，有n/2 - 1个父节点。 从最后一个父节点a[n/2-1]开始，依次将每一个以该父节点为顶点的树调整为大根堆。 注：如果有交换，则会出现递归情况，因为从root调整下来的值，作为新的root，有可能比下边的节点的值还要小，所以相当于有两个for循环，第一个用来遍历根节点，第二个遍历根节点的子节点 堆排序实现：（大顶堆/小顶堆的概念：根值最大或最小） 建堆后，将当前大顶堆，最大元素根节点与最后一个元素交换 交换后，最大的元素在数组的最后，同时调整前面的n-1个元素为大根堆 重复步骤1-2，直到最后一个元素，此时，数组为升序数组。 总结: 建堆的时候，从最后一个父节点向上调整到根节点，而且每次调整要递归 排序调整的时候，从根节点向下调整到最后一个需要调整的根节点 排序调整过程，因为被调整树除了根节点外，其余父节点均大于子节点，所以可以采取向下调整一次即可。 代码实现 //向下调整 + (int)ajustHeapWith:(int *)a head:(int)head length:(uint)length { int recursionCount = 0; int nextChild = 2 * head + 1; if (nextChild &gt;= length) { return 1; } if (nextChild + 1 &lt; length) { //如果右孩子存在，且大于左孩子 if (a[nextChild + 1] &gt; a[nextChild]) { nextChild = nextChild + 1; recursionCount ++; } } //判断是否要交换 if (a[nextChild] &gt; a[head]) { recursionCount ++; //交换 [self swap:&amp;a[nextChild] with:&amp;a[head]]; //调整一下被交换过的子树 return [self ajustHeapWith:a head:nextChild length:length]; } return recursionCount; } //建堆 + (int)buidHeapWith:(int *)a length:(uint)length { int recursionCount = 0; for (int i = length/2-1; i &gt;= 0; i--) { recursionCount += [self ajustHeapWith:a head:i length:length]; } return recursionCount; } //建堆排序 + (int)sortCArray:(int *)a length:(uint)length { //1. 建堆 int recursionCount = [self buidHeapWith:a length:length]; //2. 排序 for (int i = length-1; i&gt;0; i--) { //1. 交换a[0]与a[i] [self swap:&amp;a[0] with:&amp;a[i]]; recursionCount ++; //2. 调整堆 recursionCount += [self ajustHeapWith:a head:0 length:i]; } return recursionCount; } + (void)testHeapSort { int maxCount = 1000; int *a = [self unsortedCArrayWithLenght:maxCount]; [self logArray:a length:maxCount]; int recursionCount = [self sortCArray:a length:maxCount]; [self checkAsendingSortArray:a length:maxCount]; [self logArray:a length:maxCount]; //冒泡未优化100万，优化后冒泡50万，快速排序14000，堆排序：2331 NSLog(@&quot;循环次数%d&quot;,recursionCount); free(a); } 归并排序： 分治思想：二分法、归并排序等应用 分解问题，将大问题分解为无数个小问题 解决问题，例如对每个小问题排序 合并小问题，如归并直到整体有序 归并排序： 将数组a[N]分成两个数组a[0 ,middle],a[middle+1, N] 如果分拆的数组长度大于1，继续分拆，直到分拆的数组长度为1 开始两两合并相邻数组，并使其有序，直至整个数组有序 代码实现： #pragma mark -- 递归的方式 + (int)recursionSort:(int *)a to:(int *)b start:(int)startIndex end:(int)endIndex { if (startIndex &gt;= endIndex) { //数组长度为1，也是一种有序状态，不需排序，直接返回 return 1; } int recursionCount = 0; //划分/分治 //取中间位置 int middle = startIndex + (endIndex - startIndex)/2; //前一半 recursionCount += [self recursionSort:a to:b start:startIndex end:middle]; //后一半 recursionCount += [self recursionSort:a to:b start:middle + 1 end:endIndex]; //合并/归并 //假设前面两个归并全部执行完成，则得到了两个a[0, middle]与a[middel+1, endindex]的有序数组 //合并这两个有序数组 int i = startIndex; // 结果集合的游标 int preIndex = startIndex; // 前半部分的游标 int nextIndex = middle + 1; // 后半部分的游标 while (preIndex != middle + 1 &amp;&amp; nextIndex != endIndex + 1) { if (a[preIndex] &lt; a[nextIndex]) { b[i++] = a[preIndex++]; } else { b[i++] = a[nextIndex++]; } recursionCount++; } while (preIndex != middle + 1) { b[i++] = a[preIndex++]; recursionCount++; } while (nextIndex != endIndex + 1) { b[i++] = a[nextIndex++]; recursionCount++; } //此时b 数组为有序数组，a数组还是原来的值，需要将b数组拷贝到a数组中 int j = startIndex; while (j &lt; endIndex + 1) { a[j] = b[j]; j++; recursionCount++; } return recursionCount; } #pragma mark -- for循环的方式 + (void)sortCArray:(int *)a to:(int *)b length:(int)length groupLength:(int)groupLength { int startIndex = 0; while (startIndex &lt; length) { int preIndex = startIndex; int nextIndex = startIndex + groupLength; int i = startIndex; while (preIndex != startIndex + groupLength &amp;&amp; nextIndex != startIndex + groupLength*2 &amp;&amp; nextIndex &lt; length) { if (a[preIndex] &lt;= a[nextIndex]) { b[i++] = a[preIndex++]; } else { b[i++] = a[nextIndex++]; } } while (preIndex != startIndex + groupLength &amp;&amp; i &lt; length) { b[i++] = a[preIndex++]; } while (nextIndex != startIndex + groupLength*2 &amp;&amp; i &lt; length) { b[i++] = a[nextIndex++]; } startIndex += groupLength*2; } } + (void)sortCArray:(int *)a to:(int *)b length:(int)length { int i = 0; int groupLength = powf(2, i); while (groupLength &lt; length) { if (i++ % 2 == 0) { [self sortCArray:a to:b length:length groupLength:groupLength]; } else { [self sortCArray:b to:a length:length groupLength:groupLength]; } groupLength = pow(2, i); } if ((i-1)%2 == 0) { for (int i = 0; i &lt; length; i++) { a[i] = b[i]; } } } + (void)testMergerSort { int maxCount = 1000; int *a = [self unsortedCArrayWithLenght:maxCount]; int *b = malloc(sizeof(int) * maxCount); memset(b, 0, sizeof(int) * maxCount); int recursionCount = [self recursionSort:a to:b start:0 end:maxCount - 1]; // [self sortCArray:a to:b length:maxCount]; [self checkAsendingSortArray:a length:maxCount]; //循环次数 //冒泡100万，50万，快速：14000，堆排序：2331，归并排序：20952 NSLog(@&quot;%d&quot;,recursionCount); free(a); free(b); } 归并拓展 当待排序文件非常大，以至于无法全部存储到内存时，先将其分割成指定大小，如1G/500M至内存，排序后存储到一个临时文件中 将上述文件，两两归并，归并结果分段输出到新的临时文件，直到所有文件全部归并到同一个文件，排序结束 排序稳定性如果排序后，相等的两个元素的相对位置发生改变，则为不稳定，否则稳定。 稳定排序：冒泡，归并排序，插入 不稳定排序：快速排序，堆排序，选择]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RAC详解]]></title>
    <url>%2F2018%2F07%2F27%2FRAC%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[RAC 之原理各种编程思想汇总 命令式编程寄存器+运算器(申请内存，计算内存，更注重过程) //命令式编程举例，求阶乘 int factorialMult(int x) { int result = 1; for (int i = 1; i &lt;= x; i++) { result *= i; } return result; } 函数式编程运算方式，函数（重在表达，更专注的是业务） //函数式编程举例 n!=n*(n-1)! int factorialMultTwo(int x){ if(x == 1) return 1; return x * factorialMultTwo(x-1); } 函数式编程求最大最小值： typedef int (^CompareBlock)(int aValue, int aNext); //函数式编程获取数组中的最大值或者最小值 int maxOrMin(int *array, int count, CompareBlock block) { if (count == 1) return array[0]; int num = maxOrMin(array, count-1, block); return block(num, array[count-1]); } CompareBlock relative(CompareBlock block) { return ^int(int aValue, int aNext){ return (aValue == block(aValue, aNext) ? aNext:aValue); }; } - (void)viewDidLoad { [super viewDidLoad]; int tests[7] = {5, 4, 1, 3, 6, 8, 7}; CompareBlock eocBlock = ^int(int aValue, int aNext) { return aValue &gt; aNext ? aValue: aNext; }; int max = maxOrMin(tests, 7, eocBlock); NSLog(@&quot;max=%d&quot;, max); int min = maxOrMin(tests, 7, relative(eocBlock)); NSLog(@&quot;min=%d&quot;, min); } 函数式编程求view在window中的位置： [_eocButtton originYToWindow:_eocButtton.superview positionY:_eocButtton.frame.origin.y]; @interface UIView (PositionToWindow) - (CGFloat)originYToWindow:(UIView *)view positionY:(CGFloat)startY; @end @implementation UIView (PositionToWindow) - (CGFloat)originYToWindow:(UIView *)view positionY:(CGFloat)startY { if ([view isKindOfClass:[UIWindow class]] || view == nil) { return startY; } else { //自己处理有UIScrollView时的情况 if ([view.superview isKindOfClass:[UIScrollView class]]) { return 0; } } return [self originYToWindow:[view superview] positionY:startY+view.frame.origin.y]; } @end 响应式编程响应式的思想，实际是观察者模式，一个值伴随着一个值的变化而变化，更多的是在于种种关联和逻辑关系处理，当一个对象发生变化而产生的关联响应 //响应式编程举例 c值随着a值的变化而变化，如autolayout void ecoTest(){ int a = 1; int b = 2; int c = a+b; a = 5; printf(&quot;%d&quot;, c); } 链式编程主要通过点‘.’来连接不同的函数调用。iOS上实现链式编程比较好的框架就是Masonry，通过查看Masonry源码，我们发现，每一个函数返回类型都是一个Block变量，然后Block变量中返回的内容就是当前对象本身。 RAC 之使用 OC写的ReactiveCocoa框架 Swift写的RXSwift框架 信号的简单应用 冷信号订阅就能被触发信号 // 单元信号 冷信号／ 热信号 - (void)signalUnit{ //1.创建信号 RACSignal *signalOne = [RACSignal return:@&quot;signalOne&quot;]; RACSignal *signalTwo = [RACSignal error:[NSError errorWithDomain:@&quot;11.1.11&quot; code:12 userInfo:nil]]; RACSignal *signalThree = [RACSignal empty]; RACSignal *signalFour = [RACSignal never]; //2.订阅 [signalOne subscribeNext:^(id x) { NSLog(@&quot;id:%@&quot;, x); }]; [signalTwo subscribeError:^(NSError *error) { NSLog(@&quot;signalTwo::%@&quot;, error); }]; [signalThree subscribeNext:^(id x) { NSLog(@&quot;empty::%@&quot;, x); }]; } block信号// block信号 - (void)racSignalBlock { // 1 创建信号 RACSignal *racSignal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) { // 3 发送信号 [subscriber sendNext:@&quot;123456&quot;]; [subscriber sendNext:@&quot;654321&quot;]; return [RACDisposable disposableWithBlock:^{ NSLog(@&quot;释放&quot;); }]; }]; // 2 订阅信号 [racSignal subscribeNext:^(id x) { NSLog(@&quot;id:%@&quot;, x); }]; } 热信号需要主动触发，可用作通知功能 // 热信号 - (void)hotRacSignal { // 1 创建信号 _hotSubject = [RACSubject subject]; // 2 订阅信号 [_hotSubject subscribeNext:^(id x) { NSLog(@&quot;One 信号来了:%@&quot;, x); }]; // 2 订阅 [_hotSubject subscribeNext:^(id x) { NSLog(@&quot;Tow 信号来了:%@&quot;, x); }]; } - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event { if(!_hotSubject) { [self hotRacSignal]; } // 3 发送信号 [_hotSubject sendNext:@&quot;八点钟学院&quot;]; } 监听Button点击事件- (void)buttonRACHandle { RACSignal *touchButtonSignal = [_eocButtton rac_signalForControlEvents:UIControlEventTouchUpInside]; [touchButtonSignal subscribeNext:^(id x) { NSLog(@&quot;点击了&quot;); } error:^(NSError *error) { NSLog(@&quot;error:%@&quot;, error);; } completed:^{ NSLog(@&quot;completed&quot;); }]; } 触发修改Button属性- (void)buttonUsingSignal { RACSignal *textColorSignal = [RACSignal return:[UIColor redColor]]; RACSignal *statusSignal = [RACSignal return:@(UIControlStateNormal)]; [_button rac_liftSelector:@selector(setTitleColor:forState:) withSignals:textColorSignal,statusSignal, nil]; } 监听实例方法的触发@interface EOCObject : NSObject - (void)eocMethod:(NSString *)eocName; @end @implementation EOCObject - (void)eocMethod:(NSString *)eocName { NSLog(@&quot;eocMethod excute %@&quot;, eocName); } @end - (void)eocObjectMethodRac { _eocObject = [EOCObject new]; RACSignal *signal = [_eocObject rac_signalForSelector:@selector(eocMethod:)]; [signal subscribeNext:^(id x) { NSLog(@&quot;方法触发了：%@&quot;, x); }]; } - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event { if (!_eocObject) { [self eocObjectMethodRac]; } [_eocObject eocMethod:@&quot;123456&quot;]; } 信号量变换// 变换 - (void)changeSignal{ RACSignal *signalOne = [RACSignal return:@&quot;12345678&quot;]; RACSignal *signalTwo = [signalOne map:^id(id value) { NSLog(@&quot;做其他事情&quot;); return [value substringFromIndex:2]; }]; [signalTwo subscribeNext:^(id x) { NSLog(@&quot;signalTwo::%@&quot;, x); }]; } 数组序列化信号的转化与过滤// 数组 - (void)sequenceRAC { RACSignal *signal = @[@&quot;111&quot;, @&quot;222&quot;, @&quot;3333333&quot;, @&quot;44&quot;, @&quot;55555&quot;].rac_sequence.signal; RACSignal *newSignal = [signal filter:^BOOL(NSString *value) { if (value.length&gt;3) { return YES; } else { return NO; } }]; [newSignal subscribeNext:^(id x) { NSLog(@&quot;%@&quot;, x); }]; } 信号合并// 信号组合，多信号处理 - (void)racMerge { RACSignal *signalOne = [RACSignal return:@&quot;123&quot;]; RACSignal *signalTwo = [RACSignal return:@&quot;678&quot;]; RACSignal *mergeSignal = [signalOne merge:signalTwo]; [mergeSignal subscribeNext:^(id x) { NSLog(@&quot;%@&quot;, x); }]; } 用信号来对属性监听- (void)racKVO{ [RACObserve(self, eocName) subscribeNext:^(id x) { NSLog(@&quot;监听属性，触发了&quot;); }]; self.eocName = @&quot;八点钟学院&quot;; } 信号量处理线程执行// 异步操作 （GCD -- ） - (void)racSchedule { // 主线程的Scheduler RACScheduler *mainScheduler = [RACScheduler mainThreadScheduler]; // 子线程上的 RACScheduler *schedulerOne = [RACScheduler scheduler]; RACScheduler *schedulerTwo = [RACScheduler scheduler]; // 当前线程的Scheduler， 如果自定义线程会返回一个nil RACScheduler *schedulerCurrent = [RACScheduler currentScheduler]; RACSignal *signalOne = [RACSignal return:@&quot;123&quot;]; RACSignal *scheduleSignal = [signalOne subscribeOn:schedulerOne]; [scheduleSignal subscribeNext:^(id x) { NSLog(@&quot;%@&quot;, [NSThread currentThread]); }]; } 用信号量延时执行/// 延时 - (void)delayRac { RACScheduler *mainScheduler = [RACScheduler currentScheduler]; [mainScheduler afterDelay:2 schedule:^{ NSLog(@&quot;afterDelay&quot;); }]; } RAC 之源码分析signal生成//生成一个signal,信号变量中保存初始化时的信息 //如果是return signal，保存value //如果是error signal，保存error //如果是block signal，保存block RACSignal *signalOne = [RACSignal return:@&quot;signalOne&quot;]; RACSignal *signalTwo = [RACSignal error:[NSError errorWithDomain:@&quot;11.1.11&quot; code:12 userInfo:nil]]; RACSignal *racSignal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) { NSLog(@&quot;subscriber block&quot;); [subscriber sendNext:@&quot;123456&quot;]; return nil; }]; //RACSignal + (RACSignal *)return:(id)value { return [RACReturnSignal return:value]; } + (RACSignal *)error:(NSError *)error { return [RACErrorSignal error:error]; } + (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe { return [RACDynamicSignal createSignal:didSubscribe]; } //RACReturnSignal + (RACSignal *)return:(id)value { #ifndef DEBUG // In release builds, use singletons for two very common cases. if (value == RACUnit.defaultUnit) { static RACReturnSignal *unitSingleton; static dispatch_once_t unitPred; dispatch_once(&amp;unitPred, ^{ unitSingleton = [[self alloc] init]; unitSingleton-&gt;_value = RACUnit.defaultUnit; }); return unitSingleton; } else if (value == nil) { static RACReturnSignal *nilSingleton; static dispatch_once_t nilPred; dispatch_once(&amp;nilPred, ^{ nilSingleton = [[self alloc] init]; nilSingleton-&gt;_value = nil; }); return nilSingleton; } #endif RACReturnSignal *signal = [[self alloc] init]; signal-&gt;_value = value; #ifdef DEBUG [signal setNameWithFormat:@&quot;+return: %@&quot;, value]; #endif return signal; } //RACErrorSignal + (RACSignal *)error:(NSError *)error { RACErrorSignal *signal = [[self alloc] init]; signal-&gt;_error = error; #ifdef DEBUG [signal setNameWithFormat:@&quot;+error: %@&quot;, error]; #else signal.name = @&quot;+error:&quot;; #endif return signal; } //RACDynamicSignal + (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe { RACDynamicSignal *signal = [[self alloc] init]; signal-&gt;_didSubscribe = [didSubscribe copy]; return [signal setNameWithFormat:@&quot;+createSignal:&quot;]; } signal订阅//订阅signal，通过源码可以看出，returnSignal和errorSignal在订阅时就会触发执行block，而通过块生成的RACDynamicSignal订阅时并不会执行block，需要通过块中的subscribe去手动send [racSignal subscribeNext/Error:^(id x) { NSLog(@&quot;subscriber next id:%@&quot;, x); }]; //RACSignal，根据nextBlock，errorBlock，completeBlock封装一个RACSubscriber对象 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock { NSCParameterAssert(nextBlock != NULL); RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:NULL completed:NULL]; return [self subscribe:o]; } //RACReturnSignal - (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber { NSCParameterAssert(subscriber != nil); return [RACScheduler.subscriptionScheduler schedule:^{ [subscriber sendNext:self.value]; [subscriber sendCompleted]; }]; } //RACErrorSignal - (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber { NSCParameterAssert(subscriber != nil); return [RACScheduler.subscriptionScheduler schedule:^{ [subscriber sendError:self.error]; }]; } //RACDynamicSignal - (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber { NSCParameterAssert(subscriber != nil); RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable]; subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable]; if (self.didSubscribe != NULL) { RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^{ // 发送 RACDisposable *innerDisposable = self.didSubscribe(subscriber); [disposable addDisposable:innerDisposable]; }]; [disposable addDisposable:schedulingDisposable]; } return disposable; } //RACSubscriber - (void)sendNext:(id)value { @synchronized (self) { void (^nextBlock)(id) = [self.next copy]; if (nextBlock == nil) return; nextBlock(value); } } - (void)sendError:(NSError *)e { @synchronized (self) { void (^errorBlock)(NSError *) = [self.error copy]; [self.disposable dispose]; if (errorBlock == nil) return; errorBlock(e); } } - (void)sendCompleted { @synchronized (self) { void (^completedBlock)(void) = [self.completed copy]; [self.disposable dispose]; if (completedBlock == nil) return; completedBlock(); } } 热信号通过源码可看出，热信号并没有在订阅的时候执行，而是要专门调用sendNext，而冷信号在订阅的时候就已经执行了，所以冷信号不需要sendNext也没有此功能，只需要订阅就好了 - (void)hotRacSignal { // 1 创建信号 _hotSubject = [RACSubject subject]; // 2 订阅信号 [_hotSubject subscribeNext:^(id x) { NSLog(@&quot;One 信号来了:%@&quot;, x); }]; // 3 订阅 [_hotSubject subscribeNext:^(id x) { NSLog(@&quot;Tow 信号来了:%@&quot;, x); }]; [_hotSubject sendNext:@&quot;八点钟学院&quot;]; } @interface RACSubject : RACSignal &lt;RACSubscriber&gt; + (instancetype)subject; @end @protocol RACSubscriber &lt;NSObject&gt; - (void)sendNext:(id)value; - (void)sendError:(NSError *)error; - (void)sendCompleted; - (void)didSubscribeWithDisposable:(RACCompoundDisposable *)disposable; @end //RACSubject + (instancetype)subject { return [[self alloc] init]; } - (id)init { self = [super init]; if (self == nil) return nil; _disposable = [RACCompoundDisposable compoundDisposable]; _subscribers = [[NSMutableArray alloc] initWithCapacity:1]; return self; } //RACSignal - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock { NSCParameterAssert(nextBlock != NULL); RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:NULL completed:NULL]; return [self subscribe:o]; } //RACSubject - (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber { NSCParameterAssert(subscriber != nil); RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable]; subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable]; NSMutableArray *subscribers = self.subscribers; @synchronized (subscribers) { [subscribers addObject:subscriber]; } return [RACDisposable disposableWithBlock:^{ @synchronized (subscribers) { // Since newer subscribers are generally shorter-lived, search // starting from the end of the list. NSUInteger index = [subscribers indexOfObjectWithOptions:NSEnumerationReverse passingTest:^ BOOL (id&lt;RACSubscriber&gt; obj, NSUInteger index, BOOL *stop) { return obj == subscriber; }]; if (index != NSNotFound) [subscribers removeObjectAtIndex:index]; } }]; } 举例：改变button字体颜色- (void)buttonUsingSignal { RACSignal *textColorSignal = [RACSignal return:[UIColor redColor]]; RACSignal *statusSignal = [RACSignal return:@(UIControlStateNormal)]; [_button rac_liftSelector:@selector(setTitleColor:forState:) withSignals:textColorSignal,statusSignal, nil]; } //NSObject+RACLifting - (RACSignal *)rac_liftSelector:(SEL)selector withSignals:(RACSignal *)firstSignal, ... { NSCParameterAssert(firstSignal != nil); NSMutableArray *signals = [NSMutableArray array]; va_list args; va_start(args, firstSignal); for (id currentSignal = firstSignal; currentSignal != nil; currentSignal = va_arg(args, id)) { NSCAssert([currentSignal isKindOfClass:RACSignal.class], @&quot;Argument %@ is not a RACSignal&quot;, currentSignal); [signals addObject:currentSignal]; } va_end(args); return [[self rac_liftSelector:selector withSignalsFromArray:signals] setNameWithFormat:@&quot;%@ -rac_liftSelector: %s withSignals: %@&quot;, self.rac_description, sel_getName(selector), signals]; } - (RACSignal *)rac_liftSelector:(SEL)selector withSignalsFromArray:(NSArray *)signals { NSCParameterAssert(signals != nil); NSCParameterAssert(signals.count &gt; 0); NSMethodSignature *methodSignature = [self methodSignatureForSelector:selector]; NSCAssert(methodSignature != nil, @&quot;%@ does not respond to %@&quot;, self, NSStringFromSelector(selector)); NSUInteger numberOfArguments __attribute__((unused)) = methodSignature.numberOfArguments - 2; NSCAssert(numberOfArguments == signals.count, @&quot;Wrong number of signals for %@ (expected %lu, got %lu)&quot;, NSStringFromSelector(selector), (unsigned long)numberOfArguments, (unsigned long)signals.count); return [[self rac_liftSelector:selector withSignalOfArguments:[RACSignal combineLatest:signals]] setNameWithFormat:@&quot;%@ -rac_liftSelector: %s withSignalsFromArray: %@&quot;, self.rac_description, sel_getName(selector), signals]; } - (RACSignal *)rac_liftSelector:(SEL)selector withSignalOfArguments:(RACSignal *)arguments { NSCParameterAssert(selector != NULL); NSCParameterAssert(arguments != nil); @unsafeify(self); NSMethodSignature *methodSignature = [self methodSignatureForSelector:selector]; NSCAssert(methodSignature != nil, @&quot;%@ does not respond to %@&quot;, self, NSStringFromSelector(selector)); return [[[[arguments takeUntil:self.rac_willDeallocSignal] map:^(RACTuple *arguments) { @strongify(self); NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:methodSignature]; invocation.selector = selector; invocation.rac_argumentsTuple = arguments; [invocation invokeWithTarget:self]; return invocation.rac_returnValue; }] replayLast] setNameWithFormat:@&quot;%@ -rac_liftSelector: %s withSignalsOfArguments: %@&quot;, self.rac_description, sel_getName(selector), arguments]; } //NSInvocation+RACTypeParsing - (void)setRac_argumentsTuple:(RACTuple *)arguments { NSCAssert(arguments.count == self.methodSignature.numberOfArguments - 2, @&quot;Number of supplied arguments (%lu), does not match the number expected by the signature (%lu)&quot;, (unsigned long)arguments.count, (unsigned long)self.methodSignature.numberOfArguments - 2); NSUInteger index = 2; for (id arg in arguments) { [self rac_setArgument:(arg == RACTupleNil.tupleNil ? nil : arg) atIndex:index]; index++; } } 监听button的点击信号RACSignal *signalTwo = [button rac_signalForControlEvents:UIControlEventTouchUpInside]; [signalTwo subscribeNext:^(id x) { // button响应了点击事件， 订阅者可以做事情了 NSLog(@&quot;signalTwo::%@&quot;, x); }]; //UIControl+RACSignalSupport - (RACSignal *)rac_signalForControlEvents:(UIControlEvents)controlEvents { @weakify(self); return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) { @strongify(self); [self addTarget:subscriber action:@selector(sendNext:) forControlEvents:controlEvents]; [self.rac_deallocDisposable addDisposable:[RACDisposable disposableWithBlock:^{ [subscriber sendCompleted]; }]]; return [RACDisposable disposableWithBlock:^{ @strongify(self); [self removeTarget:subscriber action:@selector(sendNext:) forControlEvents:controlEvents]; }]; }] setNameWithFormat:@&quot;%@ -rac_signalForControlEvents: %lx&quot;, self.rac_description, (unsigned long)controlEvents]; } 更改view的background#define RAC_(TARGET, KEYPATH, NILVALUE) \ [[RACSubscriptingAssignmentTrampoline alloc] initWithTarget:(TARGET) nilValue:(NILVALUE)][@keypath(TARGET, KEYPATH)] RACSignal *viewColorSignal = [RACSignal return:[UIColor blueColor]]; RAC(self.view, backgroundColor) = viewColorSignal; //上句可以翻译成下面这句 RACSubscriptingAssignmentTrampoline *tmp = [[RACSubscriptingAssignmentTrampoline alloc] initWithTarget:(self.view) nilValue:nil]; tmp[@&quot;backgroundColor&quot;] = viewColorSignal; //因为RACSubscriptingAssignmentTrampoline类实现了以下方法，所以可以根据key直接赋值tmp[@&quot;backgroundColor&quot;] = viewColorSignal; - (void)setObject:(RACSignal *)signal forKeyedSubscript:(NSString *)keyPath; //如果需要也根据key取值，可以实现此方法 - (id)objectForKeyedSubscript:(NSString*)key;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>RAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[视频直播系统开发]]></title>
    <url>%2F2018%2F06%2F29%2F%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[音视频采集 AVFoundation：音频捕获-&gt;音频AAC编码-&gt;混合视频封装成flv/ts传输 CaptureSession：视频捕获-&gt;视频预处理-&gt;视频H.264编码-&gt;混合音频封装成flv/ts传输 //ViewController.m - (void)startCamera { AVCaptureDevice *captureDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo]; AVCaptureDeviceInput *captureDeviceInput = [AVCaptureDeviceInput deviceInputWithDevice:captureDevice error:nil]; //make output device AVCaptureVideoDataOutput *captureVideoDataOutput = [[AVCaptureVideoDataOutput alloc] init]; NSNumber *val = [NSNumber numberWithUnsignedInteger:kCVPixelFormatType_420YpCbCr8BiPlanarFullRange]; NSDictionary *videoSetting = [NSDictionary dictionaryWithObject:val forKey:(NSString *)kCVPixelBufferPixelFormatTypeKey]; captureVideoDataOutput.videoSettings = videoSetting; //将输出流的delegate设置为self来处理 [captureVideoDataOutput setSampleBufferDelegate:self queue:dispatch_get_main_queue()]; self.captureSession = [[AVCaptureSession alloc] init]; [self.captureSession addInput:captureDeviceInput]; [self.captureSession addOutput:captureVideoDataOutput]; [self.captureSession beginConfiguration]; [self.captureSession setSessionPreset:AVCaptureSessionPresetMedium]; [self.captureSession setSessionPreset:AVCaptureSessionPreset640x480]; //当把一个输入和输出添加到AVCaptureSession之后，AVCaptureSession就会在输入、输出设备之间建立连接，而且通过AVCaptureOutput可以获取这个连接对象 self.connection = [captureVideoDataOutput connectionWithMediaType:AVMediaTypeVideo]; [self.captureSession commitConfiguration]; [self.captureSession startRunning]; } - (void)captureOutput:(AVCaptureOutput *)output didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection { CVImageBufferRef imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer); //直接把samplebuffer传给AVSampleBufferDisplayLayer进行预览播放的同时压缩sampleBuffer [self.displayLayer enqueueSampleBuffer:sampleBuffer]; [self.encoder encode:sampleBuffer]; } 音视频处理 美颜 水印 人脸识别 GUPImage：第三方框架，有很多种功能，可以处理上边三个需求，还有其他SDK，如讯飞SDK、商汤SDK等 音视频编码原理使用特定的压缩算法压缩视频数据，便于视频的传输和存储。编码方式有H264（比265节省40%的空间），H265（iOS11以上原生支持），V8，V9（这两个是google提出，可以直接在播放器中播放，android端比较常用） H264H264的原理及其中的概念：每个图片跟前边的图片差异很小，所以提出一个关键帧，后边的帧只记住改变即可 I帧（关键帧）、B帧（依靠前后帧还原，复杂度较高）、P帧（依靠前边的帧还原） GOP（两个关键帧之间的帧数） FPS：frame per second，每秒的帧数，一般是30 码率 越大越清晰，相当于帧宽，帧的大小 H264帧结构结构：（I P P P I P P P I P） 序列参数集SPS：Sequence Parameter Set，包括与图像序列（定义为两个IDR图像之间的所有图像）有关的所有信息，应用于已编码视频序列。 图像参数集PPS：Picture Parameter Set，包含所有属于该图像的相关信息，用于解码已编码视频序列中的1个或多个独立的图像。 每个P中包含 分界符(0001) 序列参数集 图像参数集 SEL 基本图像（包含很多slice） 冗余图像 序列结束符 音频编码AAC采样率为44.1kHZ，采样大小为16bit的双声道。PCM的大小为44.1*16*2bps=176kb/s。AAC通畅压缩比为18：1，也有资料说是20：1，经过AAC压缩后的大小约为12kb/s左右，远远低于视频压缩后的大小 代码示例#pragma mark - H264EncoderDelegate - (void)didGetSparameterSet:(NSData *)sps pictureParameterSet:(NSData *)pps { NSLog(@&quot;didGet SparameterSet %d PparameterSet %d&quot;, (int)[sps length], (int)[pps length]); const char bytes[] = &quot;\x00\x00\x00\x01&quot;; //string literals have implicit trainling &apos;\0&apos; size_t length = (sizeof(bytes)) - 1; NSData *byteHeader = [NSData dataWithBytes:bytes length:length]; [self.fileHandler writeData:byteHeader]; [self.fileHandler writeData:sps]; [self.fileHandler writeData:byteHeader]; [self.fileHandler writeData:pps]; NSLog(@&quot;write ps finished&quot;); } - (void)didGetEncodedData:(NSData *)data isKeyFrame:(BOOL)isKeyFrame { if (self.fileHandler != NULL) { const char bytes[] = &quot;\x00\x00\x00\x01&quot;; size_t length = (sizeof(bytes)) - 1; NSData *byteHeader = [NSData dataWithBytes:bytes length:length]; [self.fileHandler writeData:byteHeader]; [self.fileHandler writeData:data]; NSLog(@&quot;write data finished&quot;); } } - (void)initEncoderWithWidth:(int)width height:(int)height { dispatch_sync(workQueue, ^{ OSStatus status = VTCompressionSessionCreate(NULL, width, height, kCMVideoCodecType_H264, NULL, NULL, NULL, didCompressH264, (__bridge void *)self, &amp;encodeSession); NSLog(@&quot;H264: VTCompressionSessionCreate %d&quot;, (int)status); if (status != 0) { NSLog(@&quot;H264: Unable to create a H264 session&quot;); return; } //最大关键帧间隔，可设定为fps的2倍，影响一个gop的大小 VTSessionSetProperty(encodeSession, kVTCompressionPropertyKey_MaxKeyFrameInterval, (__bridge CFTypeRef)@(gop)); //一个GOP的时间间隔 VTSessionSetProperty(encodeSession, kVTCompressionPropertyKey_MaxKeyFrameIntervalDuration, (__bridge CFTypeRef)@(gop/videoFrameRate)); //设置帧率，即每秒有多少帧数据 VTSessionSetProperty(encodeSession, kVTCompressionPropertyKey_ExpectedFrameRate, (__bridge CFTypeRef)@(videoFrameRate)); //码率，单位是bps，即每秒多少bit VTSessionSetProperty(encodeSession, kVTCompressionPropertyKey_AverageBitRate, (__bridge CFTypeRef)@(averageBitRate)); //设置码率的最高限制，不超过平均码率的1.5倍，因为这里的单位是byte，所以除以8，这是为了防止某一秒码率超过限制 NSArray *limit = @[@(averageBitRate*1.5/8), @(1)]; VTSessionSetProperty(encodeSession, kVTCompressionPropertyKey_DataRateLimits, (__bridge CFArrayRef)limit); //是否实时编码，YES时降低编码复杂度，快速编码 VTSessionSetProperty(encodeSession, kVTCompressionPropertyKey_RealTime, kCFBooleanTrue); //调整编码等级，H264有4个编码等级，有baseline、extend、main、high，最前边的编码复杂度低，解码效率更高，压缩率比较低 VTSessionSetProperty(encodeSession, kVTCompressionPropertyKey_ProfileLevel, kVTProfileLevel_H264_Main_AutoLevel); //是否在编码中使用B帧，因为B帧是双向预测帧，所以编码时间顺序和展示时间顺序不同，设置为true压缩率更高 VTSessionSetProperty(encodeSession, kVTCompressionPropertyKey_AllowFrameReordering, kCFBooleanTrue); //基于上下文的自适应可变长编码 和 基于上下文的自适应二进制算术编码 选择熵编码方式 VTSessionSetProperty(encodeSession, kVTCompressionPropertyKey_H264EntropyMode, kVTH264EntropyMode_CABAC); VTCompressionSessionPrepareToEncodeFrames(encodeSession); }); } - (void)encode:(CMSampleBufferRef)sampleBuffer { dispatch_sync(workQueue, ^{ frameCount ++; CVImageBufferRef imageBuffer = (CVImageBufferRef)CMSampleBufferGetImageBuffer(sampleBuffer); //create properties CMTime presentationTimeStamp = CMTimeMake(frameCount, (int32_t)videoFrameRate); CMTime duration = CMTimeMake(1, (int32_t)videoFrameRate); VTEncodeInfoFlags flags; NSDictionary *properties = nil; if (frameCount % (int32_t)gop == 0) { properties = @{(__bridge NSString*)kVTEncodeFrameOptionKey_ForceKeyFrame:@YES}; } //pass it to the encoder OSStatus statusCode = VTCompressionSessionEncodeFrame(encodeSession, imageBuffer, presentationTimeStamp, duration, (__bridge CFDictionaryRef)properties, NULL, &amp;flags); //check for error if (statusCode != noErr) { NSLog(@&quot;H264: VTCompressionSessionEncodeFrame failed with %d&quot;, (int)statusCode); //end the session VTCompressionSessionInvalidate(encodeSession); CFRelease(encodeSession); encodeSession = NULL; return; } NSLog(@&quot;H264: VTCompressionSessionEncodeFrame success&quot;); }); } //VTCompressionOutputCallback(回调方法) 由VTCompressionSessionCreate调用 void didCompressH264(void *outputCallbackRefCon, void *sourceFrameRefCon, OSStatus status, VTEncodeInfoFlags infoFlags, CMSampleBufferRef sampleBuffer) { NSLog(@&quot;didCompressH264 called with status %d, infoFlags %d&quot;, (int)status, (int)infoFlags); if (status != 0) return; if (!CMSampleBufferDataIsReady(sampleBuffer)) { NSLog(@&quot;didCompressH264 data is not ready&quot;); return; } H264Encoder *encoder = (__bridge H264Encoder *)outputCallbackRefCon; //check if we have got a key frame first BOOL keyFrame = !CFDictionaryContainsKey(CFArrayGetValueAtIndex(CMSampleBufferGetSampleAttachmentsArray(sampleBuffer, YES), 0) , kCMSampleAttachmentKey_NotSync); if (keyFrame) { CMFormatDescriptionRef format = CMSampleBufferGetFormatDescription(sampleBuffer); size_t sparamenterSetSize, sparameterSetCount; const uint8_t *sparameterSet; OSStatus statusCode = CMVideoFormatDescriptionGetH264ParameterSetAtIndex(format, 0, &amp;sparameterSet, &amp;sparamenterSetSize, &amp;sparameterSetCount, 0); if (statusCode == noErr) { size_t pparameterSetSize, pparameterSetCount; const uint8_t *pparameterSet; OSStatus statusCode = CMVideoFormatDescriptionGetH264ParameterSetAtIndex(format, 1, &amp;pparameterSet, &amp;pparameterSetSize, &amp;pparameterSetCount, 0); if (statusCode == noErr) { encoder-&gt;sps = [NSData dataWithBytes:sparameterSet length:sparamenterSetSize]; encoder-&gt;pps = [NSData dataWithBytes:pparameterSet length:pparameterSetSize]; if (encoder-&gt;_delegate) { [encoder-&gt;_delegate didGetSparameterSet:encoder-&gt;sps pictureParameterSet:encoder-&gt;pps]; } } } } CMBlockBufferRef dataBuffer = CMSampleBufferGetDataBuffer(sampleBuffer); size_t length, totalLength; char *dataPointer; OSStatus statusCodeRet = CMBlockBufferGetDataPointer(dataBuffer, 0, &amp;length, &amp;totalLength, &amp;dataPointer); if (statusCodeRet == noErr) { size_t bufferOffset = 0; static const int AVCCHeaderLength = 4; //一般情况下都是只有1帧，在最开始编码的时候有2帧，取最后一帧 while (bufferOffset &lt; totalLength - AVCCHeaderLength) { if (bufferOffset != 0) { NSLog(@&quot;一般情况下都是只有1帧，此时不是一帧 %d&quot;, (int)bufferOffset); } //read the nal unit length uint32_t NALUnitLength = 0; memcpy(&amp;NALUnitLength, dataPointer+bufferOffset, AVCCHeaderLength); //convert the length value from Big-endian to Little-endian,网络字节序一般使用大端字节序 NALUnitLength = CFSwapInt32BigToHost(NALUnitLength); //data即为一帧h264数据 //如果保存到文件中，需要将此数据前加上[0 0 0 1]4个字节，按顺序写入到h264文件中 //如果推流，需要将此数据前加上4个字节表示数据长度的数字，此数字需转为大端字节序。 //关于大端模式和小端模式 NSData *data = [[NSData alloc] initWithBytes:dataPointer+bufferOffset+AVCCHeaderLength length:NALUnitLength]; [encoder-&gt;_delegate didGetEncodedData:data isKeyFrame:keyFrame]; //move to the next NAL unit in the block buffer bufferOffset += AVCCHeaderLength + NALUnitLength; } } } 推流 封装为什么要封装？ 将经过编码的音视频帧数据信息和字幕等信息组织起来，便于播放端解析数据，对不同的数据选择不同的解码器进行解码，以完成音视频同步，字幕同步等。封装格式主要有rmvb、avi、mkv、mp4、flv、ts等 FLV格式格式：Header/PreviousTagSize0/Tag1/previousTagSize1/Tag2/previousTagSize2…Tag n/PreviousTagSize n Header： 3byte：文件类型，即flv 1byte：版本号 1byte：流信息（各个位表示不同信息，最后一位是1表示有视频流，倒数第三位是1表示有音频流） 4byte：header长度 Tag： 1byte：tag类型，表示是音频还是视频还是字母或者是数据块 3byte：数据区长度 3byte：时间戳，单位毫秒 1byte：时间戳扩展 3byte：streamID，流ID 数据区：长度由数据区长度字段决定 音频Tag： 4bit：音频格式 2bit：采样率 1bit：采样长度 1bit：音频类型 实际的音频数据 视频Tag： 4bit：帧类型 4bit：编码ID 实际的视频数据 流媒体协议HLSHLS：HTTP Live Streaming，由苹果推出，基于HLS的直播流URL式一个m3u8的文件，里面包含了最近若干个小视频TS(一种视频封装格式，这里就不扩展介绍)文件，每次通过请求m3u8文件得到ts小视频列表，然后一个一个的下载缓冲播放 一般会延时10s，如果需要和主播互动，无法忍受 HTML5可以直接播放，不需要独立App支持 RTMPRTMP：RealTime Message Protocol，底层基于可靠的传输协议层来保证信息传输的可靠性，一般基于TCP实现*开源软件和开源库支持比较完整，是Adobe的专利协议，播放端安装率高，只需要有FlashPlayer，一般延时2-5s HTTP-FLVHTTP-FLV：使用HTTP协议传输经过flv封装后的数据包，实现视频流的推拉流。 拉流端实现简单，但目前没有比较好的推流实现。HTTP协议没有复杂的交互，打开速度比RTMP更快一丢丢 RTSPRTSP：Real Time Streaming Protocol，基于文本的多媒体播放控制协议，建立并控制一个或几个时间同步的连续流媒体，由Real Networks 和 Netscape共同提出的 RTSP定义流格式，流数据经由RTP传输；RTSP实时效果非常好，适合视频聊天，视频监控等方向。 WebRTCwebRTC：实时消息传输协议实现，可以用点对点来做连麦，即多人会议，实时性较高 第三方框架LFLiveKitLFLiveKit推视频和音频流（oc写的） LFLiveVideoConfiguration *vConfig = [LFLiveVideoConfiguration defaultConfiguration]; LFLiveAudioConfiguration *aConfig = [LFLiveAudioConfiguration defaultConfiguration]; _session = [[LFLiveSession alloc] initWithAudioConfiguration:aConfig videoConfiguration:vConfig]; _session.delegate = self; //设置预览的视图 _session.preView = self.preView; //是否需要美颜 _session.beautyFace = YES; //用哪个摄像头 _session.captureDevicePosition = AVCaptureDevicePositionBack; LFLiveStreamInfo *info = [LFLiveStreamInfo new]; info.url = url; //开始往url上推流 [_session startLive:info]; //LFLiveConfiguration //LFLiveVideoConfiguration.h /// 视频的分辨率，宽高务必设定为 2 的倍数，否则解码播放时可能出现绿边(这个videoSizeRespectingAspectRatio设置为YES则可能会改变) @property (nonatomic, assign) CGSize videoSize; /// 输出图像是否等比例,默认为NO @property (nonatomic, assign) BOOL videoSizeRespectingAspectRatio; /// 视频输出方向 @property (nonatomic, assign) UIInterfaceOrientation outputImageOrientation; /// 自动旋转(这里只支持 left 变 right portrait 变 portraitUpsideDown) @property (nonatomic, assign) BOOL autorotate; /// 视频的帧率，即 fps @property (nonatomic, assign) NSUInteger videoFrameRate; /// 视频的最大帧率，即 fps @property (nonatomic, assign) NSUInteger videoMaxFrameRate; /// 视频的最小帧率，即 fps @property (nonatomic, assign) NSUInteger videoMinFrameRate; /// 最大关键帧间隔，可设定为 fps 的2倍，影响一个 gop 的大小 @property (nonatomic, assign) NSUInteger videoMaxKeyframeInterval; /// 视频的码率，单位是 bps @property (nonatomic, assign) NSUInteger videoBitRate; /// 视频的最大码率，单位是 bps @property (nonatomic, assign) NSUInteger videoMaxBitRate; /// 视频的最小码率，单位是 bps @property (nonatomic, assign) NSUInteger videoMinBitRate; ///&lt; 分辨率 @property (nonatomic, assign) LFLiveVideoSessionPreset sessionPreset; ///&lt; ≈sde3分辨率 @property (nonatomic, assign, readonly) NSString *avSessionPreset; ///&lt; 是否是横屏 @property (nonatomic, assign, readonly) BOOL landscape; //LFLiveAudioConfiguration.h /// 声道数目(default 2) @property (nonatomic, assign) NSUInteger numberOfChannels; /// 采样率 @property (nonatomic, assign) LFLiveAudioSampleRate audioSampleRate; /// 码率 @property (nonatomic, assign) LFLiveAudioBitRate audioBitrate; /// flv编码音频头 44100 为0x12 0x10 @property (nonatomic, assign, readonly) char *asc; /// 缓存区长度 @property (nonatomic, assign,readonly) NSUInteger bufferLength; //LFLiveSessionConfiguration @interface LFLiveSession : NSObject /** The delegate of the capture. captureData callback */ @property (nullable, nonatomic, weak) id&lt;LFLiveSessionDelegate&gt; delegate; /** The running control start capture or stop capture*/ @property (nonatomic, assign) BOOL running; /** The preView will show OpenGL ES view*/ @property (nonatomic, strong, null_resettable) UIView *preView; /** The captureDevicePosition control camraPosition ,default front*/ @property (nonatomic, assign) AVCaptureDevicePosition captureDevicePosition; /** The beautyFace control capture shader filter empty or beautiy */ @property (nonatomic, assign) BOOL beautyFace; /** The beautyLevel control beautyFace Level. Default is 0.5, between 0.0 ~ 1.0 */ @property (nonatomic, assign) CGFloat beautyLevel; /** The brightLevel control brightness Level, Default is 0.5, between 0.0 ~ 1.0 */ @property (nonatomic, assign) CGFloat brightLevel; /** The torch control camera zoom scale default 1.0, between 1.0 ~ 3.0 */ @property (nonatomic, assign) CGFloat zoomScale; /** The torch control capture flash is on or off */ @property (nonatomic, assign) BOOL torch; /** The mirror control mirror of front camera is on or off */ @property (nonatomic, assign) BOOL mirror; /** The muted control callbackAudioData,muted will memset 0.*/ @property (nonatomic, assign) BOOL muted; /* The adaptiveBitrate control auto adjust bitrate. Default is NO */ @property (nonatomic, assign) BOOL adaptiveBitrate; /** The stream control upload and package*/ @property (nullable, nonatomic, strong, readonly) LFLiveStreamInfo *streamInfo; /** The status of the stream .*/ @property (nonatomic, assign, readonly) LFLiveState state; /** The captureType control inner or outer audio and video .*/ @property (nonatomic, assign, readonly) LFLiveCaptureTypeMask captureType; /** The showDebugInfo control streamInfo and uploadInfo(1s) *.*/ @property (nonatomic, assign) BOOL showDebugInfo; /** The reconnectInterval control reconnect timeInterval(重连间隔) *.*/ @property (nonatomic, assign) NSUInteger reconnectInterval; /** The reconnectCount control reconnect count (重连次数) *.*/ @property (nonatomic, assign) NSUInteger reconnectCount; /*** The warterMarkView control whether the watermark is displayed or not ,if set ni,will remove watermark,otherwise add. set alpha represent mix.Position relative to outVideoSize. *.*/ @property (nonatomic, strong, nullable) UIView *warterMarkView; /* The currentImage is videoCapture shot */ @property (nonatomic, strong,readonly ,nullable) UIImage *currentImage; /* The saveLocalVideo is save the local video */ @property (nonatomic, assign) BOOL saveLocalVideo; /* The saveLocalVideoPath is save the local video path */ @property (nonatomic, strong, nullable) NSURL *saveLocalVideoPath; 拉流 原理及用到的技术 流媒体协议RTMP、RTSP、HLS、HTTP-FLV ijkplayer开源播放器 OpenGL渲染 解封装 IJKMediaFramework拉流及播放 self.player.url = @&quot;rtmp://120.26.43.68:1935/hls/test&quot;; [self.player play]; [self.view insertSubview:self.player.view atIndex:0]; self.player.view.frame = self.view.bounds; @implementation Player - (BOOL)play { self.playerController = [self createPlayerController]; [self.playerController prepareToPlay]; return YES; } - (IJKFFMoviePlayerController *)createPlayerController { IJKFFMoviePlayerController *playerController = [[IJKFFMoviePlayerController alloc] initWithContentURLString:self.url withOptions:self.options]; playerController.scalingMode = IJKMPMovieScalingModeAspectFill; playerController.shouldAutoplay = YES; [playerController setPauseInBackground:YES]; return playerController; } - (IJKFFOptions *)options { if (_options==nil) { //关于详细的播放器配置，请参考文件ff_ffplay_options.c//PPT拉流流程图 IJKFFOptions *options = [IJKFFOptions optionsByDefault]; [options setFormatOptionIntValue:5000000 forKey:@&quot;analyzeduration&quot;];//最长分析流时间 [options setFormatOptionIntValue:15000000 forKey:@&quot;timeout&quot;];//超时时间15s [options setFormatOptionIntValue:5 forKey:@&quot;fpsprobesize&quot;];//取多少帧用于分析 [options setFormatOptionValue:@&quot;nobuffer&quot; forKey:@&quot;fflags&quot;];//开启之后，会出现进入页面立马卡顿一下的问题 [options setFormatOptionIntValue:4096 forKey:@&quot;probsize&quot;];//一次分析包大小 [options setPlayerOptionIntValue:0 forKey:@&quot;packet-buffering&quot;];//连接成功后，继续读取多少个包开始播放 [options setPlayerOptionIntValue:5 forKey:@&quot;min-frames&quot;];//最少读取多少个frame之后停止预读 [options setPlayerOptionIntValue:1 forKey:@&quot;videotoolbox&quot;];//开启硬件编码 [options setPlayerOptionIntValue:29.97 forKey:@&quot;max-fps&quot;];//最大支持帧率 [options setPlayerOptionIntValue:1 forKey:@&quot;framedrop&quot;];//开启后，如果cpu处理不过来则会丢帧 //开启会丢帧，不过可以加快播放速度(在硬解码的情况下，则没有明显掉帧情况，而且只有开启直播这一下会出现掉帧) //根本问题在于，当音视频流不同步的时候，会出现丢帧的情况，这种情况使用软解码会很明显，硬解码则不会 [options setCodecOptionIntValue:IJK_AVDISCARD_DEFAULT forKey:@&quot;skip_loop_filter&quot;]; [options setCodecOptionIntValue:IJK_AVDISCARD_NONREF forKey:@&quot;skip_frame&quot;]; //下面两个参数由播放类型决定，自行增加。（点播需要） // [options setPlayerOptionIntValue:1 forKey:@&quot;an&quot;];//audio disable禁止音频 // [options setPlayerOptionIntValue:(50*1024) forKey:@&quot;max-buffer-size&quot;];//缓存大小（直播小，点播大保证流畅） // [options setFormatOptionIntValue:32 forKey:@&quot;rtbufsize&quot;];//最大内存大小用于实时缓存 options.showHudView = NO; _options = options; } return _options; } @end 音视频解码音视频解码 最初的流是封装成flv、ts格式，先解封装成视频和音频两个部分 视频硬解码成YUV格式 VideoToolbox：iOS8.0以上支持 视频软解码成YUV格式 x264、FFMpeg 音频硬解码成PCM格式 AudioToolbox 音频软解码成PCM格式 fdk_acc 最后将音视频交给播放器播放 重要知识点CMTime： 可以表示时间点，也可以表示时间长度 主要的属性 value/timeScale，value表示时间粒度的数量，timeScale表示时间单位粒度 value/timeScale = seconds 表示时间点 CMSampleBufferRef视频的一个CMSampleBufferRef对应很多个CMBlockBuffer。CMSampleBufferRef中的几个数据结构： CMSampleBuffer：存放编解码前后的视频图像的容器数据结构，包含CMTime，CMVideoFormatDesc，还有CVPixelBuffer或CMBlockBuffer CVPixelBuffer：编码前和解码后的图像数据结构 CMBlockBuffer：编码后的图像数据结构 全局优化 Mac 上安装Nginx+rtmp的操作请自行百度 聊天互动 IM：XMPP、MQTT、WebSocket 聊天室 礼物 实时消息通道xmpp：IM，GTALK，MSN都是基于此实现，此种协议只要客户端和服务器都基于此，就可以相互发送消息，如GTALK给MSN发消息，类似于邮件的STMP/POP协议 websocket：轻量级消息通道，客户端和服务端可以相互发送消息，浏览器原生支持此协议 mqtt：IBM推出的基于物联网的消息通道。协议比较简单，耗流量较少，用于嵌入式的消息通道，常用于低带宽和不稳定的网络 ![](/assets/blog/视频直播-消息模块整体结构.png) ![](/assets/blog/视频直播-连接流程.png) ![](/assets/blog/视频直播-连接状态维护.png) MQTT： 订阅/发布消息模式，支持一对多的消息发布 协议头开销小，降低网络流量 提供服务质量选择：至多一次、至少一次、只有一次 Mac 上安装Mosquitto的的操作请自行百度或参见视频教程 代码实现 建立消息通道：MQTT第三方Pod框架 列表刷新方案：多少秒检测刷新一次，达到多少数量刷新一次，RunLoop空闲时刷新。注：解析和高度计算放后台 YYText图片加载：CoreText 动画方案介绍： CoreAnimation：小动画或者大动画实现 帧动画 html5动画 视频播放 flash动画解析：FlashAnimationToMobile 服务器CDN简介：Content Delivery Network 视频录制 断流检测 自动鉴黄 GOP缓存 智能路由 实时转码，多分辨率清晰度]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>iOS</tag>
        <tag>直播</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOSRunTime]]></title>
    <url>%2F2018%2F05%2F25%2FiOSRunTime%2F</url>
    <content type="text"><![CDATA[什么是类？什么是对象？ NSObject *object = [[NSObject alloc] init]; @interface NSObject &lt;NSObject&gt; { Class isa; } typedef struct objc_class *Class; struct objc_object { Class _Nonnull isa; }; typedef struct objc_object *id; typedef struct objc_selector *SEL; struct objc_class { Class _Nonnull isa; Class _Nullable super_class; const char * _Nonnull name; long version; long info; long instance_size; struct objc_ivar_list * _Nullable ivars; struct objc_method_list * _Nullable * _Nullable methodLists; struct objc_cache * _Nonnull cache; struct objc_protocol_list * _Nullable protocols; }; 总结： 在Objective-C中，任何类的定义都是对象。类和类的实例（对象）没有任何本质上的区别。任何对象都有isa指针。 可以看出：Class 是一个 objc_class 结构类型的指针, id是一个 objc_object 结构类型的指针. 每一个对象本质上都是一个类的实例。其中类定义了成员变量和成员方法的列表。对象通过对象的isa指针指向类。 每一个类本质上都是一个对象，类其实是元类（meteClass）的实例。元类定义了类方法的列表。类通过类的isa指针指向元类。 所有的元类最终继承一个根元类，根元类isa指针指向本身，形成一个封闭的内循环。 概述Objective-C将许多决策从编译时期和链接时期延后到运行时期。只要可能，它都动态的做很多事情。这意味着它不仅需要一个编译器，还需要一个运行时系统来执行编译好的代码。对于Objective-C来说，这个运行时系统就好像一个操作系统，使objective-c能够正常工作。 本文探究NSObject类，以及Objective-C程序如何和运行时系统交互。 通过阅读本文，你应该理解Objective-C的运行时系统如何工作，以及如何利用它。尽管对于写一个Cocoa程序而言，你可能并不需要理解本文。 运行时的版本和平台版本在不同的平台上有很多不同的Objective-C的Runtime的版本。 Objective-C Runtime有2个版本——现代版本和过去版本。现代版本是Objective-C 2.0引入的，包括一系列的新特性。过去版本的编程接口在《Objective-C 1 Runtime Reference》中进行了描述，现代版本的编程接口在《Objective-C Runtime Reference》 最值得注意的新特性是在现代runtime中实例变量是“non-fragile”的： 在过去版本中，如果你改变一个类中实例变量的布局，你必须重新编译这个类的子类； 在现代版本中，如果你改变一个类的实例变量的布局，你不需要重新编译这个类的子类； 平台iphone程序和运行在OSX v10.5及以上版本的64位的程序使用现代版的runtime，其它程序（OSX桌面的32位程序）使用过去版本的runtime 如何与运行时交互Objective-C程序和Runtime的交互可以分为3个层次： 通过Objective-C源代码； 通过Foundation framework 的 NSObject类的方法； 通过直接调用Runtime函数。 Objective-C 源代码通常情况下，Runtime系统在屏幕背后自动运行，你仅仅通过写和编译Objective-C代码来使用它。当你编译带有Objective-C的类和方法的代码时，编译器会创建实现语言动态特性的数据结构和函数调用。这些数据结构会捕获类、category、protocol声明中的信息，包括我们在《Defining a Class and Protocols in The Objective-C Programming Language》中讨论的类和protocol对象、selector、实例变量模板，以及源代码中的其他内容。主要的Runtime函数是那些能发送消息的函数，我们会在Messaging一节重点讲解，它被源代码的消息表达式调用。 NSObject方法Cocoa中大部分对象都是NSObject的子类，所以大部分对象继承了它的方法。（值得注意的一个例外是NSProxy类，详情见《消息转发》这一节。）因此它的方法的行为也能够被每一个对象和每一个类实例所继承。然而，在一些情况下，NSObject类仅仅定义了一个模板，并没有提供代码。 例如说，NSObject类定义了一个description实例方法，这个方法返回描述类内容的字符串。它主要用于调试——GDB的 print-object 会打印description方法返回的字符串。NSObject并不知道这个类的内容，因此它只返回名字和对象的地址，NSObject的子类能够返回更多细节。例如， NSArray的description方法返回它包括的对象的描述列表。一些NSObject方法仅仅查询Runtime的信息。这些方法允许对象进行反省。一个例子是class方法，它 向对象询问它的类，还有isKindOfClass:方法和isMemberOfClass:方法，它们检测对象在类层次中的位置，respondsToSelector:检测对象是否响应某个消息，conformsToProtocol:检测对象是否实现了特定协议的方法。这些方法给予了对象自省能力。 Runtime方法Runtime系统是一个动态共享库，它有公共接口，它的头文件位于 /usr/include/objc的文件夹里，有方法和数据结构的集合。当你写Objective-C代码时，这里很多方法允许你使用C代码重现编译器做的事情。其它方法形成了功能基础，这些功能通过NSObject类的方法导出。写Objective-C程序时，一些Runtime方法是很有用的。《Objective-C Runtime Reference》对这些所有的方法进行了介绍。 发送消息这一章将会讲解消息传递怎样会转化为objc_msgSend方法调用，以及你怎样通过名字来引用方法，然后讲解你怎样利用objc_msgSend方法，以及在你需要的时候怎样避免动态绑定。 objc_msgSend方法在Objective-C中，直到运行时消息才会被绑定到方法实现。编译器会把一个消息表达式[receiver message]转化为一次对消息函数——objc_msgSend的调用。objc_msgSend函数将消息的接收者和消息中的方法名作为参数。任何在消息中传递的参数也同样会被objc_msgSend处理：objc_msgSend(receiver, selector, arg1, arg2, ...) 消息函数为动态绑定做了一切： 它首先找到选择器引用的过程（方法实现）。由于相同的方法也可以被不同的类实现，因此它最终找到的过程依赖于接收者的类。 然后它会调用这个过程，传给它接收的对象（指向它的数据的指针），以及这个方法需要的其它参数。 最后，它将过程的返回值作为自己的返回值。 注意：编译器会生成对消息函数的调用，你不应该在自己的代码中直接调用它。 发送消息的关键在于编译器为每个类和对象生成的结构，每个类结构包括2个基本元素： 指向superclass的指针。 类的分发表。这个表中的条目是方法的选择器和特定类的方法地址的映射。例如setOrigin::的选择器就和setOrigin::的实现的地址进行了关联，display的选择器和display的地址进行了关联，等等。 当一个新对象创建以后，内存会被分配，它的实例变量会被初始化。这其中有一个指针指向它的类结构，这个指针就是 isa 指针，使得对象能够访问它的类，并且通过这个类它能够访问它的所有父类。 注意：严格来说，isa指针并不是语言本身的一部分，但它是对象和Objective-C Runtime系统协作所必需的。对象需要和objc_object结构各个字段都相等。然而，你很少需要创建你自己的root对象，继承自NSObject和NSProxy的对象自动有一个isa变量。 当一个消息发送给一个对象时，消息函数随着isa指针在其类的消息分发表中查找方法选择器。如果找不到选择器，objc_msgSend就会跟随指向父类的指针并在其方法分发表中尝试查找选择器，如果一直失败objc_msgSend会沿着继承体系不断向上，直到到达NSObject类。一旦找到选择器，消息函数会调用该方法并将接收对象的数据结构传递给它。 这就是运行时选择方法实现的方式，也就是面向对象编程术语中方法被动态绑定到消息的方式。 为了加速消息的处理，Runtime系统会缓存选择器和使用过的方法地址。每个类都有一个独立的缓存，它能存储从父类继承来的方法以及自己独特的方法的选择器。在搜索分发表之前，消息路由会检查接收消息的对象的类的缓存（理论上如果一个方法被使用过，那么它可能会被再次使用）。如果方法选择器在缓存中，那么这个消息处理仅仅比方法调用慢一点点。一旦一个程序运行很长时间去逐渐建立这个缓存，那么几乎所有的消息都会找到一个缓存的方法。随着程序的运行，缓存会动态增长，以容纳新的消息。 使用隐藏参数当objc_msgSend发现实现一个方法的过程时，它会调用这个过程，并通过消息传递给它所有的参数，同时也会传递2个隐藏参数: 接收对象 方法选择器 这些参数会给方法实现关于和两部分的明确的信息，之所以说是隐藏，是因为他们没有在方法的源代码中明确的声明。它们是在编译的时候插入实现中的。 尽管这些参数没有被明确声明，源代码仍然能够引用他们（就好像它能够引用接收对象实例变量一样）。一个方法用self来引用接收对象，用_cmd来引用选择器。在下面的例子中，_cmd引用stange方法的选择器，self引用接收stange消息的对象。 - strange { id target = getTheReceiver(); SEL method = getTheMethod(); if ( target == self || method == _cmd ) return nil; return [target performSelector:method]; } self更有用，方法定义通过它使得接收对象的实例变量可用。 根据方法名获取函数指针唯一避免动态绑定的方法是获取方法的地址然后直接调用它，就好像它是函数一样。在一些罕见情况下，你可能想要特定的方法按顺序执行很多次但又想避免每次方法执行时发消息的开销，这可能是唯一合适的方法。 利用NSObject类中定义的methodForSelector:方法，你能够查询实现一个方法的函数指针，然后你可以用这个指针调用这个函数。methodForSelector:方法返回的函数指针必须被小心地转换成合适的类型，包括返回值和参数。 下面这个例子显示了实现setFilled:方法的函数是如何被调用的： void (*setter)(id, SEL, BOOL); int i; setter = (void (*)(id, SEL, BOOL))[target methodForSelector:@selector(setFilled:)]; for ( i = 0 ; i &lt; 1000 ; i++ ) setter(targetList[i], @selector(setFilled:), YES); 传递给函数的前两个参数是接收对象(self)和方法选择器(_cmd)。这些参数在方法语法中是隐藏的，但当方法作为函数调用时必须是显式的。 发消息时使用methodForSelector:避免动态绑定可以节约很多时间，但是这种节约只有当特定的消息被重复很多次的时候才比较明显，正如上面的for循环显示的那样。 注意，methodForSelector: 是Cocoa runtime系统提供的，不是Objective-C语言的特性。 动态方法解析动态方法解析在某些场合你可能希望动态地给一个方法提供实现，例如说Objective-C语言的@dynamic关键字：@dynamic propertyName;它告诉编译器这个方法将会被动态提供。 我们可以通过实现resolveInstanceMethod:和resolveClassMethod: 方法来动态的为一个实例对象和类提供方法。 一个Objective-C方法是一个至少包括2个参数——self和_cmd的C函数。你可以利用函数class_addMethod将一个函数添加到类中，成为类的方法。对于如下函数： void dynamicMethodIMP(id self, SEL _cmd) { // implementation .... } 你可以使用resolveInstanceMethod:把它添加类中成为类的方法，例如： @implementation MyClass + (BOOL)resolveInstanceMethod:(SEL)aSEL { if (aSEL == @selector(resolveThisMethodDynamically)) { class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;); return YES; } return [super resolveInstanceMethod:aSEL]; } @end 转发方法（也叫消息转发）和动态消息解析很大程度上是强相关的。在转发机制启动前，类有机会动态解析方法，即先调用resolveInstanceMethod再进入消息转发，如果不想进入消息转发，直接返回NO。如果使用respondsToSelector:或者instancesRespondToSelector: ，首先动态解析器可以为选择器提供一个IMP。如果你实现了 resolveInstanceMethod:但只想要特定的选择器被通过转发机制转发，你可以针对那些不想转发的选择器返回NO。 动态加载Objective-C程序能够在运行时加载和链接新的类和类别(catogery)。新代码将和程序开始时加载的类和类别一样很好的融入到程序中。 动态加载被用来做很多不同的事情。例如在系统偏好中的那些模块就是动态加载的。 在Cocoa环境中，动态加载通常被用来允许程序定制化。你的程序在运行时可以加载别人写的一些模块——就好像Interface Builder加载定制的工具箱以及OSX系统偏好程序加载定制化偏好模块。 被加载的程序能够扩展原来程序的功能。他们以一种你允许但又不能预期和定义它的行为的方式提供这些模块。你定义框架，他们实现代码。 尽管在Mach-O文件（objc_loadModules, 在objc/objc-load.h 中定义）中有方法执行Objective-C模块的动态加载，Cocoa的NSBundle类为动态绑定提供了一个更方便的接口——它是面向对象的并且和相关类集成。参阅Foundation framework reference的NSBundle类的说明以获取NSBundle类及其用法。关于Mach-O的信息请参阅《OS X ABI Mach-O File Format Reference 》。 消息转发向一个对象发送它不能处理的消息会发生错误，然而，在声明出错之前，运行时系统给接收消息的对象一个机会来处理消息。 转发当你向一个对象发送它不能处理的消息时，在它声明出错之前，runtime会给它发送forwardInvocation: 消息，这个消息有唯一的参数———一个NSInvocation对象，NSInvocation对象封装了消息本身以及消息带的参数。 你可以实现 forwardInvocation: 方法来给出一个该消息的默认响应，或者通过其他方式避免错误的产生。就像它的字面意思一样，forwardInvocation: 通常用来将消息转发给其它对象。 关于转发的范围和意图，想象下面的场景：首先，假设你设计了一个对象，能够响应 negotiate 消息，你想要它的响应包括另外一个对象的响应。你可以很轻松的实现：你只需要在你实现的 negotiate 方法中将 negotiate 消息传递给另外的对象。 更进一步，假设你想要你的对象对于 negotiate 消息的响应在其他类中实现的。一个办法是使你的对象的类继承自其他类，然而这有时候不可能，例如你的类和实现 negotiate 的类在不同的继承体系中。 尽管你的类不能继承 negotiate 方法，你仍然可以通过实现一个方法，在这个方法中仅仅需要将消息传递给那个类对象，来“借用”这个 negotiate 方法。 - (id)negotiate { if ( [someOtherObject respondsTo:@selector(negotiate)] ) return [someOtherObject negotiate]; return self; } 这种方式有点麻烦，尤其是当你有很多消息要转发给其他对象的时候。你必须去实现一个方法去覆盖每一个你想要从其他对象那里“借”的方法。然而，想要覆盖每一个消息，处理每一种情况是不可能的，而且它依赖于运行时时间，它可能会随着以后实现的方法和类而改变。 forwardInvocation: 提供了一种特别的解决方案，它是动态而非静态的。当一个对象由于缺少匹配消息选择器的方法而不能响应消息的时候，运行时系统会给它发送一个 forwardInvocation: 消息。每一个对象都从NSObject类继承了forwardInvocation: 方法。然而，这个方法的NSObject版本仅仅调用了doesNotRecognizeSelector: 方法。通过重写NSObject版本的这个方法，你就可以利用forwardInvocation: 消息提供的时机将你的消息转发给其他对象。 要转发一个消息，forwardInvocation:需要做的是： 决定消息应该流向哪里； 将原始参数传递给它 这个消息必须要能被invokeWithTarget: 发送： - (void)forwardInvocation:(NSInvocation *)anInvocation { if ([someOtherObject respondsToSelector: [anInvocation selector]]) [anInvocation invokeWithTarget:someOtherObject]; else [super forwardInvocation:anInvocation]; } 被转发消息的返回值会返回给原始的发送者。所有类型的返回值都能够被传递给发送者，包括ids、结构和双精度浮点型数字。forwardInvocation: 的作用就好像一个无法识别的消息的分发中心，将消息分发给不同的接收者。或者是一个转化中心，发送所有的消息到相同的目的地。它能将一个消息翻译成另外一个，也能够“吞噬”消息，没有响应也没有错误。forwardInvocation:也能将很多消息合并成一个响应。forwardInvocation: 如何执行取决于实现者。它提供的这样的机制使得在转发链中链接对象成为了可能。 注意：只有当接收者没有调用已有方法时forwardInvocation: 才会处理消息。也就是说如果你想让你的对象转发negotiate消息给其他对象，那么它就不能有一个negotiate方法。如果它有的话，消息将永远不能到达forwardInvocation：。 更多关于消息转发和调用的信息，请参与《 Foundation framework reference》中NSInvocation类的说明。 转发和多重继承转发模拟继承，转发能够借用一些多重继承的效果。一个对象通过转发响应了一个消息，就好像从其它对象那里借用或者继承了一个方法实现一样。 转发消息的对象继承体系分为两个分支——它自己所在的分支和消息响应者所在的分支 消息转发提供了你想要从多重继承获得的大多数特性。然而两者有一个显著地不同：多重继承将不同的功能组合在一个对象中，它侧重于大、多层面的对象。而转发侧重于将不同的能力分配给不同的对象。它将问题分解为小对象，以一种对消息发送者透明的方式将这些对象联系起来。 代理对象转发不仅模仿多重继承，而且也使得开发代表或覆盖更多实体对象的轻量级对象成为可能。代理站在另外那个对象的角度，并且向它传递消息。 代理使得向远程对象转发消息成为可能，参数可以正确的拷贝和获取。但它不会拷贝远程对象的功能，仅仅给远程对象一个本地地址，通过这个本地地址它能够接收消息。其他类别的代理对象也是可能的。例如你有一个对象，这个对象有大量数据——它可能创建了一个复杂的图像或者读取了磁盘上文件的内容。创建这个对象很耗时，因此你可能倾向于稍后创建——当需要它的时候或者系统资源闲置的时候。同时你需要这个对象的占位符，以便程序中的其他对象可以正常工作。 在这种情况下，你可能开始不会创建一个完整的对象，而是一个轻量级的代理。这个对象能够自己处理一些事情，例如回答关于数据的问题，但是它主要的功能还是作为这个大对象的占位符，以及在合适的时候转发消息。当这个代理对象的forwardInvocation: 方法接收到一个发给其他对象的消息时，它会在该对象不存在时创建它以确保对象的存在。所有发给这个大对象的消息都经过这个代理，对象和代理是等价的。 转发和继承尽管转发酷似继承，但是NSObject类绝不会把两者混淆起来。respondsToSelector: and isKindOfClass: 这两个方法仅仅存在于继承体系中，不会存在于转发链中。例如，一个Warrior对象是否响应 negotiate 方法的代码为 if ( [aWarrior respondsToSelector:@selector(negotiate)] ) ... 答案是否定的，尽管它能够接收 negotiate 消息并且做出反应，通过转发消息给Diplomat对象。 在很多情况下，否定是正确的答案。但也可能不是这样。如果你用转发去创建一个代理对象或者去扩展一个类，转发机制就和继承机制一样透明。如果你想要你的对象表现的好像它们真的继承了你要转发到的对象的行为的话，你就需要重新实现respondsToSelector:方法和isKindOfClass:方法以包含你的转发机制： - (BOOL)respondsToSelector:(SEL)aSelector { if ( [super respondsToSelector:aSelector] ) return YES; else { /* Here, test whether the aSelector message can * * be forwarded to another object and whether that * * object can respond to it. Return YES if it can. */ } return NO; } 除了 respondsToSelector: 和 isKindOfClass: 方法，instancesRespondToSelector 方法也应该映射转发机制。conformsToProtocol: 方法应该也被加到列表中。相似的，如果一个对象转发它收到的所有方法，它应该有一个方法 methodSignatureForSelector:能够返回方法描述；例如，如果一个对象能够转发消息给它的代理，它可能会像下面这样实现methodSignatureForSelector: 方法： - (NSMethodSignature*)methodSignatureForSelector:(SEL)selector { NSMethodSignature* signature = [super methodSignatureForSelector:selector]; if (!signature) { signature = [surrogate methodSignatureForSelector:selector]; } return signature; } 你可能考虑将这些转发算法放在私有代码中，这样就有了所有方法，forwardInvocation:已经包括了，请调用它。 注意：这是一个高级技术，仅适用于没有其他解决方案的情况。他不应该作为继承的替代品。如果你必须要使用该技术，请确认你已经完全理解了你要转发的类和转发到的类的行为。本节提到的方法都在Foundation framework reference 的 NSObject 类的说明中有描述。关于invokeWithTarget: 的更多信息，请参考 Foundation framework reference 中 NSInvocation 的说明。 类型编码都是表格，暂不翻译，原文地址：Objective-C Runtime Programming Guide 声明属性当编译器遇到属性声明（参见《The Objective-C Programming Language》中的属性声明），它会为这个类、类别或者协议产生一些描述性的 metadata。你可以通过一些方法访问这些metadata，这些方法能够通过类或者协议的名字查询属性，获取属性的类型，以及拷贝属性的属性。属性声明的列表对每个类和协议都适用。 属性类型和方法Property 结构定义了属性描述符的handle。 typedef struct objc_property *Property; 你可以使用 class_copyPropertyList 和 protocol_copyPropertyList 方法获取一个类、类别或者协议的属性列表： objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount) objc_property_t *protocol_copyPropertyList(Protocol *proto, unsigned int *outCount) 例如，给定如下类声明： @interface Lender : NSObject { float alone; } @property float alone; @end 你可以这样获取属性列表： id LenderClass = objc_getClass(&quot;Lender&quot;); unsigned int outCount; objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount); 你可以使用 property_getName 来获取属性名： const char *property_getName(objc_property_t property) 你可以用方法 class_getProperty 和 protocol_getProperty 获取一个类或协议的指定名字的属性的引用： objc_property_t class_getProperty(Class cls, const char *name) objc_property_t protocol_getProperty(Protocol *proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty) 你可以用 property_getAttributes 方法获取属性的名字和 @encode 类型的字符串。关于编码类型字符串的细节，请参考 《类型编码》章节，细节请参考 《属性类型字符串》和《属性类型描述举例》。 const char *property_getAttributes(objc_property_t property) 因此，你可以用下面这段代码打印一个类的属性列表： id LenderClass = objc_getClass(&quot;Lender&quot;); unsigned int outCount, i; objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount); for (i = 0; i &lt; outCount; i++) { objc_property_t property = properties[i]; fprintf(stdout, &quot;%s %s\n&quot;, property_getName(property), property_getAttributes(property)); } 属性类型字符串你可以使用 property_getAttributes 方法来获取属性的名字、@encode类型字符串，以及属性的其他属性。 代码示例@interface EOCObject : NSObject { NSString *_ecoString; } @end @implementation EOCObject - (void)eocMothod { } @end 查看方法列表//查看方法列表 //2018-10-17 09:46:42.795766+0800 EOCRuntimeClass[33064:2309568] eocMothod //2018-10-17 09:46:42.796275+0800 EOCRuntimeClass[33064:2309568] .cxx_destruct - (void)scanMethods { unsigned int outCount; Method *methods = class_copyMethodList([EOCObject class], &amp;outCount); for (int i=0; i&lt;outCount; i++) { Method method = methods[i]; SEL methodSel = method_getName(method); NSLog(@&quot;%s&quot;, sel_getName(methodSel)); } } 查看变量列表//查看变量列表 //2018-10-17 09:44:28.914333+0800 EOCRuntimeClass[33004:2307063] _ecoString - (void)scanIvars { unsigned int outCount; Ivar *ivars = class_copyIvarList([EOCObject class], &amp;outCount); for (int i=0; i&lt;outCount; i++) { Ivar ivar = ivars[i]; NSLog(@&quot;%s&quot;, ivar_getName(ivar)); } } 元类和父类元类就是类本身，元类中保存的是类方法等信息 //查看isa，有元类（类本身）影响，所以会打印两个EOCObject //2018-10-17 10:13:20.923652+0800 EOCRuntimeClass[33447:2332572] 1==EOCObject //2018-10-17 10:13:20.923874+0800 EOCRuntimeClass[33447:2332572] 2==EOCObject //2018-10-17 10:13:20.924052+0800 EOCRuntimeClass[33447:2332572] 3==NSObject //2018-10-17 10:13:20.924172+0800 EOCRuntimeClass[33447:2332572] 4==NSObject //2018-10-17 10:13:20.924317+0800 EOCRuntimeClass[33447:2332572] 5==NSObject //2018-10-17 10:35:15.841205+0800 EOCRuntimeClass[33746:2351271] 1==NSObject //2018-10-17 10:35:15.841617+0800 EOCRuntimeClass[33746:2351271] 2==(null) //2018-10-17 10:35:15.841757+0800 EOCRuntimeClass[33746:2351271] 3==(null) - (void)isaForward { EOCObject *eocObject = [[EOCObject alloc] init]; NSLog(@&quot;1==%@&quot;, object_getClass(eocObject)); NSLog(@&quot;2==%@&quot;, object_getClass(object_getClass(eocObject))); NSLog(@&quot;3==%@&quot;, object_getClass(object_getClass(object_getClass(eocObject)))); NSLog(@&quot;4==%@&quot;, object_getClass(object_getClass(object_getClass(object_getClass(eocObject))))); NSLog(@&quot;5==%@&quot;, object_getClass(object_getClass(object_getClass(object_getClass(object_getClass(eocObject)))))); NSLog(@&quot;1==%@&quot;, class_getSuperclass([EOCObject class])); NSLog(@&quot;2==%@&quot;, class_getSuperclass(class_getSuperclass([EOCObject class]))); NSLog(@&quot;3==%@&quot;, class_getSuperclass(class_getSuperclass(class_getSuperclass([EOCObject class])))); } - (void)structAnly{ EOCObject *eocObject = [[EOCObject alloc] init]; Class isa = object_getClass(eocObject); Class metaIsa = objc_getMetaClass(&quot;EOCObject&quot;); Class metaIsaOther = object_getClass(object_getClass(eocObject)); NSLog(@&quot;%@::元类%@ -- %@&quot;, isa, metaIsa, metaIsaOther); NSLog(@&quot;%p::元类%p -- %p&quot;, isa, metaIsa, metaIsaOther); //2018-10-17 13:07:47.336590+0800 EOCRuntimeClass[35671:2447195] EOCObject::元类EOCObject -- EOCObject //2018-10-17 13:07:47.336768+0800 EOCRuntimeClass[35671:2447195] 0x10af764e8::元类0x10af764c0 -- 0x10af764c0 Class metaIsaTwoGrade = object_getClass(object_getClass(object_getClass(eocObject))); NSLog(@&quot;元类的元类（父元类）%@--&gt;%p&quot;, metaIsaTwoGrade, metaIsaTwoGrade); //2018-10-17 13:07:47.337094+0800 EOCRuntimeClass[35671:2447195] 元类的元类（父元类）NSObject--&gt;0x10bf23e58 Class metaIsaThreeGrade = object_getClass(object_getClass(object_getClass(object_getClass(eocObject)))); NSLog(@&quot;元类的元类的元类（爷元类）%@--&gt;%p&quot;, metaIsaThreeGrade, metaIsaThreeGrade); //2018-10-17 13:07:47.337325+0800 EOCRuntimeClass[35671:2447195] 元类的元类的元类（爷元类）NSObject--&gt;0x10bf23e58 NSLog(@&quot;==%p&quot;, class_getSuperclass([eocObject class])); NSLog(@&quot;==%p&quot;, class_getSuperclass(class_getSuperclass([eocObject class]))); //2018-10-17 13:07:47.338250+0800 EOCRuntimeClass[35671:2447195] ==0x10bf23ea8 //2018-10-17 13:07:47.338406+0800 EOCRuntimeClass[35671:2447195] ==0x0 } 对象的isa在内存中的示意举例： 对象的初始化[[EOCObject alloc] init]初始化步骤： [EOCObject alloc] 先执行，因为EOCObject检测，没有alloc方法， 就去父类里面去查找。 检测父类是否响应 alloc， 如果有，那么执行， 开始分配内存空间大小（成员变量）。// 方法（类有关系） init 方法，检测是否响应，如果没有去父类查找。 方法执行完，会存缓存（所以一般第二次操作，会更快） 各方法区别： IMP 是函数指针 SEL 方法名（和类没关系的） Method 包含方法名和函数指针 方法定义及添加方法 /* struct objc_method { SEL method_name; char *method_types; IMP method_imp; } */ static void testCMehtod(id self, SEL _cmd, NSString *argu){ NSLog(@&quot;%@---%@&quot;, self, argu); } - (void)addC_Method{ if(class_addMethod([self class], @selector(testCMehtod), (IMP)testCMehtod, &quot;v@:@&quot;)){ [self performSelector:@selector(testCMehtod) withObject:@&quot;abc&quot;]; } } 方法交换方法交换交换的是IMP //方法交换 @implementation NSMutableDictionary (Exception) + (void)load { [self resolveNilExceptionMethod]; } + (void)resolveNilExceptionMethod{ NSMutableDictionary *dict = [[NSMutableDictionary alloc] init]; SEL originalSel = NSSelectorFromString(@&quot;setObject:forKey:&quot;); SEL exceSel = @selector(haneldeException:forKey:); Method originalMethod = class_getInstanceMethod(object_getClass(dict), originalSel); Method exchangeMethod = class_getInstanceMethod(object_getClass(dict), exceSel); method_exchangeImplementations(originalMethod, exchangeMethod); } - (void)haneldeException:(id)anObject forKey:(id&lt;NSCopying&gt;)aKey{ if (anObject == nil) { NSLog(@&quot;你传了个空过来了&quot;); anObject = @&quot;&quot;; } [self haneldeException:anObject forKey:aKey]; } @end 交换方法时为何要先实例化NSMutableDictionary？ NSNumber *numberOne = [NSNumber numberWithInt:1]; NSNumber *numberTwo = [NSNumber numberWithBool:YES]; NSLog(@”NSNumber::%@, %@, %@”, [numberOne class], [numberTwo class], [numberThr class]); NSDictionary–&gt; mutableDict 和 不可变的 （类簇），抽象类。在实际交换中，并不是交换了NSDictionary的方法，而是交换了__NSDictionaryM 这个类的方法。object_getClass(dict) 获取invocation- (void)scanInvocation{ NSMethodSignature *signature = [self methodSignatureForSelector:@selector(methodIMP:TwoArg:)]; NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature]; } - (void)methodIMP:(NSString*)str TwoArg:(NSString*)testInt{ NSLog(@&quot;%@::%@&quot;, self, _cmd); } 给现有类动态添加方法和变量：类方法是属于元类的：可以通过类别方法给类添加类方法，如果类有名称相同的方法，将会添加成功，但是在寻找执行的时候只会找到类别中的方法 实例方法是属于类的：可以通过类别方法给类添加方法，如果原类有名称相同的方法，将会添加成功，但是在寻找执行的时候只会找到类别中的方法 变量是属于实例的：如果对基类添加动态变量对内存来说将是灾难性的，只能根据关联对象方法给类关联对象 @interface EOCObject : NSObject @property (nonatomic, strong)NSString *testOne; - (void)testMethod:(NSString*)str; @end @implementation EOCObject - (void)testMethod:(NSString*)str{ NSLog(@&quot;testMethod::%@&quot;, str); } @end //关联对象方法添加变量 //添加方法时可以名称相同，通过遍历类的方法时可以看得到有两个testMethod方法存在，但执行时仅执行类别中的方法 @interface EOCObject (AddIvar) @property (nonatomic,strong)TestObject *eocClassName; - (void)testMethod:(NSString*)str; @end @implementation EOCObject (AddIvar) - (NSString*)eocClassName{ return objc_getAssociatedObject(self, &quot;eocClassName&quot;); } - (void)setEocClassName:(NSString *)eocClassName{ objc_setAssociatedObject(self, &quot;eocClassName&quot;, eocClassName, OBJC_ASSOCIATION_RETAIN); } - (void)testMethod:(NSString*)str{ NSLog(@&quot;testMethod::%@&quot;, str); } @end 调用方法时的动态特性- (void)messaegSend { NSString* (*test)(id, SEL, NSString*) = nil; test = (__typeof__(test))objc_msgSend; NSLog(@&quot;%@&quot;, test(self, @selector(messageMethod:), @&quot;Test&quot;)); } - (NSString*)messageMethod:(NSString*)test{ NSLog(@&quot;%@&quot;, test); return @&quot;messageMethod&quot;; } block方式实现方法交换+ (void)load{ [self exchangeMethod]; } + (void)exchangeMethod{ SEL originSEL = @selector(testMethod:); // 定一个函数指针（因为imp【函数指针】没有传参数的方式） __block void (*originIMP)(__unsafe_unretained id, SEL, NSString*) = NULL; // 将要用来替换原有的函数实现 id newBlock = ^(__unsafe_unretained id self, NSString *str){ NSLog(@&quot;newBlock::%@&quot;, str); // 执行旧的方法 if (originIMP) { originIMP(self, _cmd, str); } }; // 把block转化成 IMP IMP newIMP = imp_implementationWithBlock(newBlock); Method originMethod = class_getInstanceMethod([self class], originSEL); // 替换原有的函数指针，返回原有的函数指针originIMP originIMP = (__typeof__(originIMP))method_setImplementation(originMethod, newIMP); if(originIMP){ NSLog(@&quot;method_setImplementation 成功&quot;); } } 在运行时动态创建类- (void)createNewClass{ if (NSClassFromString(EOCClassOne)) { return; } // 1.动态去生成一个类 Class NewClass = objc_allocateClassPair(self.class, &quot;EOCClassOne&quot;, 0); // 2.添加变量 if(class_addIvar(NewClass, &quot;eocStr&quot;, sizeof(NSString*), log(sizeof(NSString*)), &quot;NSString&quot;)){ NSLog(@&quot;添加成功&quot;); } // 3.添加属性 objc_property_attribute_t type = {&quot;T&quot;, &quot;@\&quot;NSString\&quot;&quot;}; objc_property_attribute_t owner = { &quot;C&quot;, &quot;&quot; }; objc_property_attribute_t ivarT = { &quot;V&quot;, &quot;_ivar1&quot;}; objc_property_attribute_t ivarN = { &quot;N&quot;, &quot;&quot;}; objc_property_attribute_t atrrs[] = {type, owner, ivarT, ivarN}; if(class_addProperty(NewClass, &quot;_ivar1&quot;, atrrs, 4)){ NSLog(@&quot;属性添加成功&quot;); } // 4.提交 objc_registerClassPair(NewClass); // 提交后，不能再添加变量了，结构固定了 id testObject = [NewClass new]; [testObject setValue:@&quot;testString&quot; forKey:@&quot;eocStr&quot;]; NSLog(@&quot;%@&quot;, [testObject valueForKey:@&quot;eocStr&quot;]); // 课堂里的bug，添加变量，可以通过下面的方式来设置和获取， KVC来操作有bug Ivar ivar = class_getInstanceVariable(NewClass, &quot;_ivar1&quot;); object_setIvar(testCls, ivar, @&quot;testValue&quot;); NSLog(@&quot;::%@&quot;, object_getIvar(testCls, ivar)); // [testCls setObject:@&quot;dd&quot; forKey:@&quot;V_ivar1&quot;]; // 这样会奔溃 // NSLog(@&quot;%@&quot;, [testCls objectForKey:@&quot;V_ivar1&quot;]); unsigned int outCount, i; objc_property_t *properties = class_copyPropertyList([testCls class], &amp;outCount); for (i = 0; i &lt; outCount; i++) { objc_property_t property = properties[i]; fprintf(stdout, &quot;mytest %s %s\n&quot;, property_getName(property), property_getAttributes(property)); } } 练习NSDictionary和Model之间的转换]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>iOS</tag>
        <tag>RunTime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实时音频功能开发]]></title>
    <url>%2F2018%2F04%2F27%2F%E5%AE%9E%E6%97%B6%E9%9F%B3%E9%A2%91%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[音频概念概念音频文件的生成过程是将声音信息采样、量化和编码产生的数字信号的过程。 人耳所能听到的声音，最低的频率是从20Hz起一直到最高频率20KHZ，因此音频文件格式的最大带宽是20KHZ。 根据奈奎斯特的理论，只有采样频率高于声音信号最高频率的两倍时，才能把数字信号表示的声音还原成为原来的声音，所以音频文件的采样率一般在40~50KHZ，比如最常见的CD音质采样率44.1KHZ。 PCM对声音进行采样、量化过程被称为脉冲编码调制（Pulse Code Modulation）简称PCM，PCM是最原始的音频数据完全无损，所以PCM数据虽然音质优秀但体积庞大 然后就诞生了一系列的音频格式，如MP3（有损压缩）目前最为常用的音频格式之一 苹果默认音频格式是aac 码率MP3格式中的码率（BitRate）代表了MP3数据的压缩质量，现在常用的码率有128kbit/s、160kbit/s、320kbit/s等等，这个值越高声音质量也就越高 MP3组成MP3格式中的数据通常由两部分组成: 一部分为ID3 用来存储歌名、演唱者、专辑、音轨数等信息 另一部分为音频数据DataOffset +（我选择的时间点／总时间）*（音频数据总长度） seek（） 音频数据部分音频数据部分以帧(frame)为单位存储，每个帧都有自己的帧头帧头其中存储了采样率等解码必须的信息,所以每一个帧都可以独立于文件存在和播放帧头之后存储着音频数据，这些音频数据是若干个PCM数据帧经过压缩算法压缩得到的 AudioQueue 概念AudioQueue服务提供一种直接的,低开销的方式以用于在iOS及Mac OS X上录音和播放音乐。 使用AudioQueue播放音乐的优点就是开销很小并且支持流式播放（边下边播），但是缺点就是开发难度大，所以有网络音频库AudioStreamer，网上有很多讲AudioQueue的，但是有实例代码说明的，实在是少之又少，正好公司项目有音频需求，虽然项目中使用的并非我自己写的音频播放功能，但事后还是想自己来研究一下，这个在我看来比较神奇也比较有趣的AudioQueue。 工作原理从上图可以看出其工作原理如下 在使用AudioQueue之前首先必须理解其工作模式，它之所以这么命名是因为在其内部有一套缓冲队列BufferQueue的机制。 在AudioQueue启动之后需要通过AudioQueueAllocateBuffer生成若干个AudioQueueBufferRef结构， 这些Buffer将用来存储即将要播放的音频数据， 并且这些Buffer是受生成他们的AudioQueue实例管理的，内存空间也已经被分配（按照Allocate方法的参数）， 当AudioQueue被Dispose时这些Buffer也会随之被销毁。 当有音频数据需要被播放时首先需要被memcpy到AudioQueueBufferRef的mAudioData中（mAudioData所指向的内存已经被分配，之前AudioQueueAllocateBuffer所做的工作），并给mAudioDataByteSize字段赋值传入的数据大小。 完成之后需要调用AudioQueueEnqueueBuffer把存有音频数据的Buffer插入到AudioQueue内置的Buffer队列中。 在Buffer队列中有buffer存在的情况下调用AudioQueueStart，此时AudioQueue就回按照Enqueue顺序逐个使用Buffer队列中的buffer进行播放，每当一个Buffer使用完毕之后就会从Buffer队列中被移除并且在使用者指定的RunLoop上触发一个回调来告诉使用者 某个AudioQueueBufferRef对象已经使用完成，你可以继续重用这个对象来存储后面的音频数据。如此循环往复音频数据就会被逐个播放直到结束。 工作流程根据Apple提供的AudioQueue工作原理结合自己理解，可以得到其工作流程大致如下： 创建AudioQueue，创建一个自己的buffer数组BufferArray; 使用AudioQueueAllocateBuffer创建若干个AudioQueueBufferRef，放入BufferArray； 有数据时从BufferArray取出一个buffer，memcpy数据后用AudioQueueEnqueueBuffer方法把buffer插入AudioQueue中； AudioQueue中存在Buffer后，调用AudioQueueStart播放。（具体等到填入多少buffer后再播放可以自己控制，只要能保证播放不间断即可）； AudioQueue播放音乐后消耗了某个buffer，在另一个线程回调并送出该buffer，把buffer放回BufferArray供下一次使用； 返回步骤3继续循环直到播放结束 总结：从以上步骤其实不难看出，AudioQueue播放的过程其实就是一个典型的生产者消费者问题。生产者是AudioFileStream，它们生产处音频数据帧，放入到AudioQueue的buffer队列中，直到buffer填满后需要等待消费者消费；AudioQueue作为消费者，消费了buffer队列中的数据，并且在另一个线程回调通知数据已经被消费,生产者可以继续生产。所以在实现AudioQueue播放音频的过程中必然会接触到一些多线程同步、信号量的使用、死锁的避免等等问题。 播放流程流程：之上我们就可以了解到的音频播放流程（MP3为例） 读取MP3文件.data 每次读一千bytes 解析采样率、码率、时长等信息，分离MP3中的音频帧（看上四） （audioParse，一个文件头，音频文件数据（帧头，音频帧数据）） 对分离出来的音频帧解码得到PCM数据（看上五） 对PCM数据进行音效处理（均衡器、混响器等，非必须） 把PCM数据解码成音频信号 把音频信号交给硬件播放 （播放 AudioQueue） 重复1-6步直到播放完成 业务： 可以边播放边下载 从4步骤可以来做音效处理,需要把音频数据转换成PCM数据，再由AudioUnit+AUGraph来进行音效处理和播放 基本流程：NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;MP3Sample&quot; ofType:@&quot;mp3&quot;]; fileHandle = [NSFileHandle fileHandleForReadingAtPath:filePath]; _fileSize = [[[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:nil] fileSize]; - (void)audioThread { // 1 建立audioSession 会话 BOOL isSuccess = [eocAudioSession eocAVAudioSessionActive:YES]; if (!isSuccess) { return; } isSuccess = [eocAudioSession configAVAudioSessionCategory:AVAudioSessionCategoryPlayback]; if (!isSuccess) { return; } BOOL isEOF = NO; // 需要文件size，和一个偏移量，知道文件的eof while (_fileSize &gt; 0) {】 // 2 读音频文件 1000字节 fileHandle NSData *data = nil; if (!isEOF) { /* 从网络读取数据 网络速度很慢，数据如果没有达到 500，要阻塞，等网络下好数据，在启动 网络很快，就没问题 */ data = [fileHandle readDataOfLength:500]; _fileOffset += data.length; if (_fileOffset &gt;= _fileSize) { isEOF = YES; NSLog(@&quot;finish EOF&quot;); } } if (_playing &amp;&amp; data) { // 3 解析 eocAudioStreamParse isSuccess = [eocAudioStreamParse parserAudioStream:data]; if (!isSuccess) { NSLog(@&quot;解析数据出问题了&quot;); break; } // 5 读数据（从缓冲区里读） // 5.1 需要判断是否已经解析完文件头 if ([eocAudioStreamParse isReadyProductPacket]) { // 5.2 读音频数据 if (!eocAudioQueueRead.audioQueue) { // 创建队列 isSuccess = [eocAudioQueueRead createQueue:eocAudioStreamParse.audioStreamBasicDescription bufferSize:(UInt32)_bufferSize]; // _bufferSize*3 if (!isSuccess) { NSLog(@&quot;createQueue出问题了&quot;); break; } } // 从缓冲区里读 if (eocBuffersPool.bufferSize &lt; _bufferSize) { // pool数据不够，那么继续解析文件数据 continue; } UInt32 packetCount = 0; AudioStreamPacketDescription *packetDescription; NSData *streamData = [eocBuffersPool dequeuePoolStreamPacketDataSize:(UInt32)_bufferSize packetCount:&amp;packetCount audioStreamPacketDescription:&amp;packetDescription];】 if (streamData) { isSuccess = [eocAudioQueueRead playerAudioQueue:streamData numPackets:packetCount packetDescription:packetDescription]; if (!isSuccess) { NSLog(@&quot;playerAudioQueue fail&quot;); break; } } else { NSLog(@&quot;dequeuePoolStream fail&quot;); break; } } } } NSLog(@&quot;finish&quot;); } // 4 数据缓存区 - (void)eocAudioStreamParseForPackets:(NSArray *)packetAry{ [eocBuffersPool enqueuePoolStreamPacketsAry:packetAry]; } 创建Session并设置激活、类型和监听打断@implementation EOCAudioSession - (instancetype)init { self = [super init]; if (self) { [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(avAudioSessionInterruptionNotification:) name:AVAudioSessionInterruptionNotification object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(avAudioSessionRouteChangeNotification:) name:AVAudioSessionRouteChangeNotification object:nil]; } return self; } - (void)avAudioSessionInterruptionNotification:(NSNotification*)notifi{ NSLog(@&quot;打断了&quot;); } - (void)avAudioSessionRouteChangeNotification:(NSNotification*)notifi{ NSLog(@&quot;耳机／蓝牙&quot;); } - (BOOL)eocAVAudioSessionActive:(BOOL)active{ AVAudioSession *avAudioSeesion = [AVAudioSession sharedInstance]; NSError *error = nil; [avAudioSeesion setActive:active error:&amp;error]; if (error) { NSLog(@&quot;AVAudioSession setActive fail:%@&quot;, error); return NO; } return YES; } - (BOOL)configAVAudioSessionCategory:(NSString*)category{ AVAudioSession *avAudioSeesion = [AVAudioSession sharedInstance]; NSError *error = nil; [avAudioSeesion setCategory:category error:&amp;error]; if (error) { NSLog(@&quot;AVAudioSession setCategory fail:%@&quot;, error); return NO; } return YES; } @end 创建头和内容解析器/* 属性解析的key值 kAudioFileStreamProperty_ReadyToProducePackets kAudioFileStreamProperty_DataOffset kAudioFileStreamProperty_BitRate kAudioFileStreamProperty_DataFormat kAudioFileStreamProperty_AudioDataByteCount 音频数据总量 */ //解析属性的回调 static void EOCAudioFileStream_PropertyListenerProc(void *inClientData, AudioFileStreamID inAudioFileStream, AudioFileStreamPropertyID inPropertyID, AudioFileStreamPropertyFlags * ioFlags){ EOCAudioStreamParse *eocAudioStreamParse = (__bridge EOCAudioStreamParse *)inClientData; [eocAudioStreamParse handleAudioFileStream_PropertyListenerProc:inPropertyID]; } // 解析音频数据frame的回调 static void EOCAudioFileStream_PacketsProc(void *inClientData, UInt32 inNumberBytes, UInt32 inNumberPackets, const void *inInputData, AudioStreamPacketDescription *inPacketDescriptions){ EOCAudioStreamParse *eocAudioStreamParse = (__bridge EOCAudioStreamParse *)inClientData; NSData *data = [NSData dataWithBytes:inInputData length:inNumberBytes]; [eocAudioStreamParse handleAudioFileStream_PacketsProc:inNumberBytes Packets:inNumberPackets PacketData:data PacketDescription:inPacketDescriptions]; } // 解析 @implementation EOCAudioStreamParse - (instancetype)initWithFile:(AudioFileTypeID)fileType filezize:(UInt32)filesize{ self = [super init]; if (self) { _audioFileTypeID = fileType; _fileSize = filesize; _isContinue = YES; [self createAudioSessionStream]; } return self; } //创建解析器，并设置property和packets的解析回调 - (BOOL)createAudioSessionStream{ AudioFileStreamOpen((__bridge void*)self, EOCAudioFileStream_PropertyListenerProc, EOCAudioFileStream_PacketsProc, _audioFileTypeID, &amp;_audioFileStreamID); return YES; } - (BOOL)parserAudioStream:(NSData*)data { // 刚开始解析的时候，是解析的文件头,解析完的数据到了 EOCAudioFileStream_PropertyListenerProc // 文件解析完后那么就是音频数据，这个之后解析的数据到了EOCAudioFileStream_PacketsProc // 文件属性在文件尾，不支持流播放，返回kAudioFileStreamError_NotOptimized seek OSStatus status = AudioFileStreamParseBytes(_audioFileStreamID, (UInt32)data.length, [data bytes], _isContinue?0:kAudioFileStreamParseFlag_Discontinuity); if (status != noErr) { NSLog(@&quot;StreamParseBytes error!&quot;); return NO; } return YES; } - (BOOL)isReadyProductPacket{ return isReadyProductPacket; } // 文件属性处理 - (void)handleAudioFileStream_PropertyListenerProc:(AudioFileStreamPropertyID)inPropertyID { if (inPropertyID == kAudioFileStreamProperty_DataOffset) { UInt32 size = sizeof(_audioDataOffset); AudioFileStreamGetProperty(_audioFileStreamID, inPropertyID, &amp;size, &amp;_audioDataOffset); } else if (inPropertyID == kAudioFileStreamProperty_BitRate) { UInt32 size = sizeof(_biteRate); AudioFileStreamGetProperty(_audioFileStreamID, inPropertyID, &amp;size, &amp;_biteRate); } else if (inPropertyID == kAudioFileStreamProperty_AudioDataByteCount) { UInt32 size = sizeof(_audioDataByteCount); AudioFileStreamGetProperty(_audioFileStreamID, inPropertyID, &amp;size, &amp;_audioDataByteCount); } else if (inPropertyID == kAudioFileStreamProperty_DataFormat) { UInt32 size = sizeof(_audioStreamBasicDescription); AudioFileStreamGetProperty(_audioFileStreamID, inPropertyID, &amp;size, &amp;_audioStreamBasicDescription); } else if (inPropertyID == kAudioFileStreamProperty_ReadyToProducePackets) { // 文件属性解析完了 isReadyProductPacket = YES; _isContinue = NO; [self calcultateDuration]; } } - (void)calcultateDuration{ if (_biteRate &gt; 0 &amp;&amp; _fileSize &gt; 0) { _duration = (_fileSize-_audioDataOffset)*8.0/_biteRate; } } // 音频帧的处理 （buffer） - (void)handleAudioFileStream_PacketsProc:(UInt32)inNumberBytes Packets:(UInt32)inNumberPackets PacketData:(NSData*)packetData PacketDescription:(AudioStreamPacketDescription*)inPacketDescriptions{ if (inNumberBytes == 0 || inNumberPackets == 0) { return; } if (!_isContinue) { _isContinue = YES; } if (inPacketDescriptions == NULL) { NSLog(@&quot;inPacketDescriptions 是空&quot;); AudioStreamPacketDescription *descriptions = malloc(sizeof(AudioStreamPacketDescription)*inNumberBytes); UInt32 packSize = inNumberBytes/inNumberPackets; for (int i = 0; i &lt; inNumberPackets; i++) { UInt32 packeOffset = packSize * i; AudioStreamPacketDescription packetDes = inPacketDescriptions[i]; packetDes.mStartOffset = packeOffset; packetDes.mVariableFramesInPacket = 0;//自己算的，varibable设置为O if (i == inNumberPackets - 1) { packetDes.mDataByteSize = inNumberBytes - packeOffset; }else{ packetDes.mDataByteSize = packSize; } } inPacketDescriptions = descriptions; } NSMutableArray *packetAry = [NSMutableArray array]; for (int i = 0; i &lt; inNumberPackets; i++) { AudioStreamPacketDescription packetDes = inPacketDescriptions[i]; SInt64 startOffset = packetDes.mStartOffset; SInt64 dateSize = packetDes.mDataByteSize; NSData *data = [packetData subdataWithRange:NSMakeRange(startOffset, dateSize)]; EOCAudioStreamPacketModel *eocAudioPacketModel = [[EOCAudioStreamPacketModel alloc] initWithPacketData:data packetDescription:packetDes]; [packetAry addObject:eocAudioPacketModel]; } // 数据解析完了，回调加入pool中 if (self.delege &amp;&amp; [self.delege respondsToSelector:@selector(eocAudioStreamParseForPackets:)]) { [self.delege eocAudioStreamParseForPackets:packetAry]; } } @end 创建数据池存储已经解析了的packet，每次存入固定大小个packet，取出某个size的data @implementation EOCAudioStreamPacketBuffersPool - (instancetype)init{ self = [super init]; if (self) { _packetBufferAry = [NSMutableArray new]; _bufferSize = 0; } return self; } // 入池子保存解析后的音频数据 - (void)enqueuePoolStreamPacketsAry:(NSArray*)packets{ for (int i = 0; i &lt; packets.count; i++) { [self enqueueStreamPacket:packets[i]]; } } - (void)enqueueStreamPacket:(EOCAudioStreamPacketModel *)steamPacketsModel{ [_packetBufferAry addObject:steamPacketsModel]; _bufferSize += steamPacketsModel.data.length; } // 出池子，给audioQueue读 3000 - (NSData*)dequeuePoolStreamPacketDataSize:(UInt32)dataSize packetCount:(UInt32*)packetCount audioStreamPacketDescription:(AudioStreamPacketDescription**)packetDescription{ if (dataSize &lt;= 0 || _packetBufferAry.count == 0) { return nil; } NSMutableData *streamData = [NSMutableData data]; // 首先计算包的数量 int32_t packetSize = dataSize; int32_t i; for (i = 0; i &lt; _packetBufferAry.count; i++) { EOCAudioStreamPacketModel *packetModel = _packetBufferAry[i]; packetSize -= packetModel.data.length; if (packetSize &lt; 0) { break; } } // 异常 UInt32 pCount = (i &gt;= _packetBufferAry.count)? (UInt32)_packetBufferAry.count:(i+1); *packetCount = (UInt32)pCount; // 提供内存空间 if (packetDescription != NULL) { *packetDescription = (AudioStreamPacketDescription*)malloc(sizeof(AudioStreamPacketDescription)*pCount); } for (int j = 0; j &lt; pCount; j++) { EOCAudioStreamPacketModel *packetModel = _packetBufferAry[j]; if (packetDescription != NULL) { AudioStreamPacketDescription desc = packetModel.packetDes; desc.mStartOffset = streamData.length; (*packetDescription)[j] = desc; } [streamData appendData:packetModel.data]; } //从池子中移除 [_packetBufferAry removeObjectsInRange:NSMakeRange(0, pCount)]; _bufferSize -= streamData.length; //NSLog(@&quot;pool总大小：%ld--减少了:%ld&quot;, _bufferSize, streamData.length); return streamData; } @end 创建读取器对pool中的packet读取，放入AudioQueueBuff中去播放，并设置播放完成后的回调 //播放完成Buff后的回调 static void EOCAudioQueueOutputCallback(void * __nullable inUserData, AudioQueueRef inAQ, AudioQueueBufferRef inBuffer) { EOCAudioQueueRead *queueRead = (__bridge EOCAudioQueueRead*)inUserData; [queueRead eocAudioQueueOutputCallback:inBuffer]; } @implementation EOCAudioQueueRead - (instancetype)init{ self = [super init]; if (self) { _condition = [[NSCondition alloc] init]; _bufferQueue = [NSMutableArray array]; _reuserBufferQueue = [NSMutableArray array]; [self _mutexInit]; } return self; } - (BOOL)createQueue:(AudioStreamBasicDescription)basicDescription bufferSize:(UInt32)bufferSize{ _baiseDescription = basicDescription; /// 可以配置回调runloop OSStatus status = AudioQueueNewOutput(&amp;basicDescription, EOCAudioQueueOutputCallback, (__bridge void*)self, NULL, NULL, 0, &amp;_audioQueue); if (status != noErr) { NSLog(@&quot;AudioQueueNewOutput error&quot;); _audioQueue = nil; return NO; } status = AudioQueueStart(_audioQueue, NULL); if (status != noErr) { AudioQueueDispose(_audioQueue, YES); _audioQueue = nil; return NO; } UInt32 property = kAudioQueueHardwareCodecPolicy_PreferSoftware; AudioQueueSetProperty(_audioQueue, kAudioQueueHardwareCodecPolicy_PreferSoftware, &amp;property, sizeof(UInt32)); _bufferSize = bufferSize; if (_bufferQueue.count == 0) { for (int i = 0; i &lt; EOCNumAQBufs; i++) { AudioQueueBufferRef buffer; status = AudioQueueAllocateBuffer(_audioQueue, bufferSize, &amp;buffer); EOCAudioQueueReadModel *queueReadModel = [[EOCAudioQueueReadModel alloc] init]; queueReadModel.buffer = buffer; [_bufferQueue addObject:queueReadModel]; [_reuserBufferQueue addObject:queueReadModel]; } } return YES; } //播放等待，当没有空余的buff来装数据时，设置等待，当读完某个buff后，会将buff清空来装载新的数据，注意锁的应用 - (BOOL)playerAudioQueue:(NSData*)audioData numPackets:(UInt32)numPackets packetDescription:(AudioStreamPacketDescription*)packetDescs{ if (_reuserBufferQueue.count == 0) { [self _mutexWait]; } EOCAudioQueueReadModel *queueReadModel = [_reuserBufferQueue firstObject]; [_reuserBufferQueue removeObject:queueReadModel]; memcpy(queueReadModel.buffer-&gt;mAudioData, [audioData bytes], audioData.length); queueReadModel.buffer-&gt;mAudioDataByteSize = (UInt32)audioData.length; OSStatus status = AudioQueueEnqueueBuffer(_audioQueue, queueReadModel.buffer, numPackets, packetDescs); if (status != noErr) { NSLog(@&quot;AudioQueueEnqueueBuffer error&quot;); return NO; }else{ if (_reuserBufferQueue.count == 0) { if (!_started &amp;&amp; ![self _start]) { return NO; } } } return YES; } - (void)eocAudioQueueOutputCallback:(AudioQueueBufferRef)inBuffer{ for (int i = 0; i &lt; _bufferQueue.count; i++) { EOCAudioQueueReadModel *readModel = _bufferQueue[i]; if (readModel.buffer == inBuffer) { // 重新利用 [_reuserBufferQueue addObject:readModel]; break; } } // 有新的可以利用了 [self _mutexSignal]; // [_condition signal]; // NSLog(@&quot;signal~&quot;); } - (BOOL)_start{ OSStatus status = AudioQueueStart(_audioQueue, NULL); _started = status == noErr; return _started; } - (BOOL)pause{ // 马上停止／读完缓存再停止 AudioQueueStop(_audioQueue, YES); AudioQueuePause(_audioQueue); return YES; } - (void)_mutexInit{ pthread_mutex_init(&amp;_mutex, NULL); pthread_cond_init(&amp;_cond, NULL); } - (void)_mutexDestory { pthread_mutex_destroy(&amp;_mutex); pthread_cond_destroy(&amp;_cond); } - (void)_mutexWait{ pthread_mutex_lock(&amp;_mutex); //NSLog(@&quot;我在等待&quot;); pthread_cond_wait(&amp;_cond, &amp;_mutex); pthread_mutex_unlock(&amp;_mutex); } - (void)_mutexSignal { pthread_mutex_lock(&amp;_mutex); // NSLog(@&quot;不用等待了&quot;); pthread_cond_signal(&amp;_cond); pthread_mutex_unlock(&amp;_mutex); } @end 将本地数据改成网络音频数据@implementation EOCAudioStreamNet - (void)startLoadMusic:(NSString*)urlStr offset:(long)offset { if (urlStr.length == 0) return; if (_task) { [_task cancel]; } NSURL *musicUrl = [NSURL URLWithString:urlStr]; NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:musicUrl]; [request setHTTPMethod:@&quot;GET&quot;]; [request setCachePolicy:NSURLRequestReloadIgnoringLocalAndRemoteCacheData]; if (offset &gt; 0) { [request setValue:[NSString stringWithFormat:@&quot;bytes=%@-&quot;, @(offset)] forHTTPHeaderField:@&quot;Range&quot;]; } NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:nil]; _task = [session dataTaskWithRequest:request]; if (_task) { [_task resume]; } } // 每次读1000 - (NSData*)readDataOfLength:(int)length{ NSData *backMusicData = nil; if (audioNetData.length - audioReadedData.length &gt;= length) { backMusicData = [audioNetData subdataWithRange:NSMakeRange(audioReadedData.length, length)]; }else{ // 数据不足length 读取数据阻塞，等网络下载到足够的数据时再解锁读取 [self waitNetData]; } [audioReadedData appendData:backMusicData]; return backMusicData; } - (void)_mutexInit{ pthread_mutex_init(&amp;_mutex, NULL); pthread_cond_init(&amp;_cond, NULL); } - (void)waitNetData{ NSLog(@&quot;waitNetData&quot;); pthread_mutex_lock(&amp;_mutex); pthread_cond_wait(&amp;_cond, &amp;_mutex); pthread_mutex_unlock(&amp;_mutex); } - (void)signalEnughtData{ NSLog(@&quot;数据足了&quot;); pthread_mutex_lock(&amp;_mutex); pthread_cond_signal(&amp;_cond); pthread_mutex_unlock(&amp;_mutex); } - (void)mutexDestory{ pthread_mutex_destroy(&amp;_mutex); pthread_cond_destroy(&amp;_cond); } #pragma mark - NSURLSession Delegate - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler{ completionHandler(NSURLSessionResponseAllow); audioNetData = [NSMutableData data]; audioReadedData = [NSMutableData data]; if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(netHandleDataWithResponse:)]) { NSHTTPURLResponse *httpRespon = (NSHTTPURLResponse*)response; [self.delegate netHandleDataWithResponse:httpRespon.allHeaderFields]; } } - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data{ [audioNetData appendData:data]; [self signalEnughtData]; } - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error{ _isFinish = YES; } - (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session{ } @end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>音频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YYImage框架解析]]></title>
    <url>%2F2018%2F03%2F30%2FYYImage%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[目前 iOS 原生支持的格式有：JPEG、JPEG2000、PNG、GIF、BMP、ICO、TIFF、PICT，自 iOS 8.0 起，ImageIO 又加入了 APNG、SVG、RAW 格式的支持。在上层，开发者可以直接调用 ImageIO 对上面这些图片格式进行编码和解码。对于动图来说，开发者可以解码动画 GIF 和 APNG、可以编码动画 GIF。 UIImage的底层是通过ImageIO库实现的，ImageIO库的.h头如下： //ImageIO的基本库 #include &lt;ImageIO/ImageIOBase.h&gt; //负责读取数据 #include &lt;ImageIO/CGImageSource.h&gt; //负责写入数据 #include &lt;ImageIO/CGImageDestination.h&gt; //图片属性 #include &lt;ImageIO/CGImageProperties.h&gt; //图片元数据 #include &lt;ImageIO/CGImageMetadata.h&gt; 打印ImageIO框架所支持的可读取的图片格式和支持写入的图片格式 - (void)logImageType { CFArrayRef sourceArr = CGImageSourceCopyTypeIdentifiers(); CFShow(sourceArr); CFArrayRef destinationArr = CGImageDestinationCopyTypeIdentifiers(); CFShow(destinationArr); } //&quot;public.jpeg&quot;, &quot;public.png&quot;, &quot;com.compuserve.gif&quot;, &quot;com.canon.tif-raw-image&quot;, &quot;com.adobe.raw-image&quot;, &quot;com.dxo.raw-image&quot;,等 //&quot;public.jpeg&quot;, &quot;public.png&quot;, &quot;com.compuserve.gif&quot;, &quot;public.tiff&quot;, &quot;public.jpeg-2000&quot;,等 获取图片信息, 这里颜色空间、颜色模型、色品、InterlaceType都得详细标注 //imageMetaData表示单个图片的信息，比较详细，imageData表示的是一个图片组的信息，没有那么详细 - (void)getImageInfo { NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;mew_interlaced&quot; ofType:@&quot;png&quot;]; NSData *data = [NSData dataWithContentsOfFile:path]; CGImageSourceRef source = CGImageSourceCreateWithData((__bridge CFDataRef)data, NULL); //CGImageSourceCopyProperties 用这个获取的是图片组的信息，没单个图片多, 有文件大小 CFDictionaryRef imageMetaData = CGImageSourceCopyPropertiesAtIndex(source, 0, NULL); CFDictionaryRef imageData = CGImageSourceCopyProperties(source, NULL); CFRelease(source); NSDictionary *metaDataInfo = CFBridgingRelease(imageData); NSLog(@&quot;%@&quot;, metaDataInfo); } 注意：写CoreFoundation代码时，如果包含了alloc/copy/create这三个关键字来生成一段内存空间，则必须自己手动用CFRelease来释放，其他的如GetValue等则不需要自己来手动释放。 _bridge_transfer:常用在将CF对象转换成OC对象时使用，将CF对象的所有权交给OC对象，此时ARC就能自动管理该内存：(作用同CFBridgingRelease())，其实相当于释放CF对象，同时生成一个OC对象 _bridge_ratain:与_bridge_transfer作用相反，常用在将OC对象转换成CF对象时，将OC对象的所有权交给CF对象来管理。相当于释放OC对象，同时生成一个CF对象 图片格式可以理解为一种压缩包，就像我们的文件压缩成zip一样，但是你要在屏幕上渲染，必然是需要解码的，解码方式有以下几种： - (UIImage *)customImage { NSString * path = [[NSBundle mainBundle] pathForResource:@&quot;mew_baseline&quot; ofType:@&quot;jpg&quot;]; NSData *data = [NSData dataWithContentsOfFile:path]; CFDataRef dataRef = (__bridge CFDataRef)data; CFStringRef myKeys[2]; CFTypeRef myValues[2]; //解码就缓存 myKeys[0] = kCGImageSourceShouldCache; myValues[0] = kCFBooleanFalse; myKeys[1] = kCGImageSourceShouldCacheImmediately; myValues[1] = kCFBooleanFalse; CFDictionaryRef options = CFDictionaryCreate(NULL, (const void **)myKeys, (const void **)myValues, 2, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks); CGImageSourceRef source = CGImageSourceCreateWithData(dataRef, options); CGImageRef imageRef = CGImageSourceCreateImageAtIndex(source, 0, options); UIImage *tmpImg = [UIImage imageWithCGImage:imageRef]; CFRelease(source); CGImageRelease(imageRef); CFRelease(options); return tmpImg; } - (UIImage *)customImageTwo { NSString * path = [[NSBundle mainBundle] pathForResource:@&quot;1&quot; ofType:@&quot;png&quot;]; NSData *data = [NSData dataWithContentsOfFile:path]; allImg = [UIImage imageWithData:data]; CGImageRef cgImage = allImg.CGImage; size_t width = CGImageGetWidth(cgImage); size_t height = CGImageGetHeight(cgImage); CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(cgImage) &amp; kCGBitmapAlphaInfoMask; BOOL hasAlpha = NO; if (alphaInfo == kCGImageAlphaPremultipliedLast || alphaInfo == kCGImageAlphaPremultipliedFirst || alphaInfo == kCGImageAlphaLast || alphaInfo == kCGImageAlphaFirst) { hasAlpha = YES; } CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host; bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst; if (!twoContext) { //字节对齐：bytePerRow：260，64字节整数倍来读取的，64字节的整数倍：bytePerRow*height twoContext = CGBitmapContextCreate(NULL, width, height, 8, 0, CGColorSpaceCreateDeviceRGB(), bitmapInfo); } CGContextDrawImage(twoContext, CGRectMake(0, 0, width, height), cgImage); CGImageRef newImage = CGBitmapContextCreateImage(twoContext); // CGContextClearRect(twoContext, CGRectMake(0, 0, width, height)); return [UIImage imageWithCGImage:newImage]; } - (UIImage *)customImageThree { NSString * path = [[NSBundle mainBundle] pathForResource:@&quot;1&quot; ofType:@&quot;png&quot;]; NSData *tmpData = [NSData dataWithContentsOfFile:path]; allImg = [UIImage imageWithData:tmpData]; CGImageRef imageRef = allImg.CGImage; CGColorSpaceRef space = CGImageGetColorSpace(imageRef); size_t bitsPerComponent = CGImageGetBitsPerComponent(imageRef); size_t bitsPerPixel = CGImageGetBitsPerPixel(imageRef); size_t bytesPerRow = CGImageGetBytesPerRow(imageRef); size_t width = CGImageGetWidth(imageRef); size_t height = CGImageGetHeight(imageRef); CGBitmapInfo bitmapInfo = CGImageGetBitmapInfo(imageRef); CGDataProviderRef dataProvider = CGImageGetDataProvider(imageRef); if (!dataProvider) return NULL; CFDataRef data = CGDataProviderCopyData(dataProvider); // decode if (!data) return NULL; CGDataProviderRef newProvider = CGDataProviderCreateWithCFData(data); CFRelease(data); if (!newProvider) return NULL; CGImageRef newImage = CGImageCreate(width, height, bitsPerComponent, bitsPerPixel, bytesPerRow, space, bitmapInfo, newProvider, NULL, false, kCGRenderingIntentDefault); CFRelease(newProvider); return [UIImage imageWithCGImage:newImage]; } imageWithContentsOfFile将图片显示在屏幕上的过程： 1. 假设我们使用 +imageWithContentsOfFile: 方法从磁盘中加载一张图片，这个时候的图片并没有解压缩； 2. 然后将生成的 UIImage 赋值给 UIImageView ； 3. 接着一个隐式的 CATransaction 捕获到了 UIImageView 图层树的变化； 4. 在主线程的下一个 run loop 到来时，Core Animation 提交了这个隐式的 transaction ，这个过程可能会对图片进行 copy 操作，而受图片是否字节对齐等因素的影响，这个 copy 操作可能会涉及以下部分或全部步骤： 5. 分配内存缓冲区用于管理文件 IO 和解压缩操作； 6. 将文件数据从磁盘读到内存中； 7. 将压缩的图片数据解码成未压缩的位图形式，这是一个非常耗时的 CPU 操作； 8. 最后 Core Animation 使用未压缩的位图数据渲染 UIImageView 的图层。 在上面的步骤中，我们提到了图片的解压缩是一个非常耗时的 CPU 操作，并且它默认是在主线程中执行的。 查看解码和未解码的数据源发现：iOS 对png进行了优化，对jpg未进行优化 UIImage的底层操作是ImageIO，经过验证可以得出如下结论 imageWithData:底层调用的是CGImageSourceCreateWithData(添加symbolic breakpoint，在symbol里添加CGImageSourceCreateWithData，如果调用CGImageSourceCreateWithData函数，则会自动调试) imageNamed:背后是调用的CGImageSourceCreateWithFile和CGImageSourceCreateImageAtIndex来获取到CGImageRef的（同样的图片只调用了一次，后面不会调用） 判断平台是大端还是小端：无论是32位还是64位，char都是1个字节 - (void)isBigEndianOrLittleEndian { unsigned int a, *p; p = &amp;a; a = 0;//*p = 0x00000000 *(char *)p = 0xff;//p[0] //大端的话，高位存储在低地址;小端，低位存于低地址 //所以，大端会是：0xff000000;小端是:0x000000ff//11111111 NSLog(@&quot;p%d&quot;, *p); //linux的大端和小端判断 static union { char c[4]; unsigned int mylong; } endian_test = {&apos;l&apos;, &apos;?&apos;, &apos;?&apos;, &apos;b&apos; }; NSLog(@&quot;%c&quot;, ((char)endian_test.mylong)); } YYImage应用： //YYImage支持GIF格式、APNG格式、WEBP格式 [self addImageWithName:@&quot;niconiconi&quot; text:@&quot;Animated GIF&quot;]; [self addImageWithName:@&quot;cube&quot; text:@&quot;Animated PNG (APNG)&quot;]; [self addImageWithName:@&quot;wall-e&quot; text:@&quot;Animated WebP&quot;]; - (void)addImageWithName:(NSString *)name text:(NSString *)text { YYImage *image = [YYImage imageNamed:name]; [self addImage:image size:CGSizeZero text:text]; } - (void)addImage:(UIImage *)image size:(CGSize)size text:(NSString *)text { YYAnimatedImageView *imageView = [[YYAnimatedImageView alloc] initWithImage:image]; if (size.width &gt; 0 &amp;&amp; size.height &gt; 0) imageView.size = size; imageView.centerX = self.view.width / 2; imageView.top = [(UIView *)[_scrollView.subviews lastObject] bottom] + 30; [_scrollView addSubview:imageView]; [YYImageExampleHelper addTapControlToAnimatedImageView:imageView]; [YYImageExampleHelper addPanControlToAnimatedImageView:imageView]; for (UIGestureRecognizer *g in imageView.gestureRecognizers) { g.delegate = self; } UILabel *imageLabel = [UILabel new]; imageLabel.backgroundColor = [UIColor clearColor]; imageLabel.frame = CGRectMake(0, 0, self.view.width, 20); imageLabel.top = imageView.bottom + 10; imageLabel.textAlignment = NSTextAlignmentCenter; imageLabel.text = text; [_scrollView addSubview:imageLabel]; _scrollView.contentSize = CGSizeMake(self.view.width, imageLabel.bottom + 20); } //YYImage支持Frame数组的图片(举例：表情动态切换包) - (void)addFrameImageWithText:(NSString *)text { NSString *basePath = [[NSBundle mainBundle].bundlePath stringByAppendingPathComponent:@&quot;EmoticonWeibo.bundle/com.sina.default&quot;]; NSMutableArray *paths = [NSMutableArray new]; [paths addObject:[basePath stringByAppendingPathComponent:@&quot;d_aini@3x.png&quot;]]; [paths addObject:[basePath stringByAppendingPathComponent:@&quot;d_baibai@3x.png&quot;]]; [paths addObject:[basePath stringByAppendingPathComponent:@&quot;d_chanzui@3x.png&quot;]]; [paths addObject:[basePath stringByAppendingPathComponent:@&quot;d_chijing@3x.png&quot;]]; [paths addObject:[basePath stringByAppendingPathComponent:@&quot;d_dahaqi@3x.png&quot;]]; [paths addObject:[basePath stringByAppendingPathComponent:@&quot;d_guzhang@3x.png&quot;]]; [paths addObject:[basePath stringByAppendingPathComponent:@&quot;d_haha@2x.png&quot;]]; [paths addObject:[basePath stringByAppendingPathComponent:@&quot;d_haixiu@3x.png&quot;]]; UIImage *image = [[YYFrameImage alloc] initWithImagePaths:paths oneFrameDuration:0.1 loopCount:0]; [self addImage:image size:CGSizeZero text:text]; } //YYImage支持表单形式的图片（举例：星星表单） - (void)addSpriteSheetImageWithText:(NSString *)text { NSString *path = [[NSBundle mainBundle].bundlePath stringByAppendingPathComponent:@&quot;ResourceTwitter.bundle/fav02l-sheet@2x.png&quot;]; UIImage *sheet = [[UIImage alloc] initWithData:[NSData dataWithContentsOfFile:path] scale:2]; NSMutableArray *contentRects = [NSMutableArray new]; NSMutableArray *durations = [NSMutableArray new]; // 8 * 12 sprites in a single sheet image CGSize size = CGSizeMake(sheet.size.width / 8, sheet.size.height / 12); for (int j = 0; j &lt; 12; j++) { for (int i = 0; i &lt; 8; i++) { CGRect rect; rect.size = size; rect.origin.x = sheet.size.width / 8 * i; rect.origin.y = sheet.size.height / 12 * j; [contentRects addObject:[NSValue valueWithCGRect:rect]]; [durations addObject:@(1 / 60.0)]; } } YYSpriteSheetImage *sprite; sprite = [[YYSpriteSheetImage alloc] initWithSpriteSheetImage:sheet contentRects:contentRects frameDurations:durations loopCount:0]; [self addImage:sprite size:size text:text]; } YYImage流程跟踪： //YYImage类 + (YYImage *)imageNamed:(NSString *)name { if (name.length == 0) return nil; if ([name hasSuffix:@&quot;/&quot;]) return nil; NSString *res = name.stringByDeletingPathExtension; NSString *ext = name.pathExtension; NSString *path = nil; CGFloat scale = 1; // If no extension, guess by system supported (same as UIImage). NSArray *exts = ext.length &gt; 0 ? @[ext] : @[@&quot;&quot;, @&quot;png&quot;, @&quot;jpeg&quot;, @&quot;jpg&quot;, @&quot;gif&quot;, @&quot;webp&quot;, @&quot;apng&quot;]; NSArray *scales = _NSBundlePreferredScales(); for (int s = 0; s &lt; scales.count; s++) { scale = ((NSNumber *)scales[s]).floatValue; NSString *scaledName = _NSStringByAppendingNameScale(res, scale); for (NSString *e in exts) { path = [[NSBundle mainBundle] pathForResource:scaledName ofType:e]; if (path) break; } if (path) break; } if (path.length == 0) return nil; NSData *data = [NSData dataWithContentsOfFile:path]; if (data.length == 0) return nil; return [[self alloc] initWithData:data scale:scale]; } - (instancetype)initWithData:(NSData *)data scale:(CGFloat)scale { if (data.length == 0) return nil; if (scale &lt;= 0) scale = [UIScreen mainScreen].scale; _preloadedLock = dispatch_semaphore_create(1); @autoreleasepool { //用来获取图片数组里每个图片的属性：每张图片停留的时间等其他属性、循环次数、图片方向、图片宽高 YYImageDecoder *decoder = [YYImageDecoder decoderWithData:data scale:scale]; //图片解压 YYImageFrame *frame = [decoder frameAtIndex:0 decodeForDisplay:YES]; UIImage *image = frame.image; if (!image) return nil; self = [self initWithCGImage:image.CGImage scale:decoder.scale orientation:image.imageOrientation]; if (!self) return nil; _animatedImageType = decoder.type; if (decoder.frameCount &gt; 1) { _decoder = decoder; _bytesPerFrame = CGImageGetBytesPerRow(image.CGImage) * CGImageGetHeight(image.CGImage); _animatedImageMemorySize = _bytesPerFrame * decoder.frameCount; } self.yy_isDecodedForDisplay = YES; } return self; } //YYImageCoder类 + (instancetype)decoderWithData:(NSData *)data scale:(CGFloat)scale { if (!data) return nil; YYImageDecoder *decoder = [[YYImageDecoder alloc] initWithScale:scale]; [decoder updateData:data final:YES]; if (decoder.frameCount == 0) return nil; return decoder; } - (BOOL)updateData:(NSData *)data final:(BOOL)final { BOOL result = NO; pthread_mutex_lock(&amp;_lock); result = [self _updateData:data final:final]; pthread_mutex_unlock(&amp;_lock); return result; } - (BOOL)_updateData:(NSData *)data final:(BOOL)final { if (_finalized) return NO; if (data.length &lt; _data.length) return NO; _finalized = final; _data = data; YYImageType type = YYImageDetectType((__bridge CFDataRef)data); if (_sourceTypeDetected) { if (_type != type) { return NO; } else { [self _updateSource]; } } else { if (_data.length &gt; 16) { _type = type; _sourceTypeDetected = YES; [self _updateSource]; } } return YES; } - (void)_updateSource { switch (_type) { case YYImageTypeWebP: { [self _updateSourceWebP]; } break; case YYImageTypePNG: { [self _updateSourceAPNG]; } break; default: { [self _updateSourceImageIO]; } break; } } //YYImageCoder解码 - (YYImageFrame *)frameAtIndex:(NSUInteger)index decodeForDisplay:(BOOL)decodeForDisplay { YYImageFrame *result = nil; pthread_mutex_lock(&amp;_lock); //真正的解码，很长的一段代码 result = [self _frameAtIndex:index decodeForDisplay:decodeForDisplay]; pthread_mutex_unlock(&amp;_lock); return result; }]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>iOS</tag>
        <tag>YYImage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络及框架]]></title>
    <url>%2F2018%2F02%2F23%2F%E7%BD%91%E7%BB%9C%E5%8F%8A%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[断点下载原理及文件上传 断点下载方式 1. 断点下载（URL） 2. 判断过渡区(中转站tmp)是否存在该请求的网络数据? 3. 过度区有相关数据:计算已经下载了多少数据,配置请求头再发起网络请求 4. 过度区没有相关数据:直接发起网络请求 5. 数据下载中ing:网络数据存过渡区(中转站Tmp)由于网络问题等，有可能，下载过程中被断开 6. 数据下载完成：网络数据从过渡区(tmp)到目标区(Document) #define ImageURL @&quot;http://www.8pmedu.com/files/system/2017/06-13/225247f9edb5180454.jpg&quot; @interface BreakLoadImageVC ()&lt;NSURLSessionDelegate, NSURLSessionDataDelegate&gt; { NSString *filePathTmp; NSString *filePathDocument; NSOutputStream *outputStream; } @end @implementation BreakLoadImageVC - (void)viewDidLoad { [super viewDidLoad]; self.title = @&quot;断点下载&quot;; //ImageURL 通过md5 生成一个唯一文件名 AF NSString *fileName = [[ImageURL componentsSeparatedByString:@&quot;/&quot;] lastObject]; NSString *filePath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]; NSLog(@&quot;%@&quot;, filePath); filePathDocument = [filePath stringByAppendingPathComponent:fileName]; filePathTmp = [NSTemporaryDirectory() stringByAppendingPathComponent:fileName]; } - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event{ [self netLoadImage]; } - (void)netLoadImage{ outputStream = [[NSOutputStream alloc] initToFileAtPath:filePathTmp append:YES]; [outputStream open]; NSURL *url = [NSURL URLWithString:ImageURL]; NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url]; NSDictionary *fileInfo = [[NSFileManager defaultManager] attributesOfItemAtPath:filePathTmp error:nil]; long filesize = [[fileInfo objectForKey:NSFileSize] longValue]; [request setHTTPMethod:@&quot;GET&quot;]; [request setValue:[NSString stringWithFormat:@&quot;bytes=%ld-&quot;, filesize] forHTTPHeaderField:@&quot;Range&quot;]; NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration ephemeralSessionConfiguration] delegate:self delegateQueue:nil]; NSURLSessionTask *task = [session dataTaskWithRequest:request]; [task resume]; } //1 响应头 这次网络数据的属性（下载的总数据大小 content-Length, Content-Type） - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler{ // 获取文件总长度 completionHandler(NSURLSessionResponseAllow); } // 2 数据接收 - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data{ // 把数据图片数据存储到 tmp文件下面（中转站） // NSMutableData *fileData = [NSMutableData dataWithContentsOfFile:filePathTmp]; // if (!fileData) { // fileData = [NSMutableData data]; // } // [fileData appendData:data]; // [fileData writeToFile:filePathTmp atomically:YES]; // 后去当前已下载的数据 长度 [outputStream write:[data bytes] maxLength:data.length]; } // 3 完成 - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error{ // 把tmp文件的图片数据移动document下面（目标路径） [outputStream close]; [[NSFileManager defaultManager] moveItemAtPath:filePathTmp toPath:filePathDocument error:nil]; } @end AF方式下载 //所以AF框架不能做断点下载，因为断点下载需要一个中转站文件我们才能知道断点下载时的Range，AF采用的NSURLSessionDownloadTask只给出了下载完成后的目标地址，没有给出中转文件的地址，我们如果需要中转文件地址，则必须自己用NSURLSessionTask来做 #define ImageURL @&quot;http://www.8pmedu.com/files/system/2017/06-13/225247f9edb5180454.jpg&quot; @interface AFFileLoadVC ()&lt;NSURLSessionDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate&gt;{ NSString *filePathTmp; NSString *filePathDocument; NSOutputStream *outputStream; } @end @implementation AFFileLoadVC - (void)viewDidLoad { [super viewDidLoad]; self.title = @&quot;断点下载&quot;; //ImageURL 通过md5 生成一个唯一文件名 AF NSString *fileName = [[ImageURL componentsSeparatedByString:@&quot;/&quot;] lastObject]; NSString *filePath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]; NSLog(@&quot;%@&quot;, filePath); filePathDocument = [filePath stringByAppendingPathComponent:fileName]; } - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event{ [self netLoadAFImage]; } - (void)netLoadAFImage{ NSURL *url = [NSURL URLWithString:ImageURL]; NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url]; [request setHTTPMethod:@&quot;GET&quot;]; NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration ephemeralSessionConfiguration] delegate:self delegateQueue:nil]; NSURLSessionDownloadTask *task = [session downloadTaskWithRequest:request]; [task resume]; } //1 响应头 这次网络数据的属性（下载的总数据大小 content-Length, Content-Type） - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler{ completionHandler(NSURLSessionResponseAllow); } // 2下载过程 下载的进度 接收数据回掉 - (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite{ // bytesWritten 当前包收到的数据 totalBytesWritten已经接受的数据的， totalBytesExpectedToWrite图片数据大小 NSLog(@&quot;URLSession:%ld-%ld-%ld&quot;, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite); } // 3文件下载完成 需要对这个NSURL文件进行拷贝 - (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location{ NSLog(@&quot;didFinishDownloadingToURL:%@&quot;, location); [[NSFileManager defaultManager] moveItemAtURL:location toURL:[NSURL fileURLWithPath:filePathDocument] error:nil]; } // 4网络任务结束 - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error{ NSLog(@&quot;didCompleteWithError:%@&quot;, error); } @end 上传文件 /* 1 请求头 boundary（分界线） ****** 2 请求体（body） 开始分界线 属性数据 图片数据 结束分界线 */ #define UpdateImageURL @&quot;http://www.8pmedu.com/themes/jianmo/img/upload.php&quot; @implementation UpdateFileVC - (void)viewDidLoad { [super viewDidLoad]; self.title = @&quot;文件上传&quot;; } - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event{ [self netLoadImage]; } - (void)netLoadImage{ NSURL *url = [NSURL URLWithString:UpdateImageURL]; NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url]; [request setHTTPMethod:@&quot;POST&quot;]; NSString *bounary = @&quot;******&quot;; // 分界线 [request setValue:[NSString stringWithFormat:@&quot;multipart/form-data;charset=utf-8;boundary=%@&quot;, bounary] forHTTPHeaderField:@&quot;Content-Type&quot;]; NSMutableData *bodyData = [NSMutableData data]; // 1 开始边界 \n 为结束标识 NSString *beginBoundary = [NSString stringWithFormat:@&quot;--%@\r\n&quot;, bounary]; [bodyData appendData:[beginBoundary dataUsingEncoding:NSUTF8StringEncoding]]; // 2 属性 name和服务器的name要匹配,相当于服务获取图片的key // filename 服务器图片文件命名 NSString *serverFileKey = @&quot;image&quot;; NSString *serverFileName = @&quot;eoc10121222111.png&quot;; NSString *serverContentTypes = @&quot;image/png&quot;; NSMutableString *string = [NSMutableString string]; [string appendFormat:@&quot;Content-Disposition:form-data; name=\&quot;%@\&quot;; filename=\&quot;%@\&quot; \r\n&quot;,serverFileKey, serverFileName]; [string appendFormat:@&quot;Content-Type: %@\r\n&quot;, serverContentTypes]; [string appendFormat:@&quot;\r\n&quot;]; [bodyData appendData:[string dataUsingEncoding:NSUTF8StringEncoding]]; // 3文件数据 UIImage *image = [UIImage imageNamed:@&quot;1.png&quot;]; NSData *imageData = UIImagePNGRepresentation(image); [bodyData appendData:imageData]; // 4结束边界 NSString *endBoundary = [NSString stringWithFormat:@&quot;\r\n--%@&quot;, bounary]; [bodyData appendData:[endBoundary dataUsingEncoding:NSUTF8StringEncoding]]; [request setHTTPBody:bodyData]; NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration ephemeralSessionConfiguration] delegate:self delegateQueue:nil]; NSURLSessionTask *task = [session dataTaskWithRequest:request]; [task resume]; } //1 响应头 这次网络数据的属性（下载的总数据大小 content-Length, Content-Type） - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler{ completionHandler(NSURLSessionResponseAllow); } // 2 进度 - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSent totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend{ // 每次发送 32kb （32768）数据，bytesSent本次发送，totalBytesSent总共已发送，totalBytesExpectedToSend总共需发送，即文件大小 NSLog(@&quot;didSendBodyData:: %ld--%ld--%ld&quot;, bytesSent, totalBytesSent, totalBytesExpectedToSend); } // 3 数据接收 - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data{ NSDictionary *infoDict = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingAllowFragments error:nil]; NSLog(@&quot;didReceiveData::%@&quot;, infoDict); } // 4 完成 - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error{ NSLog(@&quot;didCompleteWithError:%@&quot;, error); } @end 流上传 - (void)netLoadDelegate { NSString *bodyStr = @&quot;versions_id=1&amp;system_type=1&quot;; NSURL *url = [NSURL URLWithString:URLPath]; //请求体 NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url]; [request setHTTPMethod:@&quot;POST&quot;]; [request setHTTPBody:[bodyStr dataUsingEncoding:NSUTF8StringEncoding]]; [request setValue:@&quot;en;q=1&quot; forHTTPHeaderField:@&quot;Accept-Language&quot;]; [request setValue:@&quot;application/x-www-form-urlencoded&quot; forHTTPHeaderField:@&quot;Content-Type&quot;]; [request setValue:@&quot;LoadUpdateNet/1.0 (iPhone; iOS 11.1; Scale/3.00)&quot; forHTTPHeaderField:@&quot;User-Agent&quot;]; /* AF写了一个 NSInputStream的子类 并且重写了 - (NSInteger)read:(uint8_t *)buffer maxLength:(NSUInteger)len 这个方法。 在这个重写的方法里面进行表单的拼接 之前会处理 表单的属性保存，如边界，name，value等字段 */ NSInputStream *inputsteam = [[NSInputStream alloc] initWithData:[bodyStr dataUsingEncoding:NSUTF8StringEncoding]]; // [request setHTTPBodyStream:inputsteam]; // 请求的时候，系统底层会对NSInputStream执行read操作 NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:nil]; NSURLSessionTask *task = [session dataTaskWithRequest:request]; [task resume]; } - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSent totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend { NSLog(@&quot;totalBytesExpectedToSend&quot;); } //NSURLConnection - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler { NSLog(@&quot;NSURLSessionResponseDisposition&quot;); completionHandler(NSURLSessionResponseAllow); } - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data { NSDictionary *infoDict = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingAllowFragments error:nil]; NSLog(@&quot;%@&quot;, infoDict); } - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error { NSLog(@&quot;==%@&quot;, error); } AF框架分析 AF简单流程跟踪 //调用 - (void)netLoad{ AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; NSMutableDictionary *params = [NSMutableDictionary dictionary]; [params setObject:@&quot;1&quot; forKey:@&quot;versions_id&quot;]; [params setObject:@&quot;1&quot; forKey:@&quot;system_type&quot;]; [manager GET:URLPath parameters:params progress:^(NSProgress * _Nonnull uploadProgress) { } success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { NSLog(@&quot;%@&quot;, responseObject); } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { }]; } //AFHTTPSessionManager初始化，其父类为AFURLSessionManager - (instancetype)initWithBaseURL:(NSURL *)url sessionConfiguration:(NSURLSessionConfiguration *)configuration { self = [super initWithSessionConfiguration:configuration]; if (!self) { return nil; } // Ensure terminal slash for baseURL path, so that NSURL +URLWithString:relativeToURL: works as expected if ([[url path] length] &gt; 0 &amp;&amp; ![[url absoluteString] hasSuffix:@&quot;/&quot;]) { url = [url URLByAppendingPathComponent:@&quot;&quot;]; } self.baseURL = url; self.requestSerializer = [AFHTTPRequestSerializer serializer]; self.responseSerializer = [AFJSONResponseSerializer serializer]; return self; } //AFURLSessionManager初始化 - (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration { self = [super init]; if (!self) { return nil; } if (!configuration) { configuration = [NSURLSessionConfiguration defaultSessionConfiguration]; } self.sessionConfiguration = configuration; self.operationQueue = [[NSOperationQueue alloc] init]; self.operationQueue.maxConcurrentOperationCount = 1; self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue]; self.responseSerializer = [AFJSONResponseSerializer serializer]; self.securityPolicy = [AFSecurityPolicy defaultPolicy]; #if !TARGET_OS_WATCH self.reachabilityManager = [AFNetworkReachabilityManager sharedManager]; #endif self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init]; self.lock = [[NSLock alloc] init]; self.lock.name = AFURLSessionManagerLockName; [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) { for (NSURLSessionDataTask *task in dataTasks) { [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil]; } for (NSURLSessionUploadTask *uploadTask in uploadTasks) { [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil]; } for (NSURLSessionDownloadTask *downloadTask in downloadTasks) { [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil]; } }]; return self; } //AFHTTPSessionManager Get方法调用，组装dataTask并执行 - (NSURLSessionDataTask *)GET:(NSString *)URLString parameters:(id)parameters progress:(void (^)(NSProgress * _Nonnull))downloadProgress success:(void (^)(NSURLSessionDataTask * _Nonnull, id _Nullable))success failure:(void (^)(NSURLSessionDataTask * _Nullable, NSError * _Nonnull))failure { NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@&quot;GET&quot; URLString:URLString parameters:parameters uploadProgress:nil downloadProgress:downloadProgress success:success failure:failure]; [dataTask resume]; return dataTask; } //AFHTTPSessionManager组装dataTask：根据HTTPMothod，路径等先组装request，然后将request传入父类真正组装dataTask - (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method URLString:(NSString *)URLString parameters:(id)parameters uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress success:(void (^)(NSURLSessionDataTask *, id))success failure:(void (^)(NSURLSessionDataTask *, NSError *))failure { NSError *serializationError = nil; NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError]; if (serializationError) { if (failure) { dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^{ failure(nil, serializationError); }); } return nil; } __block NSURLSessionDataTask *dataTask = nil; dataTask = [self dataTaskWithRequest:request uploadProgress:uploadProgress downloadProgress:downloadProgress completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) { if (error) { if (failure) { failure(dataTask, error); } } else { if (success) { success(dataTask, responseObject); } } }]; return dataTask; } //AFURLSessionManager中组装dataTask并将block保留来实现回调 - (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler { __block NSURLSessionDataTask *dataTask = nil; url_session_manager_create_task_safely(^{ dataTask = [self.session dataTaskWithRequest:request]; }); [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler]; return dataTask; } - (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler { AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:dataTask]; delegate.manager = self; delegate.completionHandler = completionHandler; dataTask.taskDescription = self.taskDescriptionForSessionTasks; [self setDelegate:delegate forTask:dataTask]; delegate.uploadProgressBlock = uploadProgressBlock; delegate.downloadProgressBlock = downloadProgressBlock; } - (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate forTask:(NSURLSessionTask *)task { NSParameterAssert(task); NSParameterAssert(delegate); [self.lock lock]; self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate; [self addNotificationObserverForTask:task]; [self.lock unlock]; } 详解组装request请求 // 上传头像 - (void)uploadUserHeadImage:(UIImage *)image { // 获得网络manager AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; manager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@&quot;application/json&quot;, @&quot;text/json&quot;, @&quot;text/javascript&quot;,@&quot;text/html&quot;, nil]; NSMutableDictionary *params = [NSMutableDictionary dictionary]; [params setObject:@&quot;value1&quot; forKey:@&quot;key1&quot;]; [params setObject:@&quot;value2&quot; forKey:@&quot;key2&quot;]; [manager POST:@&quot;http://www.8pmedu.com/themes/jianmo/img/upload.php&quot; parameters:params constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; _Nonnull formData) { // 获取图片数据 NSData *fileData = UIImageJPEGRepresentation(image, 1.0); // 设置上传图片的名字 NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; formatter.dateFormat = @&quot;yyyyMMddHHmmss&quot;; NSString *str = [formatter stringFromDate:[NSDate date]]; NSString *fileName = [NSString stringWithFormat:@&quot;%@.png&quot;, str]; [formData appendPartWithFileData:fileData name:@&quot;image&quot; fileName:fileName mimeType:@&quot;image/png&quot;]; } progress:^(NSProgress * _Nonnull uploadProgress) { NSLog(@&quot;uploadProgress:::%@&quot;, uploadProgress); } success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { // 返回结果 NSLog(@&quot;----%@&quot;, responseObject[@&quot;datas&quot;]); } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { NSLog(@&quot;+++++%@&quot;, error); }]; } - (NSURLSessionDataTask *)POST:(NSString *)URLString parameters:(id)parameters constructingBodyWithBlock:(void (^)(id &lt;AFMultipartFormData&gt; formData))block progress:(nullable void (^)(NSProgress * _Nonnull))uploadProgress success:(void (^)(NSURLSessionDataTask *task, id responseObject))success failure:(void (^)(NSURLSessionDataTask *task, NSError *error))failure { /* 分两块 一个AFURLRequestSerialization 一个 AFURLSessionManager */ // AFURLRequestSerialization 对 请求体body处理 请求头处理 NSError *serializationError = nil; // 主要是处理表单，主要是处理request body /* 表单拼接之前，对所有的相关数据进行保存 拼接 read步骤（重写了 inputstream的read方法，在这个步骤统一拼接） 保存是保存在相关对象里面（） */ NSMutableURLRequest *request = [self.requestSerializer multipartFormRequestWithMethod:@&quot;POST&quot; URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters constructingBodyWithBlock:block error:&amp;serializationError]; if (serializationError) { if (failure) { dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^{ failure(nil, serializationError); }); } return nil; } //AFURLSessionManager 涉及到NSURLSession系统的代理 __block NSURLSessionDataTask *task = [self uploadTaskWithStreamedRequest:request progress:uploadProgress completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) { if (error) { if (failure) { failure(task, error); } } else { if (success) { success(task, responseObject); } } }]; [task resume]; return task; } //AFURLRequestSerialization类 - (NSMutableURLRequest *)multipartFormRequestWithMethod:(NSString *)method URLString:(NSString *)URLString parameters:(NSDictionary *)parameters constructingBodyWithBlock:(void (^)(id &lt;AFMultipartFormData&gt; formData))block error:(NSError *__autoreleasing *)error { NSParameterAssert(method); NSParameterAssert(![method isEqualToString:@&quot;GET&quot;] &amp;&amp; ![method isEqualToString:@&quot;HEAD&quot;]); // 1 生成一个mutableRequest 配置了method 和 url NSMutableURLRequest *mutableRequest = [self requestWithMethod:method URLString:URLString parameters:nil error:error]; // AFStreamingMultipartFormData 处理表单的对象 __block AFStreamingMultipartFormData *formData = [[AFStreamingMultipartFormData alloc] initWithURLRequest:mutableRequest stringEncoding:NSUTF8StringEncoding]; // 2 处理表单 if (parameters) { // 2.1这个主要是处理非文件数据的表单 for (AFQueryStringPair *pair in AFQueryStringPairsFromDictionary(parameters)) { // 把字典转化成 AFQueryStringPair数组对象，一个key和value对应一个AFQueryStringPair对象， 因为一个参数对应一个小表单（边界+属性+值） NSData *data = nil; if ([pair.value isKindOfClass:[NSData class]]) { data = pair.value; } else if ([pair.value isEqual:[NSNull null]]) { data = [NSData data]; } else { data = [[pair.value description] dataUsingEncoding:self.stringEncoding]; } // AFStreamingMultipartFormData 对象 处理表单 if (data) { // 主要是保存 表单的属性 在read的时候拼接 name：key1 data：value1 [formData appendPartWithFormData:data name:[pair.field description]]; } } } if (block) { // 2.2这个主要是处理文件数据的表单 block在外边赋值处理 block(formData); } // 配置请求头和请求体 return [formData requestByFinalizingMultipartFormData]; } //AFStreamingMultipartFormData类 - (NSMutableURLRequest *)requestByFinalizingMultipartFormData { if ([self.bodyStream isEmpty]) { return self.request; } // Reset the initial and final boundaries to ensure correct Content-Length [self.bodyStream setInitialAndFinalBoundaries]; [self.request setHTTPBodyStream:self.bodyStream]; [self.request setValue:[NSString stringWithFormat:@&quot;multipart/form-data; boundary=%@&quot;, self.boundary] forHTTPHeaderField:@&quot;Content-Type&quot;]; [self.request setValue:[NSString stringWithFormat:@&quot;%llu&quot;, [self.bodyStream contentLength]] forHTTPHeaderField:@&quot;Content-Length&quot;]; return self.request; } HTTPS及AFNetworkingHTTPS = HTTP + 加密 + 认证 + 完整性保护，其实HTTPS是身披SSL外壳的HTTP 常用加密方法： 共享密钥加密（也称为对称加密）：共享密钥加密就是加密和解密通用一个密钥，加密和解密是一个逆向的过程。 优点是加密解密速度快，缺点是一旦密钥泄露，别人也能解密数据。 公开密钥加密（也称非对称加密），恰恰能解决共享密钥加密的困难， 其过程是这样的： 加密用公钥，解密用私钥，公钥加密后，必须要私钥 才能解密 发文方使用对方的公开密钥进行加密 接受方在使用自己的私有密钥进行解密 就算知道了结果和公钥，破解出被机密的数据是非常难的 HTTPS采用混合加密机制：共享密钥加密和公开密钥加密两者并用 HTTPS工作原理 HTTPS工作在客户端和服务器端之间。客户端和服务器本身都会自带一些加密的算法，用于双方协商加密的选择项。 客户端首先会将自己支持的加密算法，打个包告诉服务器端。 服务器端从客户端发来的加密算法中，选出一组加密算法和HASH算法（注，HASH也属于加密），并将自己的身份信息以证书的形式发回给客户端。而证书中包含了网站的地址，加密用的公钥，以及证书的颁发机构等。这里，服务器就将自己用来加密用的公钥一同发给客户端，而私钥则服务器保存着，用户解密客户端加密过后的内容。 客户端收到了服务器发来的数据包后，会做这么几件事情： 验证一下证书是否合法。一般来说，证书是用来标示一个站点是否合法的标志。如果说该证书由权威的第三方颁发和签名的，则说明证书合法。 如果证书合法，或者客户端接受和信任了不合法的证书，则客户端就会随机产生一串序列号，使用服务器发来的公钥进行加密。这时候，一条返回的消息就基本就绪。 最后使用服务器挑选的HASH算法，将刚才的消息使用刚才的随机数进行加密，生成相应的消息校验值，与刚才的消息一同发还给服务器。 服务器接受到客户端发来的消息后，会做这么几件事情： 使用私钥解密上面第3.2中公钥加密的消息，得到客户端产生的随机序列号。 使用该随机序列号，对该消息进行加密，验证的到的校验值是否与客户端发来的一致。如果一致则说明消息未被篡改，可以信任。 最后，使用该随机序列号，加上之前第2步中选择的加密算法，加密一段握手消息，发还给客户端。同时HASH值也带上。 客户端收到服务器端的消息后，接着做这么几件事情： 计算HASH值是否与发的消息一致 检查消息是否为握手消息 握手结束后，客户端和服务器端使用握手阶段产生的随机数以及挑选出来的算法进行对称加解密的传输。 总结：随机序列号–(公钥加密)–消息–(随机序列号加密)–加密消息–(HASH加密)–消息校验值，客户端给服务端发送的是消息和消息校验值 为什么不直接全程使用非对称加密算法进行数据传输？这个问题的答案是因为非对称算法的效率对比起对称算法来说，要低得多得多；因此往往只用在HTTPS的握手阶段。 AFNetworking //UIViewController类 //// NSURLSessionDelegate - (void)URLSession:(NSURLSession *)session didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler { // 验证 NSURLCredential *credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust]; completionHandler(NSURLSessionAuthChallengeUseCredential, credential); } //AFURLSessionManager类 /* 两种方式： 本地证书验证 （需要验证本地证书） 1 验证服务器 2 本地证书生成NSURLCredential对象，代理回掉block来处理相关事务 无本地证书验证NSURLAuthenticationMethodServerTrust（直接信任服务器） 1 验证服务器 2 直接通过服务器传过来的challenge 生成NSURLCredential对象(这个对象关联了客户端https相关信息)，代理回掉block来处理相关事务 */ - (void)URLSession:(NSURLSession *)session didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler { NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling; __block NSURLCredential *credential = nil; // 两种方式 1 外部处理NSURLSessionAuthChallengeDisposition 2 AF内部默认处理它 if (self.sessionDidReceiveAuthenticationChallenge) {// 1外部（你自己处理） disposition = self.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential); } else {// 2内部(AF处理) // challenge 服务器过来的，方式（NSURLAuthenticationMethodServerTrust），本地验证 if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) { if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) { // 返回YES，server是没问题的 credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];// 生成一个信任的NSURLCredential对象 if (credential) { //Use the specified credential disposition = NSURLSessionAuthChallengeUseCredential; } else { disposition = NSURLSessionAuthChallengePerformDefaultHandling; } } else { disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge; } } else { disposition = NSURLSessionAuthChallengePerformDefaultHandling; } } if (completionHandler) { completionHandler(disposition, credential); } } //AFSecurityPolicy类 /* AFSSLPinningModeNone： 这个模式表示不做SSL pinning，只跟浏览器一样在系统的信任机构列表里验证服务端返回的证书。若证书是信任机构签发的就会通过，若是自己服务器生成的证书，这里是不会通过的。 AFSSLPinningModeCertificate：这个模式表示用证书绑定方式验证证书，需要客户端保存有服务端的证书拷贝，这里验证分两步，第一步验证证书的域名/有效期等信息，第二步是对比服务端返回的证书跟客户端返回的是否一致。 AFSSLPinningModePublicKey：这个模式同样是用证书绑定方式验证，客户端要有服务端的证书拷贝，只是验证时只验证证书里的公钥，不验证证书的有效期等信息。 */ typedef NS_ENUM(NSUInteger, AFSSLPinningMode) { AFSSLPinningModeNone, //代表无条件信任服务器的证书 EOCClass AFSSLPinningModePublicKey, //代表会对服务器返回的证书中的PublicKey进行验证，通过则通过，否则不通过 AFSSLPinningModeCertificate, //代表会对服务器返回的证书同本地证书全部进行校验，通过则通过，否则不通过 }; /* 要做什么事情，然去拿什么东西（SecTrustRef） */ //验证服务器证书serverTrust/域名domain（服务器那边的） - (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust forDomain:(NSString *)domain { if (domain &amp;&amp; self.allowInvalidCertificates &amp;&amp; self.validatesDomainName &amp;&amp; (self.SSLPinningMode == AFSSLPinningModeNone || [self.pinnedCertificates count] == 0)) { // https://developer.apple.com/library/mac/documentation/NetworkingInternet/Conceptual/NetworkingTopics/Articles/OverridingSSLChainValidationCorrectly.html // According to the docs, you should only trust your provided certs for evaluation. // Pinned certificates are added to the trust. Without pinned certificates, // there is nothing to evaluate against. // // From Apple Docs: // &quot;Do not implicitly trust self-signed certificates as anchors (kSecTrustOptionImplicitAnchors). // Instead, add your own (self-signed) CA certificate to the list of trusted anchors.&quot; NSLog(@&quot;In order to validate a domain name for self signed certificates, you MUST use pinning.&quot;); return NO; } // 1 获取验证策略的数据 2 设置策略 3 验证 NSMutableArray *policies = [NSMutableArray array]; if (self.validatesDomainName) { // 验证域名 [policies addObject:(__bridge_transfer id)SecPolicyCreateSSL(true, (__bridge CFStringRef)domain)];// （SecPolicyCreateSSL 返回一个用于评估SSL证书链的策略对象） } else {/// 不验证域名 //通过X.509(数字证书的标准)的数字证书和公开密钥进行的安全网络连接是否值得信任 [policies addObject:(__bridge_transfer id)SecPolicyCreateBasicX509()]; } // 设置策略（在evaluating中设置要使用的策略） SecTrustSetPolicies(serverTrust, (__bridge CFArrayRef)policies); //AFSSLPinningModeNone 不校验证书 /* ⚠️AFServerTrustIsValid(serverTrust) 执行这句试试 如果self.allowInvalidCertificates = NO；验证这个证书要有效（） + AFServerTrustIsValid(serverTrust); 只验证域名 那么证书过期／没有过期都一样（不验证证书是否过期，【如果服务器没有去更新证书也事没问题】） （APP） */ if (self.SSLPinningMode == AFSSLPinningModeNone) { return self.allowInvalidCertificates || AFServerTrustIsValid(serverTrust); } else if (!AFServerTrustIsValid(serverTrust) &amp;&amp; !self.allowInvalidCertificates) { // 根据策略 验证证书是否有效 &amp;&amp; 不允许无效证书 return NO; } /* 代码能够走到这里说明了 1 全部信任：allowInvalidCertificates = YES 或者 域名是对的 信任 2 通过了根证书的验证（AFServerTrustIsValid） */ // // 进步一认证 // // 1 获取验证策略的数据 2 设置策略 3 验证 switch (self.SSLPinningMode) { // case AFSSLPinningModeNone: // default: // return NO; case AFSSLPinningModeCertificate: { // 全部校验 /* self.pinnedCertificates 取本地证书文件.cer，转化成NSData类型 */ NSMutableArray *pinnedCertificates = [NSMutableArray array]; for (NSData *certificateData in self.pinnedCertificates) { [pinnedCertificates addObject:(__bridge_transfer id)SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificateData)]; // 根据data生成证书对象 } /* 给serverTrust设置锚证书，即再SecTrustEvaluate评估过程中，会根据锚(pinnedCertificates)来进行验证 */ SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates); // // 校验能够信任 if (!AFServerTrustIsValid(serverTrust)) { return NO; } // obtain the chain after being validated, which *should* contain the pinned certificate in the last position (if it&apos;s the Root CA) //从serverTrust评估信任的证书链中获取的证书（AFServerTrustIsValid后再次验证） NSArray *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust); // 判断本地证书和服务器证书是否相同 for (NSData *trustChainCertificate in [serverCertificates reverseObjectEnumerator]) { if ([self.pinnedCertificates containsObject:trustChainCertificate]) { return YES; } } return NO; } case AFSSLPinningModePublicKey: { NSUInteger trustedPublicKeyCount = 0; NSArray *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);// 从证书中拿公钥数据 // 找到相同的公钥就通过 for (id trustChainPublicKey in publicKeys) { for (id pinnedPublicKey in self.pinnedPublicKeys) { if (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) { trustedPublicKeyCount += 1; // break; } } } return trustedPublicKeyCount &gt; 0; } } return NO; } AFNetworkReachabilityManager源码 /* 通过导入了这个头文件，我们得知：网络监控的实现是依赖SystemConfiguration这个api的。 说明这个api能够提供这样的功能，至少让我们明白了我们平时都会导入它的一个用途。 */ #import &lt;SystemConfiguration/SystemConfiguration.h&gt; // 当满足一个有限的并具有统一主题集合的时候， 我们就考虑用枚举 typedef NS_ENUM(NSInteger, AFNetworkReachabilityStatus) { //未知 AFNetworkReachabilityStatusUnknown = -1, // 无网络 AFNetworkReachabilityStatusNotReachable = 0, // WWAN 手机自带网络 AFNetworkReachabilityStatusReachableViaWWAN = 1, // WIFI AFNetworkReachabilityStatusReachableViaWiFi = 2, }; #pragma mark - 判断状态 // 属性 - (BOOL)isReachable { return [self isReachableViaWWAN] || [self isReachableViaWiFi]; } - (BOOL)isReachableViaWWAN { return self.networkReachabilityStatus == AFNetworkReachabilityStatusReachableViaWWAN; } - (BOOL)isReachableViaWiFi { return self.networkReachabilityStatus == AFNetworkReachabilityStatusReachableViaWiFi; } #pragma mark - 开始监听／停止监听 - (void)startMonitoring { [self stopMonitoring]; if (!self.networkReachability) { return; } __weak __typeof(self)weakSelf = self; AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) { __strong __typeof(weakSelf)strongSelf = weakSelf; strongSelf.networkReachabilityStatus = status; if (strongSelf.networkReachabilityStatusBlock) { strongSelf.networkReachabilityStatusBlock(status); } }; // context 可以看作是一个环境，如layer层的context上下文 SCNetworkReachabilityContext context = {0, (__bridge void *)callback, AFNetworkReachabilityRetainCallback, AFNetworkReachabilityReleaseCallback, NULL}; // 设置回调 状态变化会回掉 SCNetworkReachabilitySetCallback(self.networkReachability, AFNetworkReachabilityCallback, &amp;context); SCNetworkReachabilityScheduleWithRunLoop(self.networkReachability, CFRunLoopGetMain(), kCFRunLoopCommonModes); // 主动做一次网络信息测试 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0),^{ SCNetworkReachabilityFlags flags; if (SCNetworkReachabilityGetFlags(self.networkReachability, &amp;flags)) { AFPostReachabilityStatusChange(flags, callback); } }); } - (void)stopMonitoring { if (!self.networkReachability) { return; } SCNetworkReachabilityUnscheduleFromRunLoop(self.networkReachability, CFRunLoopGetMain(), kCFRunLoopCommonModes); } static void AFNetworkReachabilityCallback(SCNetworkReachabilityRef __unused target, SCNetworkReachabilityFlags flags, void *info) { AFPostReachabilityStatusChange(flags, (__bridge AFNetworkReachabilityStatusBlock)info); } /** * Queue a status change notification for the main thread. * * This is done to ensure that the notifications are received in the same order * as they are sent. If notifications are sent directly, it is possible that * a queued notification (for an earlier status condition) is processed after * the later update, resulting in the listener being left in the wrong state. 接受网络变化有两种方式 1 Block， 2 通知 为了保证来年观众方式的数据统一， 把这个过程分装到一个函数中 根据一个标识 来处理Block和通知。保证两者同一状态 */ static void AFPostReachabilityStatusChange(SCNetworkReachabilityFlags flags, AFNetworkReachabilityStatusBlock block) { AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusForFlags(flags); dispatch_async(dispatch_get_main_queue(), ^{ // block 方式 和 通知方式 if (block) { block(status); } NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter]; NSDictionary *userInfo = @{ AFNetworkingReachabilityNotificationStatusItem: @(status) }; [notificationCenter postNotificationName:AFNetworkingReachabilityDidChangeNotification object:nil userInfo:userInfo]; }); } AFNetworkReachabilityManager应用 - (void)addMonitor{ [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(testNet:) name:AFNetworkingReachabilityDidChangeNotification object:nil]; _netReachabilityManager = [AFNetworkReachabilityManager managerForDomain:@&quot;www.baidu.com&quot;]; // _netReachabilityManager = [AFNetworkReachabilityManager manager]; // [self addObserver:self forKeyPath:@&quot;netReachabilityManager&quot; options:NSKeyValueObservingOptionNew context:nil]; [_netReachabilityManager startMonitoring]; } - (void)testNet:(NSNotification*)notif { AFNetworkReachabilityStatus status = [[notif.userInfo objectForKey:AFNetworkingReachabilityNotificationStatusItem] intValue]; NSLog(@&quot;NetStatus:%@&quot;, AFStringFromNetworkReachabilityStatus(status)); } - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context{ NSLog(@&quot;===%@&quot;, change); } 面向切面的编程AOP 一位著名的iOS大神Mattt Thompson在http://nshipster.com/nsurlprotocol/ 博客里说过，说“NSURLProtocol is both the most obscure and the most powerful part of the URL Loading System.”NSURLProtocol是URL Loading System中功能最强大也是最晦涩的部分。 这句话给了NSURLProtocol一个非常准确的定性。NSURLProtocol作为URL Loading System中的一个独立部分存在，能够拦截所有的URL Loading System发出的网络请求，拦截之后便可根据需要做各种自定义处理，是iOS网络层实现AOP(面向切面编程)的终极利器，所以功能和影响力都是非常强大的。但是关于NSURLProtocol的文档非常少，文档陈旧，包括苹果官方的文档也介绍得比较简单。而且，对于NSURLProtocol的使用，有坑的地方非常多。所以说它也是晦涩的并且是危险的。 什么是 NSURLProtocol NSURLProtocol是URL Loading System的重要组成部分。首先虽然名叫NSURLProtocol，但它却不是协议。它是一个抽象类。我们要使用它的时候需要创建它的一个子类。NSURLProtocol在iOS系统中大概处于这样一个位置：net–protocol–NSURLSession–UIWebview–NSURLProtocol 可以拦截的网络请求包括NSURLSession，NSURLConnection以及UIWebVIew。基于CFNetwork的网络请求，以及WKWebView的请求是无法拦截的。现在主流的iOS网络库，例如AFNetworking，Alamofire等网络库都是基于NSURLSession或NSURLConnection的，所以这些网络库的网络请求都可以被NSURLProtocol所拦截。还有一些年代比较久远的网络库，例如ASIHTTPRequest，MKNetwokit等网路库都是基于CFNetwork的，所以这些网络库的网络请求无法被NSURLProtocol拦截。 使用 NSURLProtocol 如上文所说，NSURLProtocol是一个抽象类。我们要使用它的时候需要创建它的一个子类。 @interface CustomURLProtocol : NSURLProtocol 使用NSURLProtocol的主要可以分为5个步骤：注册—&gt;拦截—&gt;转发—&gt;回调—&gt;结束 注册： 对于基于NSURLConnection或者使用[NSURLSession sharedSession]创建的网络请求，调用registerClass方法即可。 [NSURLProtocol registerClass:[NSClassFromString(@&quot;CustomURLProtocol&quot;) class]]; 对于基于NSURLSession的网络请求，需要通过配置NSURLSessionConfiguration对象的protocolClasses属性。 NSURLSessionConfiguration *sessionConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration]; sessionConfiguration.protocolClasses = @[[NSClassFromString(@&quot;CustomURLProtocol&quot;) class]]; 拦截： 在拦截到网络请求后，NSURLProtocol会依次执行下列方法： + (BOOL)canInitWithRequest:(NSURLRequest *)request 该方法会拿到request的对象，我们可以通过该方法的返回值来筛选request是否需要被NSURLProtocol做拦截处理。比如： + (BOOL)canInitWithRequest:(NSURLRequest *)request { NSString * scheme = [[request.URL scheme] lowercaseString]; if ([scheme isEqual:@&quot;http&quot;]) { return YES; } return NO; } 这里我们就只会拦截http的请求。 + (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request 在该方法中，我们可以对request进行处理。例如修改头部信息等。最后返回一个处理后的request实例。 转发： 在拦截到网络请求，并且对网络请求进行定制处理以后。我们需要将网络请求重新发送出去。 - (id)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id&lt;NSURLProtocolClient&gt;)client 该方法会创建一个NSURLProtocol实例，这里每一个网络请求都会创建一个新的实例。 - (void)startLoading 接下来就是转发的核心方法startLoading。在该方法中，我们把处理过的request重新发送出去。至于发送的形式，可以是基于NSURLConnection，NSURLSession甚至CFNetwork。 回调： 既是面向切面的编程，就不能影响到原来网络请求的逻辑。所以上一步将网络请求转发出去以后，当收到网络请求的返回，还需要再将返回值返回给原来发送网络请求的地方。主要需要需要调用到 [self.client URLProtocol:self didFailWithError:error]; [self.client URLProtocolDidFinishLoading:self]; [self.client URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageNotAllowed]; [self.client URLProtocol:self didLoadData:data]; 这四个方法来回调给原来发送网络请求的地方。这里假设我们在转发过程中是使用NSURLSession发送的网络请求，那么在NSURLSession的回调方法中，我们做相应的处理即可。并且我们也可以对这些返回，进行定制化处理。 - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error { if (error) { [self.client URLProtocol:self didFailWithError:error]; } else { [self.client URLProtocolDidFinishLoading:self]; } } - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler { [self.client URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageNotAllowed]; completionHandler(NSURLSessionResponseAllow); } - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data { [self.client URLProtocol:self didLoadData:data]; } 结束： 在一个网络请求完全结束以后，NSURLProtocol回调用到 - (void)stopLoading 在该方法里，我们完成在结束网络请求的操作。以NSURLSession为例： - (void)stopLoading { [self.session invalidateAndCancel]; self.session = nil; } 以上便是NSURLProtocol的基本流程。 应用场景： 网络请求缓存 网络请求mock stub，知名的库OHHTTPStubs就是基于NSURLProtocol 网络相关的数据统计 URL重定向 配合实现HTTPDNS 性能优化之网络缓存层搭建封装的作用 1.搭建缓存层 2.业务隔离层(如登录失效，json解析错误) - (void)viewDidLoad { [super viewDidLoad]; NSDictionary *infodict = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;1&quot;, @&quot;versions_id&quot;, @&quot;1&quot;, @&quot;system_type&quot;, nil]; [[SYNetMananger sharedInstance] syPostNoCacheWithUrl:URLPath parameters:infodict completionHandler:^(NSError * _Nullable error, BOOL isCache, NSDictionary * _Nullable result) { if (isCache) { NSLog(@&quot;isCache&quot;); } }]; } - (void)syPostNoCacheWithUrl:(NSString*)urlString parameters:(NSDictionary * _Nullable)parameters completionHandler:(SYRequestCompletionHandler)completionHandler{ [self syPostWithURLString:urlString parameters:parameters ignoreCache:YES cacheDuration:0 completionHandler:completionHandler]; } - (void)syPostWithURLString:(NSString *)URLString parameters:(NSDictionary * _Nullable)parameters ignoreCache:(BOOL)ignoreCache cacheDuration:(NSTimeInterval)cacheDuration completionHandler:(SYRequestCompletionHandler)completionHandler{ __weak typeof(self) weakSelf = self; dispatch_async(_SYNetQueue, ^{ [weakSelf taskWithMethod:@&quot;POST&quot; urlString:URLString parameters:parameters ignoreCache:ignoreCache cacheDuration:cacheDuration completionHandler:completionHandler]; }); } - (void)taskWithMethod:(NSString*)method urlString:(NSString*)urlStr parameters:(NSDictionary *)parameters ignoreCache:(BOOL)ignoreCache cacheDuration:(NSTimeInterval)cacheDuration completionHandler:(SYRequestCompletionHandler)completionHandler{ // 1 url+参数 生成唯一码 NSString *fileKeyFromUrl = SYConvertMD5FromParameter(urlStr, method, parameters); __weak typeof(self) weakSelf = self; // 2 缓存+失效 判断是否有有效缓存 if (!ignoreCache &amp;&amp; [self.cache checkIfShouldUseCacheWithCacheDuration:cacheDuration cacheKey:fileKeyFromUrl]) { NSMutableDictionary *localCache = [NSMutableDictionary dictionary]; NSDictionary *cacheDict = [self.cache searchCacheWithUrl:fileKeyFromUrl]; [localCache setDictionary:cacheDict]; if (cacheDict) { dispatch_async(dispatch_get_main_queue(), ^{ if (weakSelf.exceptionBlock) { weakSelf.exceptionBlock(nil, localCache); } completionHandler(nil, YES, localCache); }); return; } } // 5 处理网络返回来的数据，即缓存处理 SYRequestCompletionHandler newCompletionBlock = ^( NSError* error, BOOL isCache, NSDictionary* result){ //5.1处理缓存 ⚠️参数ignoreCache(网络task发起前，是否从本来缓存中获取数据) cacheDuration(网络task结束后，是否对网络数据缓存) result = [NSMutableDictionary dictionaryWithDictionary:result]; if (cacheDuration &gt; 0) {// 缓存时效(即缓存时间)大于0 if (result) { if (weakSelf.cacheConditionBlock) { if (weakSelf.cacheConditionBlock(result)) { [weakSelf.cache saveCacheData:result forKey:fileKeyFromUrl]; } }else{ [weakSelf.cache saveCacheData:result forKey:fileKeyFromUrl]; } } } //5.2回掉 dispatch_async(dispatch_get_main_queue(), ^{ if (weakSelf.exceptionBlock) { weakSelf.exceptionBlock(error, (NSMutableDictionary*)result); } completionHandler(error, NO, result); }); }; //3 发起AF网络任务 NSURLSessionTask *task = nil; if ([method isEqualToString:@&quot;GET&quot;]) { task = [self.afHttpManager GET:urlStr parameters:parameters progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { /* 4 处理数据 （处理数据的时候，需要处理下载的网络数据是否要缓存） 这里可以直接使用 completionHandler，如果这样，网络返回的数据没有做缓存处理机制 */ newCompletionBlock(nil,NO, responseObject); } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { newCompletionBlock(error,NO, nil);; }]; }else{ task = [self.afHttpManager POST:urlStr parameters:parameters progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { newCompletionBlock(nil,NO, responseObject); } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { newCompletionBlock(error,NO, nil); }]; } [task resume]; } @implementation AppDelegate (NetCache) // 配置缓存条件 - (void)configNetCacheCondition{ // return YES 缓存， NO不缓存 [SYNetMananger sharedInstance].cacheConditionBlock = ^BOOL(NSDictionary * _Nonnull result) { if([result isKindOfClass:[NSDictionary class]]){ if([[result objectForKey:@&quot;success&quot;] intValue] == 0){ return NO; } } return YES; }; } @end @implementation AppDelegate (NetException) // 统一处理网络部分异常 - (void)configHandleNetException{ [SYNetMananger sharedInstance].exceptionBlock = ^(NSError * _Nullable error, NSMutableDictionary* result) { if(![result isKindOfClass:[NSDictionary class]]){ return ; } // 统一处理网络异常错误信息 if(error &amp;&amp; [result allKeys].count == 0){ // 这个地方就可以在内部不需要去判断error，统一直接判断result相关信息 // result错误信息配置 [result setObject:error.localizedDescription forKey:@&quot;msg&quot;]; } // (单点登录)登录异常处理 if([[result objectForKey:@&quot;statusCode&quot;] integerValue] == 401){ [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;LoginNotification&quot; object:nil]; } }; } @end 多网络请求 // 多任务处理 - (void)multiNetTask{ NSDictionary *infodictOne = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;1&quot;, @&quot;versions_id&quot;, @&quot;1&quot;, @&quot;system_type&quot;, nil]; SYNetRequestInfo *infoNetOne = [[SYNetMananger sharedInstance] syNetRequestWithURLStr:URLPath method:@&quot;POST&quot; parameters:infodictOne ignoreCache:NO cacheDuration:2 completionHandler:^(NSError * _Nullable error, BOOL isCache, NSDictionary * _Nullable result) { if (isCache) { NSLog(@&quot;isCache&quot;); } }]; NSDictionary *infodictTwo = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;1&quot;, @&quot;versions_id&quot;, @&quot;1&quot;, @&quot;system_type&quot;, nil]; SYNetRequestInfo *infoNetTwo = [[SYNetMananger sharedInstance] syNetRequestWithURLStr:URLPath method:@&quot;POST&quot; parameters:infodictTwo ignoreCache:NO cacheDuration:2 completionHandler:^(NSError * _Nullable error, BOOL isCache, NSDictionary * _Nullable result) { if (isCache) { NSLog(@&quot;isCache&quot;); } }]; NSArray *taskAry = [NSArray arrayWithObjects:infoNetOne, infoNetTwo, nil]; [[SYNetMananger sharedInstance] syBatchOfRequestOperations:taskAry progressBlock:^(NSUInteger numberOfFinishedTasks, NSUInteger totalNumberOfTasks) { } completionBlock:^(NSArray * _Nonnull operationAry) { }]; } - (void)syBatchOfRequestOperations:(NSArray&lt;SYNetRequestInfo *&gt; *)tasks progressBlock:(void (^)(NSUInteger numberOfFinishedTasks, NSUInteger totalNumberOfTasks))progressBlock completionBlock:(netSuccessbatchBlock)completionBlock{ /* 使用 dispatch_group_t 技术点 多少个任务 对group添加多少个 空任务数(dispatch_group_enter) 任务完成后 对group的任务数-1 操作(dispatch_group_leave); 当group的任务数为0了，就会执行dispatch_group_notify的block块操作，即所有的网络任务请求完了。 可以看作是一个信号量的处理， 刚开始有3个信号量 sem = 3， 当 sem = 0时 处理 */ __weak typeof(self) weakSelf = self; dispatch_async(_SYNetQueue, ^{ __block dispatch_group_t group = dispatch_group_create(); [weakSelf.batchGroups addObject:group]; __block NSInteger finishedTasksCount = 0; __block NSInteger totalNumberOfTasks = tasks.count; [tasks enumerateObjectsUsingBlock:^(SYNetRequestInfo * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) { if (obj) { // 网络任务启动前dispatch_group_enter dispatch_group_enter(group); SYRequestCompletionHandler newCompletionBlock = ^( NSError* error, BOOL isCache, NSDictionary* result){ progressBlock(finishedTasksCount, totalNumberOfTasks); if (obj.completionBlock) { obj.completionBlock(error, isCache, result); } // 网络任务结束后dispatch_group_enter dispatch_group_leave(group); }; if ([obj.method isEqual:@&quot;POST&quot;]) { [[SYNetMananger sharedInstance] syPostWithURLString:obj.urlStr parameters:obj.parameters ignoreCache:obj.ignoreCache cacheDuration:obj.cacheDuration completionHandler:newCompletionBlock]; }else{ [[SYNetMananger sharedInstance] syGetWithURLString:obj.urlStr parameters:obj.parameters ignoreCache:obj.ignoreCache cacheDuration:obj.cacheDuration completionHandler:newCompletionBlock]; } } }]; //监听 dispatch_group_notify(group, dispatch_get_main_queue(), ^{ [weakSelf.batchGroups removeObject:group]; if (completionBlock) { completionBlock(tasks); } }); }); }]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>iOS</tag>
        <tag>网络及框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[京东MVCS框架]]></title>
    <url>%2F2018%2F01%2F26%2F%E4%BA%AC%E4%B8%9CMVCS%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[京东MVCS框架搭建 NSObject+SYKVO.h/NSObject+SYKVO.m typedef void(^SYKVOBlock)(id newValue); @interface NSObject (SYKVO) - (void)addObserverSuny:(NSObject *)observer keyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options block:(SYKVOBlock)block; // 默认是NSKeyValueObservingOptionNew - (void)addObserverSuny:(NSObject *)observer keyPath:(NSString *)keyPath block:(SYKVOBlock)block; @end CSBaseStore @protocol CSBaseStore &lt;NSObject&gt; - (CSBasePipeline*)pipeline; @end @interface CSBaseStore : NSObject&lt;CSBaseStore&gt; - (void)fecthSeverData; @end CSBasePipeline @interface CSBasePipeline : NSObject @end CSBaseViewController @interface CSBaseViewController : UIViewController @property (nonatomic, strong)CSBaseStore *store; - (instancetype)initWithViewClass:(Class)viewClass store:(CSBaseStore*)store; - (void)setupPipeline:(CSBasePipeline*)pipeline; - (void)addObserver; @end @interface CSBaseViewController () @property (nonatomic, strong)Class viewClass; @end @implementation CSBaseViewController - (instancetype)initWithViewClass:(Class)viewClass store:(CSBaseStore*)store{ self = [super init]; if (self) { self.viewClass = viewClass; _store = store; } return self; } - (void)loadView{ self.view = [self.viewClass new]; } - (void)viewDidLoad { [super viewDidLoad]; [self setupPipeline:_store.pipeline]; [self.view setupPipeline:_store.pipeline]; [self addObserver]; } - (void)setupPipeline:(CSBasePipeline*)pipeline{ } @end UIView+CSBase @interface UIView (CSBase) - (void)setupPipeline:(CSBasePipeline*)pipeline; @end @implementation UIView (CSBase) - (void)setupPipeline:(CSBasePipeline*)pipeline{ } @end CSBaseScene @interface CSBaseScene : NSObject @property(nonatomic, strong)Class viewClss; @property(nonatomic, strong)Class controllerClass; @property(nonatomic, strong)Class storeClass; - (instancetype)initWithScenceWithViewClass:(Class)viewClass controllerClass:(Class)controllerClass store:(Class)storeClass; @end @implementation CSBaseScene - (instancetype)initWithScenceWithViewClass:(Class)viewClass controllerClass:(Class)controllerClass store:(Class)storeClass{ self = [super init]; if (self) { NSAssert([viewClass isSubclassOfClass:[UIView class]], @&quot;%@必须是UIView的子类&quot;, NSStringFromClass(viewClass)); NSAssert([controllerClass isSubclassOfClass:[CSBaseViewController class]], @&quot;%@必须是CSBaseViewController的子类&quot;, NSStringFromClass(controllerClass)); NSAssert([storeClass conformsToProtocol:@protocol(CSBaseStore)], @&quot;%@必须实现CSBaseStore协议&quot;, NSStringFromClass(storeClass)); _viewClss = viewClass; _controllerClass = controllerClass; _storeClass = storeClass; } return self; } @end CSBaseMediator @interface CSBaseMediator : NSObject + (UIViewController*)viewControllerWithScreen:(CSBaseScene*)scene; @end @implementation CSBaseMediator // 1 数据 2 控制器和视图 + (UIViewController*)viewControllerWithScreen:(CSBaseScene*)scene{ CSBaseStore *store = [scene.storeClass new]; // pipeline UIViewController* viewCtr = [[scene.controllerClass alloc] initWithViewClass:scene.viewClss store:store]; return viewCtr; } @end CSBaseService @interface CSBaseService : NSObject @end @implementation CSBaseService @end CSBaseStorage @interface CSBaseStorage : NSObject - (NSData*)readDataFromFile:(NSString*)filePath; - (BOOL)writeDataToFile:(NSString*)filePath; @end @implementation CSBaseStorage @end AppDelegate - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { CSBaseScene *homepageScene = [[CSBaseScene alloc] initWithScenceWithViewClass:[HomePageView class] controllerClass:[HomePageViewCtr class] store:[HomePageStore class]]; UIViewController *homePage = [CSBaseMediator viewControllerWithScreen:homepageScene]; // HomePageViewCtr *homePage = [HomePageViewCtr new]; UINavigationController *nav = [[UINavigationController alloc] initWithRootViewController:homePage]; self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds]; self.window.backgroundColor = [UIColor whiteColor]; self.window.rootViewController = nav; [self.window makeKeyAndVisible]; return YES; } HomePageViewCtr @interface HomePageViewCtr : CSBaseViewController @end @interface HomePageViewCtr () @property (nonatomic, strong)HomePagePipeline *homepagePipeline; @end @implementation HomePageViewCtr - (void)viewDidLoad { [super viewDidLoad]; self.title = @&quot;Home&quot;; [self.store fecthSeverData]; } //在框架里面进行掉用了，只需要赋值就ok了 - (void)setupPipeline:(__kindof CSBasePipeline*)pipeline{ _homepagePipeline = pipeline; } - (void)addObserver{ [_homepagePipeline addObserverSuny:self keyPath:@&quot;clipButton&quot; block:^(id newValue) { NSLog(@&quot;点击事件，做push处理或者其他处理&quot;); }]; [_homepagePipeline addObserverSuny:self keyPath:@&quot;isLoading&quot; block:^(id newValue) { NSLog(@&quot;处理网络数据&quot;); }]; } @end HomePageView @interface HomePageView : UIView @end @interface HomePageView () @property (nonatomic, strong)HomePagePipeline *homepagePipeline; @end @implementation HomePageView //在框架里面进行掉用了，只需要赋值就ok了 - (void)setupPipeline:(__kindof CSBasePipeline*)pipeline{ _homepagePipeline = pipeline; } - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event{ _homepagePipeline.clipButton = YES; } @end HomePagePipeline @interface HomePagePipeline : CSBasePipeline @property (nonatomic, strong)FctPipeline *fctPipleline; @property (nonatomic, assign)BOOL clipButton; @property (nonatomic, assign)BOOL isLoading; @property (nonatomic, strong)NSMutableArray *netArr; @end @implementation HomePagePipeline @end HomePageStore @interface HomePageStore : CSBaseStore - (void)fecthSeverData; @end @interface HomePageStore () @property (nonatomic, strong)HomePagePipeline *homePagePipeline; @end @implementation HomePageStore{ HomePagePipeline *_homePagePipeline; } - (CSBasePipeline*)pipeline{ return self.homePagePipeline; } - (HomePagePipeline*)homePagePipeline{ if (!_homePagePipeline) { _homePagePipeline = [HomePagePipeline new]; } return _homePagePipeline; } // 进行网络数据下载操作 - (void)fecthSeverData{ [self performSelector:@selector(loadingFinish) withObject:nil afterDelay:3]; } - (void)loadingFinish{ self.homePagePipeline.isLoading = YES; self.homePagePipeline.netArr = [NSMutableArray array]; } @end]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS动画]]></title>
    <url>%2F2017%2F12%2F29%2FiOS%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[iOS动画之动画原理UIView和CALayer UIView继承于：UIResponder、NSObject CALayer继承于：NSObject UIView 响应事件 CALayer 显示内容 没有CoreAnimation框架，CoreAnimation.h文件存在于QuartzCore框架中；Core Animation 包含了 CAAnimation Layer坐标 view的坐标 其实本质上是layer坐标来实现的，可以屏蔽掉layer的setFrame、setBounds、setPostion方法来达到验证。UIView 的 setFrame 方法，实际是在给 CALayer 设置 frame。每一个UIView内部都默认关联着一个CALayer, UIView有frame、bounds和center三个属性，CALayer也有类似的属性，分别为frame、bounds、position、anchorPoint。 position是layer中的anchorPoint在superLayer中的位置坐标。 互不影响原则：单独修改position与anchorPoint中任何一个属性都不影响另一个属性。 frame、position与anchorPoint有以下关系： //position.x = frame.origin.x + 0.5 * bounds.size.width； //position.y = frame.origin.y + 0.5 * bounds.size.height； frame.origin.x = position.x - anchorPoint.x * bounds.size.width； frame.origin.y = position.y - anchorPoint.y * bounds.size.height； 在Apple doc对frame的描述中有这么一句话：Layers have an implicit frame that is a function of the position, bounds, anchorPoint, and transform properties.可以看到我们推导的公式基本符合这段描述，只不过还缺少了transform，加上transform的话就比较复杂，这里就不展开讲了。 深入理解 Apple doc中还有一句描述是这样的：When you specify the frame of a layer, position is set relative to the anchor point. When you specify the position of the layer, bounds is set relative to the anchor point. 大意是：当你设置图层的frame属性的时候，position根据锚点（anchorPoint）的值来确定，而当你设置图层的position属性的时候，bounds会根据锚点(anchorPoint)来确定。 这段翻译的上半句根据前面的公式容易理解，后半句可能就有点令人迷惑了，当修改position时，bounds的width与height会随之修改吗？其实,position是点，bounds是矩形，根据锚点(anchorPoint)来确定的只是它们的位置，而不是内部属性。所以，上面这段英文这么翻译就容易理解了： 当你设置图层的frame属性的时候，position点的位置（也就是position坐标）根据锚点（anchorPoint）的值来确定，而当你设置图层的position属性的时候，bounds的位置（也就是frame的orgin坐标）会根据锚点(anchorPoint)来确定。 在实际情况中，可能还有这样一种需求，我需要修改anchorPoint，但又不想要移动layer也就是不想修改frame.origin，那么根据前面的公式，就需要position做相应地修改。简单地推导，可以得到下面的公式： positionNew.x = positionOld.x + (anchorPointNew.x - anchorPointOld.x) * bounds.size.width positionNew.y = positionOld.y + (anchorPointNew.y - anchorPointOld.y) * bounds.size.height 但是在实际使用没必要这么麻烦。修改anchorPoint而不想移动layer，在修改anchorPoint后再重新设置一遍frame就可以达到目的，这时position就会自动进行相应的改变。写成函数就是下面这样的： - (void) setAnchorPoint:(CGPoint)anchorpoint forView:(UIView *)view{ CGRect oldFrame = view; view.layer.anchorPoint = anchorpoint; view.frame = oldFrame; } 案例 //frame的计算公式 //frame.x = position.x - anchorPoint.x*width //frame.y = position.y - anchorPoint.y*height //设置坐标（frame、postion、anchorPoint）是不是本质上要得到view的x，y，width、height //1、postion {150, 150} anchorPoint {0, 0} //2、postion {100, 100} anchorPoint {0, 0} //顺序不同，结果不同 subView.frame = CGRectMake(150.f, 150.f, 100.f, 100.f); //postion的位置 subView.layer.anchorPoint = CGPointMake(1, 1); //秒钟的实现 CALayer *secondLayer = [CALayer layer]; secondLayer.bounds = CGRectMake(0.f, 0.f, 10.f, 40.f); //移动layer在父layer中的位置 secondLayer.position = CGPointMake(50.f, 50.f); //设置layer自己内部的anchorPoint secondLayer.anchorPoint = CGPointMake(0.5f, 1.f); secondLayer.backgroundColor = [UIColor lightGrayColor].CGColor; [subView.layer addSublayer:secondLayer]; //开启一个定时器 static int currentSecond = 0; [NSTimer scheduledTimerWithTimeInterval:1.f repeats:YES block:^(NSTimer * _Nonnull timer) { currentSecond++; secondLayer.transform = CATransform3DMakeRotation(currentSecond*(M_PI*2)/60, 0.f, 0.f, 1.f); }]; Layer内容 view的内容：layer决定的 无论你是图片，还是文字（分析UILabel、UITextField、UITextView），图片是通过layer的contents来决定的，其他的都是直接通过layer来决定 UIImageView怎么显示图片，通过分析UIImageView的layer来模拟实现一个view达到UIImageView的效果 viewTwo.layer.contents = (__bridge id)[UIImage imageNamed:@&quot;1.png&quot;].CGImage; 我们的内容除了contents，除了layer，它还可以通过绘制来添加；此时不得不提layer的两个代理方法displayLayer:和drawLayer:inContext: layer层展示内容：会通过它的两个代理来实现:因为默认情况下，view.layer.delegate = view; displayLayer、drawLayer都存在，那么只会调用displayLayer，不会调用drawLayer；如果没有displayLayer，就会调用drawLayer drawRect本质上是由[super drawLayer:layer inContext:ctx];调用的 drawRect：用来绘制view的；这里会造成内存的暴增效果（主要是因为UIGraphicsGetCurrentContext获取的上下文太大，通常要注意尽量小） layer.contents和绘制来的有什么区别？ 是contents的话，就是把图片展示出来 如果是draWRect（绘制），你是不是需要一块区域来绘制，首先它会生成绘制区域（宽高），所有你屏幕上看到的都是image（纹理），此时，内存大小，就是绘制区域所占内存：宽高（尺寸）4(每个像素4个字节ARGB)；retina 屏幕，一个点占2个像素，宽高22*4/1024/1024 layer.mask运用 //layer.mask运用 - (void)viewDidLoad { [super viewDidLoad]; self.view.backgroundColor = [UIColor whiteColor]; imageView = [[UIImageView alloc] initWithFrame:CGRectMake(100.f, 100.f, 200.f, 200.f)]; imageView.image = [UIImage imageNamed:@&quot;bg-mine.png&quot;]; [self.view addSubview:imageView]; //layer.mask 我需要找到一个不透明的layer //layer.mask = 不透明的layer //layer的形状就是不透明layer的形状 UIImage *img = [UIImage imageNamed:@&quot;bubble.png&quot;]; CALayer *imageLayer = [CALayer layer]; imageLayer.contents = (__bridge id)img.CGImage; imageLayer.frame = imageView.bounds; imageView.layer.mask = imageLayer; } layer动画 修改view没有动画，而修改layer层有隐式动画，为什么呢？ 任何可动画的layer的属性改变时，layer会寻找相合适的action来响应，layer向代理发送actionForLayer：forKey：代理通过返回下列三种之一响应1，返回动作对象，2返回nil，没有动作对象，继续寻找，3返回NSNULL，不需要执行动作 (UIView中就是返回了NSNULL才导致没有动画，如果改成nil，则会出现隐式动画) 1. 如果我们设置了layer的代理，那么会去方法 -(id&lt;CAAction&gt;)actionForLayer:forKey; 寻找key值，根据key来确定要执行的action（动画） - 1.1 如果 -(id&lt;CAAction&gt;)actionForLayer:forKey; 返回的是非nil包括 [NSNull null]）, 停止 ; nil继续下一个步骤 - 1.2 由于 actionForLayer:forKey 是CALayerDelegate的代理方法，选择写在Controller下，也可在UIView.m下用于开启隐式动画 2. 从layer的 `action` 字典里面搜索key 3. 从layer的 `style` 字典里面搜索key 4. 根据方法 +defaultActionForKey: 看他的返回值 5.如果以上步骤都没有结果，那么调用方法 -actionForKey，返回一个默认的动画，如&lt;CABasicAnimation&gt; 6. -addAnimation 就会把这个动画添加到layer上 * If any of these steps results in a non-nil action object, the * following steps are ignored. *如果上述的步骤返回一个非nil的结果，那么当前步骤就被 *停止了 (不包含步骤5.6. 步骤根据nil或者非nil决定最后的动画) @implementation EOCLayer - (void)addAnimation:(CAAnimation *)anim forKey:(NSString *)key { CABasicAnimation *animation = [CABasicAnimation animation]; animation.duration = 1.f; animation.fromValue = (__bridge id)[UIColor blackColor].CGColor; animation.toValue = (__bridge id)[UIColor redColor].CGColor; [super addAnimation:animation forKey:key]; //最后执行的动画以此处为准 } - (id&lt;CAAction&gt;)actionForKey:(NSString *)event { NSLog(@&quot;actionForKey %@ action %@&quot;, event, [super actionForKey:event]); CABasicAnimation *animation = [CABasicAnimation animation]; animation.duration = 3.f; animation.fromValue = (__bridge id)[UIColor whiteColor].CGColor; animation.toValue = (__bridge id)[UIColor greenColor].CGColor; return animation; //将此animation传递给 -addAnimation //如果传递nil，在 -addAnimation中也没有自定义动画，那么layer就不会执行隐式动画 } @end 事务 隐式动画默认的是0.25s，通过事务可以影响动画，比如动画的时间 通常在默认的动画模式下才生效，如果在layer的代理方法里设置过动画，则以代理的动画设置为准 代理可以用于取消action，从而达到关闭动画的效果 //事务 [CATransaction begin]; [CATransaction setAnimationDuration:5.f]; //重置动画时间 //[CATransaction setDisableActions:YES]; //action无效化，即关闭动画 //animation code area [CATransaction commit]; iOS动画之高级动画动画分类： 隐式动画：改变CALayer的属性，自动动画 显式动画CAAnimation(CAMediaTiming协议提供beginTime/duration等属性、CAAction协议提供runActionForKey方法） 属性动画（CAPropertyAnimation作用于图层的某个单一属性） 基础动画（CABasicAnimation） 关键帧动画（CAKeyframeAnimation） 动画组（CAAnimationGroup多个动画叠加） 过渡动画CATransition(type/subtype/start/endProgress/filter) 动画代理 @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; self.view.backgroundColor = [UIColor whiteColor]; layer = [CALayer layer]; layer.backgroundColor = [UIColor lightGrayColor].CGColor; layer.frame = CGRectMake(100.f, 100.f, 100.f, 100.f); [self.view.layer addSublayer:layer]; anim = [CABasicAnimation animationWithKeyPath:@&quot;backgroundColor&quot;]; anim.toValue = (__bridge id)[UIColor redColor].CGColor; anim.duration = 4.f; anim.delegate = self; [layer addAnimation:anim forKey:nil]; } - (void)animationDidStop:(CABasicAnimation *)animOne finished:(BOOL)flag { //不要直接用 if (animOne==anim) if ([animOne.keyPath isEqualToString:@&quot;backgroundColor&quot;]) { //在代理方法里animONe它是anim的深拷贝 } } @end 贝塞尔曲线BezierPath（与ShapLayer是黄金搭档） //转圈清晰效果 - (void)viewDidLoad { [super viewDidLoad]; self.view.backgroundColor = [UIColor darkGrayColor]; //加载动画 UIImageView *imageView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&quot;bg-mine.png&quot;]]; imageView.frame = CGRectMake(100.f, 200.f, 100.f, 100.f); imageView.clipsToBounds = YES; [self.view addSubview:imageView]; //1、添加layer UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:CGPointMake(50.f, 50.f) radius:50.f startAngle:0 endAngle:M_PI*2 clockwise:YES]; shapeLayer = [CAShapeLayer layer]; shapeLayer.path = path.CGPath; shapeLayer.strokeColor = [[UIColor whiteColor] colorWithAlphaComponent:0.5f].CGColor; shapeLayer.lineWidth = 100; shapeLayer.fillColor = [UIColor clearColor].CGColor; [imageView.layer addSublayer:shapeLayer]; } - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event { //strokeStart strokeEnd CABasicAnimation *anim = [CABasicAnimation animationWithKeyPath:@&quot;strokeEnd&quot;]; anim.duration = 6.f; anim.toValue = @0; [shapeLayer addAnimation:anim forKey:nil]; } @end //rect嵌套圆，中间透明，四周半透明效果 - (void)viewDidLoad { [super viewDidLoad]; self.view.backgroundColor = [UIColor darkGrayColor]; //加载动画 UIImageView *imageView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&quot;bg-mine.png&quot;]]; imageView.frame = CGRectMake(100.f, 200.f, 100.f, 100.f); imageView.clipsToBounds = YES; [self.view addSubview:imageView]; //1、添加layer UIBezierPath *path = [UIBezierPath bezierPathWithRect:CGRectMake(0.f, 0.f, 100.f, 100.f)]; [path appendPath:[UIBezierPath bezierPathWithArcCenter:CGPointMake(50.f, 50.f) radius:50.f startAngle:0 endAngle:M_PI*2 clockwise:NO]];//clockwise=NO和bezierPathByReversingPath作用相同 /* nonzero字面意思是“非零”。按该规则，要判断一个点是否在图形内，从该点作任意方向的一条射线，然后检测射线与图形路径的交点情况。从0开始计数，路径从左向右穿过射线则计数加1，从右向左穿过射线则计数减1。得出计数结果后，如果结果是0，则认为点在图形外部，否则认为在内部 evenodd字面意思是“奇偶”。按该规则，要判断一个点是否在图形内，从该点作任意方向的一条射线，然后检测射线与图形路径的交点的数量。如果结果是奇数则认为点在内部，是偶数则认为点在外部。 */ shapeLayer = [CAShapeLayer layer]; shapeLayer.path = path.CGPath; shapeLayer.fillRule = kCAFillRuleEvenOdd; shapeLayer.fillColor = [[UIColor whiteColor] colorWithAlphaComponent:0.5f].CGColor; [imageView.layer addSublayer:shapeLayer]; } //第二种实现方式 - (UIView *)maskView { UIView *maskView = [[UIView alloc] initWithFrame:CGRectMake(0.f, 0.f, 100.f, 100.f)]; maskView.backgroundColor = [UIColor colorWithWhite:1.f alpha:0.4f]; //shapeLayer是矢量图 calayer位图 UIBezierPath *path = [UIBezierPath bezierPathWithRect:CGRectMake(0.f, 0.f, 100.f, 100.f)]; [path appendPath:[[UIBezierPath bezierPathWithArcCenter:CGPointMake(50.f, 50.f) radius:50.f startAngle:0 endAngle:M_PI*2 clockwise:YES]bezierPathByReversingPath]]; shapeLayer = [CAShapeLayer layer]; shapeLayer.path = path.CGPath; maskView.layer.mask = shapeLayer; return maskView; } 基础动画CABasicAnimation @implementation EOCBasicAnimationViewController //动画的过程中，能不能响应 ； 不能响应 - (void)viewDidLoad { [super viewDidLoad]; self.view.backgroundColor = [UIColor whiteColor]; layer = [EOCShapeLayer layer]; layer.frame = CGRectMake(50.f, 50.f, 100.f, 100.f); layer.backgroundColor = [UIColor lightGrayColor].CGColor; [self.view.layer addSublayer:layer]; //你想跟踪动画的变化值 layer有动画：两个层：modelLayer、presentationLayer CABasicAnimation *anim = [CABasicAnimation animationWithKeyPath:@&quot;backgroundColor&quot;]; anim.fromValue = (__bridge id)[UIColor lightGrayColor].CGColor; anim.toValue = (__bridge id)[UIColor redColor].CGColor; anim.duration = 4.f; [layer addAnimation:anim forKey:nil]; NSLog(@&quot;%@&quot;, layer.presentationLayer.backgroundColor); } @end CALayer的属性行为其实很不正常，因为改变一个图层的属性并没有立刻生效，而是通过一段时间渐变更新。这是怎么做到的呢？当你改变一个图层的属性，属性值的确是立刻更新的（如果你读取它的数据，你会发现它的值在你设置它的那一刻就已经生效了），但是屏幕上并没有马上发生改变。这是因为你设置的属性并没有直接调整图层的外观，相反，他只是定义了图层动画结束之后将要变化的外观。这就需要讨论layer中的两个layer：modelLayer和presentationLayer，modelLayer负责属性值，presentationLayer负责动态变化，如果想监听presentationLayer动态变化的值，可以运用如下方法 /* Returns a copy of the layer containing all properties as they were * at the start of the current transaction, with any active animations * applied. This gives a close approximation to the version of the layer * that is currently displayed. Returns nil if the layer has not yet been committed. * The effect of attempting to modify the returned layer in any way is undefined. * The `sublayers&apos;, `mask&apos; and `superlayer&apos; properties of the returned * layer return the presentation versions of these properties. This * carries through to read-only layer methods. E.g., calling -hitTest: * on the result of the -presentationLayer will query the presentation * values of the layer tree. */ - (nullable instancetype)presentationLayer; /* When called on the result of the -presentationLayer method, returns * the underlying layer with the current model values. When called on a * non-presentation layer, returns the receiver. The result of calling * this method after the transaction that produced the presentation * layer has completed is undefined. */ - (instancetype)modelLayer; @interface EOCShapeLayer : CAShapeLayer @property(nonatomic, assign)CGColorRef bgColor; @end @implementation EOCShapeLayer + (BOOL)needsDisplayForKey:(NSString *)key { //你这个key属性变化的时候，是否需要调用display方法 : displayLayer:layer或者drawLayerInContext:context if ([key isEqualToString:@&quot;bgColor&quot;]) { return YES; } return [super needsDisplayForKey:key]; } - (void)display { EOCShapeLayer *tmpShapeLayer = (EOCShapeLayer *)self.presentationLayer; self.backgroundColor = tmpShapeLayer.bgColor; NSLog(@&quot;color %@&quot;, self.backgroundColor); } @end - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event { //modelLayer和selflayer是同一个layer，presentationLayer是重新生成的layer NSLog(@&quot;modelLayer %@&quot;, layer.modelLayer); NSLog(@&quot;selflayer %@&quot;, layer); NSLog(@&quot;presentationLayer %@&quot;, layer.presentationLayer); } 关键帧动画KeyFrameAnimation @implementation EOCKeyFrameAnimationViewController - (void)viewDidLoad { [super viewDidLoad]; self.view.backgroundColor = [UIColor whiteColor]; //fromValue、toValue 设置很多值，赋值给path CAShapeLayer *pathLayer = [CAShapeLayer layer]; UIBezierPath *path = [UIBezierPath bezierPath]; [path moveToPoint:CGPointMake(40.f, 175.f)]; [path addCurveToPoint:CGPointMake(300.f, 175.f) controlPoint1:CGPointMake(50.f, 40.f) controlPoint2:CGPointMake(200.f, 300.f)]; pathLayer.path = path.CGPath; pathLayer.lineWidth = 2.f; pathLayer.fillColor = [UIColor clearColor].CGColor; [pathLayer setStrokeColor:[UIColor redColor].CGColor]; [self.view.layer addSublayer:pathLayer]; shapeLayer = [CAShapeLayer layer]; shapeLayer.contents = (__bridge id)[UIImage imageNamed:@&quot;plane.png&quot;].CGImage; shapeLayer.bounds = CGRectMake(0.f, 0.f, 50.f, 50.f); shapeLayer.position = CGPointMake(40.f, 175.f); [self.view.layer addSublayer:shapeLayer]; CAKeyframeAnimation *anim = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;]; // anim.beginTime = CACurrentMediaTime() + 2.f; anim.duration = 2.f; anim.timeOffset = 1.f; anim.rotationMode = kCAAnimationRotateAuto; anim.autoreverses = YES; anim.delegate = self; anim.path = path.CGPath; anim.calculationMode = kCAAnimationCubicPaced; //pace cubicPace pace：匀速 // anim.values = @[[NSValue valueWithCGPoint:CGPointMake(100, 100)], [NSValue valueWithCGPoint:CGPointMake(200, 300)], [NSValue valueWithCGPoint:CGPointMake(50, 500)]]; [anim setValue:@&quot;八点钟学院&quot; forKey:@&quot;eoc&quot;]; // anim.keyTimes = @[@0, @0.75, @1]; //每一个值都是要小于1 [shapeLayer addAnimation:anim forKey:@&quot;eoc&quot;]; NSLog(@&quot;animation %@&quot;, anim); } @end 动画组(将属性动画组合成组) - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event { //同时缩放，平移，旋转 CAAnimationGroup * group = [CAAnimationGroup animation]; CABasicAnimation * rotation = [CABasicAnimation animation]; rotation.keyPath = @&quot;transform.rotation&quot;; rotation.toValue = @(arc4random_uniform(M_PI)); CABasicAnimation * scale = [CABasicAnimation animation]; scale.keyPath = @&quot;transform.scale&quot;; scale.toValue =@ 0.5; CABasicAnimation * position = [CABasicAnimation animation]; position.keyPath = @&quot;position&quot;; position.toValue = [NSValue valueWithCGPoint:CGPointMake(arc4random_uniform(200), arc4random_uniform(200))]; group.animations = @[rotation,scale,position]; //取消动画反弹 group.removedOnCompletion = NO; //设置动画执行完成后保持最新的效果 group.fillMode = kCAFillModeForwards; [_redView.layer addAnimation:group forKey:nil]; } 动画和layer的MediaTiming属性 上例中已经提到beginTime/timeOffset/speed //机器时间：手机最近一次重启到现在的时间 //anim的beginTime是相对于layer的beginTime的，layer的beginTime默认是为机器时间+一个正值，anim的beginTime就是layer的beginTime+一个正值 //timeOffset是动画的偏移时间，就是从某个时间点动画的位置开始动画 //speed是动画的速度动画的实际速度speed = layer.speed x anim.speed 过渡动画 @implementation EOCTransitionViewController /** 并不作用于指定的图层属性，这就是说你可以在即使不能准确得 知改变了什么的情况下对图层做动画 可以用-addAnimation:forKey:方法为layer添加一个动画 如果需要获取则通过函数中的key参数来在添加动画之后检索一个动画- (CAAnimation *)animationForKey:(NSString *)key;但并不支持在动画运行过程中修改动画，所以这个方法主要用来检测动画的属性，或者判断它是否被添加到当前图层中。 为了终止一个指定的动画，你可以用如下方法把它从图层移除掉：- (void)removeAnimationForKey:(NSString *)key;或者移除所有动画：- (void)removeAllAnimations; 动画一旦被移除，图层的外观就立刻更新到当前的模型图层的值。一般说来，动画在结束之后被自动移除，除非设置removedOnCompletion为NO，如果你设置动画在结束之后不被自动移除，那么当它不需要的时候你要手动移除它；否则它会一直存在于内存中，直到图层被销毁。 */ //合法的转场动画类型有： //fade：默认。faker淡出，layer淡入 //moveIn：layer移入覆盖faker //push：layer推入，faker推出 //reveal：覆盖在layer上面的faker被移出 //私有：（被苹果ban了，不建议直接使用） //cube：立方体旋转，layer将会在呈现的面，faker在不可见的面 //suckEffect：覆盖在layer上面的faker被抽离 //oglFlip：将背面的layer翻转到前面，faker翻转到背面、、 //rippleEffect：伴随着水面波动动画，faker淡出，layer淡入 //pageCurl：翻到下一页，faker被翻走，呈现layer //pageUnCurl：翻回上一页，layer被翻回并覆盖faker //cameraIrisHollowOpen：下面这两个是特殊的。镜头开，同时呈现部分为透明，而不是layer //cameraIrisHollowClose：类似上面，镜头关 //subtype //4个子类型，表示上左下右4个转场动画方向： //fromTop //fromLeft //fromBottom //fromRight - (void)viewDidLoad { [super viewDidLoad]; self.view.backgroundColor = [UIColor whiteColor]; shapeLayer = [CAShapeLayer layer]; shapeLayer.contents = (__bridge id)[UIImage imageNamed:@&quot;plane.png&quot;].CGImage; shapeLayer.frame = CGRectMake(25.f, 75.f, 50.f, 50.f); [self.view.layer addSublayer:shapeLayer]; } - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event { CATransition *anim = [CATransition animation]; anim.type = @&quot;cube&quot;; anim.subtype = kCATransitionFromRight; anim.duration = 4.f; [shapeLayer addAnimation:anim forKey:nil]; shapeLayer.contents = (__bridge id)[UIImage imageNamed:@&quot;bg-mine.png&quot;].CGImage; } @end iOS动画之转场动画 自定义转场动画 //与转场动画相关的头文件UIViewControllerTransitioning.h中包括 //协议：UIViewControllerContextTransitioning：由系统组装来传数据给animator //协议：UIViewControllerAnimatedTransitioning：提供动画时间及动画内容 //协议：UIViewControllerInteractiveTransitioning： //协议：UIViewControllerTransitioningDelegate： EOCNextViewController *nextViewController = [[EOCNextViewController alloc] init]; nextViewController.transitioningDelegate = self; [self presentViewController:nextViewController animated:YES completion:nil]; #pragma mark - UIViewControllerTransitionDelegate method - (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source { NSLog(@&quot;animationControllerForPresentedController&quot;); //present的时候的动画对象 return [[EOCPresentAnimator alloc] init]; } - (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed { //dismiss的时候的动画对象 return [[EOCDismissAnimator alloc] init]; } EOCPresentAnimator @interface EOCPresentAnimator : NSObject&lt;UIViewControllerAnimatedTransitioning&gt; @end @implementation EOCPresentAnimator - (NSTimeInterval)transitionDuration:(nullable id &lt;UIViewControllerContextTransitioning&gt;)transitionContext { return 2.f; } - (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext { //A控制器 到 B控制器 //获取B控制器的view fromView：A； toView：B UIView *toView = [transitionContext viewForKey:UITransitionContextToViewKey]; CGRect toViewFrame = toView.frame; //(0,0,width,height) //我要让toView的y坐标变为 height CGRect animateFrame = CGRectOffset(toViewFrame, 0.f, [UIScreen mainScreen].bounds.size.height); //让frame的x和y坐标分别有0和[UIScreen mainScreen].bounds.size.height的偏移 toView.frame = animateFrame; UIView *containerView = [transitionContext containerView]; [containerView addSubview:toView]; [UIView animateWithDuration:2.f animations:^{ toView.frame = toViewFrame; } completion:^(BOOL finished) { //completeTransition：把fromView给移除 [transitionContext completeTransition:YES]; }]; } @end EOCDismissAnimator @interface EOCDismissAnimator : NSObject&lt;UIViewControllerAnimatedTransitioning&gt; @end @implementation EOCDismissAnimator - (NSTimeInterval)transitionDuration:(nullable id &lt;UIViewControllerContextTransitioning&gt;)transitionContext { return 2.f; } - (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext { //toView：A fromView：B UIView *toView = [transitionContext viewForKey:UITransitionContextToViewKey]; UIView *fromView = [transitionContext viewForKey:UITransitionContextFromViewKey]; //对fromView：B进行操作 CGRect fromViewFrame = fromView.frame; CGRect finalFrame = CGRectOffset(fromViewFrame, 0.f, [UIScreen mainScreen].bounds.size.height); //添加toView UIView *containerView = [transitionContext containerView]; [containerView addSubview:toView]; [containerView sendSubviewToBack:toView]; [UIView animateWithDuration:2.f animations:^{ NSLog(@&quot;animation&quot;); fromView.frame = finalFrame; } completion:^(BOOL finished) { NSLog(@&quot;completion&quot;); //![transitionContext transitionWasCancelled] 而不是YES，很重要 [transitionContext completeTransition:![transitionContext transitionWasCancelled]]; }]; } @end 交互式动画效果 EOCInteractiveTransitioning *interactiveTransiton; EOCNextViewController *nextViewController = [[EOCNextViewController alloc] init]; [interactiveTransiton transitionToViewController:nextViewController]; nextViewController.transitioningDelegate = self; [self presentViewController:nextViewController animated:YES completion:nil]; - (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForDismissal:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator { return interactiveTransiton.isInteractive?interactiveTransiton:nil; } @interface EOCInteractiveTransitioning : UIPercentDrivenInteractiveTransition //会影响退出按钮的正常使用 @property(nonatomic, assign)BOOL isInteractive; - (void)transitionToViewController:(UIViewController *)viewController; @end @interface EOCInteractiveTransitioning() @property(nonatomic ,assign) BOOL shouldComplete; @property(nonatomic, strong) UIViewController *presentingVC; @end @implementation EOCInteractiveTransitioning - (void)transitionToViewController:(UIViewController *)viewController { self.presentingVC = viewController; //添加手势 UIPanGestureRecognizer *panGesture = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(handleGestureAction:)]; [self.presentingVC.view addGestureRecognizer:panGesture]; } //松手后 回弹的速度，默认值为1 - (CGFloat)completionSpeed { return 0.2; } #pragma mark - 手势执行方法 - (void)handleGestureAction:(UIPanGestureRecognizer *)gesture { //根据手势状态来进行不同的操作 switch (gesture.state) { case UIGestureRecognizerStateBegan: self.isInteractive = YES; //触发一下非交互式动画的动作 [self.presentingVC dismissViewControllerAnimated:YES completion:nil]; break; case UIGestureRecognizerStateChanged: { //获取到你下拉的距离，那么如果这个距离超过了我预定距离的一半，那么执行dismiss操作，否则取消本次dismiss操作 CGPoint transsitionPoint = [gesture translationInView:self.presentingVC.view]; CGFloat ratio = transsitionPoint.y / 400; if (ratio &gt; 0.5) { //设置标记值为YES self.shouldComplete = YES; } else { self.shouldComplete = NO; } [self updateInteractiveTransition:ratio]; } break; case UIGestureRecognizerStateEnded: case UIGestureRecognizerStateCancelled: { if (!self.shouldComplete) { [self cancelInteractiveTransition]; } else { [self finishInteractiveTransition]; } } break; default: break; } } @end 根据原理自定义 #pragma mark - 自定义转场 //transitionToChildViewController相当于presentViewController - (void)transitionToChildViewController:(UIViewController *)toViewViewController { //首先判断self你有没有childViewController UIViewController *fromViewController = [self.childViewControllers count]&gt;0?self.childViewControllers[0]:nil; //如果两者一样，就啥也不做，直接返回 if (fromViewController == toViewViewController) { return; } //把toViewController添加进来 [self addChildViewController:toViewViewController]; if (!fromViewController) { [containerView addSubview:toViewViewController.view]; return; } //不是第一个的时候，有转场动画，有fromViewController存在，那么你要从fromViewController 到 toViewController //1、生成一个动画对象 id &lt;UIViewControllerAnimatedTransitioning&gt;animator = [[EOCAnimatorTwo alloc] init]; //生成context对象 myTransitionContext *context = [[myTransitionContext alloc] initWithFromViewController:fromViewController toViewController:toViewViewController]; [animator animateTransition:context]; } @interface myTransitionContext : NSObject &lt;UIViewControllerContextTransitioning&gt; - (instancetype)initWithFromViewController:(UIViewController *)fromViewController toViewController:(UIViewController *)toViewController; - (void)completeTransition:(BOOL)didComplete; @end #pragma mark - 创建动画上下文对象 @interface myTransitionContext () @property(nonatomic, strong)NSDictionary *myViews; @property(nonatomic, strong)NSDictionary *myViewControllers; @property(nonatomic, strong)UIView *containerView; @end //这里警告多，是因为我没有实现协议里的方法 @implementation myTransitionContext - (instancetype)initWithFromViewController:(UIViewController *)fromViewController toViewController:(UIViewController *)toViewController { if (self = [super init]) { _myViews = @{UITransitionContextToViewKey:toViewController.view,UITransitionContextFromViewKey:fromViewController.view}; _myViewControllers = @{UITransitionContextToViewControllerKey:toViewController,UITransitionContextFromViewControllerKey:fromViewController}; self.containerView = fromViewController.view.superview; } return self; } - (nullable __kindof UIView *)viewForKey:(UITransitionContextViewKey)key { return self.myViews[key]; } - (void)completeTransition:(BOOL)didComplete { //干掉fromViewcontroller [self.myViews[UITransitionContextFromViewKey] removeFromSuperview];[self.myViewControllers[UITransitionContextFromViewControllerKey] removeFromParentViewController]; } @end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>iOS</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IM知识框架]]></title>
    <url>%2F2017%2F11%2F24%2FIM%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[IM英文为InstantMessaging，即时通讯 客户端网络自顶而下分为应用层(应用层、表示层、会话层)、传输层(TCP/UDP)、硬件层(网络层、数据链路层、物理层) 物理层– wire,radio协议 数据链路层– Ethernet, Token ring协议等 网络层– IP协议 传输层– TCP、UDP协议 会话层– ASAP，TLS协议 表示层– XDR协议 应用层– HTTP协议 TCP/IP连接 手机能够使用联网功能是因为手机底层实现了TCP/IP协议，可以使手机终端通过无线网络建立TCP连接。TCP协议可以对上层网络提供接口，使上层网络数据的传输建立在“无差别”的网络之上。 建立起一个TCP连接需要经过“三次握手”： 第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”（过程就不细写了，就是服务器和客户端交互，最终确定断开）. IP地址（主机名） 本地地址127.0.0.1 主机名localhost，每台电脑都有存在一个 端口号 a.和进程关联起来的（IOS App）b.有效端口号：0～65535 其中0～1024由系统使用或保留 socket编程有两种模型:SOCK_DGRAM(UDP)/SOCK_STREAM(TCP) TCP:有连接/数据可靠/无边界/双工/C/S模型 UDP:无连接/数据不可靠/有边界/双工/对等模型 TCP数据的无边界(STREAM) 需要建立连接 通过三次握手完成连接（connect（ack）） 数据没有限制 UDP（DGRAM） 不需要建立链接（所以速度快） 只管发送，不确认对方是接收（不可靠） 每个数据包的大小限制在64K内 MSG_WAITALL:标记控制数据接收必须接受到指定字节长度才返回, 利用MSG_WAITALL接收指定长度的数据,达到数据分边界 TCP实现 /* ipv4 2的32次方幂（255.255.255.255） ip 数量（40个亿） ipv6 2的128次方幂 抢购物品 （50个） 长轮询（短轮询）长链接 短链接 请求物品数量还有多少个的时候 （发送一个请求）服务做一个操作，去查询数量（当发现数量还是49个时候，不给客户短返回数据，当数量变化的时候，少了一个了48，返回数据给客户端） 测试：终端中输入`nc -l 8888`测试TCP、输入`nc -lu 9999`测试UDP */ @interface chatC : NSObject - (void)buildClient; - (void)sendData:(NSString*)content; @end #import &lt;sys/socket.h&gt; #import &lt;netinet/in.h&gt; #import &lt;arpa/inet.h&gt; @implementation chatC static int fd; - (void)buildClient{ /* ipv4 SOCK_STREAM TCP SOCK_DGRAM UDP SOCK_RAW 套接字 fd 是一个文件 */ // 1.1.建立socket fd = socket(AF_INET, SOCK_STREAM, 0); if (fd == -1) { NSLog(@&quot;socket fail&quot;); } //1.2.连接服务器 struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;); addr.sin_port = htons(8888); //三次握手发生在方法connect中：1 发送一个信号给服务端，在吗（ACK） 2服务端回一个（ACK）我在 3 客户端，那我们就开始吧 int result = connect(fd, (struct sockaddr *)&amp;addr, sizeof(addr)); if (result == -1) { NSLog(@&quot;connect fail&quot;); } //1.3.发送数据 [NSThread detachNewThreadSelector:@selector(threadSendData:) toTarget:self withObject:@&quot;123456&quot;]; //1.4.循环接收数据 [NSThread detachNewThreadSelector:@selector(threadRecvData) toTarget:self withObject:nil]; //1.5.关闭连接 } - (void)threadSendData:(NSString*)content{ if (content.length == 0) { return; } //content = @&quot;八点钟&quot;; // content.length = 3; const char* contC = [content UTF8String]; ssize_t result = send(fd, contC, strlen(contC), 0); if (result &lt; 0) { NSLog(@&quot;send fail&quot;); } } - (void)threadRecvData{ char buf[32]; while (1) { /* 0 阻塞 MSG_WAITALL 等待缓存满了才不阻塞 */ ssize_t result = recv(fd, buf, 32, MSG_WAITALL); if (result &lt;= 0) { NSLog(@&quot;recv fail!&quot;); break; } //遇到0才会终止 buf[result] = 0; NSLog(@&quot;%s&quot;, buf); } close(fd); } @end UDP实现 UDP和TCP差异不大 1. fd = socket(AF_INET, SOCK_DGRAM, 0); 2. recvfrom / sendto 3. sendto 时没有返回值，不能确定服务器是否接收到 @interface chatcUDP : NSObject - (void)buildClient; - (void)sendData:(NSString*)content; @end static int fd; static struct sockaddr_in addr; @implementation chatcUDP - (void)buildClient{ // 1.1.建立socket fd = socket(AF_INET, SOCK_DGRAM, 0); if (fd == -1) { NSLog(@&quot;socket fail&quot;); } //1.2.连接服务器 addr.sin_family = AF_INET; addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;); addr.sin_port = htons(8888); //1.3.发送数据 [NSThread detachNewThreadSelector:@selector(threadSendData:) toTarget:self withObject:content]; //1.4.循环接收数据 [NSThread detachNewThreadSelector:@selector(threadRecvData) toTarget:self withObject:nil]; //1.5.关闭连接 } - (void)threadRecvData{ char buf[32]; while (1) { // ssize_t result = recv(fd, buf, 32, 0); socklen_t size = (socklen_t)sizeof(addr); ssize_t result = recvfrom(fd, buf, 32, 0, (struct sockaddr *)&amp;addr, &amp;size); if (result &lt;= 0) { NSLog(@&quot;recv fail!&quot;); break; } buf[result] = 0; NSLog(@&quot;%s&quot;, buf); } close(fd); } - (void)threadSendData:(NSString*)content{ if (content.length == 0) { return; } //content = @&quot;八点钟&quot;; // content.length = 3; const char* contC = [content UTF8String]; //不能根据result确定服务器是否接收到 //UDP跟TCP相比，服务器的开支要小很多，所以聊天平台都是采用UDP协议，这样，为了让对方知道自己收到消息，则需要额外发送一条消息告诉对方。 ssize_t result = sendto(fd, contC, strlen(contC), 0, (struct sockaddr *)&amp;addr, sizeof(addr)); } @end 所谓的心跳包就是客户端定时发送简单的信息给服务器端告诉它我还在而已。代码就是每隔几分钟发送一个固定信息给服务端，服务端收到后回复一个固定信息如果服务端几分钟内没有收到客户端信息则视客户端断开。比如有些通信软件长时间不使用，要想知道它的状态是在线还是离线就需要心跳包，定时发包收包。发包方：可以是客户也可以是服务端，看哪边实现方便合理。一般是客户端。服务器也可以定时轮询发心跳下去。心跳包之所以叫心跳包是因为：它像心跳一样每隔固定时间发一次，以此来告诉服务器，这个客户端还活着。事实上这是为了保持长连接，至于这个包的内容，是没有什么特别规定的，不过一般都是很小的包，或者只包含包头的一个空包。在TCP的机制里面，本身是存在有心跳包的机制的，也就是TCP的选项。系统默认是设置的是2小时的心跳频率。但是它检查不到机器断电、网线拔出、防火墙这些断线。而且逻辑层处理断线可能也不是那么好处理。一般，如果只是用于保活还是可以的。心跳包一般来说都是在逻辑层发送空的包来实现的。下一个定时器，在一定时间间隔下发送一个空包给客户端，然后客户端反馈一个同样的空包回来，服务器如果在一定时间内收不到客户端发送过来的反馈包，那就只有认定说掉线了。只需要send或者recv一下，如果结果为零，则为掉线。但是，在长连接下，有可能很长一段时间都没有数据往来。理论上说，这个连接是一直保持连接的，但是实际情况中，如果中间节点出现什么故障是难以知道的。更要命的是，有的节点（防火墙）会自动把一定时间之内没有数据交互的连接给断掉。在这个时候，就需要我们的心跳包了，用于维持长连接，保活。在获知了断线之后，服务器逻辑可能需要做一些事情，比如断线后的数据清理呀，重新连接呀当然，这个自然是要由逻辑层根据需求去做了。总的来说，心跳包主要也就是用于长连接的保活和断线处理。一般的应用下，判定时间在30-40秒比较不错。如果实在要求高，那就在6-9秒。 服务端服务端的实现 /* XMPP：开源框架，xml数据通讯，太多冗余信息，流量占用多 MQTT：伪实时性 通过apns实现 对用户量少，实时性低的应用可用 WebSocket 自己创建 */ @interface ChatS : NSObject - (int)buildServer; @end //服务的套接字 static int serverfd; //可以看做一个数组容器，存放当前所有的客户端套接字fd //当客户端连接上了服务端，服务端会给客户端创建一个对应的套接字 //比如如果有2个客户端，服务端则会生成两个fd static fd_set allfd; //fd(1)、fd(2)发消息过来，监听得到fd变化，把变化的放到这个容器中来 static fd_set changefds; //allFd里最大的fd值 static int maxfd; //changefds里最大的fd值 static int maxchangefds; // select poll服务器 @implementation ChatS - (int)buildServer { // 1.1.建立socket serverfd = socket(AF_INET, SOCK_STREAM, 0); if (serverfd == -1) { printf(&quot;socket fail\n&quot;); } else { printf(&quot;socket suss\n&quot;); } struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_addr.s_addr = inet_addr(&quot;192.168.2.4&quot;); addr.sin_port = htons(8888); //1.2.bind int result = bind(serverfd, (struct sockaddr *)&amp;addr, sizeof(addr)); if (result == -1) { printf(&quot;bind fail\n&quot;); return 0; } else { printf(&quot;bind succ\n&quot;); } //1.3.listen //每次只能同时响应10个客户端，假如有15个客户端连接上来了，那么他最多处理10个，其他5个就会被拒绝 result = listen(serverfd, 10); if (result == -1) { printf(&quot;listen fail\n&quot;); return 0; } else { printf(&quot;listen succ\n&quot;); } //1.4.select while (1) { FD_ZERO(&amp;changefds); //FD_SET(fd_set *fdset);用于在文件描述符集合中增加一个新的文件描述符 //把服务端的fd添加到changefds 往容器set里面存值 FD_SET(serverfd, &amp;changefds); maxfd = maxfd&lt;serverfd?serverfd:maxfd; for (int i=0; i&lt;=maxfd; i++) { if (FD_ISSET(i, &amp;allfd)) { //添加客户端的fd到changefds里面 FD_SET(i, &amp;changefds); maxfd = maxfd&lt;i?i:maxfd; } } //select阻塞，当客户端有响应的时候(连接或者发消息)阻塞就结束 //有变化的fd就保留在allfd中，所以我们需要把allfd容器中的fd拷贝处理 //轮询套接字的状态，如果没有变化就一直轮询阻塞，如果有变化，阻塞解除 //如果有变化，则会把变化保留在changefds中，其他的自动删除 result = select(maxfd + 1, &amp;changefds, 0, 0, 0);//阻塞，客户端没有响应 //如果serverfd还存在changefds容器里边，那么说明serverfd有状态，这个状态代表有客户端连接进来了 //这个if主要是查看是否有人来连接 if (FD_ISSET(serverfd, &amp;changefds)) { printf(&quot;有人来连接了\n&quot;); //接受连接，会给客户端生成一个对应的套接字fd int fd = accept(serverfd, 0, 0); if (fd == -1) { printf(&quot;连接失败\n&quot;); break; } maxfd = maxfd&lt;fd?fd:maxfd; FD_SET(fd, &amp;allfd); } //处理客户端的事情 //没有提供直接读取fd_set的方法 要读取changefds里边的对象，需使用以下方法 char buf[256]; for (int i=0; i&lt;=maxfd; i++) { //FD_ISSET(i, &amp;allfd) fd是没有断开的 if (FD_ISSET(i, &amp;changefds) &amp;&amp; FD_ISSET(i, &amp;allfd)) { result = (int)recv(i, buf, 255, 0); if (result&lt;=0) { printf(&quot;有人退出了\n&quot;); //把这个套接字从allfd里边移除 FD_CLR(i, &amp;allfd); } buf[result] = 0; printf(&quot;来自客户端的数据：%d%s\n&quot;, result, buf); } //广播数据(对每一个连接上的客户端发送数据) for (int j=0; j&lt;=maxfd; j++) { if (FD_ISSET(j, &amp;allfd)) { result = (int)send(j, buf, strlen(buf), 0); } } } } //1.5.状态(客户的状态) //1.6 close close(serverfd); return 0; } @end HTTP原理 HTTP iOS API运用 + (void)netLoadBlock { NSURL *url = [NSURL URLWithString:URLPath]; NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url]; [request setHTTPMethod:@&quot;POST&quot;]; NSString *bodyStr = @&quot;versions_id=1&amp;system_type=1&quot;; [request setHTTPBody:[bodyStr dataUsingEncoding:NSUTF8StringEncoding]]; NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; NSURLSessionTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) { if (error) { NSLog(@&quot;%@&quot;, error); } else { NSLog(@&quot;%@&quot;, response); NSDictionary *infoDic = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingAllowFragments error:nil]; NSLog(@&quot;%@&quot;, infoDic); } }]; [task resume]; } Socket封装Get方法 + (void)startHttpGet { // 1.1.建立socket int fd = socket(AF_INET, SOCK_STREAM, 0); if (fd == -1) { NSLog(@&quot;socket fail&quot;); } //1.2.连接服务器 struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_addr.s_addr = inet_addr(&quot;47.96.219.75&quot;); addr.sin_port = htons(80); int result = connect(fd, (struct sockaddr *)&amp;addr, sizeof(addr)); if (result == -1) { NSLog(@&quot;connect fail&quot;); } //1.3.发送数据 char buf[4096]; bzero(buf, 4096); /* 1 方法名 请求路径 http协议版本号 用空格作为间隔 2 域名/ip 3 连接的状态 Connection:Close keep-alive(长连接) 4 Accept:* 可以接收到的数据类型 5 结束符 \r\n */ sprintf(buf, &quot;GET /center/front/app/util/updateVersions?versions_id=1&amp;system_type=1 HTTP/1.1\r\n&quot; &quot;Host: svr.tuliu.com\r\n&quot; &quot;Connection: Close\r\n&quot; &quot;Accept:*/*\r\n&quot; &quot;\r\n&quot;); result = (int)send(fd, buf, strlen(buf), 0); if (result&lt;=0) { NSLog(@&quot;send fail&quot;); return; } NSLog(@&quot;send suss&quot;); //1.4.接收数据 char recvbuf[4096]; while (1) { bzero(recvbuf, 4096); int length = (int)recv(fd, recvbuf, 4096, 0); if (length&lt;=0) { printf(&quot;断开了&quot;); break; } recvbuf[length] = 0; NSLog(@&quot;==================&quot;); NSLog(@&quot;%s&quot;, recvbuf); NSLog(@&quot;==================&quot;); } //1.5.关闭连接 } Socket封装Post方法 + (void)startHttpPost { // 1.1.建立socket int fd = socket(AF_INET, SOCK_STREAM, 0); if (fd == -1) { NSLog(@&quot;socket fail&quot;); } //1.2.连接服务器 struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_addr.s_addr = inet_addr(&quot;47.96.219.75&quot;); addr.sin_port = htons(80); int result = connect(fd, (struct sockaddr *)&amp;addr, sizeof(addr)); if (result == -1) { NSLog(@&quot;connect fail&quot;); } //1.3.发送数据 char buf[4096]; bzero(buf, 4096); /* 1 方法名 请求路径 http协议版本号 用空格作为间隔 2 域名/ip 3 连接的状态 Connection:Close keep-alive(长连接) 4 Accept:* 可以接收到的数据类型 5 结束符 \r\n 6 post 请求头 一个Content-Type Content-Length 7 参数体 body versions_id=1&amp;system_type=1 */ sprintf(buf, &quot;POST /center/front/app/util/updateVersions HTTP/1.1\r\n&quot; &quot;Host: svr.tuliu.com\r\n&quot; &quot;Connection: keep-alive\r\n&quot; &quot;Content-Type: application/x-www-form-urlencoded\r\n&quot; &quot;Content-Length: 27\r\n&quot; &quot;Accept:*/*\r\n&quot; &quot;\r\n&quot; &quot;versions_id=1&amp;system_type=1&quot; &quot;\r\n&quot;); result = (int)send(fd, buf, strlen(buf), 0); if (result&lt;=0) { NSLog(@&quot;send fail&quot;); return; } NSLog(@&quot;send suss&quot;); //1.4.接收数据 char recvbuf[4096]; while (1) { bzero(recvbuf, 4096); int length = (int)recv(fd, recvbuf, 4096, 0); if (length&lt;=0) { printf(&quot;断开了&quot;); break; } recvbuf[length] = 0; NSLog(@&quot;==================&quot;); NSLog(@&quot;%s&quot;, recvbuf); NSLog(@&quot;==================&quot;); } //1.5.关闭连接 }]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>iOS</tag>
        <tag>IM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主题模型切换框架解析]]></title>
    <url>%2F2017%2F10%2F27%2F%E4%B8%BB%E9%A2%98%E6%A8%A1%E5%9E%8B%E5%88%87%E6%8D%A2%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[主题模型切换 给NSObject扩展Theme，添加pickers属性来保存方法，这些方法用来更改主题颜色 @interface NSObject (EOCTheme) @property(nonatomic, strong)NSMutableDictionary *pickers; @end @implementation NSObject (EOCTheme) @dynamic pickers; - (NSMutableDictionary *)pickers { NSMutableDictionary *dict = objc_getAssociatedObject(self, @selector(pickers)); if (!dict) { //添加通知 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(changeTheme) name:@&quot;changeTheme&quot; object:nil]; dict = [NSMutableDictionary dictionary]; objc_setAssociatedObject(self, @selector(pickers), dict, OBJC_ASSOCIATION_RETAIN_NONATOMIC); } return dict; } - (void)changeTheme { //遍历字典 NSMutableDictionary *dict = self.pickers; [dict enumerateKeysAndObjectsUsingBlock:^(NSString *key, eocBlock block, BOOL * _Nonnull stop) { //key：value == selectorString：block SEL selector = NSSelectorFromString(key); #pragma clang diagnostic push #pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; [self performSelector:selector withObject:block([EOCThemeManager shareThemeManager].currentTheme)]; #pragma clang diagnostic pop }]; } 给UIButton添加设置背景颜色的扩展 @interface UIButton (EOCTheme) @property(nonatomic, strong)eocBlock eocBgColorPicker; @end @implementation UIButton (EOCTheme) @dynamic eocBgColorPicker; - (void)setEocBgColorPicker:(eocBlock)eocBgColorPicker { objc_setAssociatedObject(self, @selector(setEocBgColorPicker:), eocBgColorPicker, OBJC_ASSOCIATION_RETAIN_NONATOMIC); //调用系统的方法 [self setBackgroundColor:eocBgColorPicker([EOCThemeManager shareThemeManager].currentTheme)]; //保存起来 [self.pickers setObject:eocBgColorPicker forKey:NSStringFromSelector(@selector(setBackgroundColor:))]; } @end 设置单例模式EOCThemeManager typedef UIColor *(^eocBlock)(NSString *currentTheme); @interface EOCThemeManager : NSObject #define EOCPicker(key) [[EOCThemeManager shareThemeManager]pickerWithKey:@#key] @property(nonatomic, strong)NSMutableDictionary *themeDict; @property(nonatomic, strong)NSString *currentTheme; @property(nonatomic, strong)NSString *testName; +(instancetype)shareThemeManager; - (eocBlock)pickerWithKey:(NSString *)key; @end @implementation EOCThemeManager +(instancetype)shareThemeManager { static dispatch_once_t onceToken; static EOCThemeManager *themeManager; dispatch_once(&amp;onceToken, ^{ themeManager = [[EOCThemeManager alloc] init]; //配置主题数据源 [themeManager readThemeFromFile:@&quot;themeColorTable.plist&quot;]; }); return themeManager; } - (void)readThemeFromFile:(NSString *)file { NSString *filePath = [[NSBundle mainBundle] pathForResource:file.stringByDeletingPathExtension ofType:file.pathExtension]; NSMutableDictionary *dict = [NSMutableDictionary dictionaryWithContentsOfFile:filePath]; //把十六进制变成UIColor保存到NSDictionary里 NSEnumerator *keyEnumerator = [dict keyEnumerator]; NSString *key; while (key = [keyEnumerator nextObject]) { NSMutableDictionary *tmpDict = dict[key]; //{normal:#00aa00, night:#6600ff , red:#ffffff} [tmpDict enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) { NSString *colorString = tmpDict[key]; UIColor *color = [colorString stringToUIColor]; tmpDict[key] = color; }]; dict[key] = tmpDict; } self.themeDict = dict; } - (void)setCurrentTheme:(NSString *)currentTheme { _currentTheme = currentTheme; //抛出通知 [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;changeTheme&quot; object:nil]; } //@property和@synthesize 共同做了两个事：1、生成setter和getter方法 2、生成了_propertyName的成员变量 //当你同时手写了setter和getter方法后 @synthesize就失效了，等同于@dynamic，此时就不会生成_propertyName的成员变量 - (void)setTestName:(NSString *)testName { _testName = testName; } //- (NSString *)testName { // return _testName; //} //返回block - (eocBlock)pickerWithKey:(NSString *)key { NSMutableDictionary *dict = [EOCThemeManager shareThemeManager].themeDict; NSDictionary *tmpDict = dict[key]; eocBlock picker = ^(NSString *theme) { return tmpDict[theme]; }; return picker; } @end 定义配置文件 &lt;plist version=&quot;1.0&quot;&gt; &lt;dict&gt; &lt;key&gt;BG&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NORMAL&lt;/key&gt; &lt;string&gt;#F0F8FF&lt;/string&gt; &lt;key&gt;NIGHT&lt;/key&gt; &lt;string&gt;#FFEC8B&lt;/string&gt; &lt;key&gt;RED&lt;/key&gt; &lt;string&gt;#ff0000&lt;/string&gt; &lt;/dict&gt; &lt;key&gt;SEP&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NORMAL&lt;/key&gt; &lt;string&gt;#ffffff&lt;/string&gt; &lt;key&gt;NIGHT&lt;/key&gt; &lt;string&gt;#343434&lt;/string&gt; &lt;key&gt;RED&lt;/key&gt; &lt;string&gt;#fafafa&lt;/string&gt; &lt;/dict&gt; &lt;key&gt;TINT&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NORMAL&lt;/key&gt; &lt;string&gt;#ffffff&lt;/string&gt; &lt;key&gt;NIGHT&lt;/key&gt; &lt;string&gt;#343434&lt;/string&gt; &lt;key&gt;RED&lt;/key&gt; &lt;string&gt;#fafafa&lt;/string&gt; &lt;/dict&gt; &lt;key&gt;TEXT&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NORMAL&lt;/key&gt; &lt;string&gt;#ffffff&lt;/string&gt; &lt;key&gt;NIGHT&lt;/key&gt; &lt;string&gt;#343434&lt;/string&gt; &lt;key&gt;RED&lt;/key&gt; &lt;string&gt;#fafafa&lt;/string&gt; &lt;/dict&gt; &lt;key&gt;BAR&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NORMAL&lt;/key&gt; &lt;string&gt;#ffffff&lt;/string&gt; &lt;key&gt;NIGHT&lt;/key&gt; &lt;string&gt;#343434&lt;/string&gt; &lt;key&gt;RED&lt;/key&gt; &lt;string&gt;#fafafa&lt;/string&gt; &lt;/dict&gt; &lt;key&gt;HIGHLIGHTED&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NORMAL&lt;/key&gt; &lt;string&gt;#ffffff&lt;/string&gt; &lt;key&gt;NIGHT&lt;/key&gt; &lt;string&gt;#343434&lt;/string&gt; &lt;key&gt;RED&lt;/key&gt; &lt;string&gt;#fafafa&lt;/string&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/plist&gt; 第三方框架DKNightVersion完整版逻辑]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>iOS</tag>
        <tag>框架解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[APP文件结构分析(沙盒分析)+数据存储安全]]></title>
    <url>%2F2017%2F09%2F29%2FAPP%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90(%E6%B2%99%E7%9B%92%E5%88%86%E6%9E%90)%2B%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[APP文件结构分析(沙盒分析)+数据存储安全 沙盒结构分析 /* Documents (backup 备份){ 大文件要做 非备份设置（如视频文件，多媒体文件） 审核的，如果检查出来，就会被拒 } Librayry 1 Caches{ 系统的缓存存放在这个文件夹（如NSURLSessionTask的net获取缓存XXX/Cache/com.test.eoc/Cache.db） } 2 Preferences (backup 备份) (如 NSUserDefaults存储在XXX/Preferences/com.test.eoc.plist tmp 临时文件夹（系统会不定期删除里面的文件） 不重要性的文件 （断点下载的时候 （当文件下载没完成的时候，下载完之后会转移到目的文件夹）） */ Bundle分析 Bundle里边存放的是资源文件，不参与编译 Bundle中的资源icon.png，在xib中设置icon.png，其在xib中正常显示，而在运行时显示不正常，如果设置为bundle.bunld/icon.png，则虽在xib中显示不正常，但在运行时正常显示 //如果需要读取bundle中的文件 NSString *boundPath = [[NSBundle mainBundle] pathForResource:@&quot;EOCBundle&quot; ofType:@&quot;bundle&quot;]; NSBundle *eocBoundle = [NSBundle bundleWithPath:boundPath]; NSString *imagePath = [eocBoundle pathForResource:@&quot;11&quot; ofType:@&quot;png&quot;]; NSData *imageData = [NSData dataWithContentsOfFile:imagePath]; 归档 @interface EOCClass : NSObject &lt;NSCoding, NSCopying&gt; @property (nonatomic, strong)NSString *name; @property (nonatomic, strong)NSString *age; @property (nonatomic, strong)NSString *classId; @end @implementation EOCClass - (id)copyWithZone:(nullable NSZone *)zone{ EOCClass *eocClass = [EOCClass new]; eocClass.name = self.name; eocClass.age = self.age; eocClass.classId = self.classId; return eocClass; } // 归档 - (void)encodeWithCoder:(NSCoder *)aCoder{ [aCoder encodeObject:self.name forKey:@&quot;name&quot;]; [aCoder encodeObject:self.age forKey:@&quot;age&quot;]; [aCoder encodeObject:self.classId forKey:@&quot;classId&quot;]; } // 解挡 - (instancetype)initWithCoder:(NSCoder *)aDecoder{ EOCClass *eocClass = [EOCClass new]; eocClass.name = [aDecoder decodeObjectForKey:@&quot;name&quot;]; eocClass.age = [aDecoder decodeObjectForKey:@&quot;age&quot;]; eocClass.classId = [aDecoder decodeObjectForKey:@&quot;classId&quot;]; return eocClass; } @implementation ArchiveViewCtr - (void)viewDidLoad { [super viewDidLoad]; EOCClass *eocClass = [EOCClass new]; eocClass.name = @&quot;11&quot;; eocClass.age = @&quot;10&quot;; eocClass.classId = @&quot;eocClass&quot;; NSData *data = [NSKeyedArchiver archivedDataWithRootObject:eocClass]; NSString *filePath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]; filePath = [filePath stringByAppendingPathComponent:@&quot;eocClass&quot;]; [data writeToFile:filePath atomically:NO]; EOCClass *tempEOC = [eocClass copy];// 深拷贝（copy） 浅拷贝 （strong） } //eocClass 从文件里面对出来，是不是要解压（） - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event{ NSString *filePath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]; filePath = [filePath stringByAppendingPathComponent:@&quot;eocClass&quot;]; EOCClass *eocClass = [NSKeyedUnarchiver unarchiveObjectWithFile:filePath]; NSLog(@&quot;%@, %@, %@&quot;, eocClass.name, eocClass.age, eocClass.classId); } @end 钥匙链的增删改查及跨应用 //保存KeyChain - (void)saveDataToKeyChain{ // 根据 attributes这个字典的key进行 操作 NSMutableDictionary *infoDict = [NSMutableDictionary new]; // 数据类型 key (kSecClass) /* kSecClassInternetPassword // 互联网密码 kSecClassGenericPassword // 通用密码 kSecClassCertificate // 证书 kSecClassKey // 密钥 kSecClassIdentity // 身份ID */ [infoDict setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass]; //// ======= 跨应用数据，如果没有跨应用，则不需要配置 ======= 1 /* 1 kSecAttrAccessGroup 条件key配置 2 配置一个plist keychain-access-groups = （机构号+(Bundle identifier) 一个key 3 配置工程的 coding entitlement */ [infoDict setObject:@&quot;4SH84H8MFB.com.test.EocClass&quot; forKey:(id)kSecAttrAccessGroup]; //// ======= 跨应用数据 ======= // 数据 value NSString *passWord = @&quot;abcdefg&quot;; [infoDict setObject:[passWord dataUsingEncoding:NSUTF8StringEncoding] forKey:(id)kSecValueData]; // 查寻 设置条件 // kSecAttrServer; // 服务id //kSecAttrGeneric; // 标示符 // kSecAttrAccount; // 账户 [infoDict setObject:@&quot;EOCClassAll&quot; forKey:(id)kSecAttrAccount]; OSStatus status = SecItemAdd((CFDictionaryRef)infoDict, NULL); if (status == noErr) { NSLog(@&quot;success&quot;); }else{ NSLog(@&quot;SecItemAdd::%d&quot;, status); } } //删除KeyChain - (void)deleteArchData{ NSMutableDictionary *conditionDict = [NSMutableDictionary new]; [conditionDict setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass]; [conditionDict setObject:@&quot;EOCClass&quot; forKey:(id)kSecAttrAccount]; [conditionDict setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnData]; OSStatus status = SecItemDelete((CFDictionaryRef)conditionDict); if (status == noErr) { NSLog(@&quot;success&quot;); }else { NSLog(@&quot;SecItemCopyMatching::%d&quot;, status); } } //更新KeyChain - (void)updateArch{ NSMutableDictionary *conditionDict = [NSMutableDictionary new]; [conditionDict setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass]; [conditionDict setObject:@&quot;EOCClass&quot; forKey:(id)kSecAttrAccount]; // 数据value NSMutableDictionary *newValueDict = [NSMutableDictionary new]; NSString *passWord = @&quot;987654&quot;; [newValueDict setObject:[passWord dataUsingEncoding:NSUTF8StringEncoding] forKey:(id)kSecValueData]; OSStatus status = SecItemUpdate((CFDictionaryRef)conditionDict, (CFDictionaryRef)newValueDict); if (status == noErr) { NSLog(@&quot;success&quot;); }else { NSLog(@&quot;SecItemCopyMatching::%d&quot;, status); } } //获取KeyChain - (void)getArchData{ NSMutableDictionary *conditionDict = [NSMutableDictionary new]; [conditionDict setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass]; [conditionDict setObject:@&quot;EOCClass&quot; forKey:(id)kSecAttrAccount]; [conditionDict setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnData]; CFDataRef data = NULL; OSStatus status = SecItemCopyMatching((CFDictionaryRef)conditionDict, (CFTypeRef*)&amp;data); if (status == noErr) { NSLog(@&quot;success&quot;); }else { NSLog(@&quot;SecItemCopyMatching::%d&quot;, status); } NSData *backData = (__bridge NSData*)data; NSLog(@&quot;%s&quot;, [backData bytes]); } Local数据层方案设计一 SQL语法复习 /* id(事件抽) name（消息内容） 一次拿3条记录当作一页 */ /* 1 sql 增查删改 .help .table 看数据库里面的表 .schema 看表结构 命令不区分大小的， 值是区分大小的 二进制 bolb 整形integer 字符串 char， text， varcha， 浮点型 real 表名不能中文 唯一健（unique） 和 主键(primary key)（主键也是唯一的，一个表里只能有一个主键，而唯一健可以有很多个） 1 创建表 Sql create table if not exists eoctable(id char, name char); 2 插入 insert into eoctable values(&apos;1&apos;, &apos;eoc1&apos;) insert into eoctable(id) values (&apos;3&apos;) 3 查找 select *from eoctable; 结果排序 order by (id+0 转化id格式就行排序) select *from eoctable order by id select *from eoctable order by id+0 select *from eoctable order by id+0 desc select *from eoctable order by id+0 desc limit 1 // limit 限制条数 select max(id+0) from eoctable // max 最大值 min sum avg select *from eoctable where id+0 &gt; 7 order by id+0 limit 3 // where条件 select *from (select *from eoctable where id+0 &gt; 7) order by id+0 limit 3; select *from eoctable where name like &apos;%c1%&apos;; // 匹配符 % 3 删除 delete delete from eoctable where id = &apos;3&apos; 4 更新 update update eoctable set name = &apos;eocChange5&apos; where id = &apos;5&apos; 5 修改表 alter table eoctable add column grade char default &apos;1&apos;; 6 删除表 drop table eoctable2; 2 sqlite3 */ 功能实现 @implementation EOCClassSQL // 第一步创建db + (void)createEOCDBFile{ NSString *filePath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]; NSString *eocDBFile = [filePath stringByAppendingPathComponent:@&quot;eoc.db&quot;]; if (![[NSFileManager defaultManager] fileExistsAtPath:eocDBFile]) { if([[NSFileManager defaultManager] createFileAtPath:eocDBFile contents:nil attributes:nil]){ NSLog(@&quot;创建成功&quot;); }else { NSLog(@&quot;创建失败&quot;); } }else{ NSLog(@&quot;文件存在了&quot;); } } static sqlite3 *database; //第二种方式创建db + (void)createEOCDBFileSQL{ NSString *filePath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]; NSString *eocDBFile = [filePath stringByAppendingPathComponent:@&quot;eoc.db&quot;]; // 如果文件不存在，就创建该文件，其配置属性是 SQLITE_OPEN_CREATE int status = sqlite3_open_v2([eocDBFile UTF8String], &amp;database, SQLITE_OPEN_CREATE | SQLITE_OPEN_FULLMUTEX | SQLITE_OPEN_READWRITE, NULL); if (status != SQLITE_OK) { NSLog(@&quot;sqlite3_open_v2 fail&quot;); } } // 第二步创建表 /* sqlite3 *database; 文件指针 sql 语句是 对文件进行操作 */ + (void)createTable{ // 操作 ⚠️sqlite3_stmt 失败一定要释放 即进行sqlite3_finalize操作 // sqlite3_stmt 默认不能重复在利用 // 1 先语句 NSString *sqlStr = @&quot;create table if not exists eoctable(id char, name char)&quot;; // 2 检测语句 sqlite3_stmt *stmt; // 可以理解为 代表一条指令 int status = sqlite3_prepare_v2(database, [sqlStr UTF8String], -1, &amp;stmt, 0); if (status != SQLITE_OK) { NSLog(@&quot;sqlite3_prepare_v2 fail&quot;); sqlite3_finalize(stmt); return; } // 3 执行指令 status = sqlite3_step(stmt); if (status != SQLITE_DONE) { NSLog(@&quot;sqlite3_step fail&quot;); } // 4 结束 sqlite3_finalize(stmt); } // 增删改 + (void)insertSQLValue:(NSString*)idStr name:(NSString*)name{ // 操作 ⚠️sqlite3_stmt 失败一定要释放 即进行sqlite3_finalize操作 // sqlite3_stmt 默认不能重复在利用 // 1 先语句 NSString *sqlStr = [NSString stringWithFormat:@&quot;insert into eoctable values(&apos;%@&apos;, &apos;%@&apos;)&quot;, idStr, name]; // 2 检测语句 sqlite3_stmt *stmt; // 可以理解为 代表一条指令 int status = sqlite3_prepare_v2(database, [sqlStr UTF8String], -1, &amp;stmt, 0); if (status != SQLITE_OK) { NSLog(@&quot;sqlite3_prepare_v2 fail&quot;); sqlite3_finalize(stmt); return; } // 3 执行指令 status = sqlite3_step(stmt); if (status != SQLITE_DONE) { NSLog(@&quot;sqlite3_step fail&quot;); } // 4 结束 sqlite3_finalize(stmt); } //查 + (NSArray*)getAllRecord{ // 1 先语句 NSString *sqlStr = @&quot;select *from eoctable&quot;; sqlite3_stmt *stmt; // 可以理解为 代表一条指令 // 2 检测语句 int status = sqlite3_prepare_v2(database, [sqlStr UTF8String], -1, &amp;stmt, 0); if (status != SQLITE_OK) { NSLog(@&quot;sqlite3_prepare_v2 fail&quot;); sqlite3_finalize(stmt); return nil; } // 3 执行指令 NSMutableArray *recordAry = [NSMutableArray new]; while(sqlite3_step(stmt) == SQLITE_ROW){ int columns = sqlite3_column_count(stmt); NSMutableDictionary *infoDict = [NSMutableDictionary new]; for (int i = 0; i &lt; columns; i++) { char *keyC = (char *)sqlite3_column_name(stmt, i); NSString *keyStr = [NSString stringWithUTF8String:keyC]; char *valueC = (char *)sqlite3_column_text(stmt, i); NSString *valueStr = [NSString stringWithUTF8String:valueC]; [infoDict setObject:valueStr forKey:keyStr]; } [recordAry addObject:infoDict]; // char *idC = (char*)sqlite3_column_text(stmt, 0); // char *nameC = (char*)sqlite3_column_text(stmt, 1); // NSString *idStr = [NSString stringWithUTF8String:idC]; // NSString *nameStr = [NSString stringWithUTF8String:nameC]; // NSMutableDictionary *infoDict = [NSMutableDictionary new]; // [infoDict setObject:idStr forKey:@&quot;id&quot;]; // [infoDict setObject:nameStr forKey:@&quot;name&quot;]; // [recordAry addObject:infoDict]; } // 4 结束 sqlite3_finalize(stmt); return recordAry; } // 第三步操作表 // 第四步 关闭 + (void)closeSQL{ sqlite3_close_v2(database); } Local数据层方案设计二（数据库框架的封装） 数据库对应的类，用于提供数据库的名称、路径等 //SQLDataBase类 @interface SQLDataBase : NSObject - (instancetype)initWithFileName:(NSString*)dataBaseName; @property (nonatomic, strong, readonly)NSString *dataBaseName; // db文件名 @property (nonatomic, assign,readonly)sqlite3 *dataBaseSql; @end // 创建db文件，并生成一个文件指针 sqlite3 @implementation SQLDataBase - (instancetype)initWithFileName:(NSString*)dataBaseName{ self = [super init]; if (self) { _dataBaseName = dataBaseName; NSString *filePath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]; NSString *eocDBFile = [filePath stringByAppendingPathComponent:dataBaseName]; // 如果文件不存在，就创建该文件，其配置属性是 SQLITE_OPEN_CREATE int status = sqlite3_open_v2([eocDBFile UTF8String], &amp;_dataBaseSql, SQLITE_OPEN_CREATE | SQLITE_OPEN_FULLMUTEX | SQLITE_OPEN_READWRITE, NULL); if (status != SQLITE_OK) { NSLog(@&quot;sqlite3_open_v2 fail&quot;); } } return self; } @end 数据表对应的类，先用协议获得数据库名，表名，表结构，再根据初始化方法拼凑sql语句生成对应的表 @protocol SQLBaseTableProtocol &lt;NSObject&gt; @required // 1 文件名 db文件 - (NSString*)dataBaseName; // 2 表名 - (NSString*)tableName; // 3 表结构 - (NSDictionary*)colomnValue; @end @interface SQLBaseTable : NSObject - (void)insertTable:(id)object; @end @implementation SQLBaseTable /* 创建文件db 和 表 */ - (instancetype)init{ self = [super init]; if (self) { // 判断子类是否实现了协议（目的是按照框架规则来） if ([self conformsToProtocol:@protocol(SQLBaseTableProtocol)]) { id&lt;SQLBaseTableProtocol&gt; tmpSelf = (id&lt;SQLBaseTableProtocol&gt;) self; // 1 创建一个 sql对象 SQLCommandHandle *sqlCommandHandel = [[SQLCommandHandle alloc] init]; sqlCommandHandel.dataBaseName = [tmpSelf dataBaseName]; //备注：用懒加载的方式来创建db文件 （只有涉及到sql语句执行的时候，才去创建） // 2 准备sql 语句对象 对sqlCommand 对象操作 // @&quot;create table if not exists eoctable(id char, name char)&quot; [sqlCommandHandel preSqlCreateTableName:[tmpSelf tableName] colomnInfo:[tmpSelf colomnValue]]; // 3 执行语句（执行create表语句） [sqlCommandHandel sqlExcuteWriteCommand]; // 4 操作123 发现，我们可以把创建文件db 当作是一个SQLCommandHandle的属性 }else{ NSException *exception = [NSException exceptionWithName:@&quot;SQLBaseTable Error&quot; reason:@&quot;SQLBaseTableProtocol no comform&quot; userInfo:nil]; [exception raise]; } } return self; } @end 记录对应的类，用于对象和NSDictionary之间的转换，NSDictionary和列名列值之间的转换 @protocol SQLBaseRecordProtocol &lt;NSObject&gt; - (NSDictionary*)dictFromObjectProAndMatchTableColumn:(id&lt;SQLBaseTableProtocol&gt;)table; - (void)setRecordProValue:(id)propertyValue property:(NSString*)propertyName; @end @implementation SQLBaseRecord //对象转字典 - (NSDictionary*)dictFromObjectProAndMatchTableColumn:(id&lt;SQLBaseTableProtocol&gt;)table{ NSMutableDictionary *dict = [NSMutableDictionary new]; unsigned int count = 0; // 1 第一个把对象的属性名和value存放到 dict（key 属性名； value 属性的值） // 获取属性 数组 objc_property_t *properties = class_copyPropertyList([self class], &amp;count); for (int i = 0; i &lt; count; i++) { NSString *keyStr = [NSString stringWithUTF8String:property_getName(properties[i])]; NSString *valueStr = [self valueForKey:keyStr]; if (valueStr == nil) { [dict setObject:[NSNull null] forKey:keyStr]; }else{ [dict setObject:valueStr forKey:keyStr]; } } free(properties); // dict 和表 结构的字段关系； dict的key是否和表结构里面的key是一样的 // 匹配表字段 NSMutableDictionary *columnDict = [NSMutableDictionary dictionary]; [table.colomnValue enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) { if ([dict objectForKey:key]) { [columnDict setObject:[dict objectForKey:key] forKey:key]; }else{ [columnDict setObject:@&quot;&quot; forKey:key]; } }]; return columnDict; } // 字典转对象 - (void)setRecordProValue:(id)propertyValue property:(NSString*)propertyName{ if (!propertyName || propertyName.length == 0) { return; } NSString *setterSEL = [NSString stringWithFormat:@&quot;set%@%@:&quot;, [[propertyName substringToIndex:1] capitalizedString], [propertyName substringFromIndex:1]]; if([self respondsToSelector:NSSelectorFromString(setterSEL)]){ // value异常没处理 [self setValue:propertyValue forKey:propertyName]; }else { NSLog(@&quot;%@没有这个%@属性&quot;, NSStringFromClass([self class]), propertyName); } } @end SQLCommandHandle类用于来拼凑sql语句，拼凑的增删改查等语句放在扩展里，公共语句放于此类中 //SQLCommandHandle类 @interface SQLCommandHandle : NSObject // sqlCommand = insert into table values (&quot;1&quot;, &quot;2&quot;) @property (nonatomic, strong)NSString *dataBaseName; @property (nonatomic, strong)NSMutableString *sqlCommand; @property (nonatomic, strong)SQLDataBase *dataBase; // 写操作 （增删改） - (void)sqlExcuteWriteCommand; // 读操作 （查） - (NSArray*)sqlExcuteReadCommand; @end @implementation SQLCommandHandle // 增删改write 查read - (void)sqlExcuteWriteCommand{ // sql语句，和表结构有关系的 if ( !self.sqlCommand || self.sqlCommand.length == 0) { NSLog(@&quot;sqlCommand 不存在&quot;); return ; } sqlite3_stmt *stmt; int status = sqlite3_prepare_v2(self.dataBase.dataBaseSql, [self.sqlCommand UTF8String], -1, &amp;stmt, 0); if (status != SQLITE_OK) { NSLog(@&quot;sqlite3_prepare_v2 fail&quot;); sqlite3_finalize(stmt); return; } status = sqlite3_step(stmt); if (status != SQLITE_DONE) { NSLog(@&quot;sqlite3_step fail&quot;); } sqlite3_finalize(stmt); } - (NSArray*)sqlExcuteReadCommand{ if ( !self.sqlCommand || self.sqlCommand.length == 0) { NSLog(@&quot;sqlCommand 不存在&quot;); return nil; } sqlite3_stmt *stmt; int status = sqlite3_prepare_v2(self.dataBase.dataBaseSql, [self.sqlCommand UTF8String], -1, &amp;stmt, 0); if (status != SQLITE_OK) { NSLog(@&quot;sqlite3_prepare_v2 fail&quot;); sqlite3_finalize(stmt); return nil; } NSMutableArray *recordAry = [NSMutableArray new]; while(sqlite3_step(stmt) == SQLITE_ROW){ int columns = sqlite3_column_count(stmt); NSMutableDictionary *infoDict = [NSMutableDictionary new]; for (int i = 0; i &lt; columns; i++) { NSString *keyStr = [NSString stringWithUTF8String:sqlite3_column_name(stmt, i)]; NSString *valueStr = [NSString stringWithUTF8String:sqlite3_column_text(stmt, i)]; [infoDict setObject:valueStr forKey:keyStr]; } [recordAry addObject:infoDict]; } sqlite3_finalize(stmt); return recordAry; } - (SQLDataBase*)dataBase{ if (!_dataBase) { _dataBase = [[SQLDataBase alloc] initWithFileName:self.dataBaseName]; } return _dataBase; } @end 对SQLBaseTable进行增删改查扩展，如插入 @interface SQLBaseTable (Insert) - (void)insertDataContainBinary:(id&lt;SQLBaseRecordProtocol&gt;)object; @end @implementation SQLBaseTable (Insert) - (void)insertDataContainBinary:(id&lt;SQLBaseRecordProtocol&gt;)object{ id&lt;SQLBaseTableProtocol&gt; tmpSelf = (id&lt;SQLBaseTableProtocol&gt;) self; // 1 创建一个 sql对象 SQLCommandHandle *sqlCommandHandel = [[SQLCommandHandle alloc] init]; sqlCommandHandel.dataBaseName = [tmpSelf dataBaseName]; // 2 准备sql 语句对象 对sqlCommand 对象操作 // object 转化成字典格式 （写到基类对象里） 字典里面key（表的相关的字段名）value插入的值 NSDictionary *columnDict = [object dictFromObjectProAndMatchTableColumn:tmpSelf]; [sqlCommandHandel preSqlInsertToTableName:[tmpSelf tableName] columnInfo:columnDict]; // 3 执行语句（执行create表语句） [sqlCommandHandel sqlExcuteWriteCommand]; } @end 对SQLCommandHandle进行增删改查的扩展来生成sql语句，如createTable @interface SQLCommandHandle (CreateTable) - (void)preSqlCreateTableName:(NSString*)tableName colomnInfo:(NSDictionary*)colomnInfo; @end @implementation SQLCommandHandle (CreateTable) - (void)preSqlCreateTableName:(NSString*)tableName colomnInfo:(NSDictionary*)colomnInfo{ // @&quot;create table if not exists eoctable(id char, name char)&quot; self.sqlCommand = [NSMutableString string]; NSMutableArray *colomnAry = [NSMutableArray new]; [colomnInfo enumerateKeysAndObjectsUsingBlock:^(NSString* _Nonnull key, NSString* _Nonnull obj, BOOL * _Nonnull stop) { if (key.length == 0 || obj.length == 0) { NSLog(@&quot;创建表是，表的字段设置有问题&quot;); }else{ NSString *colomnStr = [NSString stringWithFormat:@&quot;%@ %@&quot;, key, obj]; [colomnAry addObject:colomnStr]; } }]; NSString *tableStructStr = [colomnAry componentsJoinedByString:@&quot;,&quot;]; [self.sqlCommand appendFormat:@&quot;create table if not exists %@(%@)&quot;, tableName, tableStructStr]; } @end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>App文件结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MJRefresh框架级解析]]></title>
    <url>%2F2017%2F08%2F25%2FMJRefresh%E6%A1%86%E6%9E%B6%E7%BA%A7%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[MJRefresh框架级解析之HeaderView UIScrollView扩展属性HeaderView @interface UIScrollView (UIScrollView_EOCRefresh) @property(nonatomic, strong)EOCRefreshHeaderView *EOCRefreshHeaderView; @end @implementation UIScrollView (UIScrollView_EOCRefresh) - (EOCRefreshHeaderView *)EOCRefreshHeaderView { return objc_getAssociatedObject(self, @selector(EOCRefreshHeaderView)); } - (void)setEOCRefreshHeaderView:(EOCRefreshHeaderView *)EOCRefreshHeaderView { if (self.EOCRefreshHeaderView != EOCRefreshHeaderView) { //移除之前的下拉刷新控件，保证一个scrollView只有一个下拉刷新控件 [self.EOCRefreshHeaderView removeFromSuperview]; objc_setAssociatedObject(self, @selector(EOCRefreshHeaderView), EOCRefreshHeaderView, OBJC_ASSOCIATION_RETAIN); //添加到界面上，两种方式都可以的 [self addSubview:self.EOCRefreshHeaderView]; //[self insertSubview:self.EOCRefreshHeaderView atIndex:0]; } } 定义HeaderView的状态 typedef NS_ENUM(NSInteger, EOCRefreshState) { EOCRefreshStateIdle = 1, //闲置状态 EOCRefreshStatePulling, //释放就刷新的状态 EOCRefreshStateRefreshing, //正在刷新状态 }; 定义RefreshBaseView typedef void(^eocrefreshBlock)(void); @interface EOCRefreshBaseView : UIView @property(nonatomic, strong)eocrefreshBlock headerRefreshingBlock; @property(nonatomic, strong)UIScrollView *scrollView; @property(nonatomic, assign)EOCRefreshState state; @property(nonatomic, assign)CGFloat pullingPercent; //方法 - (void)placeSubViews; - (void)scrollViewOffsetChanged:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change; - (void)beginRefresh; - (void)endRefresh; - (void)prepare; @end 实现RefreshBaseView @implementation EOCRefreshBaseView //init - (instancetype)initWithFrame:(CGRect)frame { self = [super initWithFrame:frame]; [self prepare]; self.state = EOCRefreshStateIdle; return self; } - (void)prepare { self.backgroundColor = [UIColor redColor]; } - (void)layoutSubviews { [super layoutSubviews]; [self placeSubViews]; } - (void)placeSubViews{} - (void)setState:(EOCRefreshState)state { _state = state; } //你这个控件还没有添加到superView上（因为是will），会触发了这个方法；（当你的控件添加到superView的时候调用 ； 当你从superView移除的时候 它也会调用） - (void)willMoveToSuperview:(UIView *)newSuperview { [super willMoveToSuperview:newSuperview]; //当你移除的时候，你这个newSuperView为nil；所以要在判断的外面移除 [self.superview removeObserver:self forKeyPath:@&quot;contentOffset&quot;]; if (newSuperview &amp;&amp; [newSuperview isKindOfClass:[UIScrollView class]]) { //添加了对newSuperView的kvo的观察机制 UIScrollView *scrollView = (UIScrollView *)newSuperview; self.scrollView = scrollView; [scrollView addObserver:self forKeyPath:@&quot;contentOffset&quot; options:NSKeyValueObservingOptionNew context:nil]; ///设置一下frame 的宽度和x坐标 self.eoc_w = scrollView.eoc_w; self.eoc_x = 0.f; } } - (void)beginRefresh { if (self.headerRefreshingBlock) { self.headerRefreshingBlock(); } } - (void)endRefresh { [[NSUserDefaults standardUserDefaults] setObject:[NSDate date] forKey:@&quot;lastUpdateDate&quot;]; self.state = EOCRefreshStateIdle; } #pragma mark - KVO的实现 - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context { if ([keyPath isEqualToString:@&quot;contentOffset&quot;]) { [self scrollViewOffsetChanged:change]; } } - (void)scrollViewOffsetChanged:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change {} @end 定义EOCRefreshHeaderView(最简单headerview，无任何内容) @interface EOCRefreshHeaderView : EOCRefreshBaseView + (instancetype)headerWithRefreshingBlock:(eocrefreshBlock)block; @end 实现EOCRefreshHeaderView @implementation EOCRefreshHeaderView + (instancetype)headerWithRefreshingBlock:(eocrefreshBlock)block { //如果你在外层，是通过[EOCRefreshStateHeaderView headerWithRefreshingBlock] //父类 *对象 = 子类 alloc init 没问题 //子类 *对象 = 父类 alloc init 有问题 对象（父类对象）.子类方法 会崩溃 EOCRefreshHeaderView *headerView = [[self alloc] init]; headerView.headerRefreshingBlock = block; return headerView; } - (void)placeSubViews { [super placeSubViews]; self.eoc_h = 50.f; self.eoc_y = -self.eoc_h; } //完成kvo的实现 - (void)scrollViewOffsetChanged:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change { //superView的offset CGFloat yOffset = self.scrollView.contentOffset.y; //临界值 CGFloat boundararyOffset = -self.eoc_h; CGFloat alphaRatio = (-yOffset)/self.eoc_h; self.pullingPercent = alphaRatio; if (self.state == EOCRefreshStateRefreshing) { self.alpha = 1.f; return; } if (self.scrollView.isDragging) { //你的superView：也就是scrollVIew正在被拖动 self.alpha = alphaRatio; if (self.state == EOCRefreshStateIdle &amp;&amp; yOffset &lt;= boundararyOffset) { self.state = EOCRefreshStatePulling; } else if (self.state == EOCRefreshStatePulling &amp;&amp; yOffset &gt; boundararyOffset) { self.state = EOCRefreshStateIdle; } } else { //你的superView：也就是scrollVIew停止拖动的时候 if (self.state == EOCRefreshStatePulling) { //此时是释放立即刷新的状态 self.state = EOCRefreshStateRefreshing; } self.alpha = alphaRatio; } } - (void)setState:(EOCRefreshState)state { [super setState:state]; if (state == EOCRefreshStateRefreshing) { //悬停设置 [UIView animateWithDuration:0.2f animations:^{ self.scrollView.contentInset = UIEdgeInsetsMake(self.eoc_h, 0.f, 0.f, 0.f); }]; //开始刷新 [self beginRefresh]; } else if (state == EOCRefreshStateIdle) { //恢复默认值，也就是初始值 [UIView animateWithDuration:0.4f animations:^{ self.scrollView.contentInset = UIEdgeInsetsZero; }]; } } 定义EOCRefreshStateHeaderView（文字型提示） @interface EOCRefreshStateHeaderView : EOCRefreshHeaderView @property(nonatomic, strong)UILabel *descriptionLable; @property(nonatomic, strong)UILabel *lastUpdatedTimeLabel; @end 实现EOCRefreshStateHeaderView @implementation EOCRefreshStateHeaderView - (void)prepare { [super prepare]; [self addSubview:self.descriptionLable]; [self addSubview:self.lastUpdatedTimeLabel]; } //就相当于调用了layoutSubViews，改变子view的frame - (void)placeSubViews { [super placeSubViews]; //改变两个label的frame self.descriptionLable.frame = ({ CGRect frame = self.bounds; frame.size.height = self.eoc_h/2; frame; }); self.lastUpdatedTimeLabel.frame = ({ CGRect frame = self.bounds; frame.origin.y = self.descriptionLable.eoc_h; frame.size.height = self.eoc_h/2; frame; }); } - (void)setState:(EOCRefreshState)state { [super setState:state]; if (state == EOCRefreshStateIdle) { self.descriptionLable.text = @&quot;下拉进行刷新&quot;; //上次更新的时间 self.lastUpdatedTimeLabel.text = [self lastUpdatedTime]; } else if (state == EOCRefreshStatePulling) { self.descriptionLable.text = @&quot;松开即将刷新&quot;; } else if (state == EOCRefreshStateRefreshing) { self.descriptionLable.text = @&quot;正在刷新...&quot;; } } 定义EOCRefreshNormalHeaderView（不仅有文字还有箭头和加载圈） @interface EOCRefreshNormalHeaderView : EOCRefreshStateHeaderView @property(nonatomic, strong)UIImageView *arrowImageView; @property(nonatomic, strong)UIActivityIndicatorView *loadView; @end 实现EOCRefreshNormalHeaderView - (void)prepare { [super prepare]; [self addSubview:self.arrowImageView]; [self addSubview:self.loadView]; self.loadView.hidden = YES; } - (void)placeSubViews { [super placeSubViews]; CGFloat descritionTextWidth = self.descriptionLable.textWidth; CGFloat lastTimeTextWidth = self.lastUpdatedTimeLabel.textWidth; CGFloat actualWidth = (descritionTextWidth&gt;lastTimeTextWidth?descritionTextWidth:lastTimeTextWidth); self.arrowImageView.center = CGPointMake((self.eoc_w-actualWidth)/4, self.eoc_h/2); self.arrowImageView.eoc_size = self.arrowImageView.image.size; self.loadView.center = CGPointMake((self.eoc_w-actualWidth)/4, self.eoc_h/2); self.loadView.eoc_size = self.arrowImageView.image.size; } - (void)setState:(EOCRefreshState)state { [super setState:state]; //1、角度为正，顺时针；角度为负，逆时针 //3、基本按照最短路径来，如果顺时针、逆时针角度一样的，按顺时针来 if (state == EOCRefreshStatePulling) { [UIView animateWithDuration:0.2f animations:^{ self.arrowImageView.transform = CGAffineTransformMakeRotation(0.0001-M_PI); }]; } else if (state == EOCRefreshStateIdle) { [self.loadView stopAnimating]; [UIView animateWithDuration:0.2f animations:^{ self.arrowImageView.transform = CGAffineTransformIdentity; } completion:^(BOOL finished) { self.arrowImageView.hidden = NO; self.loadView.hidden = YES; }]; } else if (state == EOCRefreshStateRefreshing) { self.arrowImageView.hidden = YES; self.loadView.hidden = NO; [self.loadView startAnimating]; } } 定义EOCRefreshGifHeader @interface EOCRefreshGifHeader : EOCRefreshStateHeaderView /** 设置state状态下的动画图片images 动画持续时间duration*/ - (void)setImages:(NSArray *)images duration:(NSTimeInterval)duration forState:(EOCRefreshState)state; - (void)setImages:(NSArray *)images forState:(EOCRefreshState)state; @property (nonatomic, strong)UIImageView *gifImageView; @property (nonatomic, strong)NSArray *images; @property (nonatomic, strong)NSMutableDictionary *stateImages; @property (nonatomic, strong)NSMutableDictionary *stateAnimationDurations; @end 实现EOCRefreshGifHeader @implementation EOCRefreshGifHeader - (void)setImages:(NSArray *)images duration:(NSTimeInterval)duration forState:(EOCRefreshState)state { self.stateImages[@(state)] = images; self.stateAnimationDurations[@(state)] = @(duration); } - (void)setImages:(NSArray *)images forState:(EOCRefreshState)state { [self setImages:images duration:images.count * 0.1 forState:state]; } #pragma mark - 覆盖父类方法 - (void)prepare { [super prepare]; [self addSubview:self.gifImageView]; } - (void)placeSubViews { [super placeSubViews]; CGFloat stateTextWidth = self.descriptionLable.textWidth; CGFloat lastTimeTextWidth = self.lastUpdatedTimeLabel.textWidth; CGFloat finalTextWidth = MAX(stateTextWidth, lastTimeTextWidth); self.gifImageView.eoc_size = _gifImageView.image.size; self.gifImageView.center = CGPointMake((self.eoc_w - finalTextWidth)/4, self.eoc_h/2); self.gifImageView.image = [_stateImages[@(EOCRefreshStateIdle)] firstObject]; } - (void)setState:(EOCRefreshState)state { [super setState:state]; if (state == EOCRefreshStateRefreshing || state == EOCRefreshStatePulling) { _gifImageView.animationImages = _stateImages[@(EOCRefreshStateRefreshing)]; _gifImageView.animationDuration = [_stateAnimationDurations[@(EOCRefreshStateRefreshing)] doubleValue]; [_gifImageView startAnimating]; } else if (state == EOCRefreshStateIdle) { [_gifImageView stopAnimating]; } } 定义和实现EOCRefreshChiBaoZhiHeader @interface EOCRefreshChiBaoZhiHeader : EOCRefreshGifHeader @end @implementation EOCRefreshChiBaoZhiHeader #pragma mark - 覆盖父类方法 - (void)prepare { [super prepare]; // 设置空闲状态的动画图片 NSMutableArray *idleImages = [NSMutableArray array]; for (NSUInteger i = 1; i&lt;=60; i++) { UIImage *image = [UIImage imageNamed:[NSString stringWithFormat:@&quot;dropdown_anim__000%zd&quot;, i]]; [idleImages addObject:image]; } [self setImages:idleImages forState:EOCRefreshStateIdle]; // 设置即将刷新状态的动画图片（一松开就会刷新的状态） NSMutableArray *refreshingImages = [NSMutableArray array]; for (NSUInteger i = 1; i&lt;=3; i++) { UIImage *image = [UIImage imageNamed:[NSString stringWithFormat:@&quot;dropdown_loading_0%zd&quot;, i]]; [refreshingImages addObject:image]; } [self setImages:refreshingImages forState:EOCRefreshStateRefreshing]; } MJRefresh框架级解析之FooterView 定义EOCRefreshFooter @interface EOCRefreshFooter : EOCRefreshBaseView + (instancetype)footerWithRefreshingBlock:(eocrefreshBlock)block; - (void)endRefreshWithNomoreData; @end 实现EOCRefreshFooter @implementation EOCRefreshFooter + (instancetype)footerWithRefreshingBlock:(eocrefreshBlock)block { EOCRefreshFooter *footerView = [[self alloc] init]; footerView.refreshingBlock = block; return footerView; } - (void)placeSubViews { self.eoc_h = 50.f; } - (void)endRefreshWithNomoreData { self.state = EOCRefreshStateNoMoreData; } - (void)setState:(EOCRefreshState)state { [super setState:state]; } @end 定义和实现EOCRefreshAutoFooter @interface EOCRefreshAutoFooter : EOCRefreshFooter @end @implementation EOCRefreshAutoFooter - (void)placeSubViews { [super placeSubViews]; //修改self的布局:baseView:x,width refreshFooter:height 现在：y self.eoc_y = self.scrollView.contentSize.height; } //当scrollView的内容超过frame的时候，根据偏移量修改状态 - (void)scrollViewOffsetChanged:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change { [super scrollViewContentSizeChanged:change]; CGFloat yOffset = self.scrollView.contentOffset.y; CGFloat boundararyOffsetY; if (self.scrollView.contentSize.height &gt; self.scrollView.frame.size.height) { boundararyOffsetY = self.scrollView.contentSize.height - self.scrollView.frame.size.height + self.frame.size.height; if (self.state != EOCRefreshStateRefreshing &amp;&amp; yOffset &gt; boundararyOffsetY) { self.state = EOCRefreshStateRefreshing; } } } //监听ContentSize，每次contentSize变化的时候，重新定义Refresh的位置 - (void)scrollViewContentSizeChanged:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change { [super scrollViewContentSizeChanged:change]; self.eoc_y = self.scrollView.contentSize.height; } //如果此时在一屏的时候往上拉 - (void)scrollViewGestureStateChanged:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change { [super scrollViewGestureStateChanged:change]; if (self.scrollView.frame.size.height &gt; self.scrollView.contentSize.height) { CGPoint transitionPoint = [self.scrollView.panGestureRecognizer translationInView:self.scrollView]; if (transitionPoint.y &lt; 0 &amp;&amp; self.scrollView.panGestureRecognizer.state == UIGestureRecognizerStateEnded &amp;&amp; self.state != EOCRefreshStateRefreshing) { self.state = EOCRefreshStateRefreshing; } } } - (void)setState:(EOCRefreshState)state { [super setState:state]; if (state == EOCRefreshStateRefreshing) { [self beginRefresh]; } } 定义和实现EOCRefreshBackFooter @interface EOCRefreshBackFooter : EOCRefreshFooter @end @implementation EOCRefreshBackFooter - (void)placeSubViews { [super placeSubViews]; [self scrollViewContentSizeChanged:nil]; } - (void)scrollViewContentSizeChanged:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change { [super scrollViewContentSizeChanged:change]; //分为两种情况1、内容小于frame 2、内容大于等于frame if (self.scrollView.contentSize.height &gt; self.scrollView.frame.size.height) { self.eoc_y = self.scrollView.contentSize.height; } else { self.eoc_y = self.scrollView.frame.size.height-self.originalInsets.top; } } //监听offset的改变，修改状态 - (void)scrollViewOffsetChanged:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change { [super scrollViewOffsetChanged:change]; CGFloat yOffset = self.scrollView.contentOffset.y; CGFloat boundararyOffsetY; //边界值 if (self.scrollView.contentSize.height &lt; self.scrollView.frame.size.height) { //内容小于frame boundararyOffsetY = self.frame.size.height-self.originalInsets.top; } else { //内容大于frame boundararyOffsetY = self.scrollView.contentSize.height - self.scrollView.frame.size.height + self.frame.size.height; } //刚刚出现footer的时候的偏移 CGFloat theFooterBoundararyOffset; if (self.scrollView.contentSize.height &lt; self.scrollView.frame.size.height) { theFooterBoundararyOffset = - self.originalInsets.top; } else { theFooterBoundararyOffset = self.scrollView.contentSize.height - self.scrollView.frame.size.height; } CGFloat alphaRatio = (yOffset-theFooterBoundararyOffset)/self.frame.size.height; self.pullingPercent = alphaRatio; if (self.state == EOCRefreshStateRefreshing) { self.alpha = 1.f; //当你刷新的时候，alpha不需要改变 return; } self.originalInsets = self.scrollView.contentInset; if (self.scrollView.isDragging) { self.alpha = alphaRatio; if (yOffset &gt;= boundararyOffsetY) { self.state = EOCRefreshStatePulling; } else { self.state = EOCRefreshStateIdle; } } else { if (self.state == EOCRefreshStatePulling) { self.state = EOCRefreshStateRefreshing; } self.alpha = alphaRatio; } } - (void)setState:(EOCRefreshState)state { [super setState:state]; if (state == EOCRefreshStateRefreshing) { CGFloat insetBottom; //内容小于frame if (self.scrollView.contentSize.height &lt; self.scrollView.frame.size.height) { insetBottom = self.scrollView.frame.size.height - self.scrollView.contentSize.height + self.frame.size.height - self.originalInsets.top; } else { //内容大于frame insetBottom = self.frame.size.height; } //能够完全显示上拉刷新控件 [UIView animateWithDuration:0.2f animations:^{ self.scrollView.eoc_insetB = insetBottom; } completion:^(BOOL finished) { [self beginRefresh]; }]; } else if (state == EOCRefreshStateIdle || state == EOCRefreshStateNoMoreData){ [UIView animateWithDuration:0.4f animations:^{ self.scrollView.eoc_insetB = self.originalInsets.bottom; }]; } }]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>iOS</tag>
        <tag>MJRefresh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带你掌握微信朋友圈实现]]></title>
    <url>%2F2017%2F07%2F28%2F%E5%B8%A6%E4%BD%A0%E6%8E%8C%E6%8F%A1%E5%BE%AE%E4%BF%A1%E6%9C%8B%E5%8F%8B%E5%9C%88%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[朋友圈粗糙实现 可以在xib中布局，然后在其VC中重新定义其位置或高度；也可以直接用代码生成及布局控件 //WXFriendCircleVCtr.m [theHeadView removeFromSuperview]; [theFootView removeFromSuperview]; [theTableView setTableHeaderView:theHeadView]; [theTableView setTableFooterView:theFootView]; theTableView = [[UITableView alloc] initWithFrame:CGRectMake(0, 0, ScreenWidth, ScreenHeight) style:UITableViewStylePlain]; theTableView.separatorStyle = UITableViewCellSeparatorStyleNone; theTableView.delegate = self; theTableView.dataSource = self; theTableView.backgroundColor = [UIColor whiteColor]; [self.view addSubview:theTableView]; 分析数据列表的每个模型的类型 /* 先分析数据模型 （根据数据搭建UI） 一种数据模型 （纯文本） 一、朋友圈内容 数据模型content：1 纯文本， 2 纯图片， 3 纯链接， 4 纯视频 混合型：5文本+图片， 6 文本+链接， 7 文本+视频 数据模型reply： 回复 */ typedef NS_ENUM(NSInteger, FCCellContentType) { FC_OnlyTextContent = 0, //文字 FC_OnlyPictureContent = 1, // 图片 FC_OnlyLinkContent = 2, // 链接 FC_OnlyMovieContent = 3, // 视频 FC_TextAndPictureContent = 4, //文字 + 图片 FC_TextAndLinkContent = 5, // 文字+链接 FC_TextAndMovieContent = 6,// 文字 + 视频 }; 建立对应的数据模型，扩展高度作为缓存的内容，避免在cell刷新的时候重复计算 //FriendCircleModel.h @interface FriendCircleModel : NSObject @property (nonatomic, strong)NSString *name; //名字 @property (nonatomic, strong)NSString *portraitPath;//头像 @property (nonatomic, assign)FCCellContentType contentType;// 数据内容（ 文字、图片，视频） ////// 内容数据 /* 假如只发了一个纯文本的内容 contentTextStr = @“晚上有没人约起？” imageAry = nil moviePath = nil messageAry = 【8】 */ @property (nonatomic, strong)NSString *contentTextStr;//文子描述 @property (nonatomic, strong)NSArray *imageAry;// 图片 @property (nonatomic, strong)NSString *moviePath;// 视频 @property (nonatomic, strong)NSDictionary *linkInfoDict;// 链接 @property (nonatomic, strong)NSMutableArray *messageAry;//评论全部属性 @property (nonatomic, strong)NSString *timeStp;// 时间 @property (nonatomic, strong)NSMutableArray *approveAry; // 点赞 /* 高度保存起来的作用（cell刷新的时候，重复计算） */ @property (nonatomic, assign)float textContentHigh; // 文本高度 @property (nonatomic, assign)float imageContentHigh; // 图片高度 @property (nonatomic, assign)float approveContentHigh;// 点赞高度 @property (nonatomic, strong)NSString *approveContentStr;// 点赞内容 // 如果这样保存 减少calayer数量 内存增长 //@property (nonatomic, strong)UIImage *imageConp; // 导致内存增长 //@property (nonatomic, strong)NSString *imageFilePath;// 导致内存不会增长，但是文件IO // 朋友圈关联一个数据库 key messsage， value imageData + (NSString*)messageContentFromDict:(NSDictionary *)messageDict; @end 可以在xib加载的时候初始化一些控件和手势 //FriendCircleCell.m - (void)awakeFromNib { [super awakeFromNib]; [approveView removeFromSuperview]; linkTapGesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapLink:)]; _fcLinkView = [[[NSBundle mainBundle] loadNibNamed:@&quot;FCLinkView&quot; owner:nil options:nil] firstObject]; } 因为加载tableview时会先调取heightForRowAtIndexPath函数，可以根据[FriendCircleCell fcCellHeight:[fcDataAry objectAtIndex:indexPath.row]]方法获取cell的高度来返回 //FriendCircleCell.m + (CGFloat)fcCellHeight:(FriendCircleModel*)cellModel{ CGFloat contentHigh = 0; if (cellModel.contentType == FC_OnlyTextContent){ contentHigh = [UIView backLinesInView:ScreenWidth-90 string:cellModel.contentTextStr font:[UIFont systemFontOfSize:14]]; contentHigh = (contentHigh &lt; 30)?30:contentHigh; cellModel.textContentHigh = contentHigh; } else if (cellModel.contentType == FC_OnlyPictureContent){ // 只有图片 NSInteger lineCount = (cellModel.imageAry.count-1)/3 + 1; contentHigh = lineCount * CellImageHight + lineCount*5; cellModel.imageContentHigh = contentHigh; } else if (cellModel.contentType == FC_OnlyLinkContent){ // 只有链接地址 contentHigh = LinkViewHight; } else if (cellModel.contentType == FC_TextAndPictureContent){ contentHigh = [UIView backLinesInView:ScreenWidth-90 string:cellModel.contentTextStr font:[UIFont systemFontOfSize:14]]; contentHigh = (contentHigh &lt; 30)?30:contentHigh; cellModel.textContentHigh = contentHigh; NSInteger lineCount = (cellModel.imageAry.count-1)/3 + 1; contentHigh = lineCount * CellImageHight + lineCount*5; cellModel.imageContentHigh = contentHigh; contentHigh = cellModel.textContentHigh + cellModel.imageContentHigh; } else if (cellModel.contentType == FC_TextAndLinkContent){ contentHigh = [UIView backLinesInView:ScreenWidth-90 string:cellModel.contentTextStr font:[UIFont systemFontOfSize:14]]; contentHigh = (contentHigh &lt; 30)?30:contentHigh; cellModel.textContentHigh = contentHigh; contentHigh += LinkViewHight; } else if (cellModel.contentType == FC_OnlyMovieContent){ contentHigh = MovieViewHight; } else if (cellModel.contentType == FC_TextAndMovieContent){ contentHigh = [UIView backLinesInView:ScreenWidth-90 string:cellModel.contentTextStr font:[UIFont systemFontOfSize:14]]; contentHigh = (contentHigh &lt; 30)?30:contentHigh; cellModel.textContentHigh = contentHigh; contentHigh += MovieViewHight; } // 点赞 高度 if (cellModel.approveAry.count &gt; 0) { NSMutableString *approveStr = [NSMutableString stringWithString:@&quot; &quot;]; [approveStr appendString:[cellModel.approveAry objectAtIndex:0]]; for (int i = 1; i &lt; cellModel.approveAry.count; i++) { [approveStr appendFormat:@&quot;,%@&quot;,[cellModel.approveAry objectAtIndex:i]]; } cellModel.approveContentStr = approveStr; cellModel.approveContentHigh = [UIView backLinesInView:ScreenWidth-90 string:approveStr font:[UIFont systemFontOfSize:12]]; }else{ cellModel.approveContentStr = @&quot;&quot;; cellModel.approveContentHigh = 0; } return CellBaseHight + contentHigh + cellModel.approveContentHigh; } 在调用cellForRowAtIndexPath函数时，获得一个cell，给cell赋值并且根据值类型来确定显示或隐藏哪些控件 /* 一个cell 对应一个model （数据处理） layoutsubview UI处理 */ //FriendCircleCell.m - (void)setCellModel:(FriendCircleModel *)cellModel{ _cellModel = cellModel; fcNameLb.text = cellModel.name; if (cellModel.contentType == FC_OnlyTextContent) { textContentLb.hidden = NO; multipleContentV.hidden = YES; textContentLb.text = cellModel.contentTextStr; [multipleContentV removeAllSubView]; } else if(cellModel.contentType == FC_OnlyPictureContent){ textContentLb.hidden = YES; multipleContentV.hidden = NO; } else if(self.cellModel.contentType == FC_OnlyLinkContent){ textContentLb.hidden = YES; multipleContentV.hidden = NO; } else if(self.cellModel.contentType == FC_TextAndPictureContent){ textContentLb.hidden = NO; multipleContentV.hidden = NO; textContentLb.text = cellModel.contentTextStr; } else if(self.cellModel.contentType == FC_TextAndLinkContent){ textContentLb.hidden = NO; multipleContentV.hidden = NO; textContentLb.text = cellModel.contentTextStr; } else if (self.cellModel.contentType == FC_OnlyMovieContent){ textContentLb.hidden = YES; multipleContentV.hidden = NO; } else if (self.cellModel.contentType == FC_TextAndMovieContent){ textContentLb.hidden = NO; multipleContentV.hidden = NO; textContentLb.text = cellModel.contentTextStr; } if (self.cellModel.approveContentHigh &gt; 0){ approveNameLb.text = self.cellModel.approveContentStr; }else{ approveNameLb.text = @&quot;&quot;; } } 调用cell的layoutSubviews来完成布局 /* 布局的逻辑，显示获取内容的整体高度，即先设置fcContentView的高度 再排版里面的自子视图 文字 + 图片的内容 */ //FriendCircleCell.m - (void)layoutSubviews { [multipleContentV removeGestureRecognizer:linkTapGesture]; if (self.cellModel.contentType == FC_OnlyTextContent) { fcContentView.height = _cellModel.textContentHigh;// 文本高度 } else if(self.cellModel.contentType == FC_OnlyLinkContent || self.cellModel.contentType == FC_TextAndLinkContent){ //// 链接类型 fcContentView.height = LinkViewHight; // 链接内容UI的高度 multipleContentV.height = LinkViewHight; if (self.cellModel.contentType == FC_TextAndLinkContent) { fcContentView.height = self.cellModel.textContentHigh + LinkViewHight; } float multipleContentVPosY = 0; //文字 if(self.cellModel.contentType == FC_TextAndLinkContent){ textContentLb.height = _cellModel.textContentHigh; multipleContentVPosY = CGRectGetMaxY(textContentLb.frame); } // 链接 （优化UI：我们可以单独的写一个链接UI控件）+ 关联性比较弱（） multipleContentV.y = multipleContentVPosY; [multipleContentV removeAllSubView];// 移除之前的 [multipleContentV addGestureRecognizer:linkTapGesture]; //添加当前的类型 _fcLinkView.infoDict = self.cellModel.linkInfoDict; [multipleContentV addSubview:_fcLinkView]; } else if(self.cellModel.contentType == FC_TextAndPictureContent|| self.cellModel.contentType == FC_OnlyPictureContent){ //// 图片类型 fcContentView.height = self.cellModel.imageContentHigh; if (_cellModel.contentType == FC_TextAndPictureContent) { fcContentView.height = _cellModel.textContentHigh + _cellModel.imageContentHigh; } //文字 float multipleContentVPosY = 0; if(self.cellModel.contentType == FC_TextAndPictureContent) { textContentLb.height = _cellModel.textContentHigh; multipleContentVPosY = CGRectGetMaxY(textContentLb.frame); } //图片 multipleContentV.y = multipleContentVPosY; multipleContentV.height = self.cellModel.imageContentHigh; [multipleContentV removeAllSubView]; for (int i = 0; i &lt; self.cellModel.imageAry.count; i++) { int line = i/3; int row = i%3; int gap = 5; NSString *imageUrlStr = [self.cellModel.imageAry objectAtIndex:i]; UIImageView *imageV = [[UIImageView alloc] initWithFrame:CGRectMake(row*CellImageHight + row*gap, line*CellImageHight + line*gap, CellImageHight, CellImageHight)]; [imageV sd_setImageWithURL:[NSURL URLWithString:imageUrlStr] placeholderImage:[UIImage imageNamed:@&quot;logo.png&quot;]]; imageV.tag = i; imageV.userInteractionEnabled = YES; UITapGestureRecognizer *tapGestureR = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapImge:)]; [imageV addGestureRecognizer:tapGestureR]; [multipleContentV addSubview:imageV]; } } else if(self.cellModel.contentType == FC_OnlyMovieContent || self.cellModel.contentType == FC_TextAndMovieContent){ // 视频类型 fcContentView.height = MovieViewHight; if (self.cellModel.contentType == FC_TextAndMovieContent) { fcContentView.height = self.cellModel.textContentHigh + MovieViewHight; } float multipleContentVPosY = 0; //文字 if(self.cellModel.contentType == FC_TextAndMovieContent){ textContentLb.height = _cellModel.textContentHigh; multipleContentVPosY = CGRectGetMaxY(textContentLb.frame); } // 视频 multipleContentV.y = multipleContentVPosY; multipleContentV.height = MovieViewHight; [multipleContentV removeAllSubView]; MovieView *movieView = [[MovieView alloc] initWithFrame:CGRectMake(0, 0, MovieViewHight, MovieViewHight)]; movieView.movieURLStr = self.cellModel.moviePath; [multipleContentV addSubview:movieView]; movieView.backgroundColor = [UIColor yellowColor]; } // 时间+留言 fcTimeLb.text = [self.cellModel.timeStp stringByAppendingString:@&quot;分钟前&quot;]; fcTimeAndMesView.frame = ({ CGRect tmpRect = fcTimeAndMesView.frame; tmpRect.origin.y = CGRectGetMaxY(fcContentView.frame); tmpRect; }); // 留言内容Table } 可以自定义cell中的子view，如FCLinkView、MessageView @interface FCLinkView : UIView{ IBOutlet UIImageView *_imageview; IBOutlet UILabel *_descLb; } @property (nonatomic, strong)NSDictionary *infoDict; @end @interface MessageView : UIView{ UITableView *_messageTable; } @property (nonatomic, strong)NSArray *messageAry; @property (nonatomic, assign)float height; @end 朋友圈性能优化 分析 /* 轻量化工具（SD） 主要的操作放到子线程，任务（线程）NSOperation if(缓存有图片){ // 缓存策略 1读取缓存图片 2加载图片 }else{ // 缓存没图片 1下载图片 // 同步下载处理 2下载完图片（图片的bitmap转化） 保存（bitmap）／／ png-》bitmap 3加载图片 } 异常情况(优化)： 1 如果中途取消操作了（imageview为nil，图片不用加载了），取消处理 2 如果在加载过程中，imageview切换了图片（之前的图片未被加载出来）取消上一个任务，加载当前任务 3 如果两个Imageview同时加载一个图片，去重处理，只需要一个下载，等图片下载完了，再同时加载(思考时间) 主线程操作: imageivew.image = image; // 设置取消节点（埋取消节点） 优化： {cache 忽略} 2MB cache只能保存几张图片就没了 （在一定程度时可以忽略） 数据库来实现缓存机制：进入前台open， 进入后台再close 1 文件打开 IO操作比较基本就一次 2 key 找对应data 沙盒文件： 1 多次的文件IO操作 2 根据MD5(url) 遍历文件夹里面的文件 */ 对UIImageView进行扩展，可以直接加载网络图片 //UIImageView + EOCLoad.h @interface UIImageView (EOCLoad) @property (nonatomic, strong)NSString *eocImageUrl; - (void)loadImageUrl:(NSString*)url placeholder:(UIImage*)image; @end 创建一个NSOperationQueue来运行每一个NSOperation， ////UIImageView + EOCLoad.m static NSOperationQueue *__eocImageQueue; @implementation UIImageView (EOCLoad) + (void)initialize { static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ __eocImageQueue = [NSOperationQueue new]; __eocImageQueue.maxConcurrentOperationCount = 6; }); } - (void)loadImageUrl:(NSString*)url placeholder:(UIImage*)image { self.image = image; self.eocImageUrl = url; ImageLoadOperation *operation = [ImageLoadOperation new]; operation.imageUrl = url; operation.imageView = self; [__eocImageQueue addOperation:operation]; } static char __eocImageUrl; - (void)setEocImageUrl:(NSString *)eocImageUrl{ objc_setAssociatedObject(self, &amp;__eocImageUrl, eocImageUrl, OBJC_ASSOCIATION_RETAIN); } - (NSString*)eocImageUrl{ return objc_getAssociatedObject(self, &amp;__eocImageUrl); } 创建一个ImageLoadOperation继承NSOperation，对其扩展属性 //ImageLoadOperation.h @interface ImageLoadOperation : NSOperation @property (nonatomic, strong)NSString *imageUrl; @property (nonatomic, weak)UIImageView *imageView; @end 实现NSOperation中的start和main方法，完成下载和缓存逻辑 //ImageLoadOperation.m typedef BOOL(^CancelBlock)(); static NSCache *__eocImageCache; static NSMutableDictionary *__sameTaskDict; static NSMutableArray *__sameTaskAry; static NSLock *__eocImageLock; @implementation ImageLoadOperation @synthesize finished = _finished; // 重写了属性关联的变量名 //操作的是成员变量 + (void)initialize{ static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ __eocImageCache = [NSCache new]; }); } /* 1NSCache 2本地沙盒文件是否存在该图片文件 */ // 主要做一些开启任务前的处理 - (void)start{ [self main]; } /* url没变，图片变了 不能用缓存 */ // 核心业务 - (void)main{ // 1 是否有缓存(cache,local文件) url() CancelBlock isCancelBlock = ^BOOL(){ BOOL cancel = NO; if (!self.imageView) { cancel = YES; } else if(![self.imageView.eocImageUrl isEqualToString:self.imageUrl]){ cancel = YES; } return cancel; }; NSData *imageData = [self cacheForKey:self.imageUrl]; if (imageData) { if (!isCancelBlock()) { [self mainThreadLoadImage:[UIImage imageWithData:imageData]]; } } else { if([__sameTaskDict objectForKey:self.imageUrl]){ // task已经在操作 把imageview 添加__sameTaskAry, NSValue *value = [NSValue valueWithNonretainedObject:self.imageView]; [__eocImageLock lock]; [__sameTaskAry addObject:value]; [__eocImageLock unlock]; [self finishStatus]; return ; }else { // task添加新任务 [__eocImageLock lock]; [__sameTaskDict setObject:@&quot;1&quot; forKey:self.imageUrl]; [__eocImageLock unlock]; } // 没有缓存 // 1 下载图片 不能浪费这次下载，所以还是把数据保存起来，下载完成后不加取消节点 // 网速慢的情况 imageData = [self netLoadImageWithUrl:self.imageUrl]; if (!imageData) { [__eocImageLock lock]; [__sameTaskDict removeObjectForKey:self.imageUrl]; [__eocImageLock unlock]; [self finishStatus]; return; } // 2 bitmap转换，因为在交给GPU渲染之前，cpu会将图片转换为bitmap的图片，所以存储图片应该是bitmap的形式，下载取缓存之后就不需要再转换 UIImage *bitmapImage = [self bitmapFromImage:[UIImage imageWithData:imageData]]; // 3 保存 NSData *bitmapData = UIImageJPEGRepresentation(bitmapImage, 1); [self saveBitmapImageData:bitmapData url:self.imageUrl]; // 4.1 处理多个task imageview1，imageview2 ...... NSMutableArray *handleImageVry = [NSMutableArray new]; // 即将处理的 NSMutableArray *cancelImageVry = [NSMutableArray new]; // 取消了的 for (int i = 0; i &lt; __sameTaskAry.count; i++) { NSValue *value = __sameTaskAry[i]; UIImageView *imageView = [value nonretainedObjectValue]; // 获取取消的任务 if (!imageView) { [cancelImageVry addObject:value]; } // 获取当前相同的任务 if ([imageView.eocImageUrl isEqualToString:self.imageUrl]) { [handleImageVry addObject:value]; } } // 在__sameTaskAry把重复的任务移除 for (int i = 0; i &lt; cancelImageVry.count; i++) { [__sameTaskAry removeObject:cancelImageVry[i]]; } for (int i = 0; i &lt; handleImageVry.count; i++) { [__sameTaskAry removeObject:handleImageVry[i]]; } // 处理当前相同任务 for (int i = 0; i &lt; handleImageVry.count; i++){ NSValue *value = handleImageVry[i]; UIImageView *imageView = [value nonretainedObjectValue]; if (!isCancelBlock() &amp;&amp; !imageView){ dispatch_async(dispatch_get_main_queue(), ^{ imageView.image = bitmapImage; }); } } [__eocImageLock lock]; [__sameTaskDict removeObjectForKey:self.imageUrl]; [__eocImageLock unlock]; if (!isCancelBlock()){ [self mainThreadLoadImage:bitmapImage]; } // 4 加载 if (!isCancelBlock()){ [self mainThreadLoadImage:bitmapImage]; } } //将finish设置为yes，表明此NSOperation执行完毕，才能将其从NSOperationQueue中移除 [self finishStatus]; } - (NSData*)cacheForKey:(NSString*)key{ NSData *imageData = [__eocImageCache objectForKey:[self md5FromStr:key]]; if (!imageData) { imageData = [self findImageFromKey:[self md5FromStr:key]]; } return imageData; } // 默认放到沙盒的document下面 - (NSData*)findImageFromKey:(NSString*)url{ NSString *documentPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]; NSString *filePath = [documentPath stringByAppendingPathComponent:[self md5FromStr:url]]; return [NSData dataWithContentsOfFile:filePath]; } // 主线程显示图片 mainThreadLoadImage这个操作之前都设置了取消节点 - (void)mainThreadLoadImage:(UIImage*)image{ dispatch_async(dispatch_get_main_queue(), ^{ self.imageView.image = image; }); } // 同步的 信号量 - (NSData*)netLoadImageWithUrl:(NSString*)url{ __block NSData *imageData = nil; dispatch_semaphore_t sema = dispatch_semaphore_create(0); NSURLSessionTask *task = [[NSURLSession sharedSession] dataTaskWithURL:[NSURL URLWithString:url] completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) { imageData = data; if (error) { NSLog(@&quot;网络异常：%@&quot;, error); } dispatch_semaphore_signal(sema); }]; [task resume]; dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER); return imageData; } // 手动进行KVO操作 - (void)finishStatus{ [self willChangeValueForKey:@&quot;finished&quot;]; _finished = YES; [self didChangeValueForKey:@&quot;finished&quot;]; } #pragma mark - bitmap - (UIImage*)bitmapFromImage:(UIImage*)targetImage{ CGImageRef imageRef = targetImage.CGImage; CGContextRef contextRef = CGBitmapContextCreate(NULL, CGImageGetWidth(imageRef), CGImageGetHeight(imageRef), CGImageGetBitsPerComponent(imageRef), CGImageGetBytesPerRow(imageRef), CGImageGetColorSpace(imageRef), CGImageGetBitmapInfo(imageRef)); CGContextDrawImage(contextRef, CGRectMake(0, 0, CGImageGetWidth(imageRef), CGImageGetHeight(imageRef)), imageRef); CGImageRef bitmapRef = CGBitmapContextCreateImage(contextRef); UIImage *bitmapImage = [UIImage imageWithCGImage:bitmapRef]; CFRelease(bitmapRef); UIGraphicsEndImageContext(); return bitmapImage; } 朋友圈优化+大数据量压力方案 数据变化，需要被动刷新 @interface WXFriendCircleVCtr (Flush){ } @property (nonatomic, strong)NSMutableArray *newMessageArr; - (void)configFlushMessage; @end @implementation WXFriendCircleVCtr (Flush) - (void)configFlushMessage{ // kCFRunLoopBeforeWaiting 监听空闲时状态 CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopBeforeWaiting, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) { // 刷新界面 主线程 NSTimeInterval pretime = CFAbsoluteTimeGetCurrent(); NSTimeInterval nextTime = CFAbsoluteTimeGetCurrent(); // 10*1024 大数据量，主要思想是拆分数据量来执行，一次最多执行多少条，主要在拆分策略 // 1 根据时间片段来操作 if (nextTime - pretime &gt; 1 ) { if (self.newMessageArr.count &gt; 10) { }else{ } } // 2 根据observer回掉次数来执行 // static int count = 0; // count++; // if (count%3 == 0) { // if (self.newMessageArr.count &gt; 10) { // // }else{ // // } // } NSArray *visibleCellAry = [_tableview visibleCells]; NSMutableArray *flushCellAry = [NSMutableArray new]; for (int i = 0; i &lt; visibleCellAry.count; i++) { FriendCircleCell *cell = visibleCellAry[i]; if(cell.cellModel.isFlush){ [flushCellAry addObject:[_tableview indexPathForCell:cell]]; cell.cellModel.isFlush = NO; } } if(flushCellAry.count &gt; 0){ [_tableview reloadRowsAtIndexPaths:flushCellAry withRowAnimation:UITableViewRowAnimationNone]; } }); // 监听的是kCFRunLoopDefaultMode CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes); [self netDataFromServer]; } // 获取服务器数据 - (void)netDataFromServer{ [NSThread detachNewThreadSelector:@selector(timerServer) toTarget:self withObject:nil]; } - (void)timerServer { NSTimer *timer = [NSTimer timerWithTimeInterval:2 target:self selector:@selector(productData) userInfo:nil repeats:YES]; //子线程中如果要实现Timer，必须手动开启一个RunLoop [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; [[NSRunLoop currentRunLoop] run]; } - (void)productData{ static int __testCount = 50; NSString *messageID = [@(__testCount++) description]; for (int i = 0; i &lt; _fcDataAry.count; i++) { FriendCircleModel *model = _fcDataAry[i]; if([model.timeStp isEqualToString:messageID]){ model.isFlush = YES; // 添加一条回复数据 //0(楼主回复XX:) 1(XX回复楼主:) 2(楼主回复:) 3(XX回复:) NSMutableDictionary *messDict = [NSMutableDictionary dictionary]; [messDict setObject:messageID forKey:@&quot;name&quot;]; [messDict setObject:[NSString stringWithFormat:@&quot;被动:%@&quot;, messageID] forKey:@&quot;msg&quot;]; [messDict setObject:@&quot;2&quot; forKey:@&quot;status&quot;]; [model.messageAry addObject:messDict]; [model.cellCellContentAry addObject:[FriendCircleModel messageContentFromDict:messDict]]; [FriendCircleCell fcCellHeight:model]; } } // 主动换醒主线程 （如果主线程处于睡眠状态，那么需要主动换醒） dispatch_async(dispatch_get_main_queue(), ^{ CFRunLoopWakeUp(CFRunLoopGetMain()); }); } @end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>iOS</tag>
        <tag>代码实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS性能优化实践]]></title>
    <url>%2F2017%2F06%2F30%2FiOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[iOS性能优化实践一腾讯bugly？？？dysm日志分析？？？ Instruments使用：用工具来监测App的各项性能，让性能了然于心。 Activity Monitor 一款ios活动监视器，能看到每一个应用所占用的系统资源情况,如：使用线程数，使用CPU时长，实际使用内存大小等。 Allocations 内存分配情况查看工具，可以查看每一个对象所占用的内存大小。方便定位内存消耗在哪些对象上 Core Animation Blended像素混合：当图层有半透明时，GPU需要进行像素混合，需要先绘制透明层下层的内容，再叠加透明层以达到透明的效果，而不影响帧率的情况下，GPU可绘制的像素是有限制的。通常优化方式：backgroundColor设置为不透明色/Opaque设置为YES/图片能不用透明的切图成不透明。没有像素混合的显示绿色，有像素混合的显示红色。重要的是backgroundColor属性，如果不设置这个属性，控件依然被认为是透明的，所以我们做的第一个优化是设置控件的backgroundColor属性。 //如果label文字有中文，依然会出现图层混合，这是因为此时label多了一个sublayer //只有最后一个没有出现像素混合的情况 [self testBlendedLayer:^(UILabel *label) { label.frame = CGRectMake(leftOffset, topOffset, width, 30); topOffset += 50; label.text = @&quot;背景颜色：默认&quot;; }]; [self testBlendedLayer:^(UILabel *label) { label.frame = CGRectMake(leftOffset, topOffset, width, 30); topOffset += 50; label.text = @&quot;背景颜色：半透明&quot;; label.backgroundColor = [UIColor colorWithWhite:0 alpha:0.3]; }]; [self testBlendedLayer:^(UILabel *label) { label.frame = CGRectMake(leftOffset, topOffset, width, 30); topOffset += 50; label.text = @&quot;背景颜色：不透明&quot;; label.backgroundColor = [UIColor lightGrayColor]; }]; [self testBlendedLayer:^(UILabel *label) { label.frame = CGRectMake(leftOffset, topOffset, width, 30); topOffset += 50; label.text = @&quot;背景颜色：无混合情况&quot;; label.backgroundColor = [UIColor lightGrayColor]; label.layer.masksToBounds = YES; }]; Color Copied images 像素在内存中的布局和它在磁盘中的存储方式并不相同。考虑一种简单的情况：每个像素有R、G、B和alpha四个值，每个值占用1字节，因此每个像素占用4字节的内存空间。一张1920*1080的照片(iPhone6 Plus的分辨率)一共有2,073,600个像素，因此占用了超过8Mb的内存。但是一张同样分辨率的PNG格式或JPEG格式的图片一般情况下不会有这么大。这是因为JPEG将像素数据进行了一种非常复杂且可逆的转化。所以CPU主要处理两件事： 把图片从PNG或JPEG等格式中解压出来，得到像素数据 如果GPU不支持这种颜色格式，CPU需要进行格式转换 图片能否需CPU要转码，需要的显示蓝色。如果图片格式GPU不能直接绘制，则会交给CPU先转码处理 //如果直接赋值origin，则图片会出现蓝色，赋值image才是正常显示 UIImageView imageView = [[UIImageView alloc] initWithFrame:self.view.bounds]; UIImage origin = [UIImage imageNamed:@”16.png”]; UIImage *image = [EOCUtil decodeImage:origin toSize:imageView.layer.bounds.size]; imageView.image = image; imageView.opaque = YES; [self.view addSubview:imageView]; (UIImage )decodeImage:(UIImage )image toSize:(CGSize)size {if (image == nil) { // Prevent “CGBitmapContextCreateImage: invalid context 0x0” error return nil;} @autoreleasepool{ // do not decode animated images if (image.images != nil) { return image; } CGImageRef imageRef = image.CGImage; CGImageAlphaInfo alpha = CGImageGetAlphaInfo(imageRef); BOOL anyAlpha = (alpha == kCGImageAlphaFirst || alpha == kCGImageAlphaLast || alpha == kCGImageAlphaPremultipliedFirst || alpha == kCGImageAlphaPremultipliedLast); if (anyAlpha) { NSLog(@&quot;图片解压失败，存在alpha通道&quot;); return image; } // current CGColorSpaceModel imageColorSpaceModel = CGColorSpaceGetModel(CGImageGetColorSpace(imageRef)); CGColorSpaceRef colorspaceRef = CGImageGetColorSpace(imageRef); BOOL unsupportedColorSpace = (imageColorSpaceModel == kCGColorSpaceModelUnknown || imageColorSpaceModel == kCGColorSpaceModelMonochrome || imageColorSpaceModel == kCGColorSpaceModelCMYK || imageColorSpaceModel == kCGColorSpaceModelIndexed); if (unsupportedColorSpace) { colorspaceRef = CGColorSpaceCreateDeviceRGB(); } CGFloat scale = [UIScreen mainScreen].scale; size_t width = size.width; size_t height = size.height; NSUInteger bytesPerPixel = 4; NSUInteger bytesPerRow = bytesPerPixel * width; NSUInteger bitsPerComponent = 8; // kCGImageAlphaNone is not supported in CGBitmapContextCreate. // Since the original image here has no alpha info, use kCGImageAlphaNoneSkipLast // to create bitmap graphics contexts without alpha info. CGContextRef context = CGBitmapContextCreate(NULL, width, height, bitsPerComponent, bytesPerRow, colorspaceRef, kCGBitmapByteOrderDefault|kCGImageAlphaNoneSkipLast); // Draw the image into the context and retrieve the new bitmap image without alpha CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef); CGImageRef imageRefWithoutAlpha = CGBitmapContextCreateImage(context); UIImage *imageWithoutAlpha = [UIImage imageWithCGImage:imageRefWithoutAlpha scale:scale orientation:image.imageOrientation]; if (unsupportedColorSpace) { CGColorSpaceRelease(colorspaceRef); } CGContextRelease(context); CGImageRelease(imageRefWithoutAlpha); NSLog(@&quot;图片解压成功&quot;); return imageWithoutAlpha; } * Misaligned图像无法重合。在项目中，我们网络请求图片，大小不一，但是展示的UIImageView有时候是固定大小。这时候我们就需要图片的缩放了。图片的缩放需要占用时间，因此我们要尽可能保证无论是本地图片还是从网络或取得图片的大小，都与其frame保持一致。 Misaligned Image表示要绘制的图像无法直接映射到屏幕上，此时系统需要进行缩放，抗锯齿等操作，增加了图形负担，通常这种问题出在对某些View的Frame重新计算和设置时产生的 //如果图片需要缩放则标记为黄色，如果没有像素对齐则标记为紫色，下例中如果赋值image1则会出现黄色蒙层，用image正常显示 EOCImageView *imageView = [[EOCImageView alloc] initWithFrame:CGRectMake(0, 70, 382, 200)]; UIImage *image = [EOCUtil decodeImage:[UIImage imageNamed:@&quot;770CB6EB-1524-44DE-987A-DB929C4AA544.jpeg&quot;] toSize:CGSizeMake(imageView.layer.bounds.size.width*2, imageView.layer.bounds.size.height*2)]; UIImage *image1 = [UIImage imageNamed:@&quot;770CB6EB-1524-44DE-987A-DB929C4AA544.jpeg&quot;]; imageView.image = image; imageView.opaque = YES; imageView.backgroundColor = [UIColor lightGrayColor]; imageView.clipsToBounds = YES; [self.view addSubview:imageView]; * Offscreen-Rendered工具：离屏渲染（CPU）：离屏渲染表示渲染发生在屏幕之外。离屏渲染意味着把渲染结果临时保存，等用到时再取出，因此相对于普通渲染更占用资源。 “Color Offscreen-Rendered Yellow”会把需要离屏渲染的地方标记为黄色，大部分情况下我们需要尽可能避免黄色的出现。离屏渲染可能会自动触发，也可以手动触发。以下情况可能会导致触发离屏渲染： 1. 重写drawRect方法；（自动触发离屏渲染） 2. 有mask或者是阴影(layer.masksToBounds, layer.shadow*)，模糊效果也是一种mask；（自动触发离屏渲染） 3. layer.shouldRasterize = true； &gt; （手动开启离屏渲染）drawRect UIGraphicGetCurrentContext() 、使用Core Graphics CreateBitMapContext()，以上两种情况都会开辟一个CGContext，分配一块内存空间，用于离屏渲染。离屏渲染（GPU）：设置cornerRadius, masks, shadows,edge antialiasing等，设置layer.shouldRasterize ＝ YES，用在view界面后续没有变化？？？ //如果图片使用了阴影，也是黄色，这说明它也进行了离屏渲染，解决方案，在设置阴影效果的四行代码下面添加一行： //这行代码制定了阴影路径，如果没有手动指定，Core Animation会去自动计算，这就会触发离屏渲染。如果人为指定了阴影路径，就可以免去计算，从而避免产生离屏渲染。 imgView.layer.shadowPath = UIBezierPath(rect: imgView.bounds).CGPath * Color Hits Green and Misses Red ：由于Shadow、Mask和Gradient等原因渲染很高，通常通过设置shouldRasterize栅格化属性为YES，缓存渲染内容。命中缓存image，显示绿色，未命中，显示红色，显然绿色越多越好，红色越少越好？？？ //光栅化是将一个layer预先渲染成位图(bitmap)，然后加入缓存中。如果对于阴影效果这样比较消耗资源的静态内容进行缓存，可以得到一定幅度的性能提升 - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { __block UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;EOCTableViewCell&quot; forIndexPath:indexPath]; // Configure the cell... static int i = 0; for (UILabel *label in cell.contentView.subviews) { if ([label isKindOfClass:[UILabel class]]) { label.text = [NSString stringWithFormat:@&quot;helloworld %d&quot;, i++]; label.layer.shouldRasterize = YES; } } return cell; } &gt; 光栅化的缓存机制是一把双刃剑，先写入缓存再读取有可能消耗较多的时间。因此光栅化仅适用于较复杂的、静态的效果。通过Instrument的调试发现，这里使用光栅化经常出现未命中缓存的情况，如果没有特殊需要则可以关闭光栅化 * Color Compositing Fast-Path Blue:离屏渲染的最后一步是把此前的多个路径组合起来。如果这个组合过程能由CPU完成，就会大量减少GPU的工作。这种技术在绘制地图中可能用到。工具用于标记由硬件绘制的路径，蓝色越多越好 * Flash updated Regions：刷新视图时，我们应该把需要重绘的区域尽可能缩小。对于未发生变化的内容则不应该重绘。工具用于标记发生重绘的区域 避免图层混合 确保控件的opaque属性设置为true，确保backgroundColor和父视图颜色一致且不透明； 如无特殊需要，不要设置低于1的alpha值； 确保UIImage没有alpha通道； 避免临时转换 确保图片大小和frame一致，不要在滑动时缩放图片； 确保图片颜色格式被GPU支持，避免劳烦CPU转换； 慎用离屏渲染 绝大多数时候离屏渲染会影响性能； 重写drawRect方法，设置圆角、阴影、模糊效果，光栅化都会导致离屏渲染； 设置阴影效果是加上阴影路径； 滑动时若需要圆角效果，开启光栅化； Counter 查看App的可能的性能瓶颈，Performance monitor counters (PMCs) 即Counter工具，衡量处理器发生的事件个数 System trace工具 它显示线程的调度、系统线程的转化和内存使用情况。简单点说就是记录一个App运行过程中所有底层系统线程、内存的调度使用过程的工具。 Timer Profiler 它按照固定的时间间隔来跟踪每一个线程的堆栈信息，通过统计比较时间间隔之间的堆栈状态，来推算某个方法执行了多久，并获得一个近似值。其实从根本上来说与我们的原始分析方法异曲同工，只不过其将各个方法消耗的时间统计起来。 iOS性能优化实践二autolayout性能分析：frame&gt;autolayout(absolute)&gt;autolayout(relative) OpenGL、CoreAnimation在GPU上，CoreGraphic在CPU上 轻量化主线程 - (void)showImageView { if (self.imageView.image) { self.imageView.image = nil; }else { //这里占用主线程过多 //改为后台线程加载，再用主线程设置 //self.imageView.image = [UIImage imageNamed:@&quot;timg.jpg&quot;]; __weak typeof(self) weakSelf = self; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ UIImage *image = [UIImage imageNamed:@&quot;timg.jpg&quot;]; dispatch_async(dispatch_get_main_queue(), ^{ weakSelf.imageView.image = image; }); }); } [self.imageView setNeedsDisplay]; } UITableView封装 //EOCBaseTableViewController类 @interface EOCBaseTableViewController () @property (assign, nonatomic) int pageIndex; @property (assign, nonatomic) BOOL isLoading; @end - (void)viewDidLoad { [super viewDidLoad]; [self refresh]; } - (void)refresh { self.pageIndex = 0; [self loadMore]; } - (void)loadMore { __block typeof(self) weakSelf = self; NSLog(@&quot;load %d&quot;,self.pageIndex); [[EOCNet shareManager] loadNewsWithStart:self.pageIndex complete:^(NSDictionary *object) { NSLog(@&quot;result %@&quot;, object); if ([[object valueForKey:@&quot;result&quot;] isKindOfClass:[NSDictionary class]]) { dispatch_async(dispatch_get_main_queue(), ^{ NSArray *newArray = [[object valueForKey:@&quot;result&quot;] valueForKey:@&quot;list&quot;]; if (weakSelf.pageIndex == 0) { [weakSelf.dataManager removeAllObjcets]; } [weakSelf.dataManager appendData:newArray]; weakSelf.pageIndex += (int)[newArray count]; [weakSelf.tableView.infiniteScrollingView stopAnimating]; [weakSelf.tableView.pullToRefreshView stopAnimating]; [weakSelf.tableView reloadData]; weakSelf.isLoading = NO; }); }else { weakSelf.isLoading = NO; } } failed:^(NSError *error) { NSLog(@&quot;%@&quot;,error); [weakSelf.tableView.infiniteScrollingView stopAnimating]; [weakSelf.tableView.pullToRefreshView stopAnimating]; weakSelf.isLoading = NO; }]; } //EOCNewsTableViewController类 - (EOCNewsDataManager *)dataManager { if (!_dataManager) { _dataManager = [EOCNewsDataManager manager]; __weak typeof(self) weakSelf = self; [_dataManager setUpdateRowHeightBlock:^(NSDictionary *info) { [weakSelf.tableView performSelectorOnMainThread:@selector(reloadData) withObject:nil waitUntilDone:NO]; }]; } return _dataManager; } - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section { return [self.dataManager.newsInfo count]; } - (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath { //主线程---&gt;子线程移除所有数据---&gt;主线程继续执行 NSDictionary *rowInfo = [self.dataManager.newsInfo objectAtIndex:indexPath.row]; return [rowInfo rowHeight]; } - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { EOCNewsTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;EOCNewsTableViewCell&quot; forIndexPath:indexPath]; if (indexPath.row &gt; [self.dataManager.newsInfo count]) { return cell; } cell.info = [self.dataManager.newsInfo objectAtIndex:indexPath.row]; return cell; } //EOCNewsDataManager类 @interface EOCNewsDataManager : NSObject @property (strong, nonatomic) NSMutableArray *newsInfo; + (EOCNewsDataManager *)manager; //缓存行高等，新增value key对时使用 - (void)modifyRowInfo:(NSDictionary *)rowInfo value:(id)value key:(NSString *)key; //刷新行高回调 - (void)setUpdateRowHeightBlock:(void (^)(NSDictionary *info))UpdateRowHeightBlock; @end @interface EOCNewsDataManager () @property (strong, nonatomic) void (^UpdateRowHeightBlock)(NSDictionary *info); @end @implementation EOCNewsDataManager + (EOCNewsDataManager *)manager { static EOCNewsDataManager *__manager = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ if (!__manager) { __manager = [[EOCNewsDataManager alloc] init]; } }); return __manager; } - (NSMutableArray *)newsInfo { if (!_newsInfo) { _newsInfo = [NSMutableArray arrayWithCapacity:100]; } return _newsInfo; } - (void)modifyRowInfo:(NSDictionary *)rowInfo value:(id)value key:(NSString *)key { if ([key isEqualToString:@&quot;bitmapImage&quot;]) { rowInfo.bitmapImage = value; }else if ([key isEqualToString:@&quot;titleHeight&quot;]) { if (fabs(rowInfo.titleHeight - [value floatValue]) &lt; 1.0) { return; } rowInfo.titleHeight = [value floatValue]; }else if ([key isEqualToString:@&quot;imageHeight&quot;]) { if (fabs(rowInfo.titleHeight - [value floatValue]) &lt; 1.0) { return; } rowInfo.imageHeight = [value floatValue]; }else if ([key isEqualToString:@&quot;rowHeight&quot;]) { if (fabs(rowInfo.titleHeight - [value floatValue]) &lt; 1.0) { return; } rowInfo.rowHeight = [value floatValue]; }else { NSMutableDictionary *dic = [NSMutableDictionary dictionaryWithDictionary:rowInfo]; [dic setObject:value forKey:key]; if ([self.newsInfo containsObject:rowInfo]) { NSInteger rowNum = [self.newsInfo indexOfObject:rowInfo]; [self.newsInfo replaceObjectAtIndex:rowNum withObject:dic]; }else { return; } } if (([key isEqualToString:@&quot;imageHeight&quot;] || [key isEqualToString:@&quot;titleHeight&quot;]) &amp;&amp; self.UpdateRowHeightBlock) { self.UpdateRowHeightBlock(rowInfo); } } @end //NSDictionary + NewsInfo类 @interface NSDictionary (NewsInfo) @property (weak, readonly) NSString *title; @property (weak, readonly) NSString *time; @property (weak, readonly) NSString *src; @property (weak, readonly) NSString *pic; @property (weak, readonly) NSString *content; @property (assign, nonatomic) float imageHeight; @property (assign, nonatomic) float titleHeight; @property (assign, nonatomic) float rowHeight; @property (strong, nonatomic) UIImage *bitmapImage; + (CGFloat)heightForImage:(UIImage *)image fitWidth:(CGFloat)width; + (float)heightForString:(NSString *)string size:(CGSize)boundingSize font:(UIFont *)font; @end @implementation NSDictionary (NewsInfo) - (NSString *)title { return [self valueForKey:@&quot;title&quot;]; } - (NSString *)time { return [self valueForKey:@&quot;time&quot;]; } - (NSString *)src { return [self valueForKey:@&quot;src&quot;]; } - (NSString *)pic { return [self valueForKey:@&quot;pic&quot;]; } - (NSString *)content { return [self valueForKey:@&quot;content&quot;]; } - (void)dealloc { objc_removeAssociatedObjects(self); } - (float)rowHeight { NSNumber *height = objc_getAssociatedObject(self, @&quot;rowHeight&quot;); if (!height) { height = @([self imageHeight] + [self titleHeight] + 48 /*22.0 + 8.0*2 + 5.0 + 5.0*/); self.rowHeight = [height floatValue]; } return [height floatValue]; } - (void)setRowHeight:(float)rowHeight { objc_setAssociatedObject(self, &quot;rowHeight&quot;, @(rowHeight), OBJC_ASSOCIATION_RETAIN); } - (float)imageHeight { NSNumber *height = objc_getAssociatedObject(self, &quot;imageHeight&quot;); if (!height) { return 120.0; }else { return height.floatValue; } } - (void)setImageHeight:(float)imageHeight { objc_setAssociatedObject(self, &quot;imageHeight&quot;, @(imageHeight), OBJC_ASSOCIATION_RETAIN); } - (float)titleHeight { NSNumber *height = objc_getAssociatedObject(self, &quot;titleHeight&quot;); if (!height) { return 0.0; }else { return height.floatValue; } } - (void)setTitleHeight:(float)titleHeight { objc_setAssociatedObject(self, &quot;titleHeight&quot;, @(titleHeight), OBJC_ASSOCIATION_RETAIN); } - (UIImage *)bitmapImage { UIImage *image = objc_getAssociatedObject(self, &quot;bitmapImage&quot;); return image; } - (void)setBitmapImage:(UIImage *)bitmapImage { objc_setAssociatedObject(self, &quot;bitmapImage&quot;, bitmapImage, OBJC_ASSOCIATION_RETAIN); } + (float)heightForString:(NSString *)string size:(CGSize)boundingSize font:(UIFont *)font { return [string?:@&quot;&quot; boundingRectWithSize:boundingSize options:NSStringDrawingUsesLineFragmentOrigin attributes:@{NSFontAttributeName:font} context:nil].size.height; } + (CGFloat)heightForImage:(UIImage *)image fitWidth:(CGFloat)width { if (!image) { NSLog(@&quot;heightForImage 图片为空&quot;); return 0.0; } return width/(image.size.width * image.scale) * (image.size.height * image.scale); } //EOCNewsTableViewCell类 @interface EOCNewsTableViewCell () @property (weak, nonatomic) IBOutlet NSLayoutConstraint *imageViewHeight; @property (weak, nonatomic) IBOutlet UIImageView *leftImageView; @property (weak, nonatomic) IBOutlet NSLayoutConstraint *titleHeight; @property (weak, nonatomic) IBOutlet UILabel *titleLabel; @property (weak, nonatomic) IBOutlet UILabel *timeLabel; @end @implementation EOCNewsTableViewCell - (void)setInfo:(NSDictionary *)info { _info = info; __weak typeof(self) weakSelf = self; NSURL *url = [NSURL URLWithString:info.pic]; [self.leftImageView sd_setImageWithURL:url placeholderImage:nil completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, NSURL *imageURL) { if (image) { weakSelf.leftImageView.image = image; weakSelf.imageViewHeight.constant = [NSDictionary heightForImage:image fitWidth:weakSelf.leftImageView.frame.size.width]; } else { weakSelf.imageViewHeight.constant = 1.0; } [[EOCNewsDataManager manager] modifyRowInfo:info value:@(weakSelf.imageViewHeight.constant) key:@&quot;imageHeight&quot;]; }]; self.titleLabel.text = info.title?:@&quot;&quot;; self.timeLabel.numberOfLines = 100; CGFloat titleHeight = [info titleHeight]; if (titleHeight &lt; 1.0) { CGFloat height = [[info class] heightForString:self.titleLabel.text size:CGSizeMake([UIScreen mainScreen].bounds.size.width - 8*2, CGFLOAT_MAX) font:self.titleLabel.font]; [[EOCNewsDataManager manager] modifyRowInfo:info value:@(height) key:@&quot;titleHeight&quot;]; } self.titleHeight.constant = [info titleHeight]; self.titleLabel.text = info.title?:@&quot;&quot;; self.timeLabel.text = info.time; } @end UITableView的复用机制是享元设计模式，当其复用时，会生成N+1个Cell 上例中可以看到执行过程如下，每次改变都需要reloadData，如果下载的图片多，会造成主线程卡顿，所以为了减少不必要的刷新，减轻主线程的任务，可以监听RunLoop，在RunLoop空闲时去刷新 [EOCBaseTableViewController refresh] [EOCBaseTableViewController reloadData] [EOCNewsTableViewController cellForRowAtIndexPath] [EOCNewsTableViewCell setInfo:] 条件执行[EOCNewsDataManager modifyRowInfo:] [EOCNewsDataManager UpdateRowHeightBlock] [EOCBaseTableViewController reloadData] //EOCNewsTableViewControllerNew类 - (void)viewDidLoad { [super viewDidLoad]; self.indexs = [NSMutableArray array]; __weak typeof(self) weakSelf = self; self.runloop = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopBeforeWaiting, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) { CFStringRef model = CFRunLoopCopyCurrentMode(CFRunLoopGetCurrent()); NSLog(@&quot;%@&quot;,(__bridge NSString *) model); CFRelease(model); [weakSelf.indexs removeAllObjects]; NSArray *visibleCells = [weakSelf.tableView visibleCells]; for (EOCNewsTableViewCell *cell in visibleCells) { if (fabs([cell.info rowHeight] - cell.frame.size.height) &gt; 1.0) { [weakSelf.indexs addObject:[weakSelf.tableView indexPathForCell:cell]]; } } if (weakSelf.indexs.count &gt; 0) { [EOCUtil runInMain:^{ NSLog(@&quot;update Row&quot;); [weakSelf.tableView reloadRowsAtIndexPaths:weakSelf.indexs withRowAnimation:UITableViewRowAnimationFade]; }]; } }); CFRunLoopAddObserver(CFRunLoopGetMain(), self.runloop, kCFRunLoopCommonModes); } 上述例子虽然可以减轻主线程的负担，但是引起UITableView卡顿的原因来自各个方面，比较常见的原因有cell的层级过多、cell中有触发离屏渲染的代码（譬如：cornerRadius、maskToBounds 同时使用）、像素是否对齐、是否使用UITableView自动计算cell高度的方法等。而使用core text可以将文本绘制在一个CGContextRef上，最后再通过UIGraphicsGetImageFromCurrentImageContext()生成图片，再将图片赋值给cell.contentView.layer，从而达到减少cell层级的目的。当然在生成图片的时候，是很耗资源的，将图片的绘制放在子线程里会更加有一个更好的UI体验。可以把生成的图片和cell的info数据相关联，存储起来，等到下次需要显示的时候，直接拿出来用。 //EOCCoreTextNewsTableViewCell类 - (void)setInfo:(NSDictionary *)info { _info = info; CGFloat titleHeight = [info titleHeight]; if (titleHeight &lt; 1.0) { CGFloat height = [[info class] heightForString:info.title size:CGSizeMake([UIScreen mainScreen].bounds.size.width - 8*2, CGFLOAT_MAX) font:[UIFont systemFontOfSize:17]]; [[EOCNewsDataManager manager] modifyRowInfo:info value:@(height) key:@&quot;titleHeight&quot;]; } self.coretextView.info = _info; [self.coretextView setNeedsDisplay]; } //EOCNewsCoreTextView类 - (void)setInfo:(NSDictionary *)info { _info = info; CGFloat titleHeight = [info titleHeight]; if (titleHeight &lt; 1.0) { CGFloat height = [[info class] heightForString:info.title size:CGSizeMake([UIScreen mainScreen].bounds.size.width - 8*2, CGFLOAT_MAX) font:[UIFont systemFontOfSize:17]]; [[EOCNewsDataManager manager] modifyRowInfo:info value:@(height) key:@&quot;titleHeight&quot;]; } #ifdef ENABLE_BACKGRUOND_CORETEXT if (!_info.bitmapImage) { [self drawInBackgound]; } else { [self setNeedsDisplay]; } #else [self setNeedsDisplay]; #endif } - (void)drawRect:(CGRect)rect { [super drawRect:rect]; #ifdef ENABLE_BACKGRUOND_CORETEXT if (self.info.bitmapImage) { CGContextTranslateCTM(context, 0, rect.size.height); CGContextRotateCTM(context, M_PI); CGContextScaleCTM(context, -1.0, 1.0); CGContextDrawImage(context, rect, self.info.bitmapImage.CGImage); }else { [self drawInBackgound]; } #else [self drawInMainThreadRect:rect]; #endif } - (void)drawInMainThreadRect:(CGRect)rect { CGContextRef context = UIGraphicsGetCurrentContext(); //设置当前文本矩阵 CGContextSetTextMatrix(context, CGAffineTransformIdentity); //文本沿y轴移动 CGContextTranslateCTM(context, 0, self.bounds.size.height); //文本翻转成为CoreText坐标系 CGContextScaleCTM(context, 1, -1); //创建绘制区域 CGMutablePathRef path = CGPathCreateMutable(); CGPathAddRect(path, NULL, CGRectMake(0, 0, rect.size.width, rect.size.height)); //创建需要绘制的文字 NSString *string = [self.info.title?:@&quot;&quot; stringByAppendingFormat:@&quot;\n%@&quot;,self.info.time]; NSMutableAttributedString *titleAttributeString = [[NSMutableAttributedString alloc] initWithString:string attributes:@{NSFontAttributeName:[UIFont systemFontOfSize:17], NSForegroundColorAttributeName:[UIColor blackColor]}]; NSString *imageUrl = self.info.pic; __weak typeof(self) weakSelf = self; UIImage *image = [[EOCImageDownManager shareInstance] loadImageWithUrl:imageUrl complete:^(UIImage *image, NSURL *imageURL, NSError *error) { if (image) { CGFloat imageHeight = [[weakSelf.info class] heightForImage:image fitWidth:SCREEN_WIDTH - 8*2]; if (fabs(weakSelf.info.imageHeight - imageHeight) &lt; 1.0) { return ; } else { [[EOCNewsDataManager manager] modifyRowInfo:weakSelf.info value:@(imageHeight) key:@&quot;imageHeight&quot;]; [weakSelf performSelectorOnMainThread:@selector(setNeedsDisplay) withObject:nil waitUntilDone:NO]; } } }]; if (image) { //图片绘制，设置代理 CTRunDelegateCallbacks callBacks; memset(&amp;callBacks,0,sizeof(CTRunDelegateCallbacks)); callBacks.version = kCTRunDelegateVersion1; callBacks.getAscent = ascentCallBacks; callBacks.getDescent = descentCallBacks; callBacks.getWidth = widthCallBacks; callBacks.dealloc = delegateDealloc; //创建CTRunDelegate CTRunDelegateRef delegate = CTRunDelegateCreate(&amp;callBacks, (__bridge void *)weakSelf.info); //使用0xfffc作为空白占位符 unichar placeHolder = 0xFFFC; NSString *emptyStr = [NSString stringWithCharacters:&amp;placeHolder length:1]; NSMutableAttributedString *imageSpace = [[NSMutableAttributedString alloc] initWithString:emptyStr]; //设置代理 CFAttributedStringSetAttribute((CFMutableAttributedStringRef)imageSpace, CFRangeMake(0, 1), kCTRunDelegateAttributeName, delegate); [titleAttributeString insertAttributedString:imageSpace atIndex:0]; CFRelease(delegate); } CTFramesetterRef frameSetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)titleAttributeString); CTFrameRef frame = CTFramesetterCreateFrame(frameSetter, CFRangeMake(0, titleAttributeString.length), path, NULL); //绘制文本 CTFrameDraw(frame, context); //绘制图像 CGRect imageRect = [self calculateImageRectWithFrame:frame]; CGContextDrawImage(context, imageRect, image.CGImage); CFRelease(frame); CFRelease(path); CFRelease(frameSetter); } - (void)drawInBackgound { __block typeof(self) blockSelf = self; NSString *imageUrl = self.info.pic; [[EOCImageDownManager shareInstance] loadImageWithUrl:imageUrl complete:^(UIImage *image, NSURL *imageURL, NSError *error) { if (image) { CGFloat imageHeight = [[blockSelf.info class] heightForImage:image fitWidth:SCREEN_WIDTH - 8*2]; [[EOCNewsDataManager manager] modifyRowInfo:blockSelf.info value:@(imageHeight) key:@&quot;imageHeight&quot;]; if (!blockSelf.info.bitmapImage) { [EOCUtil runBackground:^{ UIImage *bitmapImage = [blockSelf drawInBackgroundWithImage:image info:blockSelf.info]; [[EOCNewsDataManager manager] modifyRowInfo:blockSelf.info value:bitmapImage key:@&quot;bitmapImage&quot;]; [blockSelf performSelectorOnMainThread:@selector(setNeedsDisplay) withObject:nil waitUntilDone:NO]; }]; } } }]; } - (UIImage *)drawInBackgroundWithImage:(UIImage *)image info:(NSDictionary *)info { NSString *string = [self.info.title?:@&quot;&quot; stringByAppendingFormat:@&quot;\n%@&quot;,self.info.time]; NSMutableAttributedString *titleAttributeString = [[NSMutableAttributedString alloc] initWithString:string attributes:@{NSFontAttributeName:[UIFont systemFontOfSize:17*2], NSForegroundColorAttributeName:[UIColor blackColor]}]; CGRect rect = CGRectMake(0, 0, (SCREEN_WIDTH - 8*2)*2, (info.rowHeight - 8*2)*2); CGContextRef context = [EOCUtil createARGBContextOfSize:CGSizeMake(rect.size.width, rect.size.height)]; //创建绘制区域 CGMutablePathRef path = CGPathCreateMutable(); CGPathAddRect(path, NULL, CGRectMake(0, 0, rect.size.width, rect.size.height)); if (image) { //图片绘制，设置代理 CTRunDelegateCallbacks callBacks; memset(&amp;callBacks,0,sizeof(CTRunDelegateCallbacks)); callBacks.version = kCTRunDelegateVersion1; callBacks.getAscent = ascentCallBacks; callBacks.getDescent = descentCallBacks; callBacks.getWidth = widthCallBacks; callBacks.dealloc = delegateDealloc; //创建CTRunDelegate CTRunDelegateRef delegate = CTRunDelegateCreate(&amp;callBacks, (__bridge void *)self.info); //使用0xfffc作为空白占位符 unichar placeHolder = 0xFFFC; NSString *emptyStr = [NSString stringWithCharacters:&amp;placeHolder length:1]; NSMutableAttributedString *imageSpace = [[NSMutableAttributedString alloc] initWithString:emptyStr]; //绑定代理 CFAttributedStringSetAttribute((CFMutableAttributedStringRef)imageSpace, CFRangeMake(0, 1), kCTRunDelegateAttributeName, delegate); CFRelease(delegate); [titleAttributeString insertAttributedString:imageSpace atIndex:0]; } CTFramesetterRef frameSetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)titleAttributeString); CTFrameRef frame = CTFramesetterCreateFrame(frameSetter, CFRangeMake(0, titleAttributeString.length), path, NULL); //绘制文本 CTFrameDraw(frame, context); //绘制图像 CGRect imageRect = [self calculateImageRectWithFrame:frame]; CGContextDrawImage(context, imageRect, image.CGImage); CFRelease(frame); CFRelease(path); CFRelease(frameSetter); CGImageRef bitmapImage = CGBitmapContextCreateImage(context); CFAutorelease(bitmapImage); return [UIImage imageWithCGImage:bitmapImage scale:2.0 orientation:UIImageOrientationUp]; } -(CGRect)calculateImageRectWithFrame:(CTFrameRef)frame { //获取所有行 NSArray * arrLines = (NSArray *)CTFrameGetLines(frame); NSInteger count = [arrLines count]; //获取所有行的起始坐标 CGPoint points[count]; CTFrameGetLineOrigins(frame, CFRangeMake(0, 0), points); for (int i = 0; i &lt; count; i ++) { CTLineRef line = (__bridge CTLineRef)arrLines[i]; //获取每行中的所有CTRun NSArray * arrGlyphRun = (NSArray *)CTLineGetGlyphRuns(line); for (int j = 0; j &lt; arrGlyphRun.count; j ++) { CTRunRef run = (__bridge CTRunRef)arrGlyphRun[j]; NSDictionary * attributes = (NSDictionary *)CTRunGetAttributes(run); CTRunDelegateRef delegate = (__bridge CTRunDelegateRef)[attributes valueForKey:(id)kCTRunDelegateAttributeName]; if (delegate == nil) { continue; } NSDictionary * dic = CTRunDelegateGetRefCon(delegate); if (![dic isKindOfClass:[NSDictionary class]]) { continue; } //当前行的起点坐标 CGPoint point = points[i]; CGFloat ascent; CGFloat descent; //图片在绘制区域中的rect CGRect boundsRun; boundsRun.size.width = CTRunGetTypographicBounds(run, CFRangeMake(0, 0), &amp;ascent, &amp;descent, NULL); boundsRun.size.height = ascent + descent; //获取run中字符串的最大长度 CGFloat xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, NULL); boundsRun.origin.x = point.x + xOffset; boundsRun.origin.y = point.y - descent; CGPathRef path = CTFrameGetPath(frame); //绘制区域 CGRect colRect = CGPathGetBoundingBox(path); //偏移得到绝对坐标 CGRect imageBounds = CGRectOffset(boundsRun, colRect.origin.x, colRect.origin.y); return imageBounds; } } return CGRectZero; } @implementation EOCUtil + (void)runInMain:(void (^) ())block { if ([[NSThread currentThread] isMainThread]) { block(); }else { dispatch_async(dispatch_get_main_queue(), block); } } + (void)runBackground:(void (^) ())block { if ([[NSThread currentThread] isMainThread]) { dispatch_async(dispatch_get_global_queue(0, 0), block); }else { block(); } } + (CGSize)sizeToForImage:(UIImage *)image fitWidth:(CGFloat)width { if (!image) { return CGSizeMake(0, 0); } return CGSizeMake(width, width/(image.size.width * image.scale) * (image.size.height * image.scale)); } + (UIImage *)decodeImage:(UIImage *)image toSize:(CGSize)size { if (image == nil) { // Prevent &quot;CGBitmapContextCreateImage: invalid context 0x0&quot; error return nil; } @autoreleasepool{ // do not decode animated images if (image.images != nil) { return image; } CGImageRef imageRef = image.CGImage; CGImageAlphaInfo alpha = CGImageGetAlphaInfo(imageRef); BOOL anyAlpha = (alpha == kCGImageAlphaFirst || alpha == kCGImageAlphaLast || alpha == kCGImageAlphaPremultipliedFirst || alpha == kCGImageAlphaPremultipliedLast); if (anyAlpha) { NSLog(@&quot;图片解压失败，存在alpha通道&quot;); return image; } // current CGColorSpaceModel imageColorSpaceModel = CGColorSpaceGetModel(CGImageGetColorSpace(imageRef)); CGColorSpaceRef colorspaceRef = CGImageGetColorSpace(imageRef); BOOL unsupportedColorSpace = (imageColorSpaceModel == kCGColorSpaceModelUnknown || imageColorSpaceModel == kCGColorSpaceModelMonochrome || imageColorSpaceModel == kCGColorSpaceModelCMYK || imageColorSpaceModel == kCGColorSpaceModelIndexed); if (unsupportedColorSpace) { colorspaceRef = CGColorSpaceCreateDeviceRGB(); } size_t width = size.width; size_t height = size.height; NSUInteger bytesPerPixel = 4; NSUInteger bytesPerRow = bytesPerPixel * width; NSUInteger bitsPerComponent = 8; // kCGImageAlphaNone is not supported in CGBitmapContextCreate. // Since the original image here has no alpha info, use kCGImageAlphaNoneSkipLast // to create bitmap graphics contexts without alpha info. CGContextRef context = CGBitmapContextCreate(NULL, width, height, bitsPerComponent, bytesPerRow, colorspaceRef, kCGBitmapByteOrderDefault|kCGImageAlphaNoneSkipLast); // Draw the image into the context and retrieve the new bitmap image without alpha CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef); CGImageRef imageRefWithoutAlpha = CGBitmapContextCreateImage(context); UIImage *imageWithoutAlpha = [UIImage imageWithCGImage:imageRefWithoutAlpha scale:image.scale orientation:image.imageOrientation]; if (unsupportedColorSpace) { CGColorSpaceRelease(colorspaceRef); } CGContextRelease(context); CGImageRelease(imageRefWithoutAlpha); NSLog(@&quot;图片解压成功&quot;); return imageWithoutAlpha; } } + (CGContextRef)createARGBContextOfSize:(CGSize)size { CGContextRef context = NULL; CGColorSpaceRef colorSpace; void * bitmapData; int bitmapByteCount; int bitmapBytesPerRow; // Get image width, height. We&apos;ll use the entire image. size_t pixelsWide = size.width; size_t pixelsHigh = size.height; // Declare the number of bytes per row. Each pixel in the bitmap in this // example is represented by 4 bytes; 8 bits each of red, green, blue, and // alpha. bitmapBytesPerRow = (int)(pixelsWide * 4); bitmapByteCount = (int)(bitmapBytesPerRow * pixelsHigh); // Use the generic RGB color space. colorSpace = CGColorSpaceCreateDeviceRGB(); if (colorSpace == NULL) { fprintf(stderr, &quot;Error allocating color space\n&quot;); return NULL; } NSMutableData *data = [NSMutableData dataWithLength:bitmapByteCount]; bitmapData = [data mutableBytes]; memset(bitmapData, 0, [data length]); context = CGBitmapContextCreate (bitmapData, pixelsWide, pixelsHigh, 8, // bits per component bitmapBytesPerRow, colorSpace, kCGImageAlphaPremultipliedFirst); if (context == NULL) { free (bitmapData); fprintf (stderr, &quot;Context not created!&quot;); } // Make sure and release colorspace before returning CGColorSpaceRelease( colorSpace );//create copy 一般都要release CFAutorelease(context); return context; } @end iOS性能优化实践三 @interface EOCImageDownManager () @property (strong, nonatomic) NSMutableDictionary *downOperations; @property (strong, nonatomic) NSMutableArray *nextDownQueue; @end @implementation EOCImageDownManager + (EOCImageDownManager *)shareInstance { static dispatch_once_t onceToken; static EOCImageDownManager *__downloadManager = nil; dispatch_once(&amp;onceToken, ^{ if (!__downloadManager) { __downloadManager = [[EOCImageDownManager alloc] init]; } }); return __downloadManager; } - (UIImage *)loadImageWithUrl:(NSString *)urlStr complete:(void (^) (UIImage *image, NSURL *imageURL, NSError *error))complete { /* 一层： UIImageView+Cache UIButton+Cache，CacheInterface 二层：下载层 Download（queue） 三层：缓存，一级缓存Cache， 二级缓存：DiskCache */ if ([urlStr length] == 0) { if (complete) { complete(nil, nil, [NSError errorWithDomain:@&quot;com.leo.news&quot; code:-1 userInfo:@{@&quot;msg&quot;:@&quot;下载失败，图片url为空!&quot;}]); } return nil; } NSURL *url = [NSURL URLWithString:urlStr]; //内存中缓存 UIImage *cacheImage = [self cacheImageForUrl:url]; if (cacheImage) { if (complete) { complete(cacheImage, url, nil); } return cacheImage; } //磁盘中缓存 if ([SDWEBIMAGE_MANAGER.imageCache diskImageExistsWithKey:[SDWEBIMAGE_MANAGER cacheKeyForURL:url]]) { [EOCUtil runBackground:^{ UIImage *image = [SDWEBIMAGE_MANAGER.imageCache imageFromDiskCacheForKey:[SDWEBIMAGE_MANAGER cacheKeyForURL:url]]; if (complete) { complete(image, url, nil); } }]; return nil; } //如果正在下载 if ([self.downOperations objectForKey:url]) { return nil; } #ifdef ENABLE_LIMIT_MAX_DOWNQUEUE if ([self.downOperations count] &gt; EOCIMAGEDOWN_MAX_COUNT) { [[self nextDownQueue] addObject:[EOCDownTask taskWithUrl:url complete:complete]]; return nil; } #endif __block typeof(self) weakSelf = self; NSOperation *operation = [[SDWebImageManager sharedManager] downloadImageWithURL:url options:SDWebImageRefreshCached progress:nil completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) { if (complete) { #ifdef ENABLE_IMAGEDECODE if (image) { image = [EOCUtil decodeImage:image toSize:[EOCUtil sizeToForImage:image fitWidth:([UIScreen mainScreen].bounds.size.width - 8*2)*[UIScreen mainScreen].scale]]; } #endif complete(image, imageURL, error); } [weakSelf.downOperations removeObjectForKey:url]; #ifdef ENABLE_LIMIT_MAX_DOWNQUEUE //开启下一个下载 EOCDownTask *task = [weakSelf.nextDownQueue firstObject]; if (task) { [weakSelf.nextDownQueue removeObjectAtIndex:0]; } [weakSelf loadImageWithUrl:[task.url absoluteString] complete:task.complete]; #endif }]; [self.downOperations setObject:operation forKey:url]; return nil; } - (UIImage *)cacheImageForUrl:(NSURL *)url { SDImageCache *cache = [[SDWebImageManager sharedManager] imageCache]; NSString *cacheKey = [[SDWebImageManager sharedManager] cacheKeyForURL:url]; UIImage *image = [cache imageFromMemoryCacheForKey:cacheKey]; return image; }]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCD深度使用和底层源码分析]]></title>
    <url>%2F2017%2F05%2F26%2FGCD%E6%B7%B1%E5%BA%A6%E4%BD%BF%E7%94%A8%E5%92%8C%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[GCD深度使用和底层源码分析 串行队列 // 串行队列 只能开启一个任务 （串发dispatch_sync） - (void)serialQueue{ //执行结果是同一个线程上依次执行多个任务 dispatch_queue_t queue = dispatch_queue_create(&quot;serQueue&quot;, DISPATCH_QUEUE_SERIAL); dispatch_async(queue, ^{ NSLog(@&quot;1:%@&quot;, [NSThread currentThread]); }); dispatch_async(queue, ^{ NSLog(@&quot;2:%@&quot;, [NSThread currentThread]); }); dispatch_async(queue, ^{ NSLog(@&quot;3:%@&quot;, [NSThread currentThread]); }); dispatch_sync(queue, ^{ NSLog(@&quot;4:%@&quot;, [NSThread currentThread]); }); } 并行队列 /* 如果我们cpu是单核，能不能并行操作任务：不能 （） 如果我们cpu是双核，能不能并行操作任务：能 cpu1 处理A， cpu2 处理B */ // 并行队列 同时可以开启多个任务 （并发dispatch_async） - (void)conCurrentQueue{ //执行结果是不同个线程随机执行多个任务 dispatch_queue_t queue = dispatch_queue_create(&quot;serQueue&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^{ NSLog(@&quot;1:%@&quot;, [NSThread currentThread]); }); dispatch_async(queue, ^{ NSLog(@&quot;2:%@&quot;, [NSThread currentThread]); }); dispatch_async(queue, ^{ NSLog(@&quot;3:%@&quot;, [NSThread currentThread]); }); dispatch_sync(queue, ^{ NSLog(@&quot;4当前线程:%@&quot;, [NSThread currentThread]); }); } 任务分组 // 组 多个任务执行 - (void)group_gcd{ // 1 创建组 dispatch_group_t group = dispatch_group_create(); dispatch_queue_t queue = dispatch_queue_create(&quot;serQueue&quot;, DISPATCH_QUEUE_CONCURRENT); // 2向组添加任务 任务数count=3 dispatch_group_async(group, queue, ^{ NSLog(@&quot;task one::%@&quot;, [NSThread currentThread]); }); dispatch_group_async(group, queue, ^{ NSLog(@&quot;task two::%@&quot;, [NSThread currentThread]); }); dispatch_group_async(group, queue, ^{ NSLog(@&quot;task three::%@&quot;, [NSThread currentThread]); }); // 3组任务全部完成了，就通知 任务数count为0 dispatch_group_notify(group, queue, ^{ NSLog(@&quot;finish all task&quot;); }); } // 一个界面执行加载多个网络请求，可以用到group - (void)groupStyleTwo{ // 1 创建组 dispatch_group_t group = dispatch_group_create(); dispatch_queue_t queue = dispatch_queue_create(&quot;serQueue&quot;, DISPATCH_QUEUE_CONCURRENT); // 填加一个空任务 for (int i = 0; i &lt; 3; i++) { dispatch_group_enter(group); // 任务数+1 dispatch_async(queue, ^{ [self netLoadSync:i]; // 如果在这个任务再开一个线程，那么不能保证你的需求 dispatch_group_leave(group);// 任务数-1 }); } // 3组任务全部完成了，就通知 dispatch_group_notify(group, queue, ^{ NSLog(@&quot;finish all task&quot;); }); } // task 同步执行 - (void)netLoadSync:(int)taskCount { NSString *urlstr = [NSString stringWithFormat:@&quot;%@?versions_id=1&amp;system_type=1&quot;, URLPath]; NSURL *url = [NSURL URLWithString:urlstr]; NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url]; NSURLSession *session = [NSURLSession sharedSession]; dispatch_semaphore_t sema = dispatch_semaphore_create(0); NSURLSessionTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error){ // NSDictionary *infoDict = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingAllowFragments error:nil]; NSLog(@&quot;完成了,taskcount:%d&quot;, taskCount); dispatch_semaphore_signal(sema); }]; [task resume]; dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER); NSLog(@&quot;finish 代码跑完了：%d&quot;,taskCount); } 栅栏 //栅栏 - (void)barrier_fct{ dispatch_queue_t queue = dispatch_queue_create(&quot;serQueue&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^{ NSLog(@&quot;分界线前：taskOne&quot;); }); dispatch_async(queue, ^{ NSLog(@&quot;分界线前：taskTwo&quot;); }); dispatch_async(queue, ^{ NSLog(@&quot;分界线前：taskThree&quot;); }); dispatch_barrier_async(queue, ^{ // 分界线里面，queue可以看作是串行的，当前只能执行barrier里面的task NSLog(@&quot;分界线里面的任务&quot;); }); dispatch_async(queue, ^{ NSLog(@&quot;分界线后：taskFour&quot;); }); dispatch_async(queue, ^{ NSLog(@&quot;分界线后：taskFive&quot;); }); } //栅栏的应用，隔离写操作 - (void)testRWAry{ dispatch_queue_t queue = dispatch_queue_create(&quot;testRWAry&quot;, DISPATCH_QUEUE_CONCURRENT); for (int i = 0; i &lt; 50; i++) { // 读 dispatch_async(queue, ^{ NSLog(@&quot;%d::%@&quot;, i, [self indexTo:i]); }); // 写 dispatch_async(queue, ^{ [self addObject:[NSString stringWithFormat:@&quot;%d&quot;, i]]; }); } } // 写 保证只有一个在操 作（避免了同时多个写操作导致的问题） - (void)addObject:(NSString*)object{ dispatch_barrier_async(rwQueue, ^{ if (object != nil) { [_safeAry addObject:object]; } }); } // 主队列 mainqueue--》 主线程 mainThread // 注意同步，因为业务关系，必须马上数据 - (NSString*)indexTo:(NSInteger)index{ __block NSString *result = nil; dispatch_sync(rwQueue, ^{ if (index &lt; _safeAry.count) { result = _safeAry[index]; } }); return result; } 重复执行 // 重复 执行任务 dispatch_apply - (void)apply_gcd{ dispatch_queue_t queue = dispatch_queue_create(&quot;testRWAry&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_apply(5, queue , ^(size_t count) { NSLog(@&quot;%d&quot;, count); }); } 延后执行 // 延后 dispatch_after - (void)after_GCD { //没有RunLoop，所以延后时新开线程执行 dispatch_queue_t queue = dispatch_queue_create(&quot;testRWAry&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^{ NSLog(@&quot;start:%@&quot;, [NSThread currentThread]); dispatch_after(1, queue, ^{ NSLog(@&quot;dispatch_after:%@&quot;, [NSThread currentThread]); }); NSLog(@&quot;end&quot;); }); } 手动激活队列后执行 // 激活 dispatch_activate手动激活队列时才会执行 - (void)queueInactive{ dispatch_queue_t queue = dispatch_queue_create(&quot;testRWAry&quot;, DISPATCH_QUEUE_CONCURRENT_INACTIVE); dispatch_async(queue, ^{ NSLog(@&quot;start:%@&quot;, [NSThread currentThread]); }); dispatch_activate(queue); } GCD调用执行函数 // _f IMP dispatch_async_f的第二个参数是testFunction的参数 // 调用函数执行，执行线程不是主线程，是子线程中 - (void)function_f{ dispatch_queue_t queue = dispatch_queue_create(&quot;testRWAry&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async_f(queue, nil, testFunction); } void testFunction(){ NSLog(@&quot;testFunction::--&gt;%@&quot;, [NSThread currentThread]); } 系统底层定时器 // 定时器 dispatch_source_t unix (pthread) GCD() dispatch_source_t soure; - (void)timeSource { // dispatch_object_t; // 1 创建一个队列 dispatch_queue_t eoc_queueOneTT = dispatch_queue_create(&quot;eoc_queueOneTT&quot;, DISPATCH_QUEUE_SERIAL); // io source关联到队列 soure = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); // 配置soure的时间 dispatch_source_set_timer(soure, DISPATCH_TIME_NOW, 1, 1); // 配置source的处理事件 dispatch_source_set_event_handler(soure, ^{ NSLog(@&quot;soure_event:==%@&quot;, [NSThread currentThread]); }); // 开启定时器 dispatch_resume(soure); } 锁和死锁 - (void)signalLock{ [NSThread detachNewThreadSelector:@selector(signalLockWrite) toTarget:self withObject:nil]; [NSThread detachNewThreadSelector:@selector(signalLockRead) toTarget:self withObject:nil]; } #pragma mark - 信号量 + 互斥锁 = 死锁 - (void)signalLockWrite { while (1) { [mutexLock lock]; if (count &gt;= 10) { NSLog(@&quot;空间满了没有内存了&quot;); dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER); // 阻塞 }else{ count++; NSLog(@&quot;空间:%d&quot;, count); } [mutexLock unlock]; } } - (void)signalLockRead{ while (1) { [mutexLock lock]; if (count &gt;= 10) { count--; NSLog(@&quot;释放空间&quot;); dispatch_semaphore_signal(sema); }else{ count++; } [mutexLock unlock]; } } #pragma mark - 信号量+ 互斥锁（死锁） - (void)signalLockWrite{ while (1) { [_condition lock]; if (count &gt;= 10) { // 没有内存了 NSLog(@&quot;空间满了&quot;); [_condition wait]; }else{ count++; } [_condition unlock]; } } - (void)signalLockRead{ while (1) { [_condition lock]; if (count &gt;= 10) { count--; NSLog(@&quot;释放空间&quot;); [_condition signal]; }else{ count++; } [_condition unlock]; } } 条件锁原理 pthread_mutex_t mutex; pthread_mutex_init(&amp;mutex, 0); pthread_cond_t cond; pthread_cond_init(&amp;cond, 0); // theory c OC条件量的c实现 - (void)conditionLockOne{ while (1) { ////这个mutex主要是用来保证pthread_cond_wait的并发性 pthread_mutex_lock(&amp;mutex); if (count &gt;= 10) { // 没有内存了 NSLog(@&quot;空间满了&quot;); // pthread_cond_wait会先解除之前的pthread_mutex_lock锁定的mtx，然后阻塞在等待对列里休眠，直到再次被唤醒（大多数情况下是等待的条件成立而被唤醒，唤醒后，该进程会先锁定先pthread_mutex_lock(&amp;mtx);，再读取资源 //用这个流程是比较清楚的/*lock--&gt;wait()--&gt;unlock--&gt;signal--&gt;lock--&gt;unlock*/ pthread_cond_wait(&amp;cond, &amp;mutex);// 阻塞 但是mutex这个解了 }else{ count++; } pthread_mutex_unlock(&amp;mutex); } } - (void)conditionLockTwo { while (1) { pthread_mutex_lock(&amp;mutex); if (count &gt;= 10) { count--; NSLog(@&quot;释放空间&quot;); pthread_cond_signal(&amp;cond); }else{ count++; } pthread_mutex_unlock(&amp;mutex); } } 递归锁及其原理 @interface RecursiveLock : NSObject{ pthread_mutex_t _reclock; NSRecursiveLock *recursiveLock; } - (instancetype)init{ self = [super init]; if (self) { [self oc_recursiveLockinit]; [self c_recursiveLockinit]; } return self; } - (void)oc_recursiveLockinit{ recursiveLock = [[NSRecursiveLock alloc] init]; } - (void)c_recursiveLockinit{ pthread_mutexattr_t attr; pthread_mutexattr_init (&amp;attr); pthread_mutexattr_settype (&amp;attr, PTHREAD_MUTEX_RECURSIVE); pthread_mutex_init (&amp;_reclock, &amp;attr); pthread_mutexattr_destroy (&amp;attr); } - (void)recursiveLock{ NSLog(@&quot;start&quot;); NSLog(@&quot;result:%d&quot;, [self addCount:10]); NSLog(@&quot;end&quot;); } - (void)recursiveLockTheory{ NSLog(@&quot;theory start&quot;); NSLog(@&quot;theory result:%d&quot;, [self addC__Count:10]); NSLog(@&quot;theory end&quot;); } // 递归里面做安全策略，用互斥锁会造成死锁的，所以必须用递归锁 - (int)addCount:(int)count{ [recursiveLock lock]; if (count &lt; 1) { return count; } __block int tmp; NSLog(@&quot;count::%d&quot;, count); tmp = count + [self addCount:count-1]; [recursiveLock unlock]; return tmp; } - (int)addC__Count:(int)count{ pthread_mutex_lock(&amp;_reclock); if (count &lt; 1) { return count; } __block int tmp; NSLog(@&quot;theory count::%d&quot;, count); tmp = count + [self addC__Count:count-1]; pthread_mutex_unlock(&amp;_reclock); return tmp; } ？？？？未完]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>iOS</tag>
        <tag>GCD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC多线程分析及使用和死锁处理]]></title>
    <url>%2F2017%2F04%2F28%2FOC%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%86%E6%9E%90%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%92%8C%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[OC多线程分析及使用和死锁处理 线程方式:NSThread，NSOperation, GCD NSThread 一线程对象 对应一个线程，当执行完之后，不能重新开启一个线程也是单独存在 // 主动开线程 // [NSThread detachNewThreadSelector:@selector(threadOne) toTarget:self withObject:nil]; //手动开启，手动开启线程只能开一次 _thread = [[NSThread alloc] initWithTarget:self selector:@selector(threadTwo) object:nil]; [_thread start]; 线程队列NSQueueOperation Operation抽象类必须用其子类实现 系统的Operation对象 NSBlockOperation /* operation可以添加到OperationQueue中去执行，在OperationQueue中执行时，所有的block会异步执行，也就是说要新启线程，但也可以调用[operation start]手动开启，手动开启的时候，代码会同步执行，且只能执行一次（参见finish），如果有多个block块，则会分配一个到主线程上执行，其他block会新启用线程执行 block并不是先添加就先执行，当operation执行后，就不能在添加block */ - (void)viewDidLoad { [super viewDidLoad]; void (^tblock)() = ^{ NSLog(@&quot;tblock:%@&quot;, [NSThread currentThread]); }; operationQueue = [NSOperationQueue new]; blockOperation = [[NSBlockOperation alloc] init]; // NSBlockOperation里面block块全部结束，那么这个NSBlockOperation才算结束（即finished = YES） //运用 ：多个任务处理（任务A，任务B，任务C）三个任务完成了，通过KVO监听得到 （任务是block块） [blockOperation addObserver:self forKeyPath:@&quot;isFinished&quot; options:NSKeyValueObservingOptionNew context:nil]; [blockOperation addExecutionBlock:^{ NSLog(@&quot;one block:%@&quot;, [NSThread currentThread]); }]; [blockOperation addExecutionBlock:^{ NSLog(@&quot;two block:%@&quot;, [NSThread currentThread]); }]; [blockOperation addExecutionBlock:tblock]; //[operationQueue addOperation:blockOperation]; } - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context{ NSLog(@&quot;%@&quot;, keyPath); NSLog(@&quot;%@&quot;, change); } - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event{ //start 没有重复开启： 因为在start方法里面对blockOperation的状态finish状态进行判断，如果finish=YES，就不会执行了，main 直接是调用block [blockOperation start]; //[blockOperation main]; } NSInvocationOperation(NSInvocation) - (void)viewDidLoad { [super viewDidLoad]; // 3 selector 方法签名（方法的对象结构，相关的结构信息：返回值，调用者，方法名，参数） NSMethodSignature *signture = [self methodSignatureForSelector:@selector(name:age:sex:)]; // 2 signture invation = [NSInvocation invocationWithMethodSignature:signture] ; invation.target = self; invation.selector = @selector(name:age:sex:); //和签名的seletor要对应起来 // 配置参数 NSString *name = @&quot;eoc&quot;; NSString *age = @&quot;2&quot;; NSString *sex = @&quot;男&quot;; [invation setArgument:&amp;name atIndex:2]; [invation setArgument:&amp;age atIndex:3]; [invation setArgument:&amp;sex atIndex:4]; //[invation getReturnValue:]; // 1 需要 invation _invocationOperation = [[NSInvocationOperation alloc] initWithInvocation:invation]; //[invation invoke]; NSOperationQueue *queue = [NSOperationQueue new]; [queue addOperation:_invocationOperation]; } //把这个方法 看作一个比较耗时业务 - (NSString*)name:(NSString*)name age:(NSString*)age sex:(NSString*)sex{ NSLog(@&quot;name: age: sex:%@&quot;, [NSThread currentThread]); return [NSString stringWithFormat:@&quot;%@%@%@&quot;, name, age, sex]; } 自定义Operation对象 Operation状态（KVO通知） [twoOperation addObserver:self forKeyPath:@&quot;finished&quot; options:NSKeyValueObservingOptionNew context:nil]; } - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context{ NSLog(@&quot;%@&quot;, keyPath); } * start方法和main方法理解 - (void)viewDidLoad { [super viewDidLoad]; queue = [NSOperationQueue new]; //EocOperation重写start，SimpleOperation重写main，发现addOperation后均会执行，但重写start后并没有执行dealloc方法，是因为EocOperation的状态为未完成状态 _finished = NO； EocOperation *eocOperation = [EocOperation new]; SimpleOperation *simpOperation = [SimpleOperation new]; [queue addOperation:eocOperation]; [queue addOperation:simpOperation]; } //eocOperation - (void)main{ // 主要的业务逻辑放到这里处理 NSLog(@&quot;main2&quot;); // 如果是手动调用并且只有一个block块，则其在主线程上执行，主线程自己有runLoop，而如果在新启线程上执行的话，需要调用[[NSRunLoop currentRunLoop] run]在线程上维护一个RunLoop _timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(timeCount) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] run]; } - (void)timeCount{ static int count = 0; count++; if (count &gt; 5) { [_timer invalidate]; } NSLog(@&quot;timeCount&quot;); } - (void)start{ //异常处理，状态修改 NSLog(@&quot;%@&quot;, [NSThread currentThread]); //[NSThread detachNewThreadSelector:@selector(main) toTarget:self withObject:nil]; // self.finished = YES if (_finished) { return; } if (self.isExecuting) { return; } NSLog(@&quot;start&quot;); [self main]; _finished = YES; } - (void)dealloc{ NSLog(@&quot;start::%s&quot;, __func__); } * 配置Operation执行行为（依赖关系） - (void)viewDidLoad { [super viewDidLoad]; queue = [NSOperationQueue new]; NSBlockOperation *eocOperation = [[NSBlockOperation alloc] init]; [eocOperation addExecutionBlock:^{ NSLog(@&quot;one block task&quot;); }]; [eocOperation addExecutionBlock:^{ NSLog(@&quot;two block task&quot;); }]; NSBlockOperation *twoOperation = [[NSBlockOperation alloc] init]; [twoOperation addExecutionBlock:^{ NSLog(@&quot;Three block task&quot;); }]; [twoOperation addExecutionBlock:^{ NSLog(@&quot;Four block task&quot;); }]; // 先后顺序关系 twoOperation 先，然后再eocOperation // 在执行之前，把依赖关系建立好 [eocOperation addDependency:twoOperation]; [queue addOperation:eocOperation]; [queue addOperation:twoOperation]; [twoOperation addObserver:self forKeyPath:@&quot;finished&quot; options:NSKeyValueObservingOptionNew context:nil]; } - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context{ NSLog(@&quot;%@&quot;, keyPath); } * 分析依赖关系本质 本质是finish的状态监听 线程取消问题，僵尸线程问题 NSThead操作 - (void)viewDidLoad { [super viewDidLoad]; //手动开启 _thread = [[NSThread alloc] initWithTarget:self selector:@selector(threadTwo) object:nil]; [_thread start]; } - (void)threadTwo { NSLog(@&quot;threadTwo::%@&quot;, [NSThread currentThread]); for (int i = 0; i &lt; 5; i++) { if([NSThread currentThread].isCancelled){ return; } sleep(2); NSLog(@&quot;%d&quot;, i); // 取消节点，正在要取消线程要设置取消节点 //取消节点的设置越多，取消的效率越高 if([NSThread currentThread].isCancelled){ //主动来结束线程操作 return; } } } - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event{ //线程不能真正取消，如果需要取消，则需要取消节点 [_thread cancel]; } RunLoop操作 - (void)ThreadOne{ NSLog(@&quot;start thread&quot;); port = [NSPort new]; //如果没有这一句则RunLoop一直在跑，不会执行finish，就会形成僵尸线程 [self performSelector:@selector(endThread:) withObject:nil afterDelay:2]; [[NSRunLoop currentRunLoop] addPort:port forMode:NSDefaultRunLoopMode]; [[NSRunLoop currentRunLoop] run]; NSLog(@&quot;finish thread&quot;); } - (IBAction)endThread:(id)sender{ [[NSRunLoop currentRunLoop] removePort:port forMode:NSDefaultRunLoopMode]; } - (void)ThreadTwo{ NSLog(@&quot;start thread&quot;); _timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(stopTimer:) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] run]; NSLog(@&quot;finish thread&quot;); } //手动点击屏幕在主线程停止timer并不能调用ThreadTwo的finish - (IBAction)stopTimerAction:(id)sender{ [_timer invalidate]; } //需要在当前线程环境中停止timer才能调用ThreadTwo的finish - (void)stopTimer:(NSTimer *)timer{ NSLog(@&quot;stopTimer&quot;); static int count = 0; count++; if (count &gt; 5) { [_timer invalidate]; } }]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>iOS</tag>
        <tag>OC多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[block原理及详解]]></title>
    <url>%2F2017%2F03%2F31%2Fblock%E5%8E%9F%E7%90%86%E5%8F%8A%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Block原理细纠Block就是一个结构体，里面存储了指向函数体中包含定义block时的代码块的函数指针，以及block外部上下文变量等信息 block的内存分布 理解： 当你的block没有使用外部变量的时候，通通都是global的，无论你怎么修饰、无论是否成员变量； 全局变量、静态变量、静态局部变量在block中的存储，block都为globalBlock 当在block里添加了外部变量，那么block的内存就会变成不一样: 当block赋值给strong变量、(非weak的)成员变量，block为mallocBlock； 如果把block作为自定义函数的参数，那么该block是在栈区（系统的方法，会自动把block从栈区放到堆区） static变量无法加__block符的 细究： 当你的block使用了外部局部变量的时候，block本身就是在栈区，arc，当你有外部变量，strong、copy，那么iOS系统会自动给它copy，就从栈区到了堆区； 栈区：内存是由系统管理的，堆区是由程序员管理（怎么管理呢：通过这两个函数malloc release）；但是arc下，release系统给你加了，release也不需要了，malloc也是系统给你自动添加了。 总结： 函数参数 栈区 weak变量修饰的时候 也是在栈区 如果没有外部变量（外部变量如果是global、static）block都是在全局区 如果有外部变量的情况下，当你被strong、copy修饰的时候，会从栈转移到堆区 注意： 当 block 调用 copy 方法时，如果 block 在栈上，会被拷贝到堆上； 当 block 作为函数返回值返回时，编译器自动将 block 作为 _Block_copy 函数，效果等同于 block 直接调用 copy 方法； 当 block 被赋值给 __strong id 类型的对象或 (非weak)成员变量时，编译器自动将 block 作为 _Block_copy 函数，效果等同于 block 直接调用 copy 方法； 当 block 作为参数被传入方法名带有 usingBlock 的 Cocoa Framework 方法或 GCD 的 API 时。这些方法会在内部对传递进来的 block 调用 copy 或 _Block_copy 进行拷贝; Block结构图： struct block_impl { void *isa;//oc里所有对象都有该指针，用于实现对象相关的功能 int Flags;//flags，用于按bit位表示一些block的附加信息，本文后面介绍block copy的实现代码可以看到对该变量的使用。 int Reserved;//保留变量 void *FuncPtr;//函数指针，指向具体的block实现的函数调用地址。 }; struct block_desc_0 { size_t reserved;//保留变量 size_t Block_size;//block的大小 }; struct block_impl_0 { struct block_impl impl; struct block_desc_0 *Desc; int *i; block_impl_0(void *fp, struct block_desc_0 *desc, int* _i, int flags=0):i(_i) {//构造函数 impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; struct block_desc_0 block_desc_0_Data = { 0, sizeof(struct block_impl_0)}; static void block_func_0 (struct block_impl_0 *__cself) { printf(&quot;八点钟学院 %d&quot;, *(__cself-&gt;i)); } void test() { //我需要调用blockimpl的函数指针 int j = 10000; int *i = &amp;j;//模拟局部对象变量的传递 //int i=10;模拟局部基本变量的传递 struct block_impl_0 implTest = block_impl_0((void *)block_func_0, &amp;block_desc_0_Data, i); void (*impTestPointer)() = (void (*)())&amp;implTest; block_impl *tmpPointer = (block_impl *)impTestPointer; void (*Func)(block_impl *) = (void (*)(block_impl *))tmpPointer-&gt;FuncPtr; Func(tmpPointer); } 由上边的block原理可以得出结论： - (void)emptyBlockFunction { void (^emptyBlock)() = ^{ NSLog(@&quot;八点钟学院&quot;); }; emptyBlock(); } - (void)simpleDataBlockFunction { int i = 10; void (^simpleDataBlock)() = ^{ //i++;会报错，因为i传递到block中是实参传递，而实参不能改变 NSLog(@&quot;八点钟学院 %d&quot;, i); }; simpleDataBlock(); } - (void)objcDataBlockFunction { UILabel *tmpLabel = [[UILabel alloc] init]; void (^objcDataBlock)() = ^{ tmpLabel = [[UILabel alloc] init];//会报错，因为传递过来的虽然是地址，但不能对地址进行重新赋值，原理如下例所示 tmpLabel.frame = CGRectMake(0, 0, 100, 100);//不会报错，可以改变传入的值的属性 NSLog(@&quot;八点钟学院, %@&quot;, tmpLabel); }; objcDataBlock(); } { NSMutableArray *array = [[NSMutableArray alloc] init]; [array addObject:@&quot;abc&quot;]; [self returnArray:array]; NSLog(@&quot;array %@&quot;, array); } - (NSMutableArray *)returnArray:(NSMutableArray *)array { //如果有这一句，array最后打印为{abc}，如果没有这一句，array最后打印为{abc,123}，从而得出结论：对象传递传递的是地址，如果没有对其重新分配空间，函数中若操作对象，其值就会改变，如果对其重新分配了空间，指针就会指向其他的内存位置，则不会影响原来的值 array = [[NSMutableArray alloc] init]; [array addObject:@&quot;123&quot;]; return array; } - (void)classDataBlockFunction { //_label是一个成员变量 //传递的是self，而不是_label，而且block对self是强引用 //self是一个结构体，需要知道哪个结构体，才会在block执行的时候正确找到该结构体下的结构体变量，你要访问结构体的变量，结构体指针-&gt;变量或者结构体.变量 void (^classDataBlock)() = ^{ NSLog(@&quot;八点钟学院 %@&quot;, _label); }; classDataBlock(); } //因为__block传递的是个地址，所以其修饰的值可以修改 //__block 实质上会转化为一个结构体，结构体里有forwarding ，forwarding指向结构体自己 //block刚开始是在栈里面，通过block构造函数，我让block里面的结构体为上面结构体的地址（同一个东西) //运行的时候，从栈拷贝到堆区，那么会新生成一个堆区的block ，这个堆区的block里面的结构体的forwarding指向堆区block；栈里面的结构体里的forwarding指向的是堆区block的forwarding； - (void)blockDataBlockFunction { __block int a = 100; //我们的block本身是在栈区，当你赋值给strong的变量的时候，它会从栈到堆区 void (^blockDataBlock)() = ^{ a = 1000; NSLog(@&quot;八点钟学院, %d&quot;, a); }; blockDataBlock(); NSLog(@&quot;栈区a = %d&quot;, a); } - (void)globalDataBlockFunction { void (^globalDataBlock)() = ^{ globalValue = 100; NSLog(@&quot;八点钟学院 %d&quot;, globalValue); }; globalDataBlock(); } - (void)staticDataBlockFunction { void (^staticDataBlock)() = ^{ staticValue = 100; NSLog(@&quot;八点钟学院 %d&quot;, staticValue); }; staticDataBlock(); } - (void)tmpStaticDataBlockFunction { //下面这个静态变量，它的作用域是在这个函数内部，但是它的内存永远存在（只要app还在），因为它是存在静态变量区的 //看这个局部静态变量，那么你可以对比下globalvalue，全局静态变量 //通过传地址，让静态变量b的值可以一处修改，到处相同（达到globalVlue和全局静态变量的效果）； //为什么要传地址，你要知道把一个变量作为实参，变量是不能改变的；那么，你可以以变量的地址作为实参传过去，那么这个地址不能改变，但是你可以改变地址里面的内容。 static int b = 11; void (^tmpStaticDataBlock)() = ^{ b = 110; NSLog(@&quot;八点钟学院 %d&quot;, b); }; b = 100; tmpStaticDataBlock(); } - (void)weakCycleBlockFunction { //block初始化时会对otherObject进行retain操作 //object 0x60000001d2b0 &amp;object 0x7ffeecaa1048 //object 0x60000001d2b0 &amp;object 0x60400025c130 //object 0x60000001d2b0 &amp;object 0x60400025c130 NSObject *otherObject = [[NSObject alloc] init]; NSLog(@&quot;object %p &amp;object %p&quot;, otherObject, &amp;otherObject); blk = ^{ NSLog(@&quot;object %p &amp;object %p&quot;, otherObject, &amp;otherObject); }; blk(); otherObject = nil; blk(); } - (void)weakCycleBlockFunctionTwo { //block初始化时不会对weak进行retain，强引用会对其retain加1，当block执行完后，strong被销毁，引用计数减1 //object 0x604000205410 &amp;object 0x7ffee030c3b8 //object 0x604000205410 &amp;object 0x7ffee030c318 //object 0x604000205410 &amp;object 0x600000247bb0 //object 0x0 &amp;object 0x7ffee030c318 //object 0x0 &amp;object 0x600000247bb0 NSObject *otherObject = [[NSObject alloc] init]; NSLog(@&quot;object %p &amp;object %p&quot;, otherObject, &amp;otherObject); __weak typeof(otherObject)weakObject = otherObject; blk = ^{ __strong typeof(weakObject)strongObject = weakObject; NSLog(@&quot;object %p &amp;object %p&quot;, strongObject, &amp;strongObject); NSLog(@&quot;object %p &amp;object %p&quot;, weakObject, &amp;weakObject); }; blk(); otherObject = nil; blk(); } - (void)weakCycleBlockFunctionThree { //block是同步执行 NSObject *otherObject = [[NSObject alloc] init]; NSLog(@&quot;object %p &amp;object %p&quot;, otherObject, &amp;otherObject); __weak typeof(otherObject)weakObject = otherObject; blk = ^{ __strong typeof(weakObject)strongObject = weakObject; if (strongObject) { NSLog(@&quot;object %p &amp;object %p&quot;, strongObject, &amp;strongObject); sleep(3); NSLog(@&quot;object %p &amp;object %p&quot;, strongObject, &amp;strongObject); } }; blk(); otherObject = nil; sleep(5); blk(); } - (void)strongCycleBlockFunction { //object 0x600000011290 &amp;object 0x7fd6af52e5d8 //object 0x600000011290 &amp;object 0x7fd6af52e5d8 //object 0x0 &amp;object 0x7fd6af52e5d8 object = [[NSObject alloc] init]; NSLog(@&quot;object %p &amp;object %p&quot;, object, &amp;object); //对于成员变量，block是把self引用计数+1，不是对成员变量object本身来增加引用计数的 blk = ^{ NSLog(@&quot;object %p &amp;object %p&quot;, object, &amp;object); }; blk(); object = nil; blk(); } ？？？未完 block源码解析]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>iOS</tag>
        <tag>block</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图文混排原理实现及应用]]></title>
    <url>%2F2017%2F02%2F24%2F%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[图文混排原理实现及应用富文本绘制步骤： 先需要一个StringA 把StringA转换成attributeString，并添加相关样式 生成CTFramesetter，得到CTFrame 绘制CTFrameDraw @interface EOCTextLabel() { NSRange sepRange; CGRect sepRect; } @end @implementation EOCTextLabel - (void)drawRect:(CGRect)rect { sepRange = NSMakeRange(30, 5); NSMutableAttributedString *attriStr = [[NSMutableAttributedString alloc] initWithString:self.text attributes:nil]; [attriStr addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:16] range:NSMakeRange(0, self.text.length)]; [attriStr addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:sepRange]; CGContextRef context = UIGraphicsGetCurrentContext(); //生成frame CTFramesetterRef frameset = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attriStr); CGPathRef path = CGPathCreateWithRect(CGRectMake(0, 0, self.frame.size.width, self.frame.size.height), &amp;CGAffineTransformIdentity); CTFrameRef frame = CTFramesetterCreateFrame(frameset, CFRangeMake(0, 0), path, nil); //调整坐标 CGContextSetTextMatrix(context, CGAffineTransformIdentity); CGContextTranslateCTM(context, 0, self.frame.size.height); CGContextScaleCTM(context, 1, -1); //绘制 CTFrameDraw(frame, context); //获取信息 NSArray *lines = (__bridge NSArray *)CTFrameGetLines(frame); CGPoint pointArray[lines.count]; memset(pointArray, 0, sizeof(pointArray)); //由于坐标系的关系，不直接通过这种方式拿行(CTLine)的起始位置 CTFrameGetLineOrigins(frame, CFRangeMake(0, 0), pointArray); double heightAddup = 0; //CTLine信息获取 for (int i=0; i&lt;lines.count; i++) { CTLineRef line = (__bridge CTLineRef)lines[i]; NSArray *runs = (__bridge NSArray *)CTLineGetGlyphRuns(line); CGFloat ascent = 0; CGFloat descent = 0; CGFloat lineGap = 0; CTLineGetTypographicBounds(line, &amp;ascent, &amp;descent, &amp;lineGap); double runHeight = ascent + descent + lineGap; double startX = 0; //CTRun信息获取 for (int j=0; j&lt;runs.count; j++) { CTRunRef run = (__bridge CTRunRef)runs[j]; CFRange runRange = CTRunGetStringRange(run); double runWidth = CTRunGetTypographicBounds(run, CFRangeMake(0, 0), 0, 0, 0); if (runRange.location == sepRange.location &amp;&amp; runRange.length == sepRange.length) { //计算我们需要的位置和size，即rect NSLog(@&quot;找到了&quot;); NSLog(@&quot;%f, %f, %f, %f&quot;, startX, heightAddup, runWidth, runHeight); sepRect = CGRectMake(startX, heightAddup, runWidth, runHeight); //只有点击第三个字符时才会触发 //sepRect = CGRectMake(startX+runWidth*2/5, heightAddup, runWidth/5, runHeight); } startX += runWidth; } //字的高度叠加 heightAddup += runHeight; NSLog(@&quot;%f====%f&quot;, pointArray[i].y, heightAddup); } //添加button按钮和事件也可以达到需求要求 [self setNeedsLayout]; } - (void)layoutSubviews { if (sepRect.size.width&gt;0) { } } - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event { UITouch *touch = [touches anyObject]; CGPoint point = [touch locationInView:self]; if (CGRectContainsPoint(sepRect, point)) { NSLog(@&quot;点击&quot;); } } 图文混排步骤 定义attributeString，里边包含占位符及其宽高等属性 根据attributeString绘制 遍历frame，line，run找出占位符的坐标及大小 调用[self setNeedsLayout]后自动layoutSubviews，设置ImageView的位置和图片 #define EOCCoreTextImageWidthPro @&quot;EOCCoreTextImageWidthPro&quot; #define EOCCoreTextImageHeightPro @&quot;EOCCoreTextImageHeightPro&quot; static CGFloat ctRunDelegateGetWidthCallback(void *refCon) { NSDictionary *infoDic = (__bridge NSDictionary *)refCon; if ([infoDic isKindOfClass:[NSDictionary class]]) { return [infoDic[EOCCoreTextImageWidthPro] floatValue]; } return 0; } static CGFloat ctRunDelegateGetAscentCallback(void *refCon) { NSDictionary *infoDic = (__bridge NSDictionary *)refCon; if ([infoDic isKindOfClass:[NSDictionary class]]) { return [infoDic[EOCCoreTextImageHeightPro] floatValue]; } return 0; } static CGFloat ctRunDelegateGetDescentCallback(void *refCon) { return 0; } @interface EOCImageLabel() { NSInteger ImageSpaceIndex; CGRect sepRect; UIImageView *_eocImageV; } @end @implementation EOCImageLabel // Only override drawRect: if you perform custom drawing. // An empty implementation adversely affects performance during animation. - (void)drawRect:(CGRect)rect { ImageSpaceIndex = self.text.length; NSMutableAttributedString *attriStr = [[NSMutableAttributedString alloc] initWithString:self.text attributes:nil]; [attriStr addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:16] range:NSMakeRange(0, self.text.length)]; //图片占位符添加 NSMutableAttributedString *attriImageSpaceStr = [self sepImageSpaceWithWidth:100 height:50]; [attriStr appendAttributedString:attriImageSpaceStr]; NSMutableAttributedString *attriTailStr = [[NSMutableAttributedString alloc] initWithString:@&quot;123456789&quot; attributes:nil]; [attriStr appendAttributedString:attriTailStr]; CGContextRef context = UIGraphicsGetCurrentContext(); //生成frame CTFramesetterRef frameset = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attriStr); CGPathRef path = CGPathCreateWithRect(CGRectMake(0, 0, self.frame.size.width, self.frame.size.height), &amp;CGAffineTransformIdentity); CTFrameRef frame = CTFramesetterCreateFrame(frameset, CFRangeMake(0, 0), path, nil); //调整坐标 CGContextSetTextMatrix(context, CGAffineTransformIdentity); CGContextTranslateCTM(context, 0, self.frame.size.height); CGContextScaleCTM(context, 1, -1); //绘制 CTFrameDraw(frame, context); //获取信息 NSArray *lines = (__bridge NSArray *)CTFrameGetLines(frame); CGPoint pointArray[lines.count]; memset(pointArray, 0, sizeof(pointArray)); //由于坐标系的关系，不直接通过这种方式拿行(CTLine)的起始位置 CTFrameGetLineOrigins(frame, CFRangeMake(0, 0), pointArray); double heightAddup = 0; //CTLine信息获取 for (int i=0; i&lt;lines.count; i++) { CTLineRef line = (__bridge CTLineRef)lines[i]; NSArray *runs = (__bridge NSArray *)CTLineGetGlyphRuns(line); CGFloat ascent = 0; CGFloat descent = 0; CGFloat lineGap = 0; CTLineGetTypographicBounds(line, &amp;ascent, &amp;descent, &amp;lineGap); double runHeight = ascent + descent + lineGap; double startX = 0; //CTRun信息获取 for (int j=0; j&lt;runs.count; j++) { CTRunRef run = (__bridge CTRunRef)runs[j]; CFRange runRange = CTRunGetStringRange(run); double runWidth = CTRunGetTypographicBounds(run, CFRangeMake(0, 0), 0, 0, 0); if (ImageSpaceIndex==runRange.location &amp;&amp; ImageSpaceIndex &lt; runRange.location + runRange.length) { //计算我们需要的位置和size，即rect NSLog(@&quot;找到了&quot;); NSLog(@&quot;%f, %f, %f, %f&quot;, startX, heightAddup, runWidth, runHeight); sepRect = CGRectMake(startX, heightAddup, runWidth, runHeight); //只有点击第三个字符时才会触发 //sepRect = CGRectMake(startX+runWidth*2/5, heightAddup, runWidth/5, runHeight); } startX += runWidth; } //字的高度叠加 heightAddup += runHeight; NSLog(@&quot;%f====%f&quot;, pointArray[i].y, heightAddup); } //添加button按钮和事件也可以达到需求要求 [self setNeedsLayout]; } - (void)layoutSubviews { if (sepRect.size.width&gt;0) { _eocImageV = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&quot;0.png&quot;]]; [self addSubview:_eocImageV]; } _eocImageV.frame = sepRect; } - (NSMutableAttributedString *)sepImageSpaceWithWidth:(float)width height:(float)height { //创建占位符 NSMutableAttributedString *spaceAttribut = [[NSMutableAttributedString alloc] initWithString:@&quot; &quot; attributes:nil]; //配置占位符的属性 CTRunDelegateCallbacks callbacks; memset(&amp;callbacks, 0, sizeof(CTRunDelegateCallbacks)); callbacks.getAscent = ctRunDelegateGetAscentCallback; callbacks.getDescent = ctRunDelegateGetDescentCallback; callbacks.getWidth = ctRunDelegateGetWidthCallback; callbacks.version = kCTRunDelegateCurrentVersion; static NSMutableDictionary *argDic = nil; argDic = [[NSMutableDictionary alloc] init]; [argDic setValue:@(width) forKey:EOCCoreTextImageWidthPro]; [argDic setValue:@(height) forKey:EOCCoreTextImageHeightPro]; CTRunDelegateRef runDelegate = CTRunDelegateCreate(&amp;callbacks, (__bridge void*)argDic); CFAttributedStringSetAttribute((CFMutableAttributedStringRef)spaceAttribut, CFRangeMake(0, 1), kCTRunDelegateAttributeName, runDelegate); return spaceAttribut; }]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>iOS</tag>
        <tag>图文混排</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[离屏渲染及图片压缩、滤镜等原理解析]]></title>
    <url>%2F2017%2F01%2F27%2F%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93%E5%8F%8A%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E3%80%81%E6%BB%A4%E9%95%9C%E7%AD%89%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[离屏渲染及图片压缩、滤镜等原理解析 图片压缩 { //上句变成下句的时候，发现内存的使用变的很小 _albumImage = [UIImage imageNamed:@&quot;3.jpg&quot;]; _albumImage = [self scaleImage:[UIImage imageNamed:@&quot;3.jpg&quot;] size:_pngImageV.frame.size]; [self imageDataLoad]; } - (void)imageDataLoad { // png 文件属性格式并不会压缩，压缩的是图片内容（像素） NSData* pngImageData = UIImagePNGRepresentation(_albumImage); NSData *jpgImageData = UIImageJPEGRepresentation(_albumImage, 0.1); _pngImageV.image = [UIImage imageWithData:pngImageData]; _jpgImageV.image = [UIImage imageWithData:jpgImageData]; NSLog(@&quot;png::%@&quot;, [self length:pngImageData.length]); NSLog(@&quot;jpg::%@&quot;, [self length:jpgImageData.length]); } //打印出来发现原图836k，尺寸4288 × 2848，png 18Mb828KB，jpg为1时 5Mb3KB，为0.1时302KB？？？ - (NSString*)length:(NSInteger)length{ if (length &gt; 1024 * 1024) { int mb = length/(1024*1024); int kb = (length%(1024*1024))/1024; return [NSString stringWithFormat:@&quot;%dMb%dKB&quot;,mb, kb]; }else{ return [NSString stringWithFormat:@&quot;%dKB&quot;,length/1024]; } } // bitmap - (UIImage*)scaleImage:(UIImage*)image size:(CGSize)imageSize{ UIGraphicsBeginImageContext(imageSize); [image drawInRect:CGRectMake(0, 0, imageSize.width, imageSize.height)]; UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return newImage; } 图片像素处理 /* 从图片文件把 图片数据的像素拿出来(RGBA), 对像素进行操作， 进行一个转换（Bitmap （GPU）） 修改完之后，还原（图片的属性 RGBA,RGBA (宽度，高度，色值空间，拿到宽度和高度，每一个画多少个像素，画多少行)） */ - (void)filterImage{ CGImageRef imageRef = self.image.CGImage; // 颜色空间 RGBA AGBR RGB CGColorSpaceRef colorSpace = CGImageGetColorSpace(imageRef); CGImageAlphaInfo alpInfo = CGImageGetAlphaInfo(imageRef); // AlphaInfo 信息 // bitmap的数据 kCGColorSpaceModelRGB; CGDataProviderRef providerRef = CGImageGetDataProvider(imageRef); CFDataRef bitmapData = CGDataProviderCopyData(providerRef); NSInteger pixLength = CFDataGetLength(bitmapData); Byte *pixbuf = CFDataGetMutableBytePtr(bitmapData); // RGBA 为一个单元 for (int i = 0; i &lt; pixLength; i+=4) { [self eocImageFiletPixBuf:pixbuf offset:i]; } // 1个像素点=4个Component 1个Component占1个Byte 1个Byte有8个bit，一行有 像素点数x4个Byte size_t width = CGImageGetWidth(imageRef); size_t height = CGImageGetHeight(imageRef); size_t bits = CGImageGetBitsPerComponent(imageRef); // 8 size_t bitsPerrow = CGImageGetBytesPerRow(imageRef); // width * bits // 准备绘制图片了 // bitmap 生成一个上下文 再通过上下文生成图片 CGContextRef contextR = CGBitmapContextCreate(pixbuf, width, height, bits, bitsPerrow, colorSpace, alpInfo); CGImageRef filterImageRef = CGBitmapContextCreateImage(contextR); UIImage *filterImage = [UIImage imageWithCGImage:filterImageRef]; _filterImageV.image = filterImage; } // RGBA 为一个单元 彩色照变黑白照 - (void)eocImageFiletPixBuf:(char*)pixBuf offset:(int)offset{ int offsetR = offset; int offsetG = offset + 1; int offsetB = offset + 2; int offsetA = offset + 3; int red = pixBuf[offsetR]; int gre = pixBuf[offsetG]; int blu = pixBuf[offsetB]; int alp = pixBuf[offsetA]; int gray = (red + gre + blu)/3; pixBuf[offsetR] = gray; pixBuf[offsetG] = gray; pixBuf[offsetB] = gray; } 截图 //规则截图和不规则 - (void)shotScreen:(id)sender{ UIGraphicsBeginImageContext(CGSizeMake(200, 200)); CGContextRef context = UIGraphicsGetCurrentContext(); //UIImage *image = [UIImage imageNamed:@&quot;3.jpg&quot;]; // 先clipcontext 规则的 //CGRect rect = CGRectMake(0, 0, 200, 200); //CGContextAddEllipseInRect(context, rect); // path //CGContextClip(context); //[image drawInRect:CGRectMake(0, 0, 200, 200)]; // 非规则的path CGMutablePathRef pathRef = CGPathCreateMutable(); CGPoint lines[] = { CGPointMake(0, 0), CGPointMake(150, 70), CGPointMake(200, 200), CGPointMake(50, 120), CGPointMake(30, 30) }; CGPathAddLines(pathRef, NULL, lines, 5); CGContextAddPath(context, pathRef); CGContextClip(context); UIImage *imageTwo = [UIImage imageNamed:@&quot;3.jpg&quot;]; [imageTwo drawInRect:CGRectMake(0, 0, 200, 200)]; UIImage *clipImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); _eocImageV.image = clipImage; } //蒙版，context上画了两次 - (void)Blend{ // CGContextSetBlendMode(context, &lt;#CGBlendMode mode#&gt;); UIImage *imageTwo = [UIImage imageNamed:@&quot;3.jpg&quot;]; UIGraphicsBeginImageContext(CGSizeMake(200, 200)); CGContextRef context = UIGraphicsGetCurrentContext(); [imageTwo drawInRect:CGRectMake(0, 0, 200, 200)]; UIColor *redColor = [UIColor colorWithRed:1 green:0 blue:0 alpha:0.5]; CGContextSetFillColorWithColor(context, redColor.CGColor); CGContextSetBlendMode(context, kCGBlendModeNormal); CGContextFillRect(context, CGRectMake(0, 0, 200, 200)); CGImageRef imageRef = CGBitmapContextCreateImage(context); _eocImageV.image = [UIImage imageWithCGImage:imageRef]; UIGraphicsEndImageContext(); } //对view视图截图 - (void)imageFromFullView{ UIGraphicsBeginImageContext(self.view.frame.size); CGContextRef context = UIGraphicsGetCurrentContext(); [self.view.layer renderInContext:context]; CGImageRef imageRef = CGBitmapContextCreateImage(context); _eocImageV.image = [UIImage imageWithCGImage:imageRef]; UIGraphicsEndImageContext(); }]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>iOS</tag>
        <tag>离屏渲染</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity导入Swift工程]]></title>
    <url>%2F2016%2F12%2F30%2FUnity%E5%AF%BC%E5%85%A5Swift%E5%B7%A5%E7%A8%8B(%E5%BE%85%E5%AE%8C%E6%88%90)%2F</url>
    <content type="text"></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity导入时小技巧]]></title>
    <url>%2F2016%2F11%2F25%2FUnity%E5%AF%BC%E5%85%A5%E6%97%B6%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[导入Unity时的小技巧解决修改配置繁琐问题从上边的过程可以看出，每次导入Unity之前，都需要更改build settings中的许多配置，这种操作很多很繁琐，如何让其更简单的配置呢，根据此大神的git地址，发现，根据xcconfig文件来配置target的config很容易，所以受此启发，我更新了配置方式 首先创建一个xcconfig文件，并书写内容 #include &quot;Pods/Target Support Files/Pods-CityPlus/Pods-CityPlus.debug.xcconfig&quot; OTHER_CFLAGS = -DINIT_SCRIPTING_BACKEND=1 $(inherited) ${PODS_OTHER_CFLAGS} OTHER_LDFLAGS = $(inherited) ${PODS_OTHER_LDFLAGS} -weak-lSystem -weak_framework CoreMotion -weak_framework GameKit -weak_framework iAd -framework CoreGraphics -framework AVFoundation -framework CoreVideo -framework CoreMedia -framework SystemConfiguration -framework CoreLocation -framework MediaPlayer -framework CFNetwork -framework AudioToolbox -framework OpenAL -framework QuartzCore -framework OpenGLES -framework UIKit -framework Foundation -liconv.2 -liPhone-lib; HEADER_SEARCH_PATHS = $(inherited) ${PODS_HEADER_SEARCH_PATHS} $(UNITY_IOS_EXPORT_PATH)/Classes $(UNITY_IOS_EXPORT_PATH)/Classes/Native $(UNITY_IOS_EXPORT_PATH)/Libraries $(UNITY_IOS_EXPORT_PATH)/Libraries/libil2cpp/include $(UNITY_IOS_EXPORT_PATH)/Libraries/Plugins/iOS; LIBRARY_SEARCH_PATHS = $(inherited) $(UNITY_IOS_EXPORT_PATH)/Libraries $(UNITY_IOS_EXPORT_PATH)/Libraries/libil2cpp/include $(UNITY_IOS_EXPORT_PATH)/Libraries/Plugins/iOS; FRAMEWORK_SEARCH_PATHS = $(inherited) ${PODS_FRAMEWORK_SEARCH_PATHS} ENABLE_BITCODE = NO; SWIFT_OBJC_BRIDGING_HEADER = CityPlus/Supporting Files/CityPlus-Bridging-Header.h; CLANG_CXX_LANGUAGE_STANDARD = compiler-default; CLANG_CXX_LIBRARY = libc++; CLANG_WARN_BOOL_CONVERSION = NO; CLANG_WARN_CONSTANT_CONVERSION = NO; CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES; CLANG_WARN_EMPTY_BODY = NO; CLANG_WARN_ENUM_CONVERSION = NO; CLANG_WARN_INT_CONVERSION = NO; CLANG_WARN_OBJC_ROOT_CLASS = YES; CLANG_WARN_UNREACHABLE_CODE = NO; CLANG_WARN__DUPLICATE_METHOD_MATCH = NO; GCC_C_LANGUAGE_STANDARD = C99; GCC_ENABLE_OBJC_EXCEPTIONS = YES; GCC_PRECOMPILE_PREFIX_HEADER = YES; GCC_THUMB_SUPPORT = NO; GCC_USE_INDIRECT_FUNCTION_CALLS = NO; GCC_WARN_64_TO_32_BIT_CONVERSION = NO; GCC_WARN_64_TO_32_BIT_CONVERSION[arch=*64] = YES; GCC_WARN_ABOUT_RETURN_TYPE = YES; GCC_WARN_UNDECLARED_SELECTOR = NO; GCC_WARN_UNINITIALIZED_AUTOS = NO; GCC_WARN_UNUSED_FUNCTION = NO; UNITY_RUNTIME_VERSION = 5.3.0f4; UNITY_SCRIPTING_BACKEND = il2cpp; UNITY_IOS_EXPORT_PATH = ../UnityBuildiOSProj; 从上边的xcconfig文件中即可定义此工程的build settings，在project下的Info栏目中选择相应的xcconfig文件即可。细心的同学可能会发现其中有${PODS_HEADER_SEARCH_PATHS}等pod变量，这些是怎么来的呢？ 这是因为我们在工程中使用了pod工具，而pod工程也是用xcconfig来组织项目框架，所以就会出现一个问题，target本身是引用pod的xcconfig，而现在我们要将target的xcconfig变成我们自己的，这要怎么办呢，最后提出了一个方案，让我们自己的xcconfig文件内容包含pod的xcconfig文件内容，所以这就是最后的解决思路，我们看看pod的xcconfig文件内容 ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES = YES EMBEDDED_CONTENT_CONTAINS_SWIFT = YES ENABLE_BITCODE = NO PODS_FRAMEWORK_SEARCH_PATHS = $(inherited) &quot;$PODS_CONFIGURATION_BUILD_DIR/AFNetworking&quot; &quot;$PODS_CONFIGURATION_BUILD_DIR/CHTCollectionViewWaterfallLayout&quot; &quot;$PODS_CONFIGURATION_BUILD_DIR/CocoaAsyncSocket&quot; &quot;$PODS_CONFIGURATION_BUILD_DIR/CocoaLumberjack&quot; &quot;$PODS_CONFIGURATION_BUILD_DIR/KissXML&quot; &quot;$PODS_CONFIGURATION_BUILD_DIR/MBProgressHUD&quot; &quot;$PODS_CONFIGURATION_BUILD_DIR/MJExtension&quot; &quot;$PODS_CONFIGURATION_BUILD_DIR/MJRefresh&quot; &quot;$PODS_CONFIGURATION_BUILD_DIR/PureLayout&quot; &quot;$PODS_CONFIGURATION_BUILD_DIR/ReactiveCocoa&quot; &quot;$PODS_CONFIGURATION_BUILD_DIR/Result&quot; &quot;$PODS_CONFIGURATION_BUILD_DIR/SDWebImage&quot; &quot;$PODS_CONFIGURATION_BUILD_DIR/STPopup&quot; &quot;$PODS_CONFIGURATION_BUILD_DIR/UPCarouselFlowLayout&quot; &quot;$PODS_CONFIGURATION_BUILD_DIR/VPImageCropper&quot; &quot;$PODS_CONFIGURATION_BUILD_DIR/XMPPFramework&quot; &quot;$PODS_CONFIGURATION_BUILD_DIR/ZLPhotoBrowser&quot; &quot;$PODS_CONFIGURATION_BUILD_DIR/iConsole&quot; &quot;${PODS_ROOT}/BaiduMapKit/BaiduMapKit&quot; GCC_PREPROCESSOR_DEFINITIONS = $(inherited) COCOAPODS=1 PODS_HEADER_SEARCH_PATHS = $(SDKROOT)/usr/include/libxml2 $(inherited) $(SDKROOT)/usr/include/libxml2 $(SDKROOT)/usr/include/libresolv $(inherited) &quot;${PODS_ROOT}/Headers/Public&quot; &quot;${PODS_ROOT}/Headers/Public/BaiduMapKit&quot; LD_RUNPATH_SEARCH_PATHS = $(inherited) &apos;@executable_path/Frameworks&apos; &apos;@loader_path/Frameworks&apos; PODS_OTHER_CFLAGS = $(inherited) -iquote &quot;$PODS_CONFIGURATION_BUILD_DIR/AFNetworking/AFNetworking.framework/Headers&quot; -iquote &quot;$PODS_CONFIGURATION_BUILD_DIR/CHTCollectionViewWaterfallLayout/CHTCollectionViewWaterfallLayout.framework/Headers&quot; -iquote &quot;$PODS_CONFIGURATION_BUILD_DIR/CocoaAsyncSocket/CocoaAsyncSocket.framework/Headers&quot; -iquote &quot;$PODS_CONFIGURATION_BUILD_DIR/CocoaLumberjack/CocoaLumberjack.framework/Headers&quot; -iquote &quot;$PODS_CONFIGURATION_BUILD_DIR/KissXML/KissXML.framework/Headers&quot; -iquote &quot;$PODS_CONFIGURATION_BUILD_DIR/MBProgressHUD/MBProgressHUD.framework/Headers&quot; -iquote &quot;$PODS_CONFIGURATION_BUILD_DIR/MJExtension/MJExtension.framework/Headers&quot; -iquote &quot;$PODS_CONFIGURATION_BUILD_DIR/MJRefresh/MJRefresh.framework/Headers&quot; -iquote &quot;$PODS_CONFIGURATION_BUILD_DIR/PureLayout/PureLayout.framework/Headers&quot; -iquote &quot;$PODS_CONFIGURATION_BUILD_DIR/ReactiveCocoa/ReactiveCocoa.framework/Headers&quot; -iquote &quot;$PODS_CONFIGURATION_BUILD_DIR/Result/Result.framework/Headers&quot; -iquote &quot;$PODS_CONFIGURATION_BUILD_DIR/SDWebImage/SDWebImage.framework/Headers&quot; -iquote &quot;$PODS_CONFIGURATION_BUILD_DIR/STPopup/STPopup.framework/Headers&quot; -iquote &quot;$PODS_CONFIGURATION_BUILD_DIR/UPCarouselFlowLayout/UPCarouselFlowLayout.framework/Headers&quot; -iquote &quot;$PODS_CONFIGURATION_BUILD_DIR/VPImageCropper/VPImageCropper.framework/Headers&quot; -iquote &quot;$PODS_CONFIGURATION_BUILD_DIR/XMPPFramework/XMPPFramework.framework/Headers&quot; -iquote &quot;$PODS_CONFIGURATION_BUILD_DIR/ZLPhotoBrowser/ZLPhotoBrowser.framework/Headers&quot; -iquote &quot;$PODS_CONFIGURATION_BUILD_DIR/iConsole/iConsole.framework/Headers&quot; -isystem &quot;${PODS_ROOT}/Headers/Public&quot; -isystem &quot;${PODS_ROOT}/Headers/Public/BaiduMapKit&quot; PODS_OTHER_LDFLAGS = $(inherited) -ObjC -l&quot;sqlite3.0&quot; -l&quot;stdc++.6.0.9&quot; -framework &quot;AFNetworking&quot; -framework &quot;BaiduMapAPI_Base&quot; -framework &quot;BaiduMapAPI_Cloud&quot; -framework &quot;BaiduMapAPI_Location&quot; -framework &quot;BaiduMapAPI_Map&quot; -framework &quot;BaiduMapAPI_Radar&quot; -framework &quot;BaiduMapAPI_Search&quot; -framework &quot;BaiduMapAPI_Utils&quot; -framework &quot;CHTCollectionViewWaterfallLayout&quot; -framework &quot;CocoaAsyncSocket&quot; -framework &quot;CocoaLumberjack&quot; -framework &quot;CoreGraphics&quot; -framework &quot;CoreLocation&quot; -framework &quot;CoreTelephony&quot; -framework &quot;KissXML&quot; -framework &quot;MBProgressHUD&quot; -framework &quot;MJExtension&quot; -framework &quot;MJRefresh&quot; -framework &quot;OpenGLES&quot; -framework &quot;PureLayout&quot; -framework &quot;QuartzCore&quot; -framework &quot;ReactiveCocoa&quot; -framework &quot;Result&quot; -framework &quot;SDWebImage&quot; -framework &quot;STPopup&quot; -framework &quot;Security&quot; -framework &quot;SystemConfiguration&quot; -framework &quot;UPCarouselFlowLayout&quot; -framework &quot;VPImageCropper&quot; -framework &quot;XMPPFramework&quot; -framework &quot;ZLPhotoBrowser&quot; -framework &quot;iConsole&quot; OTHER_SWIFT_FLAGS = $(inherited) &quot;-D&quot; &quot;COCOAPODS&quot; PODS_BUILD_DIR = $BUILD_DIR PODS_CONFIGURATION_BUILD_DIR = $PODS_BUILD_DIR/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME) PODS_ROOT = ${SRCROOT}/Pods 从pod的内容可以看出，原来我们自己的xcconfig文件中的${PODS_HEADER_SEARCH_PATHS}等pod变量都来自于pod的xcconfig文件中，然而pod的xcconfig文件中为什么会是PODS_HEADER_SEARCH_PATHS这些变量，而不是pod默认生成的HEADER_SEARCH_PATHS呢，这是由于我们在pod file文件中更改了这些键值中键的命名，我们来看一下podfile文件 platform :ios, &apos;8.1&apos; use_frameworks! target &apos;CityPlus&apos; do pod &apos;AFNetworking&apos;, &apos;~&gt;3.1.0&apos; pod &apos;MBProgressHUD&apos;, &apos;~&gt; 1.0.0&apos; pod &apos;PureLayout&apos;,&apos;~&gt; 3.0.2&apos; pod &apos;BaiduMapKit&apos;,&apos;~&gt; 3.0.0&apos; pod &apos;UPCarouselFlowLayout&apos; pod &apos;SDWebImage&apos;,&apos;~&gt; 3.8.1&apos; pod &apos;CHTCollectionViewWaterfallLayout&apos;, &apos;~&gt; 0.9.5&apos; ##JsonModel pod &apos;MJExtension&apos;, &apos;~&gt; 3.0.13&apos; pod &apos;ReactiveCocoa&apos;, &apos;~&gt; 4.2.2&apos; ##相册选择图片裁剪处理 pod &apos;VPImageCropper&apos;, &apos;~&gt; 0.0.4&apos; ##下拉刷新，上拉加载更多控件 pod &apos;MJRefresh&apos;, &apos;~&gt; 3.1.12&apos; ##相册图片选择器 pod &apos;ZLPhotoBrowser&apos;, &apos;~&gt; 1.0.7&apos; pod &apos;STPopup&apos; ##离线bug调试组件 pod &apos;iConsole&apos;, &apos;~&gt; 1.5.3&apos; pod &apos;XMPPFramework&apos;, :git =&gt; &quot;https://github.com/robbiehanson/XMPPFramework.git&quot;, :branch =&gt; &apos;master&apos; post_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| config.build_settings[&apos;SWIFT_VERSION&apos;] = &apos;2.3&apos; end end workDir = Dir.pwd xcDebugConfigFilename = &quot;#{workDir}/Pods/Target Support Files/Pods-CityPlus/Pods-CityPlus.debug.xcconfig&quot; puts &quot;xcconfigFilename #{xcDebugConfigFilename}&quot; xcDebugConfig = File.read(xcDebugConfigFilename) newXcDebugconfig = xcDebugConfig.gsub(/FRAMEWORK_SEARCH_PATHS/, &quot;PODS_FRAMEWORK_SEARCH_PATHS&quot;) newXcDebugconfig = newXcDebugconfig.gsub(/HEADER_SEARCH_PATHS/, &quot;PODS_HEADER_SEARCH_PATHS&quot;) newXcDebugconfig = newXcDebugconfig.gsub(/OTHER_LDFLAGS/, &quot;PODS_OTHER_LDFLAGS&quot;) newXcDebugconfig = newXcDebugconfig.gsub(/OTHER_CFLAGS/, &quot;PODS_OTHER_CFLAGS&quot;) File.open(xcDebugConfigFilename, &quot;w&quot;) { |file| file &lt;&lt; newXcDebugconfig } xcReleaseConfigFilename = &quot;#{workDir}/Pods/Target Support Files/Pods-CityPlus/Pods-CityPlus.release.xcconfig&quot; puts &quot;xcconfigFilename #{xcReleaseConfigFilename}&quot; xcReleaseConfig = File.read(xcReleaseConfigFilename) newXcReleaseconfig = xcReleaseConfig.gsub(/FRAMEWORK_SEARCH_PATHS/, &quot;PODS_FRAMEWORK_SEARCH_PATHS&quot;) newXcReleaseconfig = newXcReleaseconfig.gsub(/HEADER_SEARCH_PATHS/, &quot;PODS_HEADER_SEARCH_PATHS&quot;) newXcReleaseconfig = newXcReleaseconfig.gsub(/OTHER_LDFLAGS/, &quot;PODS_OTHER_LDFLAGS&quot;) newXcReleaseconfig = newXcReleaseconfig.gsub(/OTHER_CFLAGS/, &quot;PODS_OTHER_CFLAGS&quot;) File.open(xcReleaseConfigFilename, &quot;w&quot;) { |file| file &lt;&lt; newXcReleaseconfig } end end 这样就很清晰明了了，在pod file中，我们在安装完pod后，将pod的xcconfig文件内的键值都进行了一次替换 解决导入速度问题导入unity的Class和Libaray文件夹时，最大的问题就是耗时太久，没有半个小时搞不下来，最终探究其过程和原因，发现有一个很耗时的地方动作重复了，即把Class-&gt;Native中的所有.h文件导入了一次，又删除了一次，同样把Libraries-&gt;libil2cpp中所有的文件删除又导入了一次 如何解决这个问题呢，想到最好的一个办法就是先在Native文件夹里搜索所有匹配.h的文件，然后全选将其删除到垃圾桶，再根据步骤将Class拖入到XCode工程中去（会发现此时速度提升了很多），等拖入完成后再去文件夹中按键Ctr+Z将删除的文件撤销回来，此种方法即避免了.h文件被拖入XCode工程，然后又被从工程中删除引用的重复问题 Libraries-&gt;libil2cpp中的文件可以采用同样的方法避免 这种方式虽然可以节省大部分时间，将时间从半个多小时缩短到五分钟左右，但是对于程序员来说还是比较久，有什么更好的办法呢？ 从以上步骤的时间花费可以看出，5分钟的导入时间很大一部分都是在搜索.h，删除.h，撤销删除的时间，我简单做了一个测试，14821个文件中搜索占了60秒，删除占了64秒，撤销删除占了120秒，就是说，这些步骤加起来都有4分钟多，如何解决这个问题呢？ 受以下问题启示，我们可以自己写一段代码，将.h文件移动到另一个目录，等到导入完成，再将.h文件移动回来，代码如下 /// 将Native中的.h文件移动到一个暂时的文件夹中 public func removeHFile() -&gt; Void { let desNativeDir : String = ProjectPath + &quot;Temp/Native/&quot;; let srcNativeDir : String = ProjectPath + &quot;UnityBuildiOSProj/Classes/Native/&quot;; let fileManager : FileManager = FileManager.default; do { if fileManager.fileExists(atPath: desNativeDir) { try fileManager.removeItem(atPath: desNativeDir); } try fileManager.createDirectory(at: URL(string:&quot;file://&quot;+desNativeDir)!, withIntermediateDirectories: true, attributes: nil); print(Date()); let hfiles : [String] = try fileManager.contentsOfDirectory(atPath: srcNativeDir); for file : String in hfiles { if (file.contains(&quot;.h&quot;)) { try fileManager.moveItem(atPath: srcNativeDir+file, toPath: desNativeDir+file); } } print(Date()); } catch let error { print(error.localizedDescription); } } /// 将原来备份的.h文件移动回来 public func moveHFileBack() -&gt; Void { let srcNativeDir : String = ProjectPath + &quot;Temp/Native/&quot;; let desNativeDir : String = ProjectPath + &quot;UnityBuildiOSProj/Classes/Native/&quot;; let fileManager : FileManager = FileManager.default; do { print(Date()); let hfiles : [String] = try fileManager.contentsOfDirectory(atPath: srcNativeDir); for file : String in hfiles { if (file.contains(&quot;.h&quot;)) { try fileManager.moveItem(atPath: srcNativeDir+file, toPath: desNativeDir+file); } } print(Date()); if fileManager.fileExists(atPath: srcNativeDir) { try fileManager.removeItem(atPath: srcNativeDir); } } catch let error { print(error.localizedDescription); } } 经测试，移动到临时目录耗时20秒，移动回来耗时25秒，又一次大大缩短了导入的时间 一键解决重复修改问题在引入Unity工程完成后，我们开始编译运行，会发现编译不通过，需要修改一些内容，包括以下1和2，当运行起来后，会发生错误，要修改3，这些内容虽然修改及其简单，但是多次导入会显得很麻烦，有没有更简单的做法呢？ 删除Unity中对main.mm的引用，因为全局只需要一个main.mm unknown type name __declspec，更改declspec为attribute 更改GetAppController函数 为了解决这些问题，我在工程中写了一个小程序，用代码完成这些操作 创建一个mac os下的command line 的 Target，在target中添加如下代码，点击运行此target即可更改所有问题 删除Unity中对main.mm的引用，因为全局只需要一个main.mm /// 删除main.mm引用 /// /// - Returns: 是否删除main.mm引用成功 func removeMainmm() -&gt; Bool { let path : String = ProjectPath+&quot;CityPlus/CityPlus.xcodeproj/project.pbxproj&quot;; var keys : Set&lt;String&gt; = []; let propertyList : [String: Any] = parseProject(path: path)!; //寻找所有的main.mm的id for key1 : String in propertyList.keys { if key1 == &quot;objects&quot; { let propertyList1 : [String: Any] = propertyList[key1] as! [String : Any]; for key2 : String in propertyList1.keys { let propertyList2 : [String: Any] = propertyList1[key2] as! [String : Any]; for key3 : String in propertyList2.keys { if (propertyList2[key3] is String) { let value3 : String = propertyList2[key3] as! String; if (key3 == &quot;path&quot; &amp;&amp; value3 == &quot;main.mm&quot;) { print(&quot;find key &quot;+key2+&quot; and path &quot;+value3); keys.insert(key2); } } } } } } //只保留在UnityBuildiOSProj文件夹下的main.mm的id for key1 : String in propertyList.keys { if key1 == &quot;objects&quot; { let propertyList1 : [String: Any] = propertyList[key1] as! [String : Any]; for key2 : String in propertyList1.keys { let propertyList2 : [String: Any] = propertyList1[key2] as! [String : Any]; if (propertyList2.keys.contains(&quot;path&quot;) &amp;&amp; propertyList2[&quot;path&quot;] is String) { let path : String = propertyList2[&quot;path&quot;] as! String; for key3 : String in propertyList2.keys { if (propertyList2[key3] is [String]) { let value3 : [String] = propertyList2[key3] as! [String]; for value4 : String in value3 { if (keys.contains(value4)) { if (!path.contains(&quot;UnityBuildiOSProj&quot;)) { print(&quot;remove key &quot;+value4); keys.remove(value4); } } } } } } } } } print(&quot;all id is &quot;+keys.description); if keys.count == 0 { print(&quot;find no key&quot;); return false; } //备份project文件，读取备份内容，将内容中关于main.mm的id部分删除，再重写写入project文件 var url : URL = URL(string:&quot;file://&quot;+path)!; let backupURL = backupURLOf(projectURL: &amp;url); do { if FileManager().fileExists(atPath: backupURL.path) { try FileManager().removeItem(at: backupURL) } try FileManager().moveItem(at: url, to: backupURL) print(&quot;已备份project工程文件，地址backupURL: \(backupURL)&quot;) let content : String = read(path: path+&quot;.backup&quot;); let myStrings : [String] = content.components(separatedBy: NSCharacterSet.newlines); print(myStrings.count); var resultString : String = String(); for key : String in keys { for string : String in myStrings { if (string.contains(key)) { print(string); } else { resultString = resultString.appending(string).appending(&quot;\n&quot;); } } } return writeString(aStr: resultString, toFile: path); } catch let error { do { print(&quot;generate new project file failed: \(error.localizedDescription), try to roll back project file!&quot;) try FileManager().moveItem(at: backupURL, to: url) } catch _ { print(&quot;roll back project file failed! backup file url: \(backupURL), error: \(error.localizedDescription)&quot;) } return false; } } unknown type name __declspec，更改declspec为attribute /// 修改il2cpp-config.h中的attribute /// /// - Returns: 是否修改成功 func replaceDec2Attr() -&gt; Bool { let path : String = ProjectPath + &quot;UnityBuildiOSProj/Libraries/libil2cpp/include/il2cpp-config.h&quot;; var content : String = read(path: path); if content.contains(&quot;__declspec(noreturn)&quot;) { content = content.replacingOccurrences(of: &quot;__declspec(noreturn)&quot;, with: &quot;__attribute__((noreturn))&quot;); let res = writeString(aStr: content, toFile: path); return res; } else { return false; } } 更改GetAppController函数 /// 修改GetAppController中的代码 /// /// - Returns: 是否修改成功 func editGetAppController() -&gt; Bool { let path : String = ProjectPath + &quot;UnityBuildiOSProj/Classes/UnityAppController.h&quot;; var content : String = read(path: path); if !content.contains(&quot;#import \&quot;CPAppDelegate.h\&quot;&quot;) { //添加#import &quot;CPAppDelegate.h&quot; content = content.replacingOccurrences(of: &quot;#import &lt;QuartzCore/CADisplayLink.h&gt;&quot;, with: &quot;#import &lt;QuartzCore/CADisplayLink.h&gt;\n#import \&quot;CPAppDelegate.h\&quot;&quot;); //替换GetAppController函数 content = content.replacingOccurrences(of: &quot;(UnityAppController*)[UIApplication sharedApplication].delegate&quot;, with: &quot;[(CPAppDelegate*)[UIApplication sharedApplication].delegate unityController]&quot;) let res = writeString(aStr: content, toFile: path); return res; } else { return false; } } 其他用到的代码 func read(path:String) -&gt; String { let file : FileHandle = FileHandle(forReadingAtPath:path)!; let data : Data = file.readDataToEndOfFile(); let aStr : String = NSString(data: data, encoding: String.Encoding.utf8.rawValue) as! String; file.closeFile(); return aStr; } /// 将字符串写入到文件中 /// /// - Parameters: /// - aStr: 字符串 /// - path: 文件的路径 /// - Returns: 是否写入成功 func writeString(aStr: String, toFile path : String) -&gt; Bool { do { try aStr.write(toFile: path, atomically: true, encoding: String.Encoding.utf8); return true; } catch let err as NSError { print(err); return false; } } /// 将工程文件内容转为字典对象 /// /// - Parameter fileURL: 文件路径 URL /// - Returns: 字典对象，即转化后的内容 func parseProject(path: String) -&gt; [String: Any]? { do { let file : FileHandle = FileHandle(forReadingAtPath:path)!; let fileData = file.readDataToEndOfFile(); let plist = try PropertyListSerialization.propertyList(from: fileData, options: .mutableContainersAndLeaves, format: nil) return plist as? [String:Any] } catch let error { print(&quot;read project file failed. error: \(error.localizedDescription)&quot;) return nil } } 整体的过程将导入时间从半个小时以上，缩短至两分钟以内~~~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity导入时填坑]]></title>
    <url>%2F2016%2F10%2F28%2FUnity%E5%AF%BC%E5%85%A5%E6%97%B6%E5%A1%AB%E5%9D%91%2F</url>
    <content type="text"><![CDATA[实际应用中所遇到的坑unknown type name __declspec该版本unity3d工程编译成xcode可执行文件后，导入IOS过程中会报2次错误，具体描述如下：“unknown type name __declspec” 解决方法：xcode中找到il2cpp-config.h文件，在181行（上下）找到 #define NORETURN __declspec(noreturn) 改成 #define NORETURN attribute((noreturn)) Unknown type name ‘UnityViewControllerBase’有人建议：UnityViewControllerBase报错, 把它改成UIViewController但是我通过前向引用声明解决这个问题： 平台编译报错编译报错，而且多大俩百多个。全是链接错误。最后网上发现，我自己导出工程时目标是真机，不是模拟器，而编译时对象是模拟器。所以编译不成功 修改编译报错现在又遇到个棘手的问题，在Unity里面增删东西之后编译导出覆盖iOS工程，在Native iOS工程这边编译，出现连接错误，报错200+，都是referenced from错误。一天的时间，还未找到解决方案。目前我能想到的解决方案就是先删掉Unity_iOS工程，然后到重新导入Native_iOS工程。删除main.mm文件，配置一下il2cpp_config.h文件的NORETURN 宏定义……………..####事实证明，这种做法是正确的！！！！！！！ pch文件中import类的位置iPhone_target_Prefix.pch文件中会import一些常用的类，这些类一定要放在 #ifdef __OBJC__ #import 《Foundation/Foundation.h》 #import 《UIKit/UIKit.h》 #import &quot;macro.h&quot; #import 各种你的类 #endif 放外面的话会报NSObjCRuntime.h，NSZone.h，NSObject.h里面的unknown type name ‘NSString’之类的错这里也有这类报错的解释 引入宏引起编译错误上面iPhone_target_Prefix.pch引用了macro.h，里面是各种宏，会引起如下错误，不知道是什么鬼。。 解决办法就是不要把宏引用放在iPhone_target_Prefix.pch里，在各自的viewcontroller里引用macro.h同样的，如果pch引用的其他ios原生文件中也写过宏，全部都要去掉不知道还有没有别的办法了，我是把原先写在pch中的引用全都手动一个个拷贝到每个需要的viewcontroller中了 没有引入需要的Framework发生的问题 解决方法：添加需要的库文件即可 启动时遇到的问题编译成功之后，在真机运行，启动时遇到错误： -[AppDelegate rootViewController]: unrecognized selector sent to instance 0x15d687660&apos; 需要去更改UnityAppController.h文件 86行的代码，更改为如下代码： inline UnityAppController* GetAppController() { return [(CPAppDelegate*)[UIApplication sharedApplication].delegate unityController]; } 随时记着删除掉unity工程中的main.mm文件OC和Unity交互时字串的问题OC的字串不是以\0结尾，Unity字串必须标志以\0结尾，所以在OC和Unity通讯传参数的过程中，必须要有一个转换 NSString* UniObjMakeNSString (const char* string) { if (string) { return [NSString stringWithUTF8String: string]; } else { return [NSString stringWithUTF8String: &quot;&quot;]; } } char* UniObjMakeCString(NSString *str) { const char* string = [str UTF8String]; if (string == NULL) { return NULL; } char* res = (char*)malloc(strlen(string) + 1); strcpy(res, string); return res; } duplicate symbols for architecture arm64在Unity引入暴风魔镜SDK的时候，出现了如下错误 这是由于target的build settings中other linker flag参数中添加了$(inherited)，而$(inherited)代表的意思就是此参数配置继承子工程配置，而在此项目中的子工程是pod工程，所以会沿用Pods/Pods-CityPlus.debug.xcconfig中OTHER_LDFLAGS参数配置，这些参数配置中包括了-ObjC，这个参数就是问题的源点，去掉就可以了 还记得我们在学习C程序的时候，从C代码到可执行文件经历的步骤是： 源代码 &gt; 预处理器 &gt; 编译器 &gt; 汇编器 &gt; 机器码 &gt; 链接器 &gt; 可执行文件 在最后一步需要把.o文件和C语言运行库链接起来，这时候需要用到ld命令。源文件经过一系列处理以后，会生成对应的.obj文件，然后一个项目必然会有许多.obj文件，并且这些文件之间会有各种各样的联系，例如函数调用。链接器做的事就是把这些目标文件和所用的一些库链接在一起形成一个完整的可执行文件 那么，Other linker flags设置的值实际上就是ld命令执行时后面所加的参数 下面逐个介绍3个常用参数： －ObjC：加了这个参数后，链接器就会把静态库中所有的Objective-C类和分类都加载到最后的可执行文件中。Unix的标准静态库实现和Objective-C的动态特性之间有一些冲突：Objective-C没有为每个函数（或者方法）定义链接符号，它只为每个类创建链接符号。这样当在一个静态库中使用类别来扩展已有类的时候，链接器不知道如何把类原有的方法和类别中的方法整合起来，就会导致你调用类别中的方法时，出现”selector not recognized”，也就是找不到方法定义的错误。为了解决这个问题，引入了-ObjC标志，它的作用就是将静态库中所有的和对象相关的文件都加载进来，然而当静态库中全部是分类而没有类时就会引起－ObjC失效 －all_load：会让链接器把所有找到的目标文件都加载到可执行文件中，但是千万不要随便使用这个参数！假如你使用了不止一个静态库文件，然后又使用了这个参数，那么你很有可能会遇到ld: duplicate symbol错误，因为不同的库文件里面可能会有相同的目标文件，所以建议在遇到-ObjC失效的情况下使用-force_load参数。 -force_load：所做的事情跟-all_load其实是一样的，但是-force_load需要指定要进行全部加载的库文件的路径，这样的话，你就只是完全加载了一个库文件，不影响其余库文件的按需加载 这个问题的解决方法就是将SDK升级]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity导入OC工程]]></title>
    <url>%2F2016%2F09%2F30%2FUnity%E5%AF%BC%E5%85%A5OC%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[iOS工程和Unity工程中界面的交互 将Unity工程打包成iOS工程，作为库工程准备调用 新建一个iOS主工程，将Unity库工程添加进来 调用Unity工程的界面，添加到iOS工程的界面中来显示 将Unity工程打包成iOS工程，作为库工程准备调用1，打开build settting 2，设置playersetting 3，building导出,并选择你要导出的目录,并记录 新建一个iOS主工程，将Unity库工程添加进来1，新建xcode工程与unity导出的项目在同一级目录下,例如:~/Document/unity ; ~/Document/iostest 2，删除storyboard以及删除plist文件相关设置 3，引入unity工程文件 Classes以及Libraries文件夹选择如下引入方式 Data选择如下引入方式 4，清理无用文件引用 在xcode中删除,请这样删除,只删除引用 在Libraries中的libil2cpp这个文件夹 在Classes中的Native这个文件夹下所有.h文件 5，添加链接的库文件 6，设置build settting 注意Other C Flags和Other C++ Flags的值，容易被拼错 user defined ,在xcode中的build setting中添加 7，添加pch文件,并且将unity中Classes的Prefix.pch复制并替换到我们的pch文件中 修改我们自己的supporting files下面的main.m 为main.mm 删除在build phases的unity的main.mm文件 调用Unity工程的界面，添加到iOS工程的界面中来显示修改iOS工程的AppDelegate的代码 #import &lt;UIKit/UIKit.h&gt; @class UnityAppController; @interface CPAppDelegate : UIResponder &lt;UIApplicationDelegate&gt; @property (strong, nonatomic) UIWindow *window; @property (strong, nonatomic) UIWindow *unityWindow; @property (strong, nonatomic) UnityAppController *unityController; - (void)showUnityWindow; - (void)hideUnityWindow; @end @implementation CPAppDelegate - (UIWindow*)unityWindow { return UnityGetMainWindow(); } - (void)showUnityWindow { [self.unityWindow makeKeyWindow]; self.window.hidden = YES; } - (void)hideUnityWindow { [self.window makeKeyWindow]; } - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { self.unityController = [[UnityAppController alloc] init]; [self.unityController application:application didFinishLaunchingWithOptions:launchOptions]; return YES; } - (void)applicationWillResignActive:(UIApplication *)application { [self.unityController applicationWillResignActive:application]; } - (void)applicationDidEnterBackground:(UIApplication *)application { [self.unityController applicationDidEnterBackground:application]; } - (void)applicationWillEnterForeground:(UIApplication *)application { [self.unityController applicationWillEnterForeground:application]; } - (void)applicationDidBecomeActive:(UIApplication *)application { [self.unityController applicationDidBecomeActive:application]; } - (void)applicationWillTerminate:(UIApplication *)application { [self.unityController applicationWillTerminate:application]; } @end UnityAppController的代码 extern &quot;C&quot; UIWindow* UnityGetMainWindow() { return GetAppController().mainDisplay.window; } extern &quot;C&quot; UIViewController* UnityGetGLViewController() { return GetAppController().rootViewController; } extern &quot;C&quot; UIView* UnityGetGLView() { return GetAppController().unityView; } extern &quot;C&quot; ScreenOrientation UnityCurrentOrientation() { return GetAppController().unityView.contentOrientation; } inline UnityAppController* GetAppController() { // return (UnityAppController*)[UIApplication sharedApplication].delegate; return [(CPAppDelegate*)[UIApplication sharedApplication].delegate unityController]; } ViewController的代码 - (void)setupUnityView { GetAppController().unityView.frame = CGRectMake(0, 0, PJ_SCREEN_WIDTH, PJ_SCREEN_WIDTH); GetAppController().unityView.center = CGPointMake(PJ_SCREEN_WIDTH/2.0, PJ_SCREEN_WIDTH/2.0); [self.shopHomeBannerView addSubview:UnityGetGLView()]; [self.shopHomeBannerView bringSubviewToFront:UnityGetGLView()]; [self performSelector:@selector(openMerchantDisplay) withObject:nil afterDelay:1]; } - (void)openMerchantDisplay { NSDictionary* params = @{@&quot;methodName&quot; : @&quot;panorama&quot;, @&quot;toggle&quot; : @(true), @&quot;url&quot; : @&quot;http://source-img.img-cn-beijing.aliyuncs.com/%E6%9C%8D%E8%A3%85.jpg@50Q.jpg&quot;}; [self sendUnityMessage:[CPUtils JsonFromData:params]]; } - (void)sendUnityMessage:(NSString*)message { UnitySendMessage(&quot;Unity&quot;,&quot;send&quot;, message.UTF8String); } 至此iOS调用Unity界面的操作完成。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity和OC的交互]]></title>
    <url>%2F2016%2F08%2F26%2FUnity%E5%92%8COC%E7%9A%84%E4%BA%A4%E4%BA%92%2F</url>
    <content type="text"><![CDATA[OC和CS交互CS调用OC函数首先，定义一个新建一个.mm文件，然后在里面定义一个C风格接口的函数，如 extern &quot;C&quot; { void test(char* title, char* msg, char* url) { NSString* nstitle = [[NSString alloc] initWithUTF8String:title]; NSString* nsmsg = [[NSString alloc] initWithUTF8String:msg]; NSString* nsurl = [[NSString alloc] initWithUTF8String:url]; UIAlertView* view = [[UIAlertView alloc] initWithTitle:nstitle message:nsmsg delegate:nil cancelButtonTitle:NSLocalizedString(@&quot;Close&quot;, nil) otherButtonTitles:nil]; [view show]; } } 第二步，将这个mm文件放到unity工程的Assets/Plugins/IOS路径下。 第三步，在CS文件头加入using System.Runtime.InteropServices;声明函数后就可以调用： using UnityEngine; using System.Collections; using System.Runtime.InteropServices; public class testscript : MonoBehaviour { // Use this for initialization void Start () { } // Update is called once per frame void Update () { } [DllImport(&quot;__Internal&quot;)] private static extern void test (string title, string msg, string url); void OnGUI() { if (GUI.Button (new Rect (100, 100, 100, 50), &quot;test obj-c func&quot;)) { test (&quot;omytitle&quot;, &quot;omymsg&quot;, &quot;omyurl&quot;); } } } OC调用CS函数UnitySendMessage(&quot;GameObjectName1&quot;, &quot;MethodName1&quot;, &quot;Message to send&quot;); 参数1：gameobject名字；参数2：回调函数的名字；参数3：参数。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity入门]]></title>
    <url>%2F2016%2F07%2F29%2FUnity%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Unity是由Unity Technologies开发的一个让玩家轻松创建诸如三维视频游戏、建筑可视化、实时三维动画等类型互动内容的多平台的综合型游戏开发工具，是一个全面整合的专业游戏引擎。本篇将分为三大部分，第一部分会介绍一些Unity开发工具的简单使用，第二部分会介绍iOS中的OC和Unity中的CS两者方法的交互，第三部分会介绍iOS工程和Unity工程中界面的交互。 Unity 入门本节将会通过一个案例来介绍Unity的基本使用方法。案例源自Ray Wenderlich教程网站 此教程中共有三部分：(本节只翻译第一部分，因为第一部分已经是一个完整的流程，后边两个部分如果对Unity开发有浓厚兴趣可以自行参考) 在第一部分，你将会学习到用简单的播放控制机制（player control mechanism）创建游戏所需的unity基础知识，并且学习如何将工程运用（deploy）到iOS端 在第二部分，你将会学习到如何利用预编译控制对象（pre－build controller objects）和标准库里的脚本提高（enhance）播放的移动（player’s movements），以及如何用unity 远程（remote）来调试，如何自定义场景 在第三部分，你将会添加gameplay到你的工程，并且基于游戏设计的理念来添加预制（prefabs）／菜单和声音来丰富你的游戏体验 第一部分：先熟悉一下unity开发的流程，基本分为4个部分 在unity editor中组装你的游戏场景 在monoDevelop editor中为你的场景写剧本 用unity remote远程调试 通过unity editor发布到你的iOS设备中去 组装场景创建工程比较简单，具体步骤见原文 在熟悉工具界面之前，先了解界面的布局方式layout，其种类包括2 by 3/4 Split/Default/Tall/Wide几种，将layout切换到wide布局方式，从上到下的view有包括Toolbar、Scene/Game View、Hierarchy View、Project View、Inspector，各自的内容如下 Project View：unity工程包含的Asset文件夹，内容包括scripts，scenes，prefabs和其他的unity对象 Hierarchy View：在当前场景中包涵的游戏对象 Toolbar：工具条里的工具可以用来控制场景的显示和编辑 Scene View：在此处可以放置游戏对象，它包含了一个场景坐标系 Game View：这是从摄像机的角度显示你的游戏的视图 Inspector：这个为你选择的游戏对象提供了更详细的信息，并且可以修改其一些属性INIT_SCRIPTING_BACKEND Toolbar工具条中有Hand Tool、Move Tool、Rotate Tool、Scale Tool，快捷键为Q、W、E、R，具体解释如下 Hand Tool可以移动场景的视图 Move Tool可以拖动修改游戏对象的XYZ坐标，也可以在Inspector中手动修改，如果只需要修改某个轴的位置而保持其他两个不变，则只选择一个相关的箭头即可 Rotate Tool可以拖动修改游戏对象的旋转属性，也可以在Inspector中手动修改，同样的，如果只需要更改某个轴的旋转角度，则只选择某个圆圈拖动 在此时要注意一个Local view和Global view的区别，Local View的坐标系是游戏对象本身的坐标系，global view的坐标系事整个场景的坐标系 Scale Tool可以缩放游戏对象的大小，选中游戏对象，向上是放大，向下是缩小，同样可以用Inspector来设置固定值 添加游戏对象，菜单GameObject转3D转plane或cube，并设置其位置属性，菜单GameObject转Light转Point Light添加光源，并设置其位置、Range和Intensity属性，运用刚才toolbar中介绍的工具调整后，场景即创建完成，此时点击File转Save Scene保存场景 场景剧本接下来为场景中的游戏对象设置动画 可以用自己创建的scripts，或者用预装的脚本来控制游戏对象的行为，unity的脚本语言提供了预定义函数来帮助用户定义游戏对象的行为，具体如下： Update：当MonoBehaviour启用时，其Update在每一帧被调用 FixedUpdate：当MonoBehaviour启用时，其 FixedUpdate在每一帧被调用。update跟当前平台的帧数有关，而FixedUpdate是真实时间，所以处理物理逻辑的时候要把代码放在FixedUpdate而不是Update Start：在第一次update函数被调用之前触发 Awake：当游戏开始时调用，此函数中可以加一些初始化的代码 了解了unity预定的函数后，我们开始为游戏对象创建动画脚本 点击Assets转Create转JavaScript，创建了JavaScript文件后它会出现在Project View中，选择后重命名，双击文件则会自动用MonoDevelop软件打开它，修改其中的Update函数，当点击场景时，绑定此javaScript的游戏对象会重新调整坐标和旋转注意，调试时可以用函数Debug.Log打印log，用Console窗口查看output在JavaScript文件中用代码定义了游戏对象的行为后，我们就可以把它绑定到游戏对象上去了。方法是用简单的拖动或者点击后边的小三角即可。注意在JavaScript中定义的变量可以直接在Inspector中显示且可修改，也就是说，如果有两个游戏对象绑定同一个Script，直接修改Inspector中的属性，就会生成两种不同的动画 远程调试此时，运行场景，当点击游戏对象的时候，游戏对象的行为会如其绑定的JavaScript中定义的那样运作，但有一个问题就是，游戏对象会移动的越来越远，原因就是我们的摄像头对象没有跟着游戏对象的移动而移动，解决办法就是为摄像头绑定script，控制其行为与游戏对象行为的关联 unity为我们提供了很多常用的Asset，并且允许我们自己管理Asset，内容包括scripts，scenes，prefabs和其他的unity对象，此处我们为Camera绑定SmoothFollow.cs文件定义的行为，具体方法为点击菜单Asset转Import package转Utility，导入SmoothFollow.cs文件，在Project View中就会找到此文件，将此文件绑定到Camera上，并设置此camera的target属性为游戏对象cube即可，方法为点击菜单Component转Script转UtilityStandardAsset.Utility转Smooth Follow，再运行，问题解决 发布工程此时即可将工程发布称iOS工程 点击菜单File转Build Settings，在出现的对话框中选择switch platform切换到iOS平台，在点击Player Setting按钮设置平台的横竖屏、Bundle Identifier、iOS version等信息，然后添加场景到工程中点击Build按钮，即可生成Xcode工程，双击xcodeproj文件，打开工程运行到iOS设备即可 如果用户两个手指同时点击距游戏对象等距的屏幕的时候，游戏对象依然会动，这是什么情况？ 因为当在iOS设备上运行时，JS中的Input.mousePosition会被计算成多个手指点击的平均坐标，此时需要在Awake方法中判断其是否在iOS设备上运行，如果是在iOS设备上运行，则不要用Input.mousePosition属性，应该用Input.GetTouch(0).position来获取第一个手指点击时的坐标]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS面试回顾]]></title>
    <url>%2F2016%2F06%2F24%2FiOS%E9%9D%A2%E8%AF%95%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[好不容易找到iOS的工作,感叹今年的iOS端完全不好找工作,移动前端从业者越来越多,出现僧多粥少的局面,现在将面试的经历记录如下,希望能帮助到以后找工作: Camera360camera360一面： 进去之后填了求职表，是个朋友的大学同学面试的 介绍自己 安卓和iOS布局的区别 安卓比较先进强大，有绝对布局、相对布局，线性布局、层次布局、列表布局 iOS布局比较落后，只有绝对布局和相对布局，但iOS布局出来效果要好很多 解决auto layout tabview卡顿问题的解决思路 滑动时由于复用机制影响，需要重新计算高度，可以缓存高度或用FDTempleLayoutCell第三方库 将cell中的同步方法改成异步操作方式，并且在cell不显示时停止操作 设置高度等缓存 在何种情况下用autolayout，在何种情况下用代码 用autolayout可以完成的功能，用代码也可以完成，用autolayout可以完成的，代码未必可以 用autolayout做比较简单，代码少，mvc模式清晰，很多优势，代码则相反，但代码则更加灵活 用autolayout和代码结合的方式会产生很好的效果 查询、插入和删除数组、链表、NSDictionary的速度 根据下标查询的速度数组最快，下来NSDictionary，最后是链表 插入和删除的情况相同，链表最快，下来NSDictionary，最后数组 怎么控制项目进度和代码质量 项目进度的控制要：1，有尽量详细的计划 2，每日的工作按计划进行 线程有哪些实现方式 NSThread GCD NSOperationQueue pThread 在实际开发中，举例哪些情况会用到多线程，哪些情况多线程遇到死锁，资源竞争等问题，以及如何解决 下载图片，数据库，http等均要用到多线程 不要在当前线程中同步执行任务或者sleep，这样会造成死锁 任何串行队列里面串行任务嵌套执行都有问题 平时都用到哪些设计模式 mvc mvvm delegate protocol 扩展 枚举 类别 等 对block的看法 类似于一个函数指针 用handler块降低代码分散程度，回调让代码简洁优雅 代码角度可以返回多个值 为常用的块类型创建typedef，可以声明变量，也可以当函数参数 动画的分类 CAAnimation「核心动画基类」：不能直接使用，他遵循并实现了 CAMediaTiming 协议，负责动画运行时间和速度的控制。 CAPropertyAnimation「属性动画基类」：不能直接使用，他通过可动画属性进行动画设置。 CAAnimationGroup「动画组」：他是一种组合模式，可以组合多个动画进行动画行为的统一控制。 CATransition「转场动画」：主要通过滤镜进行动画效果设置。 CABasicAnimation「基础动画」：通过起点和终点状态属性参数进行动画控制。 CAKeyframeAnimation「关键帧动画」：同 CABasicAnimation 一样通过属性参数进行动画控制，但不同的是他可以有多个状态控制，不单单只有起点和终点 camera360二面 这次面试官主要想自己主导面试流程，而从中间穿插提问 技术方面最具挑战性的事情 UICollectionView移动的动画 UITableView优化的方法 FMDB如何做到线程安全 camera360三面 为何离职 期望薪资 以前的薪资构成 失败原因 最具挑战性的事情没有回答好 跟面试者没有共同语言 薪资待遇要求较高，公司达不到 货车帮货车帮一面 定位高级还是中级/定位主程还是项目管理 技术方面最具挑战性的事情 NSNotification的实现思路，问到了就不要转移话题 失败原因 改成面试中级，公司想招高级 和面试者思路不一致，面试官问了问题之后转移了话题 国际私塾国际私塾一面 介绍自己 技术技能 管理技能 国际私塾二面 简单介绍自己 对APP的理解 整个项目最小研发人数与职责 APP赚钱的途径 看一下以前做的app及对其理解 和经理的性格匹配度 失败原因 和经理的性格匹配度不高 没有hold住全场的外表和气势，与职位不符 亦非云亦非云一面 刚出道或者转行的小伙子面试 介绍自己 CoreData是不是线程安全，如何做到线程安全 淘宝的ScrollView如何嵌套 同一界面有多个table，其delegate中代码如何简化，如何用block实现 失败原因 面试者是一个入门级的小菜，准备的问题有标准答案 缺少忽悠能力和沟通能力 技术和经验也比较缺乏 正兴德正兴德一面 下载图片，显示进度，完成后显示缩略图，长按缩略图显示大图，大图可以用手指缩放 post加参数请求http中的json数据，解析后显示在table上，图片base64解密，auto layout控制cell 正兴德二面 发展方向，主程还是管理 介绍先有APP小生活 为何离职 职业规划，项目面临停止 被分配到别的部门，人员懒散 技术专家得不到提升，前途无望 如何看待加班 失败原因 基础知识不扎实 没有注意各个面试人员的情感 不要将对上个公司的抱怨表现出来 美瞳科技去了这家公司之后，面试人员简单的走了下流程，最后发给一个视频编码的课题让回去研究，三天后让最终成果发送至人事邮箱，这种公司直接pass了 景和千城跟hr聊了下工作经验，职业规划，当前工资水平和期望的工资范围 然后是技术总监面试，技术总监没做过iOS，所以我们只聊了一些关乎项目经验和职业规划的一些话题，通过交谈，项目总监比较看重我的全栈经验，我也觉得项目总监比较和蔼低调，公司业务方向VR也比较超前，所以就选择了这家公司，虽然最后被hr忽悠了点期望工资比较遗憾 成功经验 和项目总监比较能对脾气 前边的面试总结出了一套说辞 公司在规模扩招 没有笔试、二面等一系列复杂流程]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NavigationController原理及应用案例]]></title>
    <url>%2F2016%2F05%2F27%2FNavigationController%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[UINavigationController底层实现原理 Nav容器本质分析 1.1 导航区 1.2 内容区 1.3 toolbar区 导航区分析2.1 属性分析 edgesForExtendedLayout extendedLayoutIncludesOpaqueBars automaticallyAdjustsScrollViewInsets translucent 导航区 内容区 工具区 ios 7.0前 导航条拟物化风格，导航条是不透明（内容区在导航条下：64开始） ios 7.0后 扁平化风格，导航条模式是透明的（0/64） 1 透明 内容全局（0） 2 透明 内容从64开始（0，iphonex 84） 3 不透明 内容全局（0） 4 不透明 内容从64开始（0） / 透明全局（默认） - (void)translucentAndAll{ self.navigationController.navigationBar.translucent = YES; self.edgesForExtendedLayout = UIRectEdgeAll; } - (void)translucentAnd64{ self.navigationController.navigationBar.translucent = YES; self.edgesForExtendedLayout = UIRectEdgeNone; } - (void)noTranslucentAnd64{ self.navigationController.navigationBar.translucent = NO; // self.edgesForExtendedLayout = UIRectEdgeNone; } - (void)noTranslucentAndAll{ self.navigationController.navigationBar.translucent = NO; self.extendedLayoutIncludesOpaqueBars = YES; //此属性就算设置了也不起作用 // self.edgesForExtendedLayout = UIRectEdgeAll; } 2.2 导航区结构分析 UINavigationBar UINavigationItem 3、内容区分析3.1 内容结构分析 UINavigationTransitionView 内容区容器 第一 结构： 导航区 内容区 toolbar区（忽略） 第二、 三个／四个属性 理解作用 第三、 UINavigationBar（什么东西，哪些东西会刷新，哪些不会, 管理什么东西，） 第四个 了解UINavigationItem 是个什么东西, 管理什么东西 第五个 了解UIBarButtonItem UINavigationController 导航栏如何设置背景透明 - (void)transluentStyle { [self.navigationController.navigationBar setBackgroundImage:self.image forBarMetrics:UIBarMetricsDefault]; } - (UIImage*)image{ UIGraphicsBeginImageContext(CGSizeMake(100, 100)); [[[UIColor whiteColor] colorWithAlphaComponent:0] setFill]; UIRectFill(CGRectMake(0, 0, 100, 100)); UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image; } - (void)transluentTwoStyle{ NSArray *ary = [self.navigationController.navigationBar subviews]; UIColor *alphaColor = [[UIColor whiteColor] colorWithAlphaComponent:0]; for (int i = 0; i &lt; ary.count; i++) { UIView *view = ary[i]; view.backgroundColor = alphaColor; for (int j = 0; j &lt; view.subviews.count; j++) { UIView *subView = view.subviews[j]; subView.backgroundColor = alphaColor; for (int k = 0; k &lt; subView.subviews.count; k++) { UIView *subsubView = subView.subviews[k]; subsubView.backgroundColor = alphaColor; } } if([view isKindOfClass:NSClassFromString(@&quot;_UIBarBackground&quot;)]) { view.backgroundColor = alphaColor; } } } 导航栏底部黑色线条处理 - (void)viewDidLoad { UIImageView *iamgeV = [self findBackLineImageV:self.navigationController.navigationBar]; iamgeV.hidden = YES; //[self blackNavLine]; } - (UIImageView *)findBackLineImageV:(UIView*)view{ if([view isKindOfClass:[UIImageView class]] &amp;&amp; view.frame.size.height &lt;= 1){ return (UIImageView*)view; } NSArray *viewAry = view.subviews; for (int i = 0; i &lt; viewAry.count; i++) { UIView *tmpV = [self findBackLineImageV:viewAry[i]]; if (tmpV) { return (UIImageView*)tmpV; } } return nil; } - (void)blackNavLine{ self.navigationController.navigationBar.clipsToBounds = YES; } 导航栏按钮间距处理 NSMutableArray *barItems = [NSMutableArray array]; UIBarButtonItem *barItem = [[UIBarButtonItem alloc] initWithTitle:@&quot;Nav&quot; style:UIBarButtonItemStylePlain target:self action:@selector(showNav)]; UIBarButtonItem *barItemSpace = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFixedSpace target:nil action:nil]; barItemSpace.width = 60; UIBarButtonItem *barItemT = [[UIBarButtonItem alloc] initWithTitle:@&quot;view&quot; style:UIBarButtonItemStylePlain target:self action:@selector(showNavTwo)]; [barItems addObject:barItem]; [barItems addObject:barItemSpace]; [barItems addObject:barItemT]; self.navigationItem.rightBarButtonItems = barItems; 导航栏返回按钮处理 - (void)backArrowImage{ UIImage *image = [UIImage imageNamed:@&quot;arrow.png&quot;]; image = [image imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]; self.navigationController.navigationBar.backIndicatorImage = image;self.navigationController.navigationBar.backIndicatorTransitionMaskImage = image; } NavigationController的动画原理和深度用法转场动画原理解析 - (void)viewDidLoad { [super viewDidLoad]; self.title = @&quot;动画原理&quot;; UIPanGestureRecognizer *panGesture = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(panGesture:)]; [self.view addGestureRecognizer:panGesture]; } /* 1 当前的控制器view坐标的移动 2 下一个控制器view的坐标移动 */ - (void)panGesture:(UIPanGestureRecognizer*)gesture{ // 获取 当前view（fromview） pop的view（toView） UIView *containView = [self.view superview]; UIView *fromView = self.view; UIView *toView = nil; NSArray *viewCtrAry = self.navigationController.viewControllers; if (viewCtrAry.count &gt;= 2) { UIViewController *toViewCtr = viewCtrAry[viewCtrAry.count-2]; toView = toViewCtr.view; } [containView insertSubview:toView belowSubview:fromView]; CGPoint movePoint = [gesture translationInView:self.view]; [gesture setTranslation:CGPointZero inView:self.view]; float moveWidth = movePoint.x; // UINavigationBar *preBar; if (gesture.state == UIGestureRecognizerStateBegan) { toView.frame = CGRectMake(-toView.frame.size.width, toView.frame.origin.y, toView.frame.size.width, toView.frame.size.height); }else if (gesture.state == UIGestureRecognizerStateChanged){ // moveWidth *scale toView.frame = CGRectMake(toView.frame.origin.x + moveWidth, toView.frame.origin.y, toView.frame.size.width, toView.frame.size.height); fromView.frame = CGRectMake(fromView.frame.origin.x + moveWidth, fromView.frame.origin.y, fromView.frame.size.width, fromView.frame.size.height); }else { if (fromView.frame.origin.x &gt; [UIScreen mainScreen].bounds.size.width/2) { // pop [UIView animateWithDuration:0.4 animations:^{ toView.frame = CGRectMake(0, toView.frame.origin.y, toView.frame.size.width, toView.frame.size.height); fromView.frame = CGRectMake(fromView.frame.size.width, fromView.frame.origin.y, fromView.frame.size.width, fromView.frame.size.height); } completion:^(BOOL finished) { NSMutableArray *viewAry = [NSMutableArray arrayWithArray:self.navigationController.viewControllers]; [viewAry removeLastObject]; self.navigationController.viewControllers = viewAry; }]; }else { // 还原 [UIView animateWithDuration:0.4 animations:^{ fromView.frame = CGRectMake(0, fromView.frame.origin.y, fromView.frame.size.width, fromView.frame.size.height); toView.frame = CGRectMake(-toView.frame.size.width, toView.frame.origin.y, toView.frame.size.width, toView.frame.size.height); } completion:^(BOOL finished) { }]; } } } 替换系统手势 - (void)viewDidLoad { [super viewDidLoad]; self.title = @&quot;替换系统手势&quot;; //UIPanGestureRecognizer; NSArray *targets = [self.navigationController.interactivePopGestureRecognizer valueForKey:@&quot;targets&quot;]; id target = [[targets lastObject] valueForKey:@&quot;target&quot;]; SEL actionSel = NSSelectorFromString(@&quot;handleNavigationTransition:&quot;); UIPanGestureRecognizer *panGesture = [[UIPanGestureRecognizer alloc] initWithTarget:target action:actionSel]; [self.view addGestureRecognizer:panGesture]; [self scanMethods:NSClassFromString(@&quot;UIScreenEdgePanGestureRecognizer&quot;)]; } - (void)scanMethods:(Class)class{ unsigned int outCount = 0; Method *methods = class_copyMethodList(class, &amp;outCount); for (int i = 0; i &lt; outCount; i++) { SEL sel = method_getName(methods[i]); NSLog(@&quot;%@&quot;, NSStringFromSelector(sel)); } } 转场高级动画 @interface EOCNavViewCtr : UINavigationController @end @interface EOCNavViewCtr ()&lt;UINavigationControllerDelegate&gt;{ UIPercentDrivenInteractiveTransition *percentAnimation; } @end @implementation EOCNavViewCtr - (void)viewDidLoad { [super viewDidLoad]; //设置UINavigationControllerDelegate代理的方法，获取Nav动画进度和动画对象 self.delegate = self; UIPanGestureRecognizer *panGesture = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(panGesture:)]; [self.view addGestureRecognizer:panGesture]; } - (void)panGesture:(UIPanGestureRecognizer*)gesture{ // 获取 当前view（fromview） pop的view（toView） CGPoint movePoint = [gesture translationInView:self.view]; float precent = movePoint.x/[UIScreen mainScreen].bounds.size.width; if (gesture.state == UIGestureRecognizerStateBegan) { percentAnimation = [[UIPercentDrivenInteractiveTransition alloc] init]; [self popViewControllerAnimated:YES]; }else if (gesture.state == UIGestureRecognizerStateChanged){ [percentAnimation updateInteractiveTransition:precent]; }else { if (percentAnimation.percentComplete &gt; 0.5) { [percentAnimation finishInteractiveTransition]; }else { [percentAnimation cancelInteractiveTransition]; } percentAnimation = nil; } } // 返回动画进度对象 - (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)navigationController:(UINavigationController *)navigationController interactionControllerForAnimationController:(id &lt;UIViewControllerAnimatedTransitioning&gt;) animationController { if ([animationController isKindOfClass:[EOCNavAnimation class]]) { return percentAnimation; } return nil; } // 返回动画对象，所有对象均在EOCNavAnimation中操作 - (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController animationControllerForOperation:(UINavigationControllerOperation)operation fromViewController:(UIViewController *)fromVC toViewController:(UIViewController *)toVC { if (operation == UINavigationControllerOperationPop) { return [[EOCNavAnimation alloc] init]; } return nil; } @interface EOCNavAnimation : NSObject&lt;UIViewControllerAnimatedTransitioning, CAAnimationDelegate&gt; @end @implementation EOCNavAnimation{ id &lt;UIViewControllerContextTransitioning&gt; _transitionContext; } // 时间 - (NSTimeInterval)transitionDuration:(nullable id &lt;UIViewControllerContextTransitioning&gt;)transitionContext{ return 1.0; } // 过程 - (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext{ // 获取 toView（ToViewCtr）／fromView（fromViewCtr） _transitionContext = transitionContext; UIViewController *toViewCtr = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey]; UIViewController *fromViewCtr = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey]; UIView *transferView = transitionContext.containerView; [transferView insertSubview:toViewCtr.view belowSubview:fromViewCtr.view]; [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^{ fromView.frame = CGRectMake(fromView.frame.size.width, fromView.frame.origin.y, fromView.frame.size.width, fromView.frame.size.height); } completion:^(BOOL finished) { // 务必 compelte Context [transitionContext completeTransition:YES]; }]; //[self animationTwo:transferView]; } - (void)animationTwo:(UIView*)transferView{ CATransition *caTrans = [CATransition animation]; caTrans.type = @&quot;cube&quot;; caTrans.subtype = @&quot;fromLeft&quot;; caTrans.duration = [self transitionDuration:_transitionContext]; caTrans.fillMode = kCAFillModeForwards; caTrans.delegate = self; caTrans.removedOnCompletion = NO; [transferView.layer addAnimation:caTrans forKey:nil]; [transferView exchangeSubviewAtIndex:0 withSubviewAtIndex:1]; } // context结束 - (void)animationEnded:(BOOL) transitionCompleted{ } // 动画结束 - (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag{ [_transitionContext completeTransition:YES]; } 多控制器使用和常见问题(MVVM搭建及路由层)1 多控制搭建 tabbar-navbar-vcnavbar-tabbar-vc 2 不同根试图注意事项 tabbar-nabar-vc正确的设置 self.navigationItem.title来操作（因为self.title操作会影响tabbar的item） tabbar（记得隐藏，因为爷控制器是tabbarViewCtr（儿的所有控制器默认都能看到tabbar）） navbar-tabbar-vc 正确的设置 self.tabBarController.title来操作（如果self.title操作会影响tabbar的item，但对nabbar没有效果，因为导航条属于爷控制器） navbar（记得刷新，共享了一个navbar） 3 启动页延时操作 - (void)delayLaunchImage{ eocWindow = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds]; self.window.backgroundColor = [UIColor whiteColor]; eocWindow.rootViewController = [UIViewController new]; UIImageView *imageView = [[UIImageView alloc] initWithFrame:[UIScreen mainScreen].bounds]; [imageView setImage:[UIImage imageNamed:@&quot;11.PNG&quot;]]; [eocWindow addSubview:imageView]; [eocWindow makeKeyAndVisible]; [self performSelector:@selector(cancelLaunImage) withObject:nil afterDelay:5]; } - (void)cancelLaunImage{ [eocWindow resignKeyWindow]; eocWindow = nil; } 4 MVVM V(视图)(点击刷新)-&gt;C(业务逻辑)(处理事情)-&gt;M(数据)(下载数据)-&gt;V(视图)(刷新数据) V(视图)ViewModelM(数据):一个view对应一个viewModel，是双向绑定，view的变动，自动反映到ViewModel上，ViewModel的变动，也自动反映到View上 @interface RecommendVCtr () @property (nonatomic, strong)RecommendViewModel *recomendViewModel; @end - (void)viewDidLoad { [super viewDidLoad]; self.automaticallyAdjustsScrollViewInsets = NO; [_headView removeFromSuperview]; [_tableView setTableHeaderView:_headView]; UITableView *tmpTableV = _tableView; // 下载数据业务 [self.recomendViewModel loadDatafromNetWithPage:1 finishNet:^(id infoDict) { [tmpTableV reloadData]; }]; } - (RecommendViewModel*)recomendViewModel{ if (!_recomendViewModel) { _recomendViewModel = [RecommendViewModel new]; } return _recomendViewModel; } typedef void(^finishLoadBlock)(id infoDict); @interface RecommendViewModel : NSObject @property(nonatomic, assign) NSInteger rowNumber; - (CGFloat)messageHeightForRow:(NSInteger)row; - (MessageModel*)messageModelForRow:(NSInteger)row; - (NSString*)messageIdForRow:(NSInteger)row; - (void)loadDatafromNetWithPage:(NSInteger)page finishNet:(finishLoadBlock)finishBlock; - (void)deleteAdView:(UIView*)deleteView headView:(UIView*)headView tableview:(UITableView*)tableView; - (void)pushMessageDetailIndex:(NSIndexPath *)indexPath viewCtr:(UIViewController*)targetVCtr; @end @implementation RecommendViewModel @end 5 路由层 - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event{ MenuR *mr = [MenuR new]; [mr perferm:[NSClassFromString(@&quot;MainRoute&quot;) new] sel:@selector(skipToMenu:) arg:[NSNumber numberWithInt:2]]; // [MainRoute skipToMenu:2]; // RecommendVCtr *recommendVCtr = [RecommendVCtr new]; // [self.navigationController pushViewController:recommendVCtr animated:YES]; } @interface MenuR : NSObject - (void)perferm:(id)target sel:(SEL)sel arg:(id)arg; - (void)perferm:(id)target sel:(SEL)sel; @end @implementation MenuR - (void)perferm:(id)target sel:(SEL)sel arg:(id)arg{ [target performSelector:sel withObject:arg]; } - (void)perferm:(id)target sel:(SEL)sel{ [self perferm:target sel:sel arg:nil]; } @end @interface MainRoute : NSObject - (void)skipToMenu:(NSNumber*)index; @end @implementation MainRoute - (void)skipToMenu:(NSNumber*)index{ UINavigationController *target = (UINavigationController*)[UIApplication sharedApplication].keyWindow.rootViewController; target = [target.viewControllers firstObject]; SEL sel = NSSelectorFromString(@&quot;skipToMenuIndex:&quot;); if ([target respondsToSelector:sel]) { [target performSelector:sel withObject:index]; }else{ NSLog(@&quot;异常 target 找不到 skipToMenuIndex：&quot;); } } @end //UITabbarViewContoller - (void)skipToMenuIndex:(NSNumber*)indexN{ NSInteger index = [indexN integerValue]; [self.navigationController popToRootViewControllerAnimated:YES]; //self.selectedIndex = index; [self selectMenuVC:[_eocTabBar viewWithTag:index]]; } - (void)selectMenuVC:(TabBarButtton*)sender{ if (self.selectedIndex == sender.tag) { return; } self.selectedIndex = sender.tag; _selectTabBarBt.selected = NO; _selectTabBarBt = sender; _selectTabBarBt.selected = YES; } 6 业务布局分析 MVCC框架介绍 self.view.addSubview:self.viewController.addSubViewController:]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>iOS</tag>
        <tag>UInavigationContoller</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SearchController原理及应用案例]]></title>
    <url>%2F2016%2F04%2F29%2FSearchController%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[UISearchController主要API // 初始化方法, 参数是展示搜索结果的控制器, 如果是在当前控制器展示搜索结果, 就传nil - (instancetype)initWithSearchResultsController:(nullable UIViewController *)searchResultsController; // 负责更新搜索结果的代理, 需要遵循 UISearchResultsUpdating 协议 @property (nullable, nonatomic, weak) id &lt;UISearchResultsUpdating&gt; searchResultsUpdater; // 搜索控制器是否是活跃状态, 当在一个控制器展示搜索结果的时候, 可以此来判断返回的数据源 @property (nonatomic, assign, getter = isActive) BOOL active; // 控制器代理 遵循 UISearchControllerDelegate协议 @property (nullable, nonatomic, weak) id &lt;UISearchControllerDelegate&gt; delegate; // 当搜索框激活时, 是否添加一个透明视图 @property (nonatomic, assign) BOOL dimsBackgroundDuringPresentation __TVOS_PROHIBITED; @property (nonatomic, assign) BOOL obscuresBackgroundDuringPresentation NS_AVAILABLE_IOS(9_1); // default is YES // 当搜索框激活时, 是否隐藏导航条 @property (nonatomic, assign) BOOL hidesNavigationBarDuringPresentation; // default is YES @property (nullable, nonatomic, strong, readonly) UIViewController *searchResultsController; @property (nonatomic, strong, readonly) UISearchBar *searchBar; 简单用法 @interface EOCSearchControllerDemo ()&lt;UITableViewDelegate, UITableViewDataSource, UISearchResultsUpdating, UISearchControllerDelegate&gt; { NSArray *dataArr; NSArray *filterArr; } @property(nonatomic, strong)UITableView *tableView; @property(nonatomic, strong)UIScrollView *scrollView; @property(nonatomic, strong)UISearchController *searchCtrl; @end @implementation EOCSearchControllerDemo /** 1、ios11之前的SearchController 1.1 标准情况，searchBar是在tableView 1.2 当我的resultViewController是nil（也就是自己的时候）激活searchCOntroller的时候，searchBar、dimView(暗色的背景) 1.3 当我的resultViewController是另外一个resultViewController，激活searchCOntroller的时候，searchBar、dimView(暗色的背景)、resultViewController.view 1.4 searchController它激活的时候（active）的时候，如果你有resultViewController，我会把它的view添加进来；searchBar会从之前添加的view里面 拿出来重新定义frame 1.5 UISearchController你最好是在默认的情况下：autoAdjustcontentInset=yes，scrllView里来使用（tableView、collectionview） 1.6 UISearchBar的定制：textField的改变（形状、字体）；取消的文字、背景颜色 2、ios11的searchController 2.1 会放在NaviationItem.searchController 2.2 searchCOntroller.searchBar 它的位置有改变：UINavigationBar里 3、UISearchController 自定义了一个SearchBar */ - (void)viewDidLoad { [super viewDidLoad]; self.view.backgroundColor = [UIColor whiteColor]; self.definesPresentationContext = YES; //present //设置数据源 dataArr = [[EOCDataModel sharedDataModel] dataArr]; filterArr = dataArr; [self.view addSubview:self.tableView]; self.tableView.tableHeaderView = self.searchCtrl.searchBar; // if (@available(iOS 11, *)) { // self.navigationItem.searchController = self.searchCtrl; // self.navigationItem.hidesSearchBarWhenScrolling = NO; // } else { // self.tableView.tableHeaderView = self.searchCtrl.searchBar; // } // // [self customSearchbar]; } #pragma mark UISearchController searchUpdating delegate method - (void)updateSearchResultsForSearchController:(UISearchController *)searchController { NSPredicate *predicate = [NSPredicate predicateWithFormat:@&quot;(SELF CONTAINS %@)&quot;, searchController.searchBar.text]; //查询到的结果如果是在当前控制器中展示，则直接赋值并reload，如果是在别的控制器的展示，则传递值到别的控制器中 EOCSearchResultViewCtrl *resultViewCtroller = (EOCSearchResultViewCtrl *)searchController.searchResultsController; filterArr = [dataArr filteredArrayUsingPredicate:predicate]; filterArr = searchController.searchBar.text.length&gt;0?filterArr:dataArr; resultViewCtroller.filterDataArr = filterArr; [self.tableView reloadData]; } - (void)willPresentSearchController:(UISearchController *)searchController { } - (void)didPresentSearchController:(UISearchController *)searchController { } #pragma mark - delegate &amp;&amp; datasource method - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section { return filterArr.count; } - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { UITableViewCell *cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@&quot;cell&quot;]; cell.textLabel.text = filterArr[indexPath.row]; return cell; } - (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath { } - (UITableView *)tableView { if (!_tableView) { CGFloat yCoordinate = 0.f; _tableView = [[UITableView alloc] initWithFrame:CGRectMake(0.f, yCoordinate, self.view.eoc_width, self.view.eoc_height-yCoordinate) style:UITableViewStylePlain]; _tableView.delegate = self; _tableView.dataSource = self; [_tableView setTableFooterView:[[UIView alloc] init]]; } return _tableView; } - (UISearchController *)searchCtrl { if (!_searchCtrl) { EOCSearchResultViewCtrl *resultSearchCtrl = [[EOCSearchResultViewCtrl alloc] init]; //如果查询的结果是在当前控制器展示搜索结果, 就传nil，如果需要新的控制器来展示结果，就传定义好的viewController _searchCtrl = [[UISearchController alloc] initWithSearchResultsController:resultSearchCtrl]; _searchCtrl.dimsBackgroundDuringPresentation = YES; _searchCtrl.hidesNavigationBarDuringPresentation = YES; _searchCtrl.searchBar.placeholder = @&quot;八点钟学院&quot;; _searchCtrl.searchResultsUpdater = self; _searchCtrl.delegate = self; // _searchCtrl.searchBar.delegate // _seachCtrl.delegate } return _searchCtrl; } iOS11以后，self.searchCtrl.searchBar不能放在tableView的header了，会出现界面错乱问题，而要将self.searchCtrl赋值给self.navigationItem.searchController if (@available(iOS 11, *)) { self.navigationItem.searchController = self.searchCtrl; } else { self.tableView.tableHeaderView = self.searchCtrl.searchBar; } 如果需要定制UISearchbar的外刚样式： - (void)customSearchbar { //修改取消按钮的文字，从cancel变成取消 NSLog(@&quot;subViews %@&quot;, self.searchCtrl.searchBar.subviews.firstObject.subviews); ///kvc 私有属性 来修改取消按钮的标题 [[UIBarButtonItem appearanceWhenContainedInInstancesOfClasses:@[[UISearchBar class]]] setTitle:@&quot;取消&quot;]; //searchBar的取消文字颜色 self.searchCtrl.searchBar.tintColor = [UIColor redColor]; //修改取消文字颜色以及光标的颜色 //searchbar它的背景颜色白色 self.searchCtrl.searchBar.barTintColor = [UIColor whiteColor]; //textField 半圆形 UITextField *textField = (UITextField *)[self.searchCtrl.searchBar valueForKey:@&quot;_searchField&quot;]; textField.backgroundColor = [UIColor whiteColor]; textField.layer.borderColor = [UIColor redColor].CGColor; textField.layer.borderWidth = 2.f; textField.layer.cornerRadius = 14.f; textField.placeholder = @&quot;大家好&quot;; textField.tintColor = [UIColor blueColor]; textField.clipsToBounds = YES; //iOS11的背景颜色不一样 if (@available(iOS 11, *)) { for (UIView *view in textField.subviews) { if ([view isKindOfClass:NSClassFromString(@&quot;_UISearchBarSearchFieldBackgroundView&quot;)]) { [view removeFromSuperview]; } } } //取消上下两条线 for (UIView *view in self.searchCtrl.searchBar.subviews.firstObject.subviews) { if ([view isKindOfClass:NSClassFromString(@&quot;UISearchBarBackground&quot;)]) { [view removeFromSuperview]; } } } 如果需要了解系统view中的一些内部变量，可下载header文件夹进行查找 京东搜索框对比textview的addtarget foreditchanged和shouldChangeCharacterInRange的区别 自定义SearchController @class EOCSearchController; @protocol EOCSearchControllerDelegate - (void)didPresentSearchController:(EOCSearchController *)searchController; - (void)didDismissSearchController:(EOCSearchController *)searchController; @end @protocol EOCSearchResultsUpdating - (void)updateSearchResultsForSearchController:(EOCSearchController *)searchController; @end @interface EOCSearchController : UIViewController @property(nonatomic, strong)EOCSearchBar *searchBar; @property(nonatomic, weak)id &lt;EOCSearchResultsUpdating&gt; searchResultsUpdater; @property(nonatomic, weak)id &lt;EOCSearchControllerDelegate&gt; delegate; @property(nonatomic, strong)UIViewController *searchResultsController; - (instancetype)initWithSearchResultsController:(nullable UIViewController *)searchResultsController; @end @implementation EOCSearchController - (instancetype)initWithSearchResultsController:(nullable UIViewController *)searchResultsController { self = [super init]; if (searchResultsController) { //赋值searchResultsController self.searchResultsController = searchResultsController; CGFloat yCoordinate = 64.f; if (EOC_iPhoneX) { yCoordinate = 88.f; } self.view.frame = CGRectMake(0.f, yCoordinate, self.view.eoc_width, self.view.eoc_height- yCoordinate); //将结果页面添加进来 [self addChildViewController:_searchResultsController]; self.searchResultsController.view.frame = self.view.bounds; [self.view addSubview:searchResultsController.view]; } return self; } #pragma mark - event method - (void)textChange { //需要让自己添加到父的viewController里,我当前有一个文字的时候 if (_delegate &amp;&amp; self.searchBar.text.length == 1) { [_delegate didPresentSearchController:self]; } //dismiss的时候，没有文字的时候 if (_delegate &amp;&amp; self.searchBar.text.length == 0) { [_delegate didDismissSearchController:self]; } if (_searchResultsUpdater) { [_searchResultsUpdater updateSearchResultsForSearchController:self]; } } #pragma mark - searchBar - (EOCSearchBar *)searchBar { if (!_searchBar) { _searchBar = [[EOCSearchBar alloc] init]; [_searchBar addTarget:self action:@selector(textChange) forControlEvents:UIControlEventEditingChanged]; _searchBar.delegate = self; } return _searchBar; } @end 在此ViewController中使用自己封装的SearchController @interface EOCClassMainSearchCtrl ()&lt;CAAnimationDelegate, EOCSearchResultsUpdating, EOCSearchControllerDelegate&gt; { EOCButton *_scanBtn; EOCButton *_messageBtn; } @property(nonatomic, strong)EOCSearchTable *searchHistoryTable; @property(nonatomic, strong)EOCSearchController *searchController; @end @implementation EOCClassMainSearchCtrl - (void)viewDidLoad { [super viewDidLoad]; self.view.backgroundColor = [UIColor whiteColor]; [self createNavigationView]; [self.view addSubview:self.searchHistoryTable]; //searchBar 获取焦点 [self.searchController.searchBar becomeFirstResponder]; } //动画的实现 - (void)viewDidAppear:(BOOL)animated { //左边的动画 [UIView animateWithDuration:0.2f animations:^{ self.searchController.searchBar.frame = ({ CGRect frame = self.searchController.searchBar.frame; frame.origin.x -= 40.f; frame.size.width += 40.f; frame; }); _scanBtn.alpha = 0.f; }]; //右边的动画 CABasicAnimation *anim = [CABasicAnimation animationWithKeyPath:@&quot;transform.scale&quot;]; anim.duration = 0.2f; anim.fromValue = @1; anim.toValue = @0; anim.fillMode = kCAFillModeForwards; //动画截止的时候，依然保持动画最后的效果 anim.removedOnCompletion = NO; anim.delegate = self; [_messageBtn.layer addAnimation:anim forKey:nil]; [_messageBtn.layer performSelector:@selector(removeAllAnimations) withObject:nil afterDelay:1]; } #pragma mark - CAAnimation delegate - (void)animationDidStop:(CABasicAnimation *)anim finished:(BOOL)flag { //anim（深拷贝,内容复制，地址不一样） 它跟 上面的anim 不是一个anim if ([anim.keyPath isEqualToString:@&quot;transform.scale&quot;]) { //改变button _messageBtn.noImage = YES; [_messageBtn setTitle:@&quot;取消&quot; forState:UIControlStateNormal]; //继续另外一个动画 CABasicAnimation *anim1 = [CABasicAnimation animationWithKeyPath:@&quot;transform.scale&quot;]; anim1.duration = 0.2f; anim1.fromValue = @0; anim1.toValue = @1; anim1.fillMode = kCAFillModeForwards; anim1.removedOnCompletion = NO; [_messageBtn.layer addAnimation:anim1 forKey:nil]; } } #pragma mark - EOCSearchResultsUpdating 以及 EOCSearchControllerDelegate 的实现 - (void)updateSearchResultsForSearchController:(EOCSearchController *)searchController{ NSString *searchText = searchController.searchBar.text; NSPredicate *predicate = [NSPredicate predicateWithFormat:@&quot;(SELF CONTAINS %@)&quot;, searchText]; EOCSearchResultViewCtrl *resultViewCtrl = (EOCSearchResultViewCtrl *)searchController.searchResultsController; NSArray *dataArr = [EOCDataModel sharedDataModel].dataArr; resultViewCtrl.filterDataArr = [dataArr filteredArrayUsingPredicate:predicate]; } - (void)didPresentSearchController:(EOCSearchController *)searchController { [self addChildViewController:self.searchController]; [self.view addSubview:self.searchController.view]; } - (void)didDismissSearchController:(EOCSearchController *)searchController { [self.searchController.view removeFromSuperview]; [self.searchController removeFromParentViewController]; } #pragma mark - event response - (void)scanAction { } - (void)messageAction { [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;searchBarRemove&quot; object:nil]; [self removeFromParentViewController]; [self.view removeFromSuperview]; } #pragma mark - create navView - (void)createNavigationView { CGFloat yCoordinate = 20.f; if (EOC_iPhoneX) { yCoordinate = 44.f; } UIView *navView = [[UIView alloc] initWithFrame:CGRectMake(0.f, yCoordinate, self.view.eoc_width, 44.f)]; [self.view addSubview:navView]; //创建扫描按钮 _scanBtn = [EOCButton buttonWithType:UIButtonTypeCustom]; _scanBtn.frame = CGRectMake(10.f, 7.f, 30.f, 33.f); [_scanBtn setTitle:@&quot;扫一扫&quot; forState:UIControlStateNormal]; [_scanBtn setTitleColor:[UIColor grayColor] forState:UIControlStateNormal]; [_scanBtn setImage:[UIImage imageNamed:@&quot;scan_gray&quot;] forState:UIControlStateNormal]; [_scanBtn addTarget:self action:@selector(scanAction) forControlEvents:UIControlEventTouchUpInside]; [navView addSubview:_scanBtn]; //创建消息按钮 _messageBtn = [EOCButton buttonWithType:UIButtonTypeCustom]; _messageBtn.frame = CGRectMake(SCREENSIZE.width-40.f, 7.f, 30.f, 33.f); [_messageBtn setImage:[UIImage imageNamed:@&quot;message_gray&quot;] forState:UIControlStateNormal]; [_messageBtn setTitle:@&quot;消息&quot; forState:UIControlStateNormal]; [_messageBtn setTitleColor:[UIColor grayColor] forState:UIControlStateNormal]; [_messageBtn addTarget:self action:@selector(messageAction) forControlEvents:UIControlEventTouchUpInside]; [navView addSubview:_messageBtn]; //创建UISearchBar self.searchController.searchBar.frame = CGRectMake(50.f, 8.f, [[UIScreen mainScreen] bounds].size.width-103.f, 28.f); [navView addSubview:self.searchController.searchBar]; } #pragma mark - getter method - (EOCSearchController *)searchController { if (!_searchController) { //搜索结果的viewController EOCSearchResultViewCtrl *resultViewCtrl = [[EOCSearchResultViewCtrl alloc] init]; _searchController = [[EOCSearchController alloc] initWithSearchResultsController:resultViewCtrl]; _searchController.searchResultsUpdater = self; _searchController.delegate = self; } return _searchController; } - (EOCSearchTable *)searchHistoryTable { if (!_searchHistoryTable) { CGFloat yCoordinate = 64.f; if (EOC_iPhoneX) { yCoordinate = 88.f; } //创建搜索记录tableView _searchHistoryTable = [[EOCSearchTable alloc] initWithFrame:CGRectMake(0.f, yCoordinate, SCREENSIZE.width, SCREENSIZE.height-yCoordinate) style:UITableViewStyleGrouped]; if (@available(iOS 11, *)) { _searchHistoryTable.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever; } __weak typeof(_searchController)weakSearch = _searchController; _searchHistoryTable.scrollBlock = ^{ [weakSearch.searchBar resignFirstResponder]; }; //初始化历史搜索记录数组 _searchHistoryTable.searchHistoryArr = @[@&quot;历史记录&quot;, @&quot;八点钟学院&quot;, @&quot;笔记本&quot;, @&quot;iPhone7&quot;, @&quot;化妆品&quot;, @&quot;台式机&quot;]; [self.view addSubview:_searchHistoryTable]; } return _searchHistoryTable; } - (void)dealloc { NSLog(@&quot;%s&quot;, __func__); } 可以将使用UISearchController的UIViewController作为子ViewController引入主UIViewController @interface JDSearchMainCtrl () @property(nonatomic, strong)EOCNavigationView *navigationView; @end @implementation JDSearchMainCtrl - (void)viewDidLoad { [super viewDidLoad]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(notifyPorcess) name:@&quot;searchBarRemove&quot; object:nil]; self.view.backgroundColor = [UIColor whiteColor]; self.automaticallyAdjustsScrollViewInsets = NO; [self.view addSubview:self.navigationView]; } #pragma mark - 通知的实现 - (void)notifyPorcess { //左边动画 [UIView animateWithDuration:0.3f animations:^{ CGRect frame = _navigationView.searchView.frame; frame = CGRectMake(50.f, frame.origin.y, SCREENSIZE.width-103.f, 28.f); _navigationView.searchView.frame = frame; _navigationView.audioBtn.frame = ({ CGRect frame = _navigationView.audioBtn.frame; frame.origin.x = _navigationView.searchView.frame.size.width-20.f; frame; }); }]; //右边动画 CABasicAnimation *anim = [CABasicAnimation animationWithKeyPath:@&quot;transform.scale&quot;]; anim.duration = 0.2f; anim.fromValue = @0; anim.toValue = @1; [_navigationView.messageBtn.layer addAnimation:anim forKey:nil]; } #pragma mark - event response - (void)goToSearchPage { CGFloat yCoordinate = 8.f; _navigationView.searchView.frame = CGRectMake(10.f, yCoordinate, SCREENSIZE.width-63.f, 28.f); _navigationView.audioBtn.frame = ({ CGRect frame = _navigationView.audioBtn.frame; frame.origin.x = _navigationView.searchView.frame.size.width-20.f; frame; }); EOCClassMainSearchCtrl *searchCtrl = [[EOCClassMainSearchCtrl alloc] init]; [self addChildViewController:searchCtrl]; [self.view addSubview:searchCtrl.view]; } - (EOCNavigationView *)navigationView { if (!_navigationView) { CGFloat yCoordinate = 20.f; if (EOC_iPhoneX) { //判断是否是iphoneX yCoordinate = 44.f; } _navigationView = [[EOCNavigationView alloc] initWithFrame:CGRectMake(0.f, yCoordinate, self.view.eoc_width, 44.f)]; //创建navView的scanAction、audioAction、messageAction、searchAction的block __weak typeof(self)weakSelf = self; _navigationView.scanActionBlock = ^{}; _navigationView.audioActionBlock = ^{}; _navigationView.messageActionBlock = ^{}; _navigationView.searchActionBlock = ^{ [weakSelf goToSearchPage]; }; } return _navigationView; } @end 美团搜索框 beginUpdates、endUpdates的一些观点 1、现有池、重用池、model层 2、当我展开的时候，insertrow的时候，把cell从重用池放到现有池里来，就会调用cell方法，同时model层更新数据 3、当我关闭的时候，从现有池拿掉，不会调用cell方法，model层更新]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>iOS</tag>
        <tag>UISearchController</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CollectionView原理及应用案例]]></title>
    <url>%2F2016%2F03%2F25%2FCollectionView%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[日历 UICollectionViewUICollectionView的简单用法 - (void)viewDidLoad { [super viewDidLoad]; _dayAry = [NSMutableArray array]; /* 代码初始化的时候，一定要用 initWithFrame ：collectionViewLayout 这个 UICollectionViewLayout 不能直接初始化这个布局对象（必须实现他的子类） 更复杂布局需要 自己写UICollectionViewLayout的子类（如瀑布流） */ [_collectionView registerNib:[UINib nibWithNibName:@&quot;DateCell&quot; bundle:nil] forCellWithReuseIdentifier:@&quot;DateCell&quot;]; // [_collectionView registerClass:nil forCellWithReuseIdentifier:@&quot;&quot;]; [_collectionView registerNib:[UINib nibWithNibName:@&quot;DateHeadView&quot; bundle:nil] forSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@&quot;DateHeadView&quot;]; UICollectionViewFlowLayout *flowLayout = [[UICollectionViewFlowLayout alloc] init]; flowLayout.minimumInteritemSpacing = 0; flowLayout.minimumLineSpacing =0; flowLayout.itemSize = CGSizeMake(ScreenWidth/7, ScreenWidth/7); // cell的大小 flowLayout.headerReferenceSize = CGSizeMake(ScreenWidth, ScreenWidth/7); [_collectionView setCollectionViewLayout:flowLayout]; [self dataHandle:[[NSDate date] description]]; } - (void)dataHandle:(NSString*)dateStr { [_dayAry removeAllObjects]; NSInteger firstWeekDay = [EOCDateModel weekDayMonthOfFirstDayFromDate:[NSDate date]]; NSInteger dayCount = [EOCDateModel totalDaysInMonthFromDate:[NSDate date]]; // 补前面空白 for (int i = 0; i&lt; firstWeekDay; i++) { [_dayAry addObject:@&quot;&quot;]; } for (int i = 0; i&lt; dayCount; i++) { [_dayAry addObject:@(i+1)]; } // 补前面后面 int leftDay = 0; if (_dayAry.count%7) { leftDay = 7 - _dayAry.count%7; } for (int i = 0; i&lt; leftDay; i++) { [_dayAry addObject:@&quot;&quot;]; } [_collectionView reloadData]; } - (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section{ return _dayAry.count; } // The cell that is returned must be retrieved from a call to -dequeueReusableCellWithReuseIdentifier:forIndexPath: - (__kindof UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath{ DateCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;DateCell&quot; forIndexPath:indexPath]; cell.textLabel.text = [_dayAry[indexPath.row] description]; return cell; } - (UICollectionReusableView *)collectionView:(UICollectionView *)collectionView viewForSupplementaryElementOfKind:(NSString *)kind atIndexPath:(NSIndexPath *)indexPath{ if ([kind isEqualToString:UICollectionElementKindSectionHeader]) { UICollectionReusableView *headView = [collectionView dequeueReusableSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@&quot;DateHeadView&quot; forIndexPath:indexPath]; return headView; } return nil; } 自定义瀑布流 @implementation EOCCollectionLayout{ NSMutableArray *_layoutAttriAry; NSMutableArray *_originYAry; NSInteger _collectViewRowCount; } - (instancetype)init{ self = [super init]; if (self) { _layoutAttriAry = [NSMutableArray new]; _originYAry = [NSMutableArray new]; _collectViewRowCount = 3; } return self; } - (void)prepareLayout{ //准备数据 对每一个cell的布局进行初始化 [_layoutAttriAry removeAllObjects]; [_originYAry removeAllObjects]; for (int i = 0; i &lt; _collectViewRowCount; i++) { [_originYAry addObject:@(0)]; } NSInteger cellCount = [self.collectionView numberOfItemsInSection:0]; for (int i = 0; i &lt; cellCount; i++) { // 初始化每一个cell的布局属性 NSIndexPath *indexPath = [NSIndexPath indexPathForRow:i inSection:0]; UICollectionViewLayoutAttributes *atributes = [self layoutAttributesForItemAtIndexPath:indexPath]; [_layoutAttriAry addObject:atributes]; } } // 可以用自己的 - (UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath{ UICollectionViewLayoutAttributes *attributes = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath]; float cellSizeWidth = [UIScreen mainScreen].bounds.size.width/_collectViewRowCount; // 如果这个cell是一个图片内容，那么就返回图片高度 float cellSizeHeight = 50 + arc4random_uniform(100); // 通过indexPath 算出cell相应高度 float cellX = cellSizeWidth*(indexPath.row%_collectViewRowCount); float cellY = [_originYAry[indexPath.row%3] floatValue]; _originYAry[indexPath.row%_collectViewRowCount] = @(cellY + cellSizeHeight); attributes.frame = CGRectMake(cellX, cellY, cellSizeWidth, cellSizeHeight); return attributes; } // tableview 所有的高度计算，就算出了contentsize - (CGSize)collectionViewContentSize{ float maxHeight = [_originYAry[0] floatValue]; for (int i = 1; i &lt; _collectViewRowCount; i++) { if (maxHeight &lt; [_originYAry[i] floatValue]) { maxHeight = [_originYAry[i] floatValue]; } } CGSize size = CGSizeMake([UIScreen mainScreen].bounds.size.width, maxHeight); return size; } - (nullable NSArray&lt;__kindof UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect{ return _layoutAttriAry; }]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>iOS</tag>
        <tag>UICollectionView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TableView原理及应用案例]]></title>
    <url>%2F2016%2F02%2F26%2FTableView%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[TableView原理UITableView的简单用法 @implementation SecondViewCtr - (void)viewDidLoad { [super viewDidLoad]; _cellAry = [NSMutableArray new]; UITableView *_tableView = [[UITableView alloc] initWithFrame:[UIScreen mainScreen].bounds]; _tableView.delegate = self; _tableView.dataSource = self; [self.view addSubview:_tableView]; } #pragma mark - tableView delegate - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section{ NSLog(@&quot;numberOfRowsInSection:%ld&quot;, section); return 100; } - (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath{ NSLog(@&quot;heightForRowAtIndexPath:%d&quot;, (int)indexPath.row); return 200; // 高度进行一个保存 } - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{ NSLog(@&quot;cellForRowAtIndexPath:%d&quot;, (int)indexPath.row); UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;cell&quot;]; // [tableView dequeueReusableCellWithIdentifier:@&quot;cell&quot; forIndexPath:indexPath]; if (!cell) { cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@&quot;cell&quot;]; [_cellAry addObject:[NSValue valueWithNonretainedObject:cell]]; } if (indexPath.row%2) { cell.backgroundColor = [UIColor yellowColor]; }else{ cell.backgroundColor = [UIColor darkGrayColor]; } cell.textLabel.text = [@(indexPath.row) description]; return cell; } - (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath{ NSLog(@&quot;_cellAry::%ld&quot;, _cellAry.count); [tableView reloadData]; } 自定义TableView @protocol EOCTableViewDelete @required - (NSInteger)tableView:(EOCTableView *)tableView numberOfRowsInSection:(NSInteger)section; - (CGFloat)tableView:(EOCTableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath; - (EOCTableViewCell *)tableView:(EOCTableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath; @end @interface EOCTableView : UIScrollView @property (nonatomic, weak)id&lt;EOCTableViewDelete&gt;eocDelegate; - (EOCTableViewCell*)dequeueReusableCellWithIdentifier:(NSString*)identifier; - (void)reloadData; @end @implementation EOCTableView { NSMutableArray *_cellInfoAry;//存储每个cell的高度和y位置 // key是indexPath.row， vaule就是cell NSMutableDictionary *_visibleCellDict; NSMutableArray *_reusePoolCellAry; } - (instancetype)initWithFrame:(CGRect)frame { self = [super initWithFrame:frame]; if (self) { _cellInfoAry = [NSMutableArray new]; _visibleCellDict = [NSMutableDictionary new]; _reusePoolCellAry = [NSMutableArray new]; } return self; } - (void)reloadData{ [self dataHandle]; [self setNeedsLayout]; } - (void)dataHandle{ //1.1 cell的数量 不做section的处理 section = 0，就一个section NSIndexPath *indexPath = [NSIndexPath indexPathForRow:0 inSection:0]; NSInteger allCellCount = [self.eocDelegate tableView:self numberOfRowsInSection:indexPath]; //1.2 cell的位置和高度 CGFloat addupHeight = 0; for (int i = 0; i &lt; allCellCount; i++) { NSIndexPath *indexPath = [NSIndexPath indexPathForRow:0 inSection:0]; CGFloat cellHeigth = [self.eocDelegate tableView:self heightForRowAtIndexPath:indexPath]; EOCCellModel *eocCellModel = [EOCCellModel new]; eocCellModel.y = addupHeight; eocCellModel.heigth = cellHeigth; addupHeight += cellHeigth; [_cellInfoAry addObject:eocCellModel]; } [self setContentSize:CGSizeMake(self.frame.size.width, addupHeight)]; } // UI布局 - (void)layoutSubviews{ // 2.1 计算可视范围 CGFloat startY = (self.contentOffset.y &lt; 0)?0:self.contentOffset.y; CGFloat endY = ((self.contentOffset.y + self.frame.size.height) &gt; self.contentSize.height)?self.contentSize.height:(self.contentOffset.y + self.frame.size.height); // 2.2 添加相应的cell NSInteger startIndex = -1; NSInteger endIndex = 0; NSInteger index = 0; EOCCellModel *startCellM = [EOCCellModel new]; startCellM.y = startY; startIndex = [self binarySerchOC:_cellInfoAry target:startCellM]; EOCCellModel *endCellM = [EOCCellModel new]; endCellM.y = endY; endIndex = [self binarySerchOC:_cellInfoAry target:endCellM]; // 2.2.3 获取相应的cell 1种已经在界面上的， 2种没在界面的 for (NSInteger i = startIndex; i &lt;= endIndex; i++) { NSIndexPath *indexPath = [NSIndexPath indexPathForRow:i inSection:0]; EOCTableViewCell *cell = _visibleCellDict[@(indexPath.row)]; cell = [self.eocDelegate tableView:self cellForRowAtIndexPath:indexPath]; if (!cell) { cell = [self.eocDelegate tableView:self cellForRowAtIndexPath:indexPath]; [self addSubview:cell]; } [_visibleCellDict setObject:cell forKey:@(indexPath.row)]; [_reusePoolCellAry removeObject:cell]; // 这个cell可能是从重用池里面拿过来的 EOCCellModel *cellModel = _cellInfoAry[i]; cell.frame = CGRectMake(0, cellModel.y, self.frame.size.width, cellModel.heigth); } // 2.3 移除多于cell（不在可视范围里面的cell），移到重用池里 // 2.3 _visibleCellDict 这个里面的数据进行处理（不在界面上的） NSArray *visibleCellkeyAry = [_visibleCellDict allKeys]; for (NSInteger i = 0; i &lt; visibleCellkeyAry.count; i++) { NSInteger index = [visibleCellkeyAry[i] integerValue]; if (index &lt; startIndex || index &gt; endIndex) { [_reusePoolCellAry addObject:_visibleCellDict[visibleCellkeyAry[i]]]; [_visibleCellDict removeObjectForKey:visibleCellkeyAry[i]]; } } } - (NSInteger)binarySerchOC:(NSArray*)dataAry target:(EOCCellModel*)targetModel{ NSInteger min = 0; NSInteger max = dataAry.count - 1; NSInteger mid; while (min &lt; max) { mid = min + (max - min)/2; // 条件判断 EOCCellModel *midModel = dataAry[mid]; if (midModel.y &lt; targetModel.y &amp;&amp; midModel.y + midModel.heigth &gt; targetModel.y) { return mid; }else if(targetModel.y &lt; midModel.y){ max = mid;// 在左边 if (max - min == 1) { return min; } }else { min = mid;// 在右边 if (max - min == 1) { return max; } } } return -1; } // 重用池中获取cell - (EOCTableViewCell*)dequeueReusableCellWithIdentifier:(NSString*)identifier{ /* 判断是否已经在现有池里面，如果在，那么直接从现有池里面返回来 这个逻辑 需要做一个 indexPath的成员变量 EOCTableViewCell *cell = _visibleCellDict[@(indexPath.row)]; */ for(int i = 0; i &lt; _reusePoolCellAry.count; i++){ EOCTableViewCell *cell = _reusePoolCellAry[i]; if ([cell.identifier isEqualToString:identifier]) { return cell; } } return nil; }]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>iOS</tag>
        <tag>UITableView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ScrollView原理及应用案例]]></title>
    <url>%2F2016%2F01%2F29%2FScrollView%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[ScrollView原理解析UIScrollView(滚动视图)是一个在日常开发中使用频率极高的容器视图控件, 它允许用户通过滚动和缩放的方式查看超出屏幕区域大小的内容, 在应用程序开发中经常使用到的UITableView(列表视图)、UICollectionView(集合视图)和UITextView(文本视图)都是它的子类. 下面将从用户界面和事件处理两个方面对UIScrollView做一次详细的使用介绍和简要的实现原理分析. 该属性用于标识内容区域的起点相对于scrollView的起点的偏移量, 默认值为CGPointZero @property(nonatomic) CGPoint contentOffset; (void)setContentOffset:(CGPoint)contentOffset animated:(BOOL)animated; 该属性用于标识内容区域的尺寸, 默认值为CGSizeZero @property(nonatomic) CGSize contentSize; 该属性用于标识为内容区域周围增加的可滚动区域, 默认值为UIEdgeInsetsZero @property(nonatomic) UIEdgeInsets contentInset; 该属性用于标识为内容区域周围增加的总的可滚动区域, 该属性值的最终结果取决于contentInsetAdjustmentBehavior属性的值 @property(nonatomic, readonly) UIEdgeInsets adjustedContentInset API_AVAILABLE(ios(11.0)); (void)adjustedContentInsetDidChange API_AVAILABLE(ios(11.0)) NS_REQUIRES_SUPER; 该属性用于配置safeAreaInsets如何影响adjustedContentInset属性的值, 该属性可设置四个枚举值: UIScrollViewContentInsetAdjustmentAutomatic: 默认, 在UIScrollViewContentInsetAdjustmentScrollableAxes的基础上添加了向前兼容. 不论是否可以滚动, 如果scrollView所在的控制器位于导航控制器中且automaticallyAdjustsScrollViewInsets = YES, 则在上下两个方向上adjustedContentInset = contentInset + safeAreaInsets成立 UIScrollViewContentInsetAdjustmentScrollableAxes: 在可滚动方向上adjustedContentInset = contentInset + safeAreaInsets成立. 比如: contentSize.width/height &gt; frame.size.width/height或者alwaysBounceHorizontal/Vertical = YES UIScrollViewContentInsetAdjustmentNever: 在任何情况下adjustedContentInset = contentInset成立 UIScrollViewContentInsetAdjustmentAlways: 在任何情况下adjustedContentInset = contentInset + safeAreaInsets成立 @property(nonatomic) UIScrollViewContentInsetAdjustmentBehavior contentInsetAdjustmentBehavior API_AVAILABLE(ios(11.0)); iOS7版本iOS系统趋向于尽可能完全利用有限的屏幕以展示更多的用户数据，所以UINavigationBar和UITabBar默认都是半透明模糊效果，UIScrollView中的内容在它们后面也是隐约可见的。在此情况下，系统对于作为controller view的第一个subView的全屏UIScrollView，会自动处理其contentInset，使其头部和尾部的内容起始和末尾时不会被UINavigationBar和UITabBar挡住。但是如果你关闭系统这一自动功能的话：self.automaticallyAdjustsScrollViewInsets = NO;UIScrollView的内容就会从frame的（0，0）位置开始显示，这样开头就被UINavigationBar，尾部就被UITabBar挡住而只能看到模糊一片，除非用户使劲下拉上拉。这时就需要你自己去设置contentInset了。 与此同时，由于现在view的frame都是从（0，0）开始，对于非UIScrollView及其子类就会有些麻烦了，因为如果子控件frame如果不考虑UINavigationBar的高度，就会被UINavigationBar挡住，当然我们可以自己在布局的时候加上UINavigationBar的高度就行了。 其实还有一种更方便的方法就是设置其edgesForExtendedLayout属性，该属性默认为UIRectEdgeAll，意为view会充分扩展至屏幕边缘包括上下左右，而不管有没有遮挡，此时就是view的frame即为整个屏幕。但是不像UIScrollView，其它view没有contentInset一说，所以automaticallyAdjustsScrollViewInsets对其并不起作用。此时，我们修改edgesForExtendedLayout属性：self.edgesForExtendedLayout = UIRectEdgeNone;系统就会自动根据UINavigationBar和statusBar将view下移64，frame从（0，64）开始。这样，我们在布局内部控件的时候依然可以从（0，0）开始，而不必担心上部被UINavigationBar遮挡了。另一种情况就是我们不想要那种半透明模糊效果，设置UINavigationBar的translucent为NO。此时，view的frame也都会从（0，64）开始，而此时对于UIScrollView，automaticallyAdjustsScrollViewInsets就不再起作用了。 总结：UIScrollView如果要实现穿透UINavigationBar的效果，其frame就必须从（0，0）开始，然后设置合适的contentInset，如果UINavigationBar下方还有悬浮view的话，就不能依赖系统的automaticallyAdjustsScrollViewInsets了，需要自己来算contentInset。还有其他的特殊需求，就需要组合使用以上属性了。 topLayoutGuide属性表示不希望被透明的状态栏或导航栏遮挡的内容范围的最高位置。这个属性的值是它的length属性的值（topLayoutGuide.length），这个值可能由当前的ViewController或这个ViewController所属的NavigationController或TabBarController决定，有如下情况： 一个独立的ViewController，不包含于任何其他的ViewController。如果状态栏可见，topLayoutGuide表示状态栏的底部，否则表示这个ViewController的上边缘。 包含于其他ViewController的ViewController不对这个属性起决定作用，而是由容器ViewController决定这个属性的含义： 如果导航栏（Navigation Bar）可见，topLayoutGuide表示导航栏的底部。 如果状态栏可见，topLayoutGuide表示状态栏的底部。 如果都不可见，表示ViewController的上边缘。 bounds 自定义ScrollView事件 @interface EOCCustomScrollView : UIView@property(nonatomic, assign)CGSize contentSize;@property(nonatomic, strong)EOCPanGestureOne *panGesture;@end (instancetype)initWithFrame:(CGRect)frame {self = [super initWithFrame:frame];_panGesture = [[EOCPanGestureOne alloc] initWithTarget:self action:@selector(panAction:)];_panGesture.delegate = self;// _panGesture.cancelsTouchesInView = NO;[self addGestureRecognizer:_panGesture];return self;} (void)panAction:(UIPanGestureRecognizer *)gestureRecognizer {NSLog(@”bounds.x %f”, self.bounds.origin.x);CGRect tmpBounds = self.bounds;///横向的scrollView，往左/往右//UIEvent locationInview prevLocationInviewCGPoint transitionPoint = [gestureRecognizer translationInView:self];///移动距离是有最大值和最小值CGFloat minimumOffset = 0.f;CGFloat maxOffset = _contentSize.width - tmpBounds.size.width;CGFloat actualOffset = fmax(minimumOffset, fmin(maxOffset, (tmpBounds.origin.x - transitionPoint.x)));tmpBounds.origin.x = actualOffset;// if (transitionPoint.x &lt; 0 &amp;&amp; (tmpBounds.origin.x - transitionPoint.x) &lt;= (_contentSize.width - tmpBounds.size.width)) { //往左// tmpBounds.origin.x -= transitionPoint.x;// } else if (transitionPoint.x &gt; 0 &amp;&amp; (tmpBounds.origin.x - transitionPoint.x) &gt;= 0) { //往右// tmpBounds.origin.x -= transitionPoint.x;// }[gestureRecognizer setTranslation:CGPointZero inView:self];self.bounds = tmpBounds;} 查看系统ScrollView contentInset ？？？扩展：https://www.jianshu.com/p/ba88e12eddc2 京东商品详情 当设置了主scrollView有contentInset，而且主scrollView能滑动，那么首先就会触发主scrollView的滑动,然后需要你用力滑，才会触发子scrollView的滑动；（automaticallyAdjustsScrollViewInsets不设置为NO了，都是为YES；iOS11里contentInsetAdjustmentBehavior利用默认的) 主scrollView不滑动，修改它的contentSize的值 navigationItem 的titleView，我要让它能实现滑动的效果，那么，我得让scrollView成为它的titleView scrollView的两个子View的覆盖滑动，就是改变前一个view的x或者Y坐标 我要实现京东的查看商品详情的效果（往上拉的一个动画），我就是修改一个view的transform：translation（改变y坐标实现） 图片轮播图的覆盖滑动 图片轮播图，通过3个子view达到5个image内容的切换 图片轮播图的下标的动画，是根据弧度来实现（旋转的过程中，当达到M_PI／2的时候，需要切换弧度为负值，否则数字会倒立） 三个scrollView手势的冲突 封装了kvo]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>iOS</tag>
        <tag>UIScrollView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件传递及应用案例]]></title>
    <url>%2F2015%2F12%2F25%2F%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E5%8F%8A%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[事件层次分析iOS事件有哪些 UIEventTypeTouches触摸事件 UIEventTypeMotion “动作”事件(比如摇晃手机设备) UIEventTypeRemoteControl远程控制事件 UIEventTypePresses事件(和触按物理按钮有关) 响应者对象：不过在ios中不是任何对象都可以处理事件，只有继承了UIResponder的对象才能接收、处理事件，比如UIApplication、UIViewController、UIView、UIWindow。 UITouch 当用一根手指触摸屏幕时，会创建一个与手指相关联的UITouch对象。如果两根手指同时触摸屏幕，则会调用一次touchesBegan方法，创建两个UITouch对象（如果不是同时触摸，调用两次方法，每次的touches参数都只有一个UITouch对象）。 判断是否多点触摸：NSSet有多少个UITouch对象元素。 UITouch保存着跟本次手指触摸相关的信息，比如触摸的位置、时间。当手指移动时，系统会更新同一个UITouch对象，使之能够一直保存该手指的触摸位置。当手指离开屏幕时，系统会销毁相应的UITouch对象。比如，判断单击、双击或者多击：tapCount属性 UITouch常用方法： -(CGPoint)locationInView:(UIView)view;返回触摸在参数view上的位置，该位置基于view的坐标系（以view的左上角为原点(0, 0)）；如果调用时传入的view参数为nil的话，返回的是触摸点在UIWindow的位置-(CGPoint)previousLocationInView:(UIView)view;前一个触摸点的位置,参数同上 第二个参数(UIEvent)event 每产生一个事件，就会产生一个UIEvent对象，UIEvent保存事件产生的事件和类型。UIEvent还提供了相应的方法可以获得在某个view上面的UITouch触摸对象。一次完整的触摸过程中，只会产生一个事件对象，4个触摸方法都是同一个event参数. UIView无法与用户交互的情况 userInteractionEnabled= NO 如果父视图不能与用户交互, 那么所有子控件也不能与用户交互hidden= YESalpha= 0.0 ~ 0.01子视图的位置超出了父视图的有效范围, 那么子视图超出部分无法与用户交互的UIImageView的userInteractionEnabled默认是NO，因此UIImageView以及它的子控件默认是不能接收触摸事件的 事件传递和响应 a. 手指触摸屏幕b. 事件发生，被封装为IOHIDEvent对象(IOKit.framework)c. 通过mach port转发到当前APP的主线程(SpringBoard IPC进程间通信)d. 主线程Runloop的Source1触发，因此触发Source1回调(Source1接收系统封装的触摸屏幕事件)e. Source1回调内部触发Source0回调f. Source0回调内部封装IOHIDEvent为UIEvent，并调用UIApplication的sendEvent将UIEvent传送给UIWindowg. UIWindow调用内部的hitText和pointInside方法从上层到下层遍历其各个子View从而返回处理改事件的UIView hitTest：判断pointInside，是不是在view里？是的话，遍历，不是的话返回nil; (UIView )hitTest:(CGPoint)point event:(UIEvent )event {if (self.alpha &lt;= 0.01 || !self.userInteractionEnabled || self.hidden) {return nil;}if ([self pointInside:point withEvent:event]) {NSArray subViews = [[self.subviews reverseObjectEnumerator] allObjects];UIView tmpView = self;for (UIView *view in subViews) {CGPoint convertedPoint = [self convertPoint:point toView:view];tmpView = [view hitTest:convertedPoint withEvent:event];}return tmpView;} else {return nil;}} NSObject-UIResponder-UIView 响应链：initial view - view - view controller - window - application - app delegate Hit-Test的目的就是找到手指点击到的最外层的那个view。它进行类似于探测的工作，判断是否点击在某个视图上。 所有的视图按照树状层次结构组织，每个view都有自己的superView，包括vc的self.view：1.当一个view被添加到superView上的时候，它的nextResponder就会被指向它的superView；2.当vc被初始化的时候，self.view(topmost view)的nextResponder会被指向所在的controller；(概括前两者就是：如果当前这个view是控制器的self.view,那么控制器就是上一个响应者 如果当前这个view不是控制器的view,那么父控件就是上一个响应者)3.vc的nextResponder会被指向self.view的superView。4.最顶级的vc的nextResponder指向UIWindow。5.UIWindow的nextResponder指向UIApplication这就形成了响应链。并没有一个对象来专门存储这样的一条链，而是通过UIResponder的串连起来的。 触摸事件的运用 手势事件 手势识别和触摸事件是两个独立的事，不要混淆。 通过touches方法监听view触摸事件，有很明显的几个缺点：必须得自定义view、由于是在view内部的touches方法中监听触摸事件，因此默认情况下，无法让其他外界对象监听view的触摸事件、不容易区分用户的具体手势行为。 iOS3.2之后,把触摸事件做了封装, 对常用的手势进行了处理, 封装了6种常见的手势UITapGestureRecognizer(敲击)UILongPressGestureRecognizer(长按)UISwipeGestureRecognizer(轻扫)UIRotationGestureRecognizer(旋转)UIPinchGestureRecognizer(捏合，用于缩放)UIPanGestureRecognizer(拖拽) 通过pointInside以及hitTest找到了view，然后如果view或者它的superView有手势事件，都会响应 手势种类是通过Touch的四个事件决定的 ///view的手势和touch事件的关系 在默认情况下（即这3个属性都处于默认值的情况下），如果触摸window，首先由window上最先符合条件的控件(该控件记为hit-test view)接收到该touch并触发触摸事件touchesBegan。同时如果某个控件的手势识别器接收到了该touch，就会进行识别。手势识别成功之后发送触摸事件touchesCancelled给hit-testview，hit-test view不再响应touch。 手势识别和触摸事件是两个独立的事，只是可以通过这3个属性互相影响，不要混淆 tapGesture.cancelsTouchesInView = YES; /// 默认为YES,这种情况下当手势识别器识别到touch之后，会发送touchesCancelled给hit-testview以取消hit-test view对touch的响应，这个时候只有手势识别器响应touch。 当设置成NO时，手势识别器识别到touch之后不会发送touchesCancelled给hit-test，这个时候手势识别器和hit-test view均响应touch。 tapGesture.delaysTouchesBegan = YES; /// 默认是NO，这种情况下当发生一个touch时，手势识别器先捕捉到到touch，然后发给hit-testview，两者各自做出响应。如果设置为YES，手势识别器在识别的过程中（注意是识别过程），不会将touch发给hit-test view，即hit-testview不会有任何触摸事件。只有在识别失败之后才会将touch发给hit-testview，这种情况下hit-test view的响应会延迟约0.15ms。tapGesture.delaysTouchesEnded = YES; /// 默认为YES。这种情况下发生一个touch时，在手势识别成功后,发送给touchesCancelled消息给hit-testview，手势识别失败时，会延迟大概0.15ms,期间没有接收到别的touch才会发送touchesEnded。如果设置为NO，则不会延迟，即会立即发送touchesEnded以结束当前触摸。 例如： 给button同时添加UITapGestureRecognizer手势和UIControlEventTouchUpInside事件，如果cancelsTouchesInView为NO，两个都可执行，并且先执行tapAction后执行btnAction。如果cancelsTouchesInView为YES，则只会执行手势而不会执行事件(手势识别屏蔽了touch，touch生成事件，所以事件不执行) 把手势添加到btn的父view上即[self.view addGestureRecognizer:tap];cancelsTouchesInView=NO，点击按钮，会先后触发“tapAction:”和“btnAction:”方法；cancelsTouchesInView=YES，只会触发按钮方法不会触发手势。 如果不是btn而是别的控件，把手势添加到控件的父view上项目中用到的是collectionView，cancelsTouchesInView=NO，点击collectionViewCell，先后触发手势和Cell，cancelsTouchesInView=YES只会触发手势。 对于UIButton,UISlider等继承自UIControl的控件，都会先响应触摸事件，从而阻止手势事件。手势可以理解为是“特殊的层”。对于TableView，CollectionView这种弱点击事件，系统优先响应手势，如果要响应Cell点击事件就要实现代理方法 总结：1、手势和pointInside以及hitTest：必须得先找到view，然后才能触发手势2、第一步找到的view，那么view和它的superView的手势都能响应3、手势的种类怎么分辨出来：根据手势自己的touch四个方法来辨别出来4、手势和view的touch事件的关系:delayTouchBegin、cancelTouchInView button事件 a. button Target Action事件 [customBtn addTarget:self action:@selector(btnAction:withEvent:) forControlEvents:UIControlEventTouchUpInside];[customBtn sendActionsForControlEvents:UIControlEventTouchUpInside]; b. 触摸和button button按压种类(UITouchUpInside等)是通过Touch的四个事件决定的 c. button的touch事件和Target Action事件联系 对于UIControl类型的控件，一个给定的事件，UIControl会调用- (void)sendAction:(SEL)action to:(nullable id)target forEvent:(nullable UIEvent *)event来将action message转发到UIApplication对象，再由UIApplication对象调用其sendAction:to:fromSender:forEvent:方法来将消息分发到指定的target上，如果没有指定target(即nil)，则会将事件分发到响应链上第一个想处理消息的对象上。而如果UIControl子类想监控或修改这种行为的话，则可以重写sendAction: to: forEvent: // Btn.m (void)sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event {// 将事件传递到对象本身来处理[super sendAction:@selector(handleAction:) to:self forEvent:event];} (void)handleAction:(id)sender {NSLog(@”handle Action”);} // ViewController.m (void)viewDidLoad {[super viewDidLoad];self.view.backgroundColor = [UIColor whiteColor];Btn *btn = [[Btn alloc]initWithFrame:CGRectMake(30, 30, 100, 100)];btn.backgroundColor = [UIColor yellowColor];[btn addTarget:self action:@selector(btnclick:) forControlEvents:UIControlEventTouchUpInside];[self.view addSubview:btn];} (IBAction)btnclick:(id)sender {NSLog(@”click”);} Button实践运用案例，事件冲突 多手势共存和互斥 案例：写两个View，ViewOne和ViewTwo，在两个View上分别添加手势PanGestureOne和PanGestureTwo，结果发现都执行了gesture的touch方法，但只执行了panTwo操作 修改PanGestureOne类，得到实验现象： ///手势是否接受touch事件 (BOOL)gestureRecognizer:(UIGestureRecognizer )gestureRecognizer shouldReceiveTouch:(UITouch )touch {return YES;//返回YES，PanGestureOne中的touch方法会执行，否则不执行}///手势已经识别出来了，但是手势是否响应由它决定 (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer {return YES;//返回YES，如果不被panTwo排斥，可以出现panOne操作，否则不出现panOne操作}///本手势是否和other另外一个手势共存；你只要有一个手势，这个代理方法返回了YES，那么就是共存 (BOOL)gestureRecognizer:(UIGestureRecognizer )gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer )otherGestureRecognizer {return YES;//返回YES会同时执行panOne和panTwo，否则只执行panTwo} 需求如果需要panOne，而不需要panTwo，有两种方法实现，一种是通过gesture自带方法实现，另一种是在gesture的delegate方法中实现 [gestureTwo requireGestureRecognizerToFail:gestureOne]://gestureTwo的响应需要gestureOne响应失败，相当于提高了gestureOne的识别优先级，gestureOne检测失败后gestureTwo才能开始响应 需要在one中添加shouldBeRequiredToFailByGestureRecognizer或在two中添加shouldRequiredToFailByGestureRecognizer为YES///otherGestureRecognizer它要识别，需要gestureRecognizer被响应失败 (BOOL)gestureRecognizer:(UIGestureRecognizer )gestureRecognizer shouldBeRequiredToFailByGestureRecognizer:(UIGestureRecognizer )otherGestureRecognizer {return YES;//把one的优先级调至最高}///gestureRecognizer 需要otherGestureRecognizer响应失败 (BOOL)gestureRecognizer:(UIGestureRecognizer )gestureRecognizer shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer )otherGestureRecognizer {return YES;//把two的优先级调至最低} UIScrollView上的触摸案例 scrollview超出边界的部分不能动（hitTest修改返回的view） 图片超出了self.view的位置 (self.view.clipToBounds=YES) scrollView滑动和导航栏侧滑的有冲突 ///scrollview有一个手势pangesture、navigationController也有一个手势screenPanGestrure//[self.navigationController.interactivePopGestureRecognizer requireGestureRecognizerToFail:scrollView.panGestureRecognizer]; scrollView和它的父view的touch事件关系，scrollView它的子view的touch和手势响应的关系 1、scrollview会拦截往superview的touch事件，如果想让继续传，需要在touch事件中调用[self.nextResponder touchesBegan:];2、添加在scrollview里的视图，一般接收不到touch事件，因为ScrollView首会先响应手势事件，而忽视touch事件 如果需要不忽视touch事件如下操作： ///delayTouchInview默认是NO，cancelsTouchesInView为YESscrollView.panGestureRecognizer.cancelsTouchesInView = NO; 如果需要只响应touch事件而不管手势，如下操作： ///这两个值默认都是为YESscrollView.delaysContentTouches = NO;scrollView.canCancelContentTouches = YES; ///你设置为NO，就响应subView的触摸事件了，scrollView就不响应了 tableview点击和手势分析 ViewController中给View添加一个手势，再给View添加一个tableview，结果发现点击cell的时候不会调用didSelectRow方法： ///分析：1. cell的点击效果不是cell的手势触发，如果是cell的手势触发的话，会在view的手势触发之前调用，并且会影响view的手势执行；2、同理，tableView手势数组，也不是tableView的手势来的///所以：tableView的点击效果，就是根据tableView的touch来判断的，根据touch：location判断出index，再根据index调用didSelectRow手势的优先级高于触摸事件，所以应该放开触摸事件的操作gestureRecognizer.cancelTouchInView = NO; 如果需要只调用didSelectRow而不需要view响应手势，则需要对手势接收到的 (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer )gestureRecognizer {UIView view = getstureRecognizer.view.superView;if ([view isSubclassOf:[UITableViewCell class]) {return NO;}return YES;} UIScreenEdgeGesture UIScreenEdgePanGestureRecognizer *screenEdgePanGesture = [[UIScreenEdgePanGestureRecognizer alloc] initWithTarget:self action:@selector(panAction:)];screenEdgePanGesture.edges = UIRectEdgeRight;[self.showView addGestureRecognizer:screenEdgePanGesture]; UISlider的事件处理 UISlider放在UIScrollView中会出现拖动冲突的问题： ///手势和touch的冲突问题//self.scrollView.delaysContentTouches = NO;//self.scrollView.canCancelContentTouches = NO;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[控制器加载底层原理和UI初始化过程]]></title>
    <url>%2F2015%2F11%2F27%2F%E6%8E%A7%E5%88%B6%E5%99%A8%E5%8A%A0%E8%BD%BD%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%92%8CUI%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[控制器加载底层原理和UI初始化过程 层次关系(VC,V,CALayer) VC管理V，V管理CALayer，V中的子V在上层，不一定其Layer也在上层。 控制器初始化过程 控制器的View是和viewDidLoad有关的 C弱化(VC的精简) MVCS 调度中心(通讯机制 KVO) UI初始化过程 DrawRect(CALayer)分析 绘制富文本(图片和文字)，对CALayer的绘制。 系统中有一个全局栈stack专门存放CGContextRef，stack中正常是没有上下文的，drawRect会默认push一个上下文到全局的Context的栈stack里。 IB_DESIGNABLE IBInspectable IB_DESIGNABLE 可以将drawrect函数中绘制的图形显示在xib可视文件中IBInspectable 可以将属性显示在xib中让动态设置 xib和纯代码 init和initWithNibName/initWithFrame/initWithCoder/awakeFromNib ViewController的init封装了initWithNibName View的init封装了initWithFrame Xib初始化UI会调用initWithCoder和awakeFromNib方法 loadview方法 如果调用self.view 如果loadview未给出view，则会循环至奔溃 self.view懒加载 (UIView)view {if (!_view) {[self loadView];[self viewDidLoad];}} 布局需要注意的点、安全方式 因为viewDidLoad中view还未成形，故不要在viewDidLoad去布局，如设置frame，autolayer等，而要在viewWillLayoutSubviews方法中去操作。 因为initWithFrame中的view还未成形，故不要在initWithFrame中去添加视图，布局视图等操作，而要在layoutSubviews中去操作。 viewDidLoad中po self.view.superview结果是空，且view的frame是根据xib生成的，还没有做适配。 setNeedsLayout和setNeedsDisplay setNeedsLayout 主动调用layoutSubviews，此方法并不是即刻执行（同步执行），而是在下一个循环中执行，如果要马上刷新页面，则需要调用layoutIfNeed方法 setNeedsDisplay 主动调用drawRect方法，此方法并不是即刻执行（同步执行），而是在下一个循环中执行，系统并未提供一个马上刷新drawRect方法的函数 ？？？xib还是纯代码未讲完]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS App启动原理]]></title>
    <url>%2F2015%2F10%2F30%2FApp%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[开课典礼1、课程内容 a、新增Swift、ARKit等内容b、每个课程有删减c、有些内容变成录播d、课程时间的改变 2、学习效果 a、听课 5%b、读 10%c、视听 20%d、案例 30%e、讨论 50%f、练习 75%g、实际应用 90% 3、听直播 a、预习相关知识点b、上课跟节奏、思考c、课后实践、总结、写博客 不要用学习的勤奋，掩盖实践的懒惰！ iOS启动原理+清晰化布局1、APP启动入口 a、创建一个application对象b、设置application的代理(AppDelegate)c、创建一个事件循环（runloop）d、读info.plist文件（MainStoryboard） 2、runloop while(mode) { handleRunloopStatus();//runloop状态处理，是否stop cofigPort();//配置port timerOfRunloopTimeoutResume();//启动超时定时器，一般不会超时 runLoopDoObservers();//处理监听状态 runLoopDoSources0();//处理sources0 if (msg) { goto:handle_msg;//处理消息 } wait();//等待消息 if (msg) { handle_msg();//处理消息 } else { __CFRunLoopDoSource1();//处理source1 } } CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) { if (activity == kCFRunLoopEntry) { NSLog(@&quot;kCFRunLoopEntry&quot;); } else if (activity == kCFRunLoopBeforeTimers) { NSLog(@&quot;kCFRunLoopBeforeTimers&quot;); } else if (activity == kCFRunLoopBeforeSources) { NSLog(@&quot;kCFRunLoopBeforeSources&quot;); } else if (activity == kCFRunLoopBeforeWaiting) { NSLog(@&quot;kCFRunLoopBeforeWaiting&quot;); } else if (activity == kCFRunLoopAfterWaiting) { NSLog(@&quot;kCFRunLoopAfterWaiting&quot;); } else if (activity == kCFRunLoopExit) { NSLog(@&quot;kCFRunLoopExit&quot;); } }); CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopCommonModes); load方法执行在main函数之前，顺序是compile sources里的顺序 动态库在编译时加载进来，在所有操作之前 timer和GCD不能准点执行，会有一定的偏差，原因是与RunLoop的事件队列有关 RunLoop和线程一一对应，常驻线程必须要开启runloop 断点的类型分为异常断点（Exception Breakpoint）和符号断点（Symbolic Breakpoint）等。符号断点中的符号可以指方法名称或函数名称。符号断点可以中断某个函数的调用。用户还可以添加执行断点的条件。 异常断点可以使程序在每次发生异常时，都会被中断。一般用来捕获未知异常。 3、自动释放池 在程序中po [NSRunLoop currentRunLoop]可以看到RunLoop中有个注册的observer叫_wrapRunLoopWithAutoreleasePoolHandler，每隔一段时间系统会向RunLoop中发送事件，从而引发会_wrapRunLoopWithAutoreleasePoolHandler函数执行去自动释放内存中没有用到的对象。 自动释放池被维护在一个栈中，他是一个对象，他可以自动释放他维护的没有用的对象。而自动释放池对象的释放则是由RunLoop每隔一段时间去释放。 4、定时器 有时候RunLoop会很忙，从而跳过定时器的某一次执行。要看某次是否被跳过，则需要注意oneTimerHardDeadline数值，即时间容忍截止 5、清晰化布局 didFinishLaunchingWithOptionsapplicationWillEnterForegroundapplicationDidBecomeActiveapplicationWillResignActiveapplicationDidEnterBackgroundapplicationWillTerminate 可以运用类别对AppDelegate做拆分，从而达到按功能点拆分的目的 ？？？window和布局未讲完]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift实战]]></title>
    <url>%2F2015%2F09%2F25%2FSwift%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift的重点基础语法]]></title>
    <url>%2F2015%2F08%2F28%2FSwift%E9%87%8D%E7%82%B9%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Swift APP 中的入口函数main /* 编译的时候，找@UIApplicationMain 标记类，并插入main函数的模块代码，从而实现和OC类似的效果 如果有需要，也可以自己定义main函数，但main和UIApplicationMain标记不能同时存在，会编译出错 */ @UIApplicationMain class AppDelegate: UIResponder, UIApplicationDelegate { var window: UIWindow? } 变量和常亮 func 常量变量(){ // 1 let 声明常量 var声明变量 // let 常量只能为他赋值一次 // 2.1 声明一个变量，编译器会自动推断类型，前提条件：提供的信息不足。 // 2.2 需要在变量后面声明类型，用冒号分割 // 注意：不像OC，Swift中值永远不会被隐式转换为其他类型，如果你需要把一个值的转换成其他类型，只能显式转换 let testOne = 20 var testTwo:Double = 30 // 不同的类型不能作相应的加减操作 // Int(testTwo) 用testTwo当作参数，初始化生成了一个Int变量，此步骤不是强制转换 let testThree = testOne + Int(testTwo) let testFour = Double(testOne) + testTwo let stringOne: String = &quot;123456&quot; let stringTwo = &quot;9876&quot; print(testOne, testTwo, testThree, testFour, stringOne, stringTwo) } 类型转换as // ？（option 可选的 可以为空）用 ！ 来拆包 func 类型转换() { let testOne: Int = 20 // 强制转换 as let testTwo = testOne as? Double let testThree = testOne as? Array&lt;Any&gt; print(testTwo, testThree) var shoppingArr = [&quot;1234&quot;, &quot;4567&quot;] var shoppingArrTwo = shoppingArr as? Array&lt;Any&gt; shoppingArrTwo![1] = 123 print(shoppingArrTwo) } 数组和字典 func 数组和字典() { //数组 // 1. 自动推断类型 let testOneArr = [&quot;1234&quot;, &quot;4567&quot;] var testTwoArr = [&quot;11&quot;, &quot;22&quot;] var testAnyArr = [11, &quot;11&quot;] as [Any] testTwoArr.append(&quot;123&quot;) // 2. 定义时设置类型 var testThreeArr = Array&lt;String&gt;() var testFourArr = Array&lt;Int&gt;() var testFiveArr = Array&lt;Any&gt;() testThreeArr.append(&quot;12345&quot;) //testThreeArr.append(1234) testFourArr.append(1234) //testFourArr.append(&quot;123456&quot;) testFiveArr.append(123456) testFiveArr.append(&quot;98766&quot;) print(testThreeArr, testFourArr, testFiveArr) testFiveArr[0] = 2 testFiveArr[1] = &quot;345&quot; // NSMutableArray; // NSArray; // 3. 另一种定义方式 var stringArray = [String]() // Array&lt;String&gt;() if(stringArray.isEmpty){ print(&quot;空的数组stringArray&quot;) } stringArray.append(&quot;string&quot;) stringArray.append(&quot;stringTwo&quot;) // 字典 // 1. 自动推断类型 var dictOne = [ &quot;keyOne&quot;:&quot;valueOne&quot;, &quot;keyTwo&quot;:&quot;valueTwo&quot;, ] print(dictOne) // 2. 定义时设置类型 var dictThree = Dictionary&lt;String, String&gt;() dictThree[&quot;key1&quot;] = &quot;keyValue1&quot; print(dictThree) print(dictThree[&quot;key1&quot;]) // 3. 另一种定义方式 var dictTwo = [String: String]() if(dictTwo.isEmpty){ print(&quot;空的字典dictTwo&quot;) } dictTwo[&quot;keyOne&quot;] = &quot;keyValueOne&quot; print(dictTwo) } 循环 //for循环 // 1. 循环 1...5 闭区间的操作符 表示从1到5数字 进行遍历 for index in 1...5 { print(index) } // 已经不支持了 //for var index = 0; index &lt; names.count; index++ { // //} // 2. 循环开区间 for index in 1..&lt;5 { print(&quot;::&quot;, index) } // 3. 注意 indexTest在存在于循环的生命周期里 var indexTest:Int = 0 for indexTest in 1...3 { print(&quot;::&quot;, indexTest) } print(indexTest) // 4. 如果你不需要知道区间内每一项的值， 可以是使用下划线（_） 替代变量名，来忽略对值的访问 var multiCount = 1; let power = 3; for _ in 1...5 { multiCount *= power } print(multiCount) // 5. 数组遍历 for in 遍历一个数组的所有元素 let names = [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;, &quot;六六&quot;] for name in names { print(name) } // (索引, 值) for (index, name) in names.enumerated() { // print(index, name) } // 字典 // 注意 字典元素的遍历顺序和插入顺序可能不同，因为字典内容在内部是无序的， 所有遍历元素事不能保证顺序 let numberOfTag = [&quot;鸡蛋&quot;:1, &quot;白菜&quot;:6, &quot;黄瓜&quot;:3] for (key, value) in numberOfTag { print(key, value) } // 字符串中的字符也是通过for in来遍历的 for charac in &quot;hello&quot; { print(charac) } // 数组 倒序 for name in names.reversed() { print(name); } // while() do-while() repeat-while() /* do while 不支持了，使用 repeat while */ var countScan = 1 repeat { countScan = countScan + 1 print(&quot;浏览次数：&quot;, countScan) } while countScan &lt; 5 while countScan &lt; 10 { countScan = countScan + 1 print(&quot;浏览次数：&quot;, countScan) } //举例： // 求一个容器里最大的值 var largetest = 0 let eocNumbers = [ &quot;红波&quot;: [1, 5, 13, 18, 22, 40], &quot;蓝波&quot;: [2, 4, 26, 36, 22, 41], &quot;绿波&quot;: [3, 5, 45, 22, 17, 33], ] for (_, numbers) in eocNumbers { for number in numbers{ if number &gt; largetest { largetest = number } } } print(&quot;largetest:&quot;, largetest) // 获取最大值 和 位置 largetest = 0 var kindKey = &quot;&quot; var indexValue = 0 for (key, numbers) in eocNumbers { for (index, number) in numbers.enumerated() { if number &gt; largetest { largetest = number indexValue = index kindKey = key } } } let strTeest = &quot;\(largetest), \(kindKey)&quot; print(&quot;最大值:\(largetest), 位置:\(kindKey),\(indexValue)&quot;) print(strTeest) 元组 // 元组 是多个值组合而成的复合值。 元组中的值可以是任意类型，每一个元素的类型可以是不同的 let http404Error = (404, &quot;Error Net&quot;) print(http404Error) print(http404Error.0, http404Error.1) let (statusCode, statusDes) = http404Error print(statusCode, statusDes) // 忽略其中的某个值 _ let (statusCodeTwo, _) = http404Error print(statusCodeTwo) // 是可以给元组定义元素名字 let http200Status = (status: 200, desc: &quot;success&quot;) print(http200Status.status, http200Status.desc) print(http200Status.0, http200Status.1) 条件语句 // if 条件语句 /* 在if 语句中， 条件必须是一个布尔表达式，不会隐式与0做对比 这样的代码会报错 var testCondition = &quot;1&quot; if testCondition { } */ var testCondition:String? = &quot;1&quot; //if testCondition { //} let testConditionTwo = 5 if testConditionTwo &gt; 1 { print(&quot;true&quot;) } // 可以使用if 和 let 来处理值缺失情况， 如果变量的值为nil， 条件会判断为false if let condtion = testCondition { print(&quot;ture&quot;) } else { print(&quot;false&quot;) } if testCondition != nil { print(&quot;testCondition 有值&quot;) } //switch 条件语句 /* switch break 当匹配的case分支中代码执行完，就会终止swich语句， 而不会执行下一个case分支。 不需要在case分支中显示的使用break语句， 避免忘记写break而产生的错误， 从一个case 分支贯穿到下一个， 如果需要贯穿下一个 使用fallthrough 关键字 注意 每一个case 分支都必须包含一条语句。 */ let characterTest: Character = &quot;壹&quot; switch characterTest { case &quot;1&quot;, &quot;壹&quot;: // 可以包含多个模式，用逗号把他们分开 print(&quot;一&quot;) // fallthrough // case &quot;2&quot;: print(&quot;二&quot;) case &quot;3&quot;: print(&quot;三&quot;) default: print(&quot;Not&quot;) } // 2 区间匹配 let eocCount = 3000 var countType:String switch eocCount { case 0...9: countType = &quot;个&quot; case 10...99: countType = &quot;十&quot; case 100...999: countType = &quot;百&quot; case 1000...9999: countType = &quot;千&quot; default: countType = &quot;万&quot; } print(countType) // 3 元组 switch let eocPoint = (1, 1) switch eocPoint { case (0, 0): print(&quot;在原点&quot;) case (0, _): print(&quot;在Y抽上&quot;) case (_, 0): print(&quot;在X抽上&quot;) case (-2...2, -2...2): print(&quot;在我们要求范围内&quot;) default: print(&quot;不在要求范围内&quot;) } /* 4 值绑定 允许将匹配的值绑定到一个临时变量 */ let anotherPoint = (6, 1) switch anotherPoint { case (let x, 0): print(&quot;在x抽上的位置：\(x)&quot;) case (0, let y): print(&quot;在y抽上的位置：\(y)&quot;) case let(x, y): print(&quot;Point:&quot;, x, y) } // where // case可以使用 where语句来判断额外的条件 let eocAnotherPoint = (2, 2) switch eocAnotherPoint { case let(x, y) where x == y: print(&quot;位置对称轴上&quot;) case let(x, y) where x == -y: print(&quot;反对称轴上&quot;) case let(x, y): print(&quot;Point:&quot;, x, y) } 函数 // 1无返回值的函数 func firstMethod(){ print(&quot;secondMethod&quot;) } firstMethod() // 2 有参数，有返回值 func secondMethod(number: Int, number2: Int) -&gt; Int { print(number, number2) return number + number2 } // 关键字（func） + 方法名（参数）-&gt; 返回值 secondMethod(number: 1, number2: 2) // 3 多个返回值 元组的方式 func calculateMethod(numberArr: Array&lt;Int&gt;) -&gt; (max:Int, min:Int, sum:Int) { var max = Int.min var min = Int.max var sum = 0 for number in numberArr { if max &lt; number{ max = number } if min &gt; number { min = number } sum += number } return (max, min, sum) } let numbers = [1, 2, 3, 4, 5] let (max, min, sum) = calculateMethod(numberArr: numbers) print(max, min, sum) // 4 定义外部参数名 写在局部参数名之前，用空格分隔 func joinString(first str1: String, second str2: String) -&gt; String { return str1 + str2 } joinString(first: &quot;1&quot;, second: &quot;2&quot;) // 注意：如果你提供了外部参数名，那么函数在掉用时，必须使用外部参数名 // 主要是增加可读性， 如果函数参数名的意图很明显了， 那就不需要定义外部参数名 // 5 忽略参数名 使用 _ func joinStringTwo(_ str1: String, _ str2: String) -&gt; String { return str1 + str2 } joinStringTwo(&quot;1&quot;, &quot;3&quot;) // 6 给参数设置默认值 func joinStringThree(_ str1: String, _ str2: String = &quot;0000&quot;) -&gt; String { return str1 + str2 } print(joinStringThree(&quot;111&quot;)) print(joinStringThree(&quot;111&quot;, &quot;2222&quot;)) //注意 ⚠️ 将带有默认值的参数放在函数参数列表的最后 func joinStingFour(_ str1: String, _ str2: String = &quot;0000&quot;, _ str3: String = &quot;1111&quot;) -&gt; String { return str1 + str2 + str3 } print(joinStingFour(&quot;111&quot;)) print(joinStingFour(&quot;111&quot;, &quot;222&quot;)) // 7 可变参数： 不确定数量的输入参数， 通过在变量类型名后面加入...的方式来定义可变参数 func sumCount(argNumbers: Int...) -&gt; Int { var sum = 0 for number in argNumbers { sum += number } return sum } sumCount(argNumbers: 1) sumCount(argNumbers: 1, 2) sumCount(argNumbers: 1, 2, 3) // 注意⚠️ 一个函数最多能有一个可变参数， 而且他必须在参数表中的最后一个 // 8 输入输出参数(inout)： 如果想要一个函数的参数 和 外部传过来的是同一个参数，即函数内部对参数修改，就是对外部参数的进行的修改，使用 inout 关键字 func swapTwo(num1: inout Int, num2: inout Int) { let tempA = num1; num1 = num2 num2 = tempA } var numberOne = 1 var numberTwo = 2 swapTwo(num1: &amp;numberOne, num2: &amp;numberTwo) print(numberOne, numberTwo) // 注意⚠️ 输入输出参数不能有默认值 // 只能以变量作为输入输出参数 // 9 函数类型 // 每个函数都有特定的函数类型， 函数的参数类型和返回类型组成 func addTwoInt(a:Int, b: Int) -&gt; Int { return a + b } //addTwoInt 的函数类型 (Int, Int) -&gt; Int let methodVar: (Int, Int) -&gt; Int = addTwoInt print(methodVar(1, 2)) //举例 func printHelloW() { print(&quot;test&quot;) } //printHellow 函数类型 () -&gt; () // 10 在swift中，使用函数类型就像使用其他类型一样。 可以定一个变量或者常量，将函数赋值给他 // 函数嵌套 对外界是不可见的，当然，函数stepForwordTwo和函数stepBackwardTwo也可以放在函数chooseStepFunctionTwo外部 func chooseStepFunctionTwo(_ condition:Bool) -&gt; (Int) -&gt; Int { print(&quot;chooseStepFunctionTwo&quot;) var testVar = 8 // 捕获变量 // 向前走一步 func stepForwordTwo(_ input: Int) -&gt; Int{ testVar = testVar + 1 print(&quot;testVar:&quot;, testVar) return input + 1 } // 向后走一步 func stepBackwardTwo(_ input: Int) -&gt; Int { testVar = testVar - 1 print(&quot;testVar:&quot;, testVar) return input - 1 } return condition ? stepBackwardTwo: stepForwordTwo } var currentValue = 5 let moveToZero = chooseStepFunctionTwo(currentValue &gt; 0) while currentValue != 0 { currentValue = moveToZero(currentValue) print(currentValue) } print(&quot;走到起始点了&quot;) let moveToFont = chooseStepFunctionTwo(currentValue &lt; 0) while currentValue &lt; 10 { currentValue = moveToFont(currentValue) print(currentValue) } print(&quot;走到终点了&quot;) 闭包 /* 闭包: OC中的block块比较类似 方法：（参数） -&gt; 返回值 {函数体} 闭包: {(参数) -&gt; 返回值 in 函数体 } { (参数) -&gt; 返回值 in // 参数 inout，可变参数 元组 ..... (函数体) } */ func 闭包() { let names = [5, 6, 1, 9, 8] let namesSortOne = names.sorted() { (num1, num2) -&gt; Bool in return num1 &gt; num2 } let namesSortTwo = names.sorted { (num1, num2) -&gt; Bool in return num1 &lt; num2 } print(namesSortOne) print(namesSortTwo) func sortMethod(num1:Int, num2:Int) -&gt; Bool { return num1 &gt; num2 } let namesSortThree = names.sorted(by: sortMethod) print(namesSortThree) // 1.2 可以隐式的返回 // 单行表达式闭包 可以通过隐藏return关键字来隐式返回单行表达式结果 let nameSortFour = names.sorted { num1, num2 in num1 &gt; num2 } print(nameSortFour) // 1.3 参数名可以缩写 /* Swifr自动为提供了参数名称缩写功能， 可以直接通过$0， $1， $2来顺序掉用闭包的参数 in关键字也同样可以被省略，此时闭包表达式完全有闭包函数体构成 */ let nameSortFive = names.sorted() { return $0 &lt; $1 } print(nameSortFive) let nameSortSix = names.sorted{ $0 &lt; $1 } print(&quot;nameSortSix:&quot;, nameSortSix) // 总结： Swift可以推断起参数和返回值的类型， 因此String，Bool类型并不需要作为闭包表达式定义中的一部分，因为所有的类型都可以被争取推断， 返回箭头的 -&gt; 和参数也可以被省略。 // 2 尾随闭包 增强函数的可读性 _ = names.sorted() { (num1, num2) -&gt; Bool in return num1 &lt; num2 } func eocTaskMethod(styleMethod: ()-&gt;()) { print(&quot;ecoTaskMethod&quot;) styleMethod(); } //正规写法 eocTaskMethod(styleMethod:{ print(&quot;styleMethod 闭包&quot;) }) // 使用的尾随闭包 进行函数调用 eocTaskMethod() { print(&quot;styleMethod 闭包2&quot;) } // 注意： 如果函数只需要闭包表达式一个参数，当使用尾随方式的时候， 可以把()省略掉 eocTaskMethod { print(&quot;styleMethod 闭包2&quot;) } // ()-&gt;() 函数类型 无参数无返回值的函数类型 func eocTaskMethodTwo(_ styleMethodTwo: ()-&gt;()){ print(&quot;eocTaskMethodTwo&quot;) styleMethodTwo(); } func eocTaskMethedThree(){ print(&quot;eocTaskMethedThree&quot;) } //eocTaskMethodTwo(eocTaskMethedThree) // 省略参数名的，一板一眼的写法 eocTaskMethodTwo ({ print(&quot;styleMethodTwo&quot;) }) } 和OC的block同原理，闭包也会有引入环的问题，所以使用时要特别注意 枚举 func 枚举() { // OC 枚举成员会默认赋予一个默认的整数值 // Swift 不会默认赋值， North South East West 不是隐式的等于 0 1 2 3 enum CompassPoint { case North //,N case South case East case West } print(CompassPoint.North) // print(CompassPoint.N) var direction = CompassPoint.North direction = .South // 注意⚠️ direction的类型已知时， 设值的时候， 可以不再写类型名 let directionTwo: CompassPoint = .East print(direction, directionTwo) switch directionTwo { case .North: print(&quot;北&quot;) case .South: print(&quot;南&quot;) case .East: print(&quot;东&quot;) case .West: print(&quot;西&quot;) //default: } // 相关值绑定 enum Barcode { case NumberCode(Int, Int) // 系统，唯一标识 case StringCode(String) } var productBarcode = Barcode.NumberCode(12, 3232423412412) var pruductTwoBarcode = Barcode.StringCode(&quot;qweqweqfsdfefefe&quot;) // 值提取 使用swicht case switch productBarcode { case .NumberCode(let system, let identifi): print(&quot;数字条形码：系统编号：\(system) 物品标示:\(identifi)&quot;) case .StringCode(let code): print(&quot;字符串条形码,物品码:\(code)&quot;) } //简洁一点 switch pruductTwoBarcode { case let .NumberCode(system, identifi): print(&quot;数字条形码：系统编号：\(system) 物品标示:\(identifi)&quot;) case let .StringCode(code ): print(&quot;字符串条形码,物品码:\(code)&quot;) } // 原始值 rawValue（默认值） 如果是整形Int Float,Double 如果枚举成员没有值时， 他们会自动递增 ，如下 meat 等于2 // 原始值（默认值） 预先填充， 而且原始值具有相同的类型 // String 不会自动递增 enum GoodsType: Int { case veg = 1 case meat case wine } let goodsOne = GoodsType.veg let goodsTwo = GoodsType.meat print(&quot;GoodsType:&quot;, goodsOne.rawValue, goodsTwo.rawValue) enum GoodsTypeTwo: String { case veg = &quot;蔬菜&quot; case meat case wine } let goodsTypeOne = GoodsTypeTwo.veg let goodsTypeTwo = GoodsTypeTwo.meat print(&quot;GoodsTypeTwo:&quot;, goodsTypeOne.rawValue, goodsTypeTwo.rawValue)// &quot;蔬菜&quot;，meat // 通过rawValue参数来创建指定的枚举 let goodsFour = GoodsType(rawValue: 5) //返回的是一个可选类型 （） print(&quot;goodsFour:&quot;, goodsFour ?? GoodsTypeTwo.veg) // 注意⚠️ 并非所有可能的Int值都可以找到一个匹配的食物，所以 GoodsType(rawValue: )返回是一个可选的类型 } 结构体和类 func 结构体和类() { //1. 使用时注意：结构体总是通过被复制的方式在代码中传递，是属于值类型，枚举也是属于值类型 //类是引用类型 struct EOCStruct { var firstName = &quot;EOC&quot; var age = 1 } class EOCClass { var firstName = &quot;EOC&quot; var age = 2 } var eocStructOne = EOCStruct() let eocStructTwo = eocStructOne eocStructOne.age = 2 print(&quot;eocStructTwo.age::&quot;, eocStructTwo.age) let eocClassOne = EOCClass() let eocClassTwo = eocClassOne eocClassOne.age = 3 print(&quot;eocClassTwo.age::&quot;, eocClassTwo.age) enum CompassPoint: Int { case North, South, East, West } var direction = CompassPoint.West let directionTwo = direction direction = .East print(directionTwo) // 2 结构体 都有一个自动生成的成员逐一构造函数，用于初始化结构体实例中的成员属性 // 而类是没有的 let eocStructThree = EOCStruct(firstName: &quot;八点钟&quot;, age: 2) //会报错 //let eocClassThree = EOCClass(firstName: &quot;八点钟&quot;, age: 2) print(eocStructThree.firstName, eocStructThree.age) //恒等于运算符 === 表示两个类的常量或者变量引用同一个类的实例 // 不等于 !== // == 等于表示两个值类型的变量相等 let eocClassFive = EOCClass() let eocClassSix = eocClassFive if (eocClassFive === eocClassSix) { print(&quot;引用同一个类的实例&quot;) } else { print(&quot;引用不同的类的实例&quot;) } //swift所有的基础类型Int、Float、Bool、String、Array、Dictionary(值方式传递) 拷贝行为 let stringOne: String = &quot;one&quot; let stringTwo: String = &quot;one&quot; if stringOne == stringTwo { print(&quot;stringOne == stringTwo&quot;) } } 属性 func 属性() { //存储属性 //注意，延迟加载存储属性声明变量(var)，如果去掉lazy，会在初始化的时候打印init //如果是常量，常量属性在构造过程中，必须有初始值 class FileOperation { var fileName = &quot;data.text&quot; init() { print(&quot;FileOperation init&quot;) } } class FileEOCManager { lazy var fileOperation = FileOperation() var desc = &quot;FileEOCManager&quot; } let fileManager = FileEOCManager() print(fileManager.fileOperation) //计算属性 struct Point { var x = 0.0, y = 0.0 } struct Size { var width = 0.0, height = 0.0 } struct Rect { var origin = Point() var size = Size() //property方法 _变量 //Swift如果要实现 _center var center: Point { get { //center //会死循环 let centerX = origin.x + (size.width/2) let centerY = origin.y + (size.height/2) return Point(x: centerX, y: centerY) } // set(newCenter) {// //center = //会死循环// origin.x = newCenter.x - (size.width/2)// origin.y = newCenter.y - (size.height/2)// } set {//注意：如果没有定义表示新值的参数名，可以使用默认名称newValue //center = //会死循环 origin.x = newValue.x - (size.width/2) origin.y = newValue.y - (size.height/2) } } } var rectOne = Rect() rectOne.center = Point(x: 10, y: 10) // 3. 只读计算属性 //注意：get可以单独使用（只有get的叫只读计算属性） //使用了set必须使用get struct Cube { var width = 0.0, height = 0.0, depth = 0.0 var volume: Double { return width * height * depth } //外部参数名，来增强可读性 init(width w: Double, height h: Double, depth d: Double) { width = w height = h depth = d } } let cubeOne = Cube(width: 1, height: 2, depth: 3) print(cubeOne.volume) // 4. 属性观察期 willSet didSet class StepCounter { var totalSteps: Int = 0 { willSet {//在设置新的值之前调用，默认值newValue print(&quot;willSet&quot;, totalSteps, newValue) } didSet {//在新的值被设置之后立即调用 print(&quot;didSet&quot;, totalSteps, oldValue) //self.totalSteps = 3 不会死循环 if (totalSteps &gt; 1000) { totalSteps = 1000 } } } } let stepCounter = StepCounter() stepCounter.totalSteps = 1 print(&quot;totalSteps&quot;, stepCounter.totalSteps) //willSet/didSet 和 get/set 两套只能二选一 //类的属性 使用关键字 static struct GoodsStruct { static var type = &quot;GoodsStruct&quot; // 值类型的类型属性 var name = &quot;meat&quot; static func structName() { print(&quot;GoodsStruct&quot;) } //值类型的属性不能在它的实例方法中被修改，如果要修改使用mutating mutating func changeName(n: String) { name = n } } print(GoodsStruct.type) print(GoodsStruct.structName()) class GoodsClass { static var type = &quot;GoodsClass&quot;//类的类型属性 var name = &quot;meat&quot; class func className() { print(&quot;GoodsClass&quot;) } } print(GoodsClass.type) print(GoodsClass.className()) //类方法 值类型 static 类 static/class struct EOCPoint { var x = 0.0 var y = 0.0 mutating func changeNewPoint(newPoint: EOCPoint) { self = newPoint } } var testPoint = EOCPoint() let testPointTwo = EOCPoint(x: 1, y: 1) testPoint.changeNewPoint(newPoint: testPointTwo) print(&quot;point:&quot;, testPoint.x, testPoint.y) } 最后一课 //1. 下标 subscript struct TestTable { subscript(index: Int) -&gt; String { return &quot;eocTable&quot; } subscript(key: String) -&gt; String { return &quot;eocTable&quot; } } //2. 继承 override重写 防止重写 final var, final func, final class func, //final class 类 A(这样的类是不可以被继承的) class OneClass { func className() { print(&quot;OneClass&quot;) } } class OneSubClass: OneClass { override func className() { print(&quot;OneSubClass&quot;) } } //3. 构造 var oneTest = OneClass() var oneTestTwo = OneClass.init() class TwoClass { var name: String //存储类型属性不能处于一个未知状态 var type: String? init(name: String) { self.name = name } } //注意：常量属性只能在定义它的类的构造过程中修改，不能在子类中修改 //3.1 重写属性，只能重写 set get(let 不能声明计算属性) class TwoSubClass: TwoClass { var classname: String override init(name: String) { classname = &quot;TwoSubClass&quot; super.init(name: name) } //便利构造器convenience调用同类的构造器 convenience init(classname: String) { self.init(name: &quot;eoc&quot;) self.classname = classname } } //便利构造器必须横向代理，指定构造器向上代理 //当制定了一个构造器，默认构造器无法访问了(结构体) var twoTest = TwoClass(name: &quot;1111&quot;) //TwoSubClass(classname: &quot;12333&quot;) //可失败构造器 注意：不要在表明可失败构造器成功的情况下，使用关键字return class ThreeClass { var name: String = &quot;eoc&quot; init() { } init?(name: String) { if name.isEmpty { return nil } self.name = name } } class ThreeSubClass: ThreeClass { override init(name: String) {//覆盖一个可失败构造器 super.init() if name.isEmpty { self.name = &quot;&quot; } else { self.name = name; } } } //4. 析构 class FourClass { var name = &quot;1&quot; required init() {//子类都必须的实现该构造器 //如果子类继承的构造器能够满足必要构造器要求，无需显式的在子类中提供必要构造器的实现 } } class FourSubClass: FourClass { var type: String required init() { type = &quot;&quot; super.init() } init(type: String) { self.type = type } deinit {//析构函数 print(&quot;deinit&quot;) } } //5. 扩展 //不能添加存储属性，可以添加计算属性和静态计算属性 //可以添加新的便利构造器，不能添加新的指定构造器或者析构函数 //不能覆盖方法 extension FourClass { convenience init(testOne: Int) { self.init() print(&quot;FourClass extension convenience init&quot;) } } extension Double { var km: Double { return self*1000 } var m: Double { return self } var cm: Double { return self/100 } } //6. 协议 protocol OneProtocol { func classname() var fullName: String {get set}//属性，在声明后加上{get set}表示可读可写 static func classMethod() //static mutating func changeProperty()//突变方法 } //先写父类，再写协议 class FiveClass: FourClass, OneProtocol { var fullName: String = &quot;EOC&quot; func classname() { print(&quot;FiveClass&quot;) } static func classMethod() { print(&quot;classMethod&quot;) } func changeProperty() { } } //委托协议 protocol TwoProtocol { } class SixClass { var delegate: OneProtocol? var delegateTwo: (OneProtocol &amp; TwoProtocol)? } //可选 @objc protocol ThreeProtocol { @objc optional func className() } class SevenClass: ThreeProtocol { //如果是继承OneProtocol会报错，因为OneProtocol里的方法是必须继承的，而ThreeProtocol里的方法是可选的，因为有@objc //let sevenClass: SevenClass = SevenClass() //(sevenClass as ThreeProtocol).className?() } //7. 泛型 方法中通常用一个字母T来命名类型参数 func swapTwoInts(num1: inout Int, num2: inout Int) { let tempA = num1 num1 = num2 num2 = tempA } func swapTwo&lt;T&gt;(num1: inout T, num2: inout T) { let tempA = num1 num1 = num2 num2 = tempA } struct Stack&lt;T&gt; { var items = [T]() mutating func push(item: T) { items.append(item) } mutating func pop() -&gt; T { return items.removeLast() } } // 8. 运算符重载 struct Vector2D { var x = 1.0 var y = 1.0 //不是成员方法 参数被命名为left，right，代表 + 左右两个Vector2D对象 static func + (left: Vector2D, right: Vector2D) -&gt; Vector2D { return Vector2D(x: left.x+right.x, y: left.y+right.y) } static prefix func ++ (left: inout Vector2D) { left.x = left.x + 1 left.y = left.y + 1 } }]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift编码规范]]></title>
    <url>%2F2015%2F07%2F31%2FSwift%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[这篇Swift风格指南与你看到的其他的指南有所不同，此篇指南主要焦点集中在打印和Web展示的可读写上。我们创建此篇风格指南的目的，是为了让我们的图书、教程以及初学者套件中的代码保持优美和一致，即使我们有很多不同的作者共同编写这些图书。 我们的首要目标是一致性，可读性和简洁性。具体参见raywenderlich swift-style-guide ，此翻译版对应的是swift-style-guide May 11, 2017 commit 版本 0f1f0848c4313201006e18cbf3b5c8b1365204ce 正确性要尽量使你的代码编译时没有警告，甚至把警告当做错误处理。这条规则影响了很多语法的使用，如推荐使用#selector文而不是用字符串 命名使用具有描述性的和一致的命名使你的代码更加易读和易懂，更多关于Swift的命名方式参见Swift API Design Guidelines，下边列出几项比较重要的规则 在调用的地方力求清晰 相对于简介，清晰更重要 用驼峰式命名规则 类型和协议用大写，其他的都用小写 保留所有需要的词同时省略不必要的词 使用基于角色的名称，而不是类型 有时对弱类型信息进行补偿 力求流畅使用 工厂方法应以make开头 命名方法时的一些副作用 动词方法转非变异版本加ed，ing的规则 名词方法转变异版本直接加formX规则 boolean类型应该读起来像断言 协议描述的东西读起来应该像名词 协议描述的能力应该以able或ible结尾 使用不让专家惊讶或混淆初学者的术语 一般避免缩略语 用先例命名 使用方法和属性来简化函数 大小写均匀分布（casing acronyms and initialisms uniformly up or down） 给相似功能的方法相同的基本名称 避免在返回值上负载过多的值 选择一个号的参数名称，这样文档会更加清晰 给闭包和元组设置标签 充分利用默认参数 章法当提起方法规范时，易懂是最重要的，所以给方法命名的时候，越简单越好 写方法时不带参数，这样，调用的时候直接用addTarget 写方法时用参数标记，这样，调用的时候用addTarget(_:action:) 写方法时用参数标记和类型标记，这样，调用的时候用addTarget(_: Any?, action: Selector?) 举个例子，当我们用UIGestureRecognizer时，会采用第一种方式 类前缀Swift中类别(类，结构体)在编译时会把模块设置为默认的命名空间，所以不用为了区分类别而添加前缀，比如RW。如果担心来自不同模块的两个名称发生冲突，可以在使用时添加模块名称来区分，注意不要滥用模块名称，仅在有可能发生冲突或疑惑的场景下使用 import SomeModule let myClass = MyModule.UsefulClass() Delegates在定义委托方法时，第一个未命名参数应是委托数据源（UIKit包含了很多例子） 正例 func namePickerView(_ namePickerView: NamePickerView, didSelectName name: String) func namePickerViewShouldReload(_ namePickerView: NamePickerView) -&gt; Bool 反例 func didSelectName(namePicker: NamePickerViewController, name: String) func namePickerShouldReload() -&gt; Bool 使用类型推断使用编译器提供的类型推断可以写出更简单，清晰的代码(更多见Type Inference) 正例 let selector = #selector(viewDidLoad) view.backgroundColor = .red let toView = context.view(forKey: .to) let view = UIView(frame: .zero) 反例 let selector = #selector(ViewController.viewDidLoad) view.backgroundColor = UIColor.red let toView = context.view(forKey: UITransitionContextViewKey.to) let view = UIView(frame: CGRect.zero) 泛型泛型类参数应具有描述性，遵守“大骆驼命名法”,如果一个参数名没有具体的含义，可以使用传统单大写字符，如T, U, 或V等 正例 struct Stack&lt;Element&gt; { ... } func write&lt;Target: OutputStream&gt;(to target: inout Target) func swap&lt;T&gt;(_ a: inout T, _ b: inout T) 反例 struct Stack&lt;T&gt; { ... } func write&lt;target: OutputStream&gt;(to target: inout target) func swap&lt;Thing&gt;(_ a: inout Thing, _ b: inout Thing) 语言使用美式英语的拼写方式来定义接口 正例 let color = &quot;red&quot; 反例 let colour = &quot;red&quot; 代码组织用extension组织你的代码可以让代码更有逻辑块性，每个extension应该设置一个//MARK:块来让代码更好的组织起来 协议一致性特别地，在向模型添加协议一致性时，更倾向于为协议方法添加一个单独的扩展。这样可以让相关联的一些方法放在一起，从而简化向类及其相关方法添加协议的说明 你可以使用is和as操作符来检查是否遵循某一协议或强制转化为某一类型，此操作叫做检验协议的一致性 正例 class MyViewController: UIViewController { // class stuff here } // MARK: - UITableViewDataSource extension MyViewController: UITableViewDataSource { // table view data source methods } // MARK: - UIScrollViewDelegate extension MyViewController: UIScrollViewDelegate { // scroll view delegate methods } 反例 class MyViewController: UIViewController, UITableViewDataSource, UIScrollViewDelegate { // all methods } 由于编译器不允许您在派生类中重新声明协议一致性，因此并不总是需要复制基类的扩展组，如果派生类是一个终端类，并且覆盖了少量的方法，情况尤其如此。保留扩展组的时间由作者自行决定。 对于UIKit view controllers, 建议用extensions定义不同的类，按照生命周期，自定义访问，IBAction分组。 没有用到的代码无用的代码，包括Xcode生成的模板代码和占位符注释应该删除，除非是有目的性的保留这些代码。只有当你的文章或书指引用户使用被注释的代码时除外(For RW) 一些方法内只是简单地调用了父类里面的方法也需要删除，包括UIApplicationDelegate内的空方法和无用方法。 正例 override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { return Database.contacts.count } 反例 override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. } override func numberOfSections(in tableView: UITableView) -&gt; Int { // #warning Incomplete implementation, return the number of sections return 1 } override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { // #warning Incomplete implementation, return the number of rows return Database.contacts.count } 最少引入减少不必要的引入，例如引入Foundation能满足的情况下不用引入UIKit 间隔 缩进使用2个空格. 在Xcode的偏好设置和项目设置都可以配置。(缩进两个是为了更好的显示和打印，一般都是用4个空格) 方法体的大括号和其他大括号 (if/else/switch/while等) 首括号和首行语句在同一行，尾括号新起一行 可以先选择代码，然后按Control-I (or Editor\Structure\Re-Indent in the menu)重新缩进整理代码 方法之间应该有一条空行，以帮助视觉清晰度和组织。方法内的空行应该分隔单独的功能，但是有太多的空行往往意味着你应该将此方法重构为几个方法。 冒号往往在左边没有空格，在右边有一个空格。除三元运算符?:，空字典[:]和#selector语法(_:)外 每一行尽量保持在70个字符以内，不要故意做折行处理 每一行的末尾要避免空格的出现 在每个文件的末尾添加一个换行符 正例 if user.isHappy { // Do something } else { // Do something else } 反例 if user.isHappy { // Do something } else { // Do something else } 正例 class TestDatabase: Database { var data: [String: CGFloat] = [&quot;A&quot;: 1.2, &quot;B&quot;: 3.2] } 反例 class TestDatabase : Database { var data :[String:CGFloat] = [&quot;A&quot; : 1.2, &quot;B&quot;:3.2] } 注释如果有需要，用注释来解释某一段代码做了什么事情。注释必须保持最新，过期的注释要及时删除。 避免代码中出现注释块，代码本身应尽量起到注释的作用，如果注释是为了生成文档可以例外。 类和结构体应该使用哪一个? 注意，结构体是值类型。结构体在使用中没有标识。一个数组包含[a, b, c]和另外一个数组包含[a, b, c]是完全一样的，它们完全可以互相替换，使用第一个还是使用第二个都一样，因为它们代表的是同一个东西。这就是为什么数组是结构体。 类是引用类型。类使用的场景是需要一个标识或者需要一个特定的生命周期。假设你需要对人抽象为一个类，因为两个人，是两个不同的东西。即使两个人有同样的名字和生日，也不能确定这两个人是一样的。但是人的生日是一个结构体，因为日期1950/03/03和另外一个日期1950/03/03是相同的,日期是结构体没有唯一标示。 有时，一些事物应该定义为结构体，但是还需要实现AnyObject协议或者已经在以前的历史版本中定义为类（NSDate，NSSet），所以尽可能的注意类和结构体之间的区别。 类定义 class Circle: Shape { var x: Int, y: Int var radius: Double var diameter: Double { get { return radius * 2 } set { radius = newValue / 2 } } init(x: Int, y: Int, radius: Double) { self.x = x self.y = y self.radius = radius } convenience init(x: Int, y: Int, diameter: Double) { self.init(x: x, y: y, radius: diameter / 2) } override func area() -&gt; Double { return Double.pi * radius * radius } } extension Circle: CustomStringConvertible { var description: String { return &quot;center = \(centerString) area = \(area())&quot; } private var centerString: String { return &quot;(\(x),\(y))&quot; } } 上面的例子展示了下面的设计准则： 属性，变量，常量和参数等在声明定义时，其中: 符号后有空格，而: 符号前没有空格。比如x: Int, 和Circle: Shape 如果出于相同的目的和上下文定义多个变量/数据结构时，可以定义在同一行。 缩进getter，setter的定义和属性观察器的定义。 不需要添加internal这样的默认的修饰符。也不需要在重写一个方法时添加访问修饰符。 将其他的一些函数(如打印)等组织在扩展(extension)中 用private访问控制权限隐藏不需要分享的细节，如centerString方法 self的使用为了保持简洁，可以避免使用 self 关键词，因为Swift 在访问对象属性和调用对象方法不需要使用 self。 只有在编译器需要的时候（当在构造器中需要区分属性名和参数名时需要使用 self，还有当在在闭包表达式中引用属性值）才会用到self，也就是说，如果编译器不要self能编译正确，就省略self 计算属性为了保持简洁，如果一个属性是只读的，请忽略掉get语句。因为只有在需要定义set语句的时候，才需要get语句。 正例 var diameter: Double { return radius * 2 } 反例 var diameter: Double { get { return radius * 2 } } Final在教程中将类或者成员标记为final有可能会使人从主题上分心，所以这个不是很必要，然而有些情况下，使用final可以更加澄清你的意图，值得付出代价。在下面的示例中，Box具有特定的用途，不允许有派生类存在，所以把他标志成final会更加清楚 // Turn any generic type into a reference type using this Box class. final class Box&lt;T&gt; { let value: T init(_ value: T) { self.value = value } } 函数声明在定义短函数声明时保持在一行，一行内包括头括号: func reticulateSplines(spline: [Double]) -&gt; Bool { // reticulate code goes here } 对于声明较长的函数时，在适当的位置换行并在第二行多添加一个缩进： func reticulateSplines(spline: [Double], adjustmentFactor: Double, translateConstant: Int, comment: String) -&gt; Bool { // reticulate code goes here } 闭包表达式仅在闭包表达式参数在参数列表中最后一个时，才使用尾随闭包表达式。闭包参数命名要有描述性。 正例 UIView.animate(withDuration: 1.0) { self.myView.alpha = 0 } UIView.animate(withDuration: 1.0, animations: { self.myView.alpha = 0 }, completion: { finished in self.myView.removeFromSuperview() }) 反例 UIView.animate(withDuration: 1.0, animations: { self.myView.alpha = 0 }) UIView.animate(withDuration: 1.0, animations: { self.myView.alpha = 0 }) { f in self.myView.removeFromSuperview() } 当单个闭包表达式上下文清晰时，使用隐式的返回值： attendeeList.sort { a, b in a &gt; b } 链式方法使用尾随闭包应该要做到清晰易读，至于如何使用空格，换行，还是使用命名和匿名参数不做具体要求 let value = numbers.map{ $0 * 2 }.filter{ $0 % 3 == 0 }.index(of: 90) let value=numbers .map{ $0 * 2 } .filter{ $0 &gt; 50 } .map{$0 + 10} 类型优先使用Swift原生类型，因为Swift提供了到Objective-C的桥接，所以你仍然可以根据需要使用Objective-C提供的方法 正例 let width = 120.0 // Double let widthString = (width as NSNumber).stringValue // String 反例 let width: NSNumber = 120.0 // NSNumber let widthString: NSString = width.stringValue // NSString 在 Sprite Kit 代码中, 使用CGFloat可以避免数据多次转换，让代码更简洁。 常量定义常量使用 let 关键字，定义变量使用 var 关键字， 如果变量的值未来不会发生变化要使用常量。 建议: 一个好的技巧是，使用 let 定义任何东西，只有在编译器提出警告需要改变的时候才修改为 var 定义。 您可以使用类型属性定义类型上的常量而不是类型的实例上的常量。若要将类型属性声明为常量，只需使用static let。以这种方式声明的类型属性通常优于全局常量，因为它们更容易与实例属性区别开来。例子: 正例 enum Math { static let e = 2.718281828459045235360287 static let root2 = 1.41421356237309504880168872 } let hypotenuse = side * Math.root2 反例 let e = 2.718281828459045235360287 // pollutes global namespace let root2 = 1.41421356237309504880168872 let hypotenuse = side * root2 // what is root2? 注意：使用不区分大小写的枚举的好处是变量不会被无意初始化，且在一个单独的命名空间中工作 静态方法和变量类型属性静态方法和类形属性类似于全局方法和全局属性，应该节制使用。它们的使用场景在于如果某些功能局限于特别的类型或和Objective-C 互相调用。 可选类型变量和函数返回值声明为可选类型(?)，这样如果赋nil值可以接受。 当你确认实例变量稍晚会在使用前初始化，可以在声明时用 ！表示隐式的拆包类型，比如在viewDidLoad中会初始化的子视图。 当你访问一个可选类型值时，如果只需要访问一次或者在可选值链中有多个可选类型值时，请使用可选类型值链： self.textContainer?.textLabel?.setNeedsDisplay() 如果可以方便的一次性拆包或者执行多次性操作时，使用可选类型绑定: if let textContainer = self.textContainer { // do many things with textContainer } 当我们命名一个可选值变量和属性时，避免使用如optionalString 或 maybeView名称，因为可选值的已经体现在类型定义中。 在可选值绑定时，直接映射原始的命名比使用诸如unwrappedView 或 actualLabel好。 正例 var subview: UIView? var volume: Double? // later on... if let subview = subview, let volume = volume { // do something with unwrapped subview and volume } 反例 var optionalSubview: UIView? var volume: Double? if let unwrappedSubview = optionalSubview { if let realVolume = volume { // do something with unwrappedSubview and realVolume } } 延迟初始化延迟初始化用来细致地控制对象的生命周期，这对于想实现延迟加载视图的UIViewController特别有用，你可以即时调用闭包，也可以调用私有构造方法： lazy var locationManager: CLLocationManager = self.makeLocationManager() private func makeLocationManager() -&gt; CLLocationManager { let manager = CLLocationManager() manager.desiredAccuracy = kCLLocationAccuracyBest manager.delegate = self manager.requestAlwaysAuthorization() return manager } 注意： 这个地方不需要[unowned self]，因为没有形成闭环 Location manager 的负面效果会弹出对话框要求用户提供权限，这是做延时加载的原因 类型推断推荐使用更加紧凑的代码，让编译器能够推断出每个常量和变量的类型。类型推断也适用于小的数组和字典，如果需要可以指定特定的类型，如 CGFloat 或 Int16 正例 let message = &quot;Click the button&quot; let currentBounds = computeViewBounds() var names = [&quot;Mic&quot;, &quot;Sam&quot;, &quot;Christine&quot;] let maximumWidth: CGFloat = 106.5 反例 let message: String = &quot;Click the button&quot; let currentBounds: CGRect = computeViewBounds() let names = [String]() 对空的数组和字典，如何使用类型注解 正例 var names: [String] = [] var lookup: [String: Int] = [:] 反例 var names = [String]() var lookup = [String: Int]() 遵循这个准则意味着提取描述性名称比以前更重要 语法糖使用简洁的类型定义语法，而不是全称语法 正例 var deviceModels: [String] var employees: [Int: String] var faxNumber: Int? 反例 var deviceModels: Array&lt;String&gt; var employees: Dictionary&lt;Int, String&gt; var faxNumber: Optional&lt;Int&gt; 函数 VS 方法自由函数不依附于任何类或类型，应该节制地使用。如果可能，优先使用方法而不是自由函数，这有助于代码的可读性和易发现性。 正例 let sorted = items.mergeSorted() // easily discoverable rocket.launch() // acts on the model 反例 let sorted = mergeSort(items) // hard to discover launch(&amp;rocket) 自由函数使用的场景是当他本身不和具体的类别或实例相关。 let tuples = zip(a, b) // feels natural as a free function (symmetry) let value = max(x, y, z) // another free function that feels natural 内存管理代码（不仅正式代码，包括demo）应避免指针循环引用，分析对象图，使用弱引用和无主引用避免强引用循环. 另外使用值类型(结构体和枚举)可以避免循环引用 延长对象生命周期 延长对象生命周期习惯上使用[weak self]和guard let strongSelf = self else { return }语法。 [weak self] 优于 [unowned self] 因为前者更更能明显地体现self 生命周期长于闭包块。 显式延长生命周期优先于可选性拆包。 正例 resource.request().onComplete { [weak self] response in guard let strongSelf = self else { return } let model = strongSelf.updateModel(response) strongSelf.updateUI(model) } 反例 // might crash if self is released before response returns resource.request().onComplete { [unowned self] response in let model = self.updateModel(response) self.updateUI(model) } 反例 // deallocate could happen between updating the model and updating UI resource.request().onComplete { [weak self] response in let model = self?.updateModel(response) self?.updateUI(model) } 访问控制教程中的严格访问控制注释可能会分散主题，所以不是必需的。然而，如果合适的应用private和fileprivate访问控制，则会增进封装并使主题更加明显，所以，当合适的时候选择使用private和fileprivate访问控制。有时在写extension的时候会用到fileprivate 当需要访问控制权限的时候，用open,public,internal关键字 访问控制符一般放在属性修饰符的最前面. 除非需要使用 static 修饰符和一些属性关键字，如@IBAction, @IBOutlet 或 @discardableResult 正例 private let message = &quot;Great Scott!&quot; class TimeMachine { fileprivate dynamic lazy var fluxCapacitor = FluxCapacitor() } 反例 fileprivate let message = &quot;Great Scott!&quot; class TimeMachine { lazy dynamic fileprivate var fluxCapacitor = FluxCapacitor() } 控制流程循环使用for-in表达式，而不使用 while 表达式。 正例 for _ in 0..&lt;3 { print(&quot;Hello three times&quot;) } for (index, person) in attendeeList.enumerated() { print(&quot;\(person) is at position #\(index)&quot;) } //by表示step，步长 for index in stride(from: 0, to: items.count, by: 2) { print(index) } for index in (0...3).reversed() { print(index) } 反例 var i = 0 while i &lt; 3 { print(&quot;Hello three times&quot;) i += 1 } var i = 0 while i &lt; attendeeList.count { let person = attendeeList[i] print(&quot;\(person) is at position #\(i)&quot;) i += 1 } 黄金路径当编码遇到条件判断时，左边的距离是黄金路径或幸福路径，也就是说，不要嵌套if循环，多个返回语句是可以的。guard 就为此而生的。 正例 func computeFFT(context: Context?, inputData: InputData?) throws -&gt; Frequencies { guard let context = context else { throw FFTError.noContext } guard let inputData = inputData else { throw FFTError.noInputData } // use context and input to compute the frequencies return frequencies } 反例 func computeFFT(context: Context?, inputData: InputData?) throws -&gt; Frequencies { if let context = context { if let inputData = inputData { // use context and input to compute the frequencies return frequencies } else { throw FFTError.noInputData } } else { throw FFTError.noContext } } 当有多个条件需要用 guard 或 if let 解包，可用复合语句避免嵌套。 正例 guard let number1 = number1, let number2 = number2, let number3 = number3 else { fatalError(&quot;impossible&quot;) } // do something with numbers 反例 if let number1 = number1 { if let number2 = number2 { if let number3 = number3 { // do something with numbers } else { fatalError(&quot;impossible&quot;) } } else { fatalError(&quot;impossible&quot;) } } else { fatalError(&quot;impossible&quot;) } 失败防护防护语句的退出有很多方式，一般都是单行语句，如 return,throw,break,continue 和 fatalError()等。 避免出现大的代码块，如果清理代码需要多个退出点，可以用 defer 模块避免重复清理代码。？？？ 分号Swift不强制每条语句有分号，当一行内写多个语句的时候是必须的，但是，代码规范要求不要在一行里写多个语句。 正例 let swift = &quot;not a scripting language&quot; 反例 let swift = &quot;not a scripting language&quot;; Swift和JS是完全不同的语言，JS省略分号一般是不安全的 圆括号条件判断时圆括号不是必须的，建议省略 正例 if name == &quot;Hello&quot; { print(&quot;World&quot;) } 反例 if (name == &quot;Hello&quot;) { print(&quot;World&quot;) } 在一些比较长的表达式中，圆括号有时候可以让代码更易读 let playerMark = (player == current ? &quot;X&quot; : &quot;O&quot;) 组织和APP唯一标识在本网站的课程上的工程信息，组织应该被设置成Ray Wenderlich，并且APP唯一标识应该被设置成com.razeware.TutorialName，其中TutorialName标识课程工程的名称 版权声明以下的版权信息应该包括在每个文件的顶部 /** * Copyright (c) 2017 Razeware LLC * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the &quot;Software&quot;), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * Notwithstanding the foregoing, you may not use, copy, modify, merge, publish, * distribute, sublicense, create a derivative work, and/or sell copies of the * Software in any work that is designed, intended, or marketed for pedagogical or * instructional purposes related to programming, coding, application development, * or information technology. Permission for such use, copying, modification, * merger, publication, distribution, sublicensing, creation of derivative works, * or sale is expressly withheld. * * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. */ 笑脸笑脸是raywenderlich.com网站一个非常突出的特性！对编码的主题来说，正确的使用笑脸会产生巨大的快乐和幸福感。由于ASCII的艺术，右方括号能代表最大的笑脸，而右圆括号只能创建一半的笑脸，所以，我们使用右方括号代表一个笑脸:] 正例 :] 反例 :) 参考 The Swift API Design Guidelines The Swift Programming Language Using Swift with Cocoa and Objective-C Swift Standard Library Reference]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift2语法学习]]></title>
    <url>%2F2015%2F06%2F26%2FSwift%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[从2014-06-03苹果开发者大会发布Swift1.0到2015-12-04苹果公司宣布开源Swift2.1，再从苹果2016-03-21释放稳定成熟版本Swift2.2到2016-09-13Swift3.0的变革，Swift一路走来，在社区以及核心团队的努力下，越来越成熟、稳定。我们这节以关东升老师的《从零开始学Swift》来学习基于Swift2.2的语法知识，关于Swift的后续更新及变革，我会在后续的文章中发专题整理，如果想要看Swift源码的同学或者想膜拜大神的同学可以在本地址中查看 准备起航本书约定 示例代码约定：约定示例代码和本书章节之间的关系 图示约定：图中的圆圈、箭头和手势表示的意思 函数和方法签名约定： 函数和方法签名是函数和方法表示方式，签名由函数和方法的名称和每个参数组成，不包括返回值和参数类型，例如 print函数有两种不同的函数签名 print(_:separator:terminator:) print(_:separator:terminator:) 无论是函数还是方法，小括号中凡是有冒号的地方，说明这里有一个参数 承接上一行代码约定：用符号表示承接上一行 代码行号约定：用圆圈中阿拉伯数字约定行数 Swift开发工具 Xcode开发工具 苹果公司自己出的开发工具，比较常用，并且免费 AppCode开发工具 JetBrains公司开发来替代Xcode的一款产品，它提供了一些Xcode没有的一些功能，操作界面继承了JetBrains的一贯风格。它还提供了很多灵活的设置项目，可以根据用户喜好设置操作界面，这也是很多人喜欢它的原因，但是它是收费的 第一个Swift程序前三种为交互式方式运行、后两种为编译为可执行文件方式运行 使用PERLPERL是Read-Eval-Print Loop，译为读取-求值-输出，直接在终端输入swift即可进入编码模式编码，按:quit退出Swift PERL 在终端通过swift命令启动Swift REPL，直接键入代码即可，然后通过:quit退出 使用PlaygroundPlayground是对PERL的封装，是图形界面化的交互运行编程环境工具 使用Web网站比较出名的是swiftstub.com，这个网站允许在任何平台下编译和运行Swift程序 通过Xcode创建OS X工程使用AppCode创建OS X工程 当程序中设置断点后，只有调试状态下运行遇到断点能挂起，而Run按钮运行到断点不会挂起，Xcode则没有debug按钮，Run按钮运行遇到断点会挂起，JetBrains公司旗下几乎所有编程工具都采用类似的设计，类似的还有Eclipse 使用swiftc命令将swift文件编译成可执行文件运行Xcode还提供了一个基于命令行的Swift代码编译命令Swiftc，我们可以再终端运行Swiftc命令编译Swift代码，如运行swiftc HelloWorld.swift，如果HelloWorld.swift文件中有编译错误，则会在命令行中抛出显示，如果编译成功，终端没有任何提示，在当前目录下会生成和HelloWorld.swift名字相同的可执行文件，其图标是exec黑色，如果有多个Swift文件可以使用如下命令 swiftc *.*，那么编译成功输出一个名为main的文件，然后输入 ./HelloWorld 命令即可运行 代码解释在Linux下编译和运行Swift程序Swift语法基础标识符和关键字（均区分大小写）标识符就是变量、常量、方法、函数、枚举、结构体、类、协议等由开发人员指定的名字，具体规则见书本 Swift中的字母采用的是Unicode编码，Unicode编码叫做统一编码，它包含了亚洲文字编码，如中文、日文、韩文等字符，甚至是我们在聊天工具中使用的表情符号，如手机中常有的emoj表情，这些符号事实上也是Unicode，而非图片，这些符号在Swift中都可以使用 关键字是类似于标识符的保留字符序列，由语言本身定义好的，不能挪用他用，除非用重音符号将其括起来 Java的关键字都是小写字母，而Swift关键字没有这种规律，有大写、小写、下划线等。但要记住，在Swift中，关键字是区分大小写的，因此class和Class是不同的，当然Class不是Swift的关键字 常量和变量在声明和初始化常量时，请在标识符的前面加上关键字let 在Swift中声明变量，就是在标识符的前面加上关键字var 一般，如果在程序中使用常量可以提高程序的可读性，但常量不能修改值，而如果数据类型是引用类型（类声明类型）的时候，则最好声明为let，let声明的引用数据类型不会改变引用(即：指针)，但可以改变其内容 在swift中数据类型分为值类型和引用类型，整数、浮点型、布尔型、字符、字符串、元祖、集合、枚举和结构体都属于值类型，而类属于引用类型 注释Swift程序中有两类注释：单行注释(//)和多行注释(/**/)，多行注释可以嵌套 表达式表达式有3种形式： 不指定数据类型：因为Swift可以自动推断数据类型 指定数据类型：也可以指定数据类型 使用分号：一条语句结束后可以不加分号，也可以加分号，但多条语句写在一行的时候，需要通过分号来区别语句 原则上在声明变量或常量时不要指定数据类型，因为这样程序代码非常简洁，但有时需要指定特殊的数据类型，必须加上数据类型 运算符算术运算符算术运算符可以分为一元运算符（包括-/++/—）和二元运算符（包括+/-/*///%） 关系运算符关系运算是比较两个表达式的大小关系的运算，它的结果是布尔型数据，包括==/!=/&gt;/&lt;/&gt;=/&lt;=/===/!==（用于引用类型的比较，a与b同引用同一个实例时返回true） 注意字符串String类型不能使用===/!===进行比较，因为String是值类型而不是引用类型 逻辑运算符逻辑运算符是对布尔型变量进行运算，其结果也是布尔型，包括!/&amp;&amp;/||,!表示逻辑反，&amp;&amp;和||都有短路计算的特点 位运算符位运算符是以二进制bit位单位进行运算的，操作数和结果数都是整形数据，包括&amp;/|/^/~/&gt;&gt;/&lt;&lt;，分别表示按位与、按位或、按位异或、按位取反、右移a位、左移a位 其他运算符 三元运算符（?:） 括号运算符 引用号(.)实例调用属性、方法等 赋值运算符 问号(?用来声明可选类型) 感叹号(!对可选类型值进行显式拆包) is(判断某个实例是否为某种类型) as(强制转换类型) 箭头(-&gt;说明函数或方法返回值) 逗号运算符(用于集合分隔元素) 冒号运算符(用于字典分隔键值对) Swift原生数据类型Swift数据类型Swift中的数据类型包括：整型、浮点型、布尔型、字符、字符串、元祖、集合、枚举、结构体和类等 这些类型在赋值或给函数传递时的方式不同，分为值类型和引用类型，值类型就是创建一个副本，把副本赋值或传递过去，这样在函数的调用过程中不会影响原始数据；引用类型就是把数据本身的引用即指针，赋值或传递过去，这样在函数的调用过程中会影响原始数据 整型Swift提供8(Int8/Unit8)、16(Int16/Unit16)、32(Int32/Unit32)、64(Int64/Unit64)位形式的有符号及无符号整数，这些整数类型遵循C语言的命名规范 Swift语言提供了类型推断功能，从编程过程上讲，声明变量或常量时应该尽可能采用类型推断，因为这样可以使代码更加简洁，但有非默认数据类型时除外，如Int16，Character 浮点型浮点型分为浮点数float(32位)和双精度浮点数double(64位)（默认）两种 数字表示方式二进制以0b开头，八进制0o，十六进制0x，指数e2表示10的2次方(var myMoney = 3.36e2;即3.36乘以10的2次方) 数字类型之间的转换Swift是一种安全的语言，对于类型的检查非常严格，不同类型之间不能随便转换。 与其他语言不同的是，Swift的不同类型之间不能随便转变，而是需要通过一些函数进行显式转换，如构造函数UInt16(***)/UInt8(***)/Float(***) 布尔型布尔型只有两个值：true和false，它不能像C和Objective-C一样使用1替代true或使用0代表false 元组类型元组是一种数据结构，在关系型数据库中，元组就是表中的一条记录，每列就是一个字段 var student1 = (&quot;1001&quot;, &quot;张三&quot;, 30, 90) print(&quot;学生：\(student1.1) 学号：\(student1.0) 语文成绩：\(student1.2) 数学成绩：\(student1.3)&quot;) let (id1,name1,age1,score1) = student1 print(&quot;学生：\(name1) 学号：\(id1) 语文成绩：\(age1) 数学成绩：\(score1)&quot;) let (id1,name1,age1,score1)=student1表示对student1元祖变量分解 可选类型Swift语言与OC和JAVA等语言有很大的不同，Swift所有的数据类型声明的变量或常量都不能为空值(nil)，但在运行过程中有时候被赋值给nil是在所难免的，例如我们在查询数据库记录，没有查出符合条件的数据是很正常的事情，为此，Swift为每一种数据类型提供一种可选类型(optional)，即在某个数据类型后面加上问号(?)或感叹号(!) 如果我们直接打印非空的可选类型 var n1 : Int? = 10 print(n1) 数据的结果是Optional(10)，而非10.这说明n1不是普通类型，也不能与不同值进行计算，所以视图计算表达式n1+100会发生编译错误，因此对于可选类型拆包是必要的 拆包就是将可选类型变成普通类型，拆包分为显式拆包和隐式拆包，使用问号声明的可选类型在拆包时需要使用感叹号，这种方式称为显式拆包；使用感叹号声明的可选类型在拆包时可以不使用感叹号，这种方式称为隐式拆包，隐式拆包也可以使用感叹号 在不能保证可选类型值是否为空之前最好不要拆包，否则会出现运行时错误 fatal error:unexpectedly found nil while unwrapping an Optional value 函数返回的可选类型在if或while语句中赋值并进行判断的写法称为可选绑定。可选绑定过程做了两件事情：首先判断表达式是否为空值，然后如果为非空则将返回的类型值拆包，并赋值给一个常量，常量的作用域是if或while语句为true的分支 func divide(n1: Int, n2: Int) -&gt; Double? { if (n2 == 0) { return nil } return Double(n1)/Double(n2) } if let result = divide(100, n2: 0) { print(result) print(&quot;success&quot;) } else { //print(result) //编译错误 print(&quot;success&quot;) } Swift原生字符串字符字符串的组成单位是字符，在Swift中字符类型是Character，如果在声明时省略Character类型声明，编译器自动推断出的类型不是字符类型，而是字符串类型，在swift字符中，必须使用双引号把字符括起来 在Swift中，为了表示一些特殊字符，前面要加上反斜杠，如\t,\n,\r,\’,\”,\等 创建字符串在Swift中字符串的类型是String，事实上String是一个结构体，为了能够和NSString相互转化，苹果公司提供一种“零开销桥接技术”使得互相转化更加低成本，更加简单 可变字符串在Swift中通过let声明的字符串常量是不可变字符串，var声明的字符串变量是可变字符串 可变类型可调用append,insert,removeAtIndex,removeRange,replaceRange等方法 ()语句非常强大，可以将任何数据类型拼接起来 var flower: Character = &quot;abc&quot; flower.append(&quot;def&quot;) print(&quot;flower is \(flower)&quot;) “…”是闭区间运算符，半开区间运算符是”..&lt;”和”&lt;.&lt;” var range = startIndex...endIndex var range = startIndex..&lt;endIndex var str = &quot;Objective C and Swift&quot; str.removeRange(range) 字符串比较字符串类型与整形和浮点型一样，都可以进行相等以及大小的比较，比较的依据是Unicode编码值的大小 字符串比较重有时候需要比较前缀或后缀，比如hasSuffix()/hasPrefix 控制语句程序设计中的控制语句有3种，即顺序、分支和循环语句 分支语句包括if、switch、guard 循环语句包括while、repeat-while、for和for-in 跳转语句包括break，continue，fallthrough，return和throw 分支语句Swift中的switch语句和其他语言的不同之处有2 它可以使用整形、浮点型、字符、字符串和元祖等类型、而且它的值可以是离散的也可以是连续的范围 case语句不需要显式地添加break语句，分支执行完成就会跳出switch语句 switch 条件表达式 { case 值1:(90...100) 语句组1 case 值2:(80..&lt;90) 语句组2 case 值3: 语句组3 default: 语句组... } guard语句与if语句非常相似，可以判断一个条件为false情况下执行某语句，否则终止或跳过执行某语句，它的设计目的是替换复杂if-else语句的嵌套，提高程序可读性 //当条件表达式为true时跳过else语句中的内容，执行语句组内容，条件表达式为false时执行else语句中的内容，跳转语句一般是return、break、continue和throw，return和throw关键字用于guard语句中，break和continue要在一个循环体中使用guard语句中 guard 条件表达式 else { 跳转语句 } 语句组 struct Blog { let name: String? let URL: String? let Author: String? } func ifStyleBlog(blog: Blog) { if let blogName = blog.name { print(&quot;这篇博客名:\(blogName)&quot;) } else { print(&quot;这篇博客没有名字&quot;) } } func guardStyleBlog(blog: Blog) { guard let blogName = blog.name else { print(&quot;这篇博客没有名字&quot;) return } print(&quot;这篇博客名:\(blogName)&quot;) } 循环语句循环语句能够使代码重复执行，Swift编程语言支持4种循环构造类型：while、repeat-while、for和for-in //while语句是一种先判断的循环结构，格式如下 while 循环条件 { 语句组 } //repeat-while语句的使用与while语句相似，不过repeat-while语句是事后判断循环条件结构，语句格式如下 repeat { 语句组 } while 循环条件 //for语句是应用最广泛、功能最强的一种循环语句，格式如下 for 初始化; 循环条件; 迭代 { 语句组 } //Swift提供了一种专门用于遍历集合的for循环---for-in循环，使用for-in循环不必按照for的标准套路编写代码，你只需要提供一个集合就可以遍历 let numbers = [1,2,3,4,5,6,7,8,9] for item in numbers { print(&quot;Count is : \(item)&quot;) } //在for-in语句中如果需要循环变量，可以使用集合的enumerate方法 for (index, element) in numbers.enumerate() { print(&quot;Item \(index) \(element)&quot;) } 跳转语句跳转语句可以改变程序的顺序执行，可以实现程序的跳转，Swift有5种跳转语句：break、continue、fallthrough、throw和return break语句有两种方式，可以带标签，也可以不带标签，带标签的话会使程序跳出标签指示的循环体，不带标签使程序跳出所在层的循环体 label1: for var x = 0; x &lt; 5; x++ { label2: for var y = 5; y &gt; 0; y-- { if y == x { break label1 } print(&quot;(x,y)=(\(x),\(y))&quot;) } } print(&quot;Game Over!&quot;) (x,y)=(0,5) (x,y)=(0,4) (x,y)=(0,3) (x,y)=(0,2) (x,y)=(0,1) (x,y)=(1,5) (x,y)=(1,4) (x,y)=(1,3) (x,y)=(1,2) Game Over! continue语句用来结束本次循环，跳过循环体中尚未执行的语句，接着进行终止条件的判断，以决定是否继续循环，在循环体中使用continue语句有两种方式，可以带标签，也可以不带标签 label1: for var x = 0; x &lt; 5; x++ { label2: for var y = 5; y &gt; 0; y-- { if y == x { continue label1 } print(&quot;(x,y)=(\(x),\(y))&quot;) } } print(&quot;Game Over!&quot;) (x,y)=(0,5) (x,y)=(0,4) (x,y)=(0,3) (x,y)=(0,2) (x,y)=(0,1) (x,y)=(1,5) (x,y)=(1,4) (x,y)=(1,3) (x,y)=(1,2) (x,y)=(2,5) (x,y)=(2,4) (x,y)=(2,3) (x,y)=(3,5) (x,y)=(3,4) (x,y)=(4,5) Game Over! fallthrough是贯通语句，只能使用在switch语句的case分支中，表示将贯通下边的case分支，为了防止错误的发生，Swift的switch语句case分之默认不能贯通，即执行完一个case分支就跳出switch语句，但凡是都有例外，如果算法真的需要多个case分支贯通，也可以使用fallthrough分支 范围与区间运算符闭区间(…)包含上下临界值，半开区间(..&lt;)包含下临界值，但不包含上临界值，在编程之后区间运算符与上下临界值之间不能有空格 值绑定有时候在一些控制语句中可以将表达式的值临时赋给一个常量或变量，这些常量或变量能够在该控制语句中使用，这称为“值绑定”，值绑定可以应用于if、guard和switch等控制语句中 struct Blog { let name: String? let URL: String? let Author: String? } //if中的值绑定 func ifStyleBlog(blog: Blog) { if let blogName = blog.name, let blogURL = blog.URL, let blogAuthor = blog.Author { print(&quot;这篇博客名:\(blogName)&quot;) print(&quot;这篇博客由:\(blogAuthor)写的&quot;) print(&quot;这篇博客网址:\(blogURL)&quot;) } else { print(&quot;这篇博客信息不完整&quot;) } } //guard中的值绑定 func guardStyleBlog(blog: Blog) { guard let blogName = blog.name, let blogURL = blog.URL, let blogAuthor = blog.Author else { print(&quot;这篇博客信息不完整&quot;) return } print(&quot;这篇博客名:\(blogName)&quot;) print(&quot;这篇博客由:\(blogAuthor)写的&quot;) print(&quot;这篇博客网址:\(blogURL)&quot;) } //switch中的值绑定 var student = (id:&quot;1002&quot;, name:&quot;李四&quot;, age:32, ChineseScore:90 EnglishScore:91) switch student { case (_, _, let AGE, 90...100, 90...100): if (AGE&gt;30) { desc = &quot;老优&quot; } else { desc = &quot;小优&quot; } case ... } print(&quot;说明：\(desc)&quot;) where语句有时我们可以在一些控制语句中使用where语句，进行条件过滤，where类似于SQL语句中的where语句，能够使用where语句的控制语句有switch、for-in和guard等，此外，where语句还可以应用于泛型 //switch中使用where语句 var student = (id:&quot;1002&quot;, name:&quot;李四&quot;, age:32, ChineseScore:90 EnglishScore:91) switch student { case (_, _, let AGE, 90...100, 90...100) where age&gt;20: desc = &quot;优&quot; case ... } print(&quot;说明：\(desc)&quot;) //for-in中使用where语句 let numbers = [1,2,3,4,5,6,7,8,9] for item in numbers where item&gt;5 { print(&quot;Count is : \(item)&quot;) } //guard中使用where语句 struct Blog { let name: String? let URL: String? let Author: String? } func guardStyleBlog(blog: Blog) { guard let blogName = blog.name where blog.Author == &quot;Tony&quot; &amp;&amp; blogName == &quot;Tony&apos;s Blog&quot; else { print(&quot;这篇博客信息不完整&quot;) return } print(&quot;这篇博客名:\(blogName)&quot;) } Swift原生集合类型Swift中提供了3种数据结构的实现，数组、Set和字典，字典也叫映射或散列表 Swift中的数组集合数组(array)是一串有序的由相同类型元素构成的集合 Swift数组类型是Array，Array是结构体类型，是一个一维泛型集合（多维集合需要自己实现），在声明一个Array类型的时候可以使用下面语句之一： //类型为Array&lt;String&gt;,&lt;String&gt;是泛型，说明在这个数组中只能存放字符串类型的数据 var studentList1: Array&lt;String&gt; var studentList2: [String] Array类型往往在声明的同时进行初始化 var studentList1: Array&lt;String&gt; = [&quot;&quot;, &quot;&quot;, &quot;&quot;]; var studentList2: [String] = [&quot;&quot;, &quot;&quot;, &quot;&quot;]; let studentList3: [String] = [&quot;&quot;, &quot;&quot;, &quot;&quot;]; var studentList4: [String] = [String](); var声明的数组类型是可变数组，如果初始化之后不再修改数组，应该将数组声明为let的，即不变的数组 不可变数组在访问效率上比可变数组(var声明的数组)要高，可变数组通过牺牲访问效率换取可变性 Swift中的字典集合Swift字典表示一种非常复杂的集合，允许按照某个键来访问元素，字典是由两部分集合构成的，一个是键集合，一个是值集合，键集合不能有重复元素，而值集合可以，键和值是成对出现的 字典中键和值的集合是无序的 Swift字典类型是Dictionary，Dictionary也是结构体类型，也是一个泛型集合，在声明一个Dictionary类型的时候可以使用下面的语句之一： var studentDictionary1: Dictionary&lt;Int, String&gt; var studentDictionary2: [Int: String] Dictionary类型往往在声明的同时进行初始化 var studentDictionary1: Dictionary&lt;Int, String&gt; = [102:&quot;&quot;, 105:&quot;&quot;, 108:&quot;&quot;] var studentDictionary2 = [102:&quot;&quot;, 105:&quot;&quot;, 108:&quot;&quot;] let studentDictionary3 = [102:&quot;&quot;, 105:&quot;&quot;, 108:&quot;&quot;] var studentDictionary4 = Dictionary&lt;Int, String&gt;() var studentDictionary5 = [Int: String]() 不可变字典与可变字典之间的关系类似于不可变数组和可变数组之间的关系。var声明的字典是可变字典，如果初始化后不再修改字典，应该讲字典声明为let的，即不可变的字典 Swift中的Set集合Swift中Set集合是一串无序的，不能重复的相同类型元素构成的集合，在声明一个Set类型时可以使用下边的语句 var studentList: Set&lt;String&gt; Set类型往往在声明的同时进行初始化 let studentList1: Set&lt;String&gt; = [&quot;&quot;, &quot;&quot;, &quot;&quot;] 不可变Set集合与可变Set集合之间的关系，类似于不可变数组和可变数组之间的关系，var声明的Set集合是可变的，如果初始化之后不再修改，应该将Set集合声明为let的，即不变的Set集合 Swift的Set类型是Set，Set是结构体类型，也是一个一维泛型集合 函数Swift中的函数很灵活，它可以独立存在，即全局函数；也可以存在于别的函数中，即嵌套函数；还可以存在于类、结构体和枚举中，即方法 使用函数要使用函数首先需要定义函数，然后在合适的地方进行调用，函数定义的语法格式如下： func 函数名(参数列表) -&gt; 返回值类型 { 语句组 return 返回值 } func rectangleArea(width:Double, height:Double) -&gt; Double { let area = width * height return area } print(&quot;320X480的长方形的面积是：\(rectangle(320, height:480))&quot;) 在参数列表后使用箭头-&gt;指示返回值类型，返回值有单个值和多个值，多个值返回可以使用元组类型实现，如果函数没有返回值，则”-&gt; 返回值类型”部分可以省略。 Swift函数调用时除了第一个参数外，其他参数需要指定参数名。但是Swift1.x之前不需要指定， 可以使用rectangleArea(320, 480)语句调用 传递参数局部参数名就是上一节讲到的width、height参数名，在定义函数时，可以在局部参数名之前加一个“外部参数名”，用空格分隔，也可以在定义函数时，使用下划线_表示省略外部参数名 //可以在局部参数名之前加一个“外部参数名”，用空格分隔 func rectangleArea(W width:Double, H height:Double) -&gt; Double { let area = width * height return area } //也可以在定义函数时，使用下划线_表示省略外部参数名 func rectangleArea(width:Double, _ height:Double) -&gt; Double { let area = width * height return area } 在定义函数第一个参数不需要使用下划线，默认第一个参数名是省略的，其他参数名要想省略，则需使用下划线 在定义函数时可以为参数设置一个默认值，当调用函数时可以忽略该参数 func makeCoffee(type: String=&quot;卡布奇诺&quot;) -&gt; String { return &quot;制作一杯\(type)咖啡&quot; } let coffee1 = makeCoffee(&quot;拿铁&quot;)//制作一杯拿铁咖啡 let coffee2 = makeCoffee()//制作一杯卡布奇诺咖啡 Swift中函数的参数个数可以变化，它可以接受不确定数量的输入类型参数，这些参数需要有相同的类型，有点像是传递一个数组，我们可以通过在参数类型名后面加入…的方式来表示这是可变参数 func sum(numbers: Double...) -&gt; Double { var total: Double = 0; for number in numbers { total += number } return total } 参数传递方式分为两种：值类型和引用类型。值类型给函数传递的是参数的一个副本，这样在函数调用过程中不会影响原始数据。引用类型是把数据本身引用(内存地址)传递过去，这样在函数的调用过程中会影响原始数据。 在众多数据类型中，只有类是引用类型，其他的数据类型全部是值类型 但是凡事都有例外，有时候需要将一个值类型参数以引用的方式传递，这也是可以实现的，Swift提供的inout关键字就可以实现 func increment(inout value: Double, amount: Double=1.0) { value += amount } var value: Double = 10.0; increment(&amp;value) print(value)//11.0 函数返回值Swift中函数的返回值是比较灵活的，主要有3种形式，无返回值、单一返回值和多返回值 有时候需要函数返回多个值，这可以通过两种方式来实现，一种是在函数定义时将函数的多个参数声明为引用类型传递，这样当函数调用结束时，这些函数的值就变化了。另一种是返回元组类型 函数类型每个函数都有一个类型，使用函数的类型与使用其他数据类型一样，可以声明变量或常量，也可以作为其他函数的参数或者返回值使用 作为函数返回类型使用 func rectangleArea(width: Double, height: Double) -&gt; Double { let area = width * height return area } func triangleArea(bottom: Double, height: Double) -&gt; Double { let area = bottom * height * 0.5 return area } func getArea(type: String) -&gt; (Double, Double) -&gt; Double { var returnFunction: (Double, Double) -&gt; Double switch type { case &quot;rect&quot;: returnFunction = rectangleArea case &quot;tri&quot;: returnFunction = triangleArea default: returnFunction = rectangleArea } return returnFunction } var area : (Double, Double) -&gt; Double = getArea(&quot;tria&quot;) print(&quot;area \(area(10, 15))&quot;) 作为参数使用 func getAreaByFunc(funcName: (Double, Double) -&gt; Double, a: Double, b: Double) { let area = funcName(a, b) return area } var result: Double = getAreaByFunc(triangle, a: 10, b: 15) print(&quot;area \(result)&quot;) 嵌套函数我们可以把函数定义在另外的函数体中，称作嵌套函数 func calculate(opr: String) -&gt; (Int, Int) -&gt; Int { func add(a: Int, b:Int) -&gt; Int { return a+b } func sub(a: Int, b: Int) -&gt; Int { return a-b } var result: (Int, Int) -&gt; Int switch opr { case &quot;+&quot;: result = add case &quot;-&quot;: result = sub defalut: result = add } return result } let f: (Int, Int) -&gt; Int = calculate(&quot;+&quot;) print(&quot;10 + 5 = \(f(10, 5))&quot;) 默认情况下，嵌套函数的作用域在外函数体内，但我们可以定义外函数的返回值类型为嵌套函数类型，从而将嵌套函数传递给外函数，被其他函数调用 闭包回顾嵌套函数一门计算机语言都支持闭包有两个前提： 支持函数类型，能够将函数作为参数或返回值传递 支持函数嵌套 闭包的概念闭包是自包含的匿名函数代码块，可以作为表达式、函数参数和函数返回值，闭包表达式的运算结果是一种函数类型 引用上节中的例子，其可以用如下代码来替换 func calculate(opr: String) -&gt; (Int, Int) -&gt; Int { var result: (Int, Int) -&gt; Int switch opr { case &quot;+&quot;: result = {(a: Int, b:Int) -&gt; Int in return a+b } case &quot;-&quot;: result = {(a: Int, b: Int) -&gt; Int in return a-b } defalut: result = {(a: Int, b:Int) -&gt; Int in return a+b } } return result } let f: (Int, Int) -&gt; Int = calculate(&quot;+&quot;) print(&quot;10 + 5 = \(f(10, 5))&quot;) 使用闭包表达式Swift中的闭包表达式的语法格式如下： //以下代码是标准形式的闭包 {(参数列表)-&gt;返回值类型 in 语句组}，如{(a:Int, b:Int)-&gt;Int in return a+b} //Swift可以根据上下文环境推断出参数类型和返回值类型，所以可以省略类型声明 {(a,b) in return a+b}或{a,b in return a+b} 其中，参数列表与函数中的的参数列表形式一样，返回值类型类似于函数中的返回值类型，但不同的是后面有in关键字 如果在闭包内部语句只有一条语句，如return a+b等，那么这种语句都是返回语句，前边的关键字return可以省略，省略后的形式如下 {a, b in a+b} //使用这种方式修改后的代码如下 func calculate(opr: String) -&gt; (Int, Int) -&gt; Int { var result: (Int, Int) -&gt; Int switch opr { case &quot;+&quot;: result = {a,b in a+b} case &quot;-&quot;: result = {a,b in a-b} defalut: result = {a,b in a+b} } return result } let f: (Int, Int) -&gt; Int = calculate(&quot;+&quot;) print(&quot;10 + 5 = \(f(10, 5))&quot;) 如果在闭包内部语句组只有一条语句，那么这种语句都是返回语句，前面的关键字return可以省略，如{a,b in a+b} 前边介绍的闭包表达式已经很简洁了，不过，Swift的闭包还可以再进行简化，Swift提供了参数名省略功能，可以用$0,$1等来指定闭包中的参数，$0指第一个参数，$1指第二个参数，如{$0+$1} result = {$0+$1} 闭包表达式本质上是函数类型，是有返回值的，我们可以直接在表达式中使用闭包的返回值。重新修改add和sub闭包，示例代码如下 let c1:Int = {(a: Int, b: Int)-&gt;Int in return a+b}(10, 5) print(&quot;10+5=\(c1)&quot;) 使用尾随闭包闭包表达式可以作为函数的参数传递，如果闭包表达式很长，就会影响程序的可读性，词尾闭包是一个书写在函数括号之后的闭包表达式，函数支持将其作为最后一个参数调用 func calculate(opr: String, funN:(Int, Int) -&gt; Int) { switch(opr) { case &quot;+&quot;: print(&quot;10 + 5 = \(funN(10, 5))&quot;) case &quot;-&quot;: print(&quot;10 + 5 = \(funN(10, 5))&quot;) } } calculate(&quot;+&quot;, funN:{(a: Int, b: Int) -&gt; Int in return a+b}) calculate(&quot;+&quot;){(a: Int, b: Int) -&gt; Int in return a+b} calculate(&quot;+&quot;){$0+$1} 捕获上下文中的变量和常量嵌套函数或闭包可以访问它所在的上下文的变量和常量，这个过程称为捕获值，即便是定义这些常量和变量的原始作用域已经不存在，嵌套函数或闭包仍然可以在函数体内或闭包体内引用和修改这些值 func makeArray() -&gt; (String) -&gt; [String] { var ary: [String] = [String]() func addElement(element: String) -&gt; [String] { ary.append(element) return ary } return addElement } let f = makeArray() print(f(&quot;张三&quot;))//[张三] print(f(&quot;李四&quot;))//[张三,李四] Swift语言中的面向对象特性在Swift语言中不仅类具有面向对象特性，结构体和枚举也都具有面向对象特性 面向对象概念和基本特征OOP的基本特征包括：封装性，继承性和多态性 封装性：就是尽可能隐藏对象的内部细节，对外形成一个边界，只保留有限的对外接口使之与外部发生联系 继承性：一些特殊类能够具有一般类的全部属性和方法，这称作特殊类对一般类的继承 多态性：是指在父类中定义的属性或方法被子类继承后，可以使同一个属性或方法在父类及其各个子类中具有不同的含义 Swift中的面向对象特性在Swift语言类中，类、结构体和枚举都是面向对象的数据类型，具有面向对象特性 结构体和枚举的实例一般不称为对象，这是因为结构体和枚举并不是彻底的面向对象类型，而只是包含了一些面向对象的特点，例如在Swift中继承只发生在类上，结构体和枚举不能继承 枚举定义枚举的语法格式如下： enum 枚举名 { 枚举的定义 } 在枚举类型中定义一组成员，与C和OC中枚举的主要作用是一样的，不同的是在C和OC中成员值是整数类型，因此在C和OC中枚举类型就是整数类型，而在Swift中，枚举的成员值默认情况下不是整数，如 enum WeekDays { case Monday case Tuesday case Wednesday case Thursday case Friday } enum WeekDays { case Monday,Tuesday,Wednesday,Thursday,Friday } var day = WeekDays.Friday day = WeekDays.Wednesday day = .Monday 使用枚举成员赋值时，我们可以采用完整的”枚举类型名.成员值”的形式，也可以省略枚举类型而采用”.成员值”的形式，这种省略形式的前提是，Swift编译器能够根据上下文环境推断类型 在switch中使用枚举类型时，switch语句中的case必须全部包含枚举中的所有成员，不能多也不能少，包括使用default的情况下，default也表示某个枚举成员 由于业务上的需要，要为每一个成员提供某种基本数据类型，我们可以为枚举类型提供原始值声明，这些原始值类型可以是字符、字符串、整数和浮点数等 enum 枚举名: 数据类型 { case 成员名 = 默认值 ... } enum WeekDays: Int { case Monday = 0 case Tuesday = 1 } 在枚举名后面跟：和数据类型就可以声明原始值枚举的类型，然后在定义case成员的时候需要提供原始值 在swift中除了可以定义一组成员值，还可以定义一组相关值，有点类型于C语言中的联合类 enum Figure { case Rectangle(Int, Int) case Circle(Int) } func printFigure(figure: Figure) { switch figure { case .Rectangle(let width, let height): print(&quot;矩形的宽：\(width) 高:\(height)&quot;) case .Circle(let radius): print(&quot;圆形的半径:\(radius)&quot;) } } var figure = Figure.Rectangle(1024, 768) printFigure(figure) 结构体与类在Swift中的结构体不仅可以定义成员变量(属性)，还可以定义成员方法，因此可以把结构体看做一种轻量级的类 Swift中的类和结构体非常相似，都具有定义和使用属性、方法、下标和构造函数等面向对象特性，但是结构体不具有继承性，也不具备运行时强制类型转换，使用析构函数和使用引用计数等能力 class 类名 { 定义的成员 } struct 结构体名 { 定义的结构体成员 } 实例化之后会开辟内存空间，只有类实例化才能称为对象，事实上，不仅仅是结构体和类可以实例化，枚举、函数类型和闭包开辟内存空间的过程也可以称为实例化，结果也可以叫做实例，但不能叫做对象 在众多的数据类型中，只需记住：只有类是引用类型，其他类型全部是值类型，即便结构体与类非常相似，它也是值类型 ===用于比较两个引用是否为同一个实例，!==则恰恰相反，这两个符号都只能用于引用类型，也就是类的实例。==和!=用来比较值类型，结构体和枚举都属于值类型，但是如果需要比较他们的==或者!=时，需要在这些类型中重载==和!=运算符，即定义相等规则 运算符重载就是定义一个重载运算符的函数，在需要执行被重载的运算符时调用该函数，以实现相应的运算，也就是说，运算符重载时通过定义函数实现的，如果没有重载去比较，则会出现编译错误 struct Department { var no: Int = 0 var name: String = &quot;&quot; } func ==(lhs: Department, rhs: Department) -&gt; Bool { return lhs.name == rhs.name &amp;&amp; lhs.no == rhs.no } func !=(lhs: Department, rhs:Department) -&gt; Bool { return lhs.name != rhs.name || lhs.no != rhs.no } 类型嵌套Swift语言中的类，结构体和枚举可以进行嵌套，即在某一类型的{}内部定义另一种类型，这种类型嵌套在Java中称为内部类，在C#中称为嵌套类 类型嵌套的优点是支持访问它外部的成员(包括方法、属性和其他的嵌套类型)，嵌套还可以有多个层次 嵌套类型的确定是它会使程序结构变得不清楚，使程序的可读性变差 可选链 在Swift中，声明一个变量的时候必须将变量先初始化赋值，而且赋值不能赋空值nil，否则会报编译错误。如果需要为其暂时赋空值nil，必须先定义变量的类型，然后再类型后边跟可选类型符?，此时变量就是可选类型，如果需要用到其值，可以用!为可选类型拆包。 关联链可以用显式拆包来操作，但是显式拆包(使用!)有一个弊端，如果可选链中某个环节为nil，将会导致代码运行时错误，我们可以采用更加温和的引用方式，使用?来代替原来的感叹号位置，?表示引用的时候，如果某个环节为nil，它不会抛出错误，而是会把nil返回给引用者，这种由问号引用可选类型的方式就是可选链 使用问号和使用感叹号的含义： 可选类型中的问号：声明这个类型是可选类型，访问这种类型的变量或常量时要使用感叹号 可选类型中的感叹号：声明这个类型也是可选类型，访问这种类型的变量或常量时可以不使用感叹号 可选链中的感叹号：多个实例具有关联关系，当从一个实例引用另外实例的方法、属性和下标等成员时就会形成引用链，由于这个链条某些环节可能有值，也可能没有值，因此需要采用感叹号的方式访问 可选链中的问号：在可选链中使用感叹号访问时，一旦链条某环节没有值，程序就会发生异常，于是我们把感叹号改成问号，这样某些环节没有值的时候返回nil，程序不会发生异常 访问范围访问范围主要有两个：模块和源文件，模块是一个应用程序包或一个框架，在Swift中，我们可以用import关键字将模块引入到自己的工程中，源文件指的是Swift中的swift文件，编译之后被包含在应用程序或框架中 Swift提供了3种访问级别，对应的访问修饰符为public，internal，private，这些访问修饰符可以修饰类、结构体、枚举等面向对象的类型，还可以修饰变量、常量、下标、元组、函数、属性等内容 public：可以被整个模块中的任何实体访问 internal：可以被同模块的实体访问，可以省略，换句话说，默认访问限定是internal private：只能在当前源文件中使用的实体，可以用作隐藏某些功能的实现细节 使用访问限定符有一些原则： 统一性原则： a，如果一个类型定义为internal或private，那么类型声明的变量或常量不能使用public访问级别(如下例) b，函数的访问级别不能高于它的参数和返回类型的访问级别 设计原则： a，如果我们编写的是应用程序，应用程序包中的所有Swift文件和其定义的实体都是供本应用使用，而不是给其他模块使用，那么我们就不用设置访问级别了，即使用默认的访问级别 b，如果我们开发的是框架，这种情况下要详细设计其中的Swift文件和实体的访问级别，让别人使用的可以设定为public，不想让别人看到的可以设定为internal或private 元组类型的访问级别：元组类型的访问级别遵循元组中字段最低级的级别 枚举类型的访问级别：枚举中成员的访问级别继承自该枚举，因此我们不能为枚举中的成员指定访问级别 private class Employee { var no: Int = 0 } internal struct Department { var name: String = &quot;&quot; } //编译错误 public let emp: Employee = Employee() //编译错误 public var department = Department() 选择类还是选择结构体最佳实践类和结构体都有如下功能： 定义存储属性 定义方法 定义下标 定义构造函数 定义扩展 实现协议 只有类才有的功能： 能够继承另外一个类 能够核对运行时对象的类型 析构对象释放资源 引用计数允许一个实例有多个引用 属性与下标Swift中的属性分为存储属性和计算属性，存储属性就是OC中的数据成员，计算属性不存储数据，但可以通过计算其他属性返回数据 集合类型中的元素还可以通过下标访问 存储属性存储属性可以存储数据，分为常量属性(用关键字let定义)和变量属性(用关键字var定义) 存储属性适用于类和结构体两种类型，不适用于枚举类型 可以在属性前边加关键字lazy，表明此属性是延时加载，即第一次访问时才加载，如果不访问就不会创建 //我们在dept属性前边添加了关键字lazy声明，这样的属性就是延时加载属性 class Employee { lazy var dept: Department = Department() } struct Department { let no: Int = 0 } let emp = Employee(); 计算属性计算属性提供了一个getter(取值访问器)来取值，以及一个可选的setter(设置访问器)来间接设置其他属性或变量的值 计算属性可以只有getter访问器，没有setter访问器，这就是只读计算属性，只读计算属性不能够赋值 面向对象类型 类型名 { 存储属性 ... var 计算属性名: 属性数据类型 { get { return 计算后属性值 } set(新属性值) { ... } } } class Employee { var firstName: String = &quot;Tony&quot; var lastName: String = &quot;Guan&quot; var fullName: String { get { return firstName+&quot;.&quot;+lastName } set(fullName) { var name = fullName.componentsSeparatedByString(&quot;.&quot;) firstName = name[0] lastName = name[1] } } } var emp = Employee() print(emp.fullName) emp.fullName = &quot;Tom.Guan&quot; print(emp.fullName) self可以用于类、结构体和枚举类型中，代表当前实例，通过self可以访问自身的实例方法和属性，self可以省略，如果属性名与局部变量或常量名发生冲突，self不能省略 属性观察者为了监听属性的变化，Swift提供了属性观察者，属性观察者能够监听存储属性的变化，即便变化前后的值相同，它们也能监听到 属性观察者不能监听延迟存储属性和常量存储属性的变化 Swift中的属性观察者主要有以下两个：willSet观察者这修改之前调用 didSet观察者在修改之后立即调用 面向对象类型 类型名 { ... var 存储属性: 属性数据类型 = 初始化值 { willSet(新值) { ...//如果没有新值，默认使用newValue变量 } didSet(旧值) { ...//如果没有旧值，默认使用oldValue变量 } } } 静态属性属性如果与实例无关，只与类有关，这种属性称为静态属性或类型属性 类中也可以定义静态计算属性，声明使用的关键字是class或static，这与结构体和枚举的声明不同 struct 结构体名/class 类名/enum 枚举名 { static var(或let) 存储属性 = &quot;XXX&quot; static var 计算属性名: 计算属性类型 { get { return 计算后属性值 } set(新属性值) { ... } } } 类静态计算属性如果使用static定义，则该属性不能在子类中被重写，如果使用class定义，则该属性可以被子类重写 在静态计算属性中不能访问实例属性(包括存储属性和计算属性)，但可以访问其他静态属性。在实例计算属性中能访问实例属性，也能访问静态属性 使用下标在Swift中，我们可以定义一些集合类型，他们可能会有一些集合类型的存储属性，这些属性中的元素可以通过下标访问，Swift中的下标相当于Java中的索引属性和C#中的索引器 面向对象类型 类型名 { 其他属性 ... subscript(参数:参数数据类型) -&gt; 返回值数据类型 { get { return 返回值 } set(新属性值) { ... } } } //实例：二维数组 struct DoubleDimensionalArray { let rows: Int, columns: Int var grid: [Int] init(rows: Int, columns: Int) { self.rows = rows self.columns = columns grid = Array(count: rows * columns, repeatedValue: 0) } subscript(row: Int, columns: Int) -&gt; Int { get { return grid[(row*columns)+columns] } set(newValue) { grid[(row*columns)+columns] = newValue } } } var ary = DoubleDimensionalArray(rows: 10, columns: 10) for var i=0; i&lt;10; i++ { for var j=0; j&lt;10; j++ { ary[i, j] = i * j; } } for var i=0; i&lt;10; i++ { for var j=0; j&lt;10; j++ { print(\t\(ary[i, j])); } print(\n); } 方法在面向对象分析与设计方法学中，类是由属性和方法组成的，方法用于完成某些操作，完成计算等任务 在Swift中方法是在枚举，结构体或类中定义的函数，因此我们之前介绍的函数知识都适用于方法，方法具有面向对象的特点，与属性类似，可以分为实例方法和静态方法 实例方法实例方法与实例属性类似，都隶属于枚举、结构体或类的个体，我们通过实例化这些类型创建实例，使用实例调用的方法 在Swift中，方法和函数的主要区别有以下3点： 方法的调用前边有主体，函数不需要 方法是在枚举、结构体或类内部定义的 方法命名规范与函数不同 一般语言，方法命名只是为了增强代码可读性，但在Swift中，方法命名更多的是处于与OC混合编程的需要，所以Swift的方法和OC的方法应该是及其相似的 结构体和枚举中的方法默认情况下是不能修改值类型变量属性的，如果要修改，则要将方法声明为变异的(mutating) class Employee { var dept: Department? } struct Department { var no: Int = 0 var name: String = &quot;&quot; var employees: [Employee] = [Employee]() func insertWithObject(anObject: Employee, index: Int) -&gt; () { let emp = anObject as! Employee employees.insert(emp, atIndex: index) } } 上述代码insert时会发生编译错误，提示employees属性不可以修改，这是因为employees是Employee的数组，即值类型。如果要修改它，就要将方法声明为变异的(mutating)，直接在枚举和结构体方法前加关键字mutating，将方法声明为变异方法，变异方法可以修改值类型的变量属性，但不能修改值类型的常量属性 如果是类的方法中可以修改值类型属性，不需要方法是变异的 在结构体和枚举的方法中能够修改引用类型属性，不需要方法是变异的 静态方法与静态属性类似，Swift中还定义了静态方法，也称为类型方法 静态方法的定义与静态属性类似，枚举和结构体的静态方法使用的关键字是static，类静态方法使用的关键字是static或class，如果使用static定义，则该方法不能再子类中被重写，如果使用class定义，则该方法可以被子类重写 静态方法与静态计算属性类似，它不能访问实例属性或实例方法 Swift的静态方法中也能使用self，这在其他语言中是没有的，此时self表示当前数据类型，不代表枚举、结构体或类的实例 构造与析构构造体和类在创建实例的过程中需要进行一些初始化工作，这个过程称为构造过程，相反，这些实例最后被释放的时候需要进行一些清除资源的工作，这个过程称为析构过程 构造函数结构体和类的实例在构造的过程中会调用一种特殊的init方法，称为构造函数 结构体和类在构造的过程中会调用一个构造函数，即便没有编写任何构造函数，编译器也会提供一个默认的构造函数 构造函数的主要作用是初始化实例，其中包括：初始化存储属性和其他的初始化 常量只能在定义的时候赋值，而在构造函数中常量属性可以不遵循这个规则，它们可以在构造函数中赋值 为了增强程序的可读性，Swift中的方法和函数可以使用外部参数，构造函数也可以使用外部参数名 构造函数中的外部参数名要比一般的方法和函数更有意义，由于构造函数命名都是init，如果一个类型中有多个构造函数，我们可以通过不同的外部参数名区分不同的构造函数 class RectangleA { var width: Double var height: Double init(W width: Double, H height: Double) { self.width = width self.height = height } } var rect = RectangleA(W: 10, H: 10) //构造函数中的局部参数名可以直接作为外部参数名使用 class RectangleA { var width: Double var height: Double init(width: Double, height: Double) { self.width = width self.height = height } } var rect = RectangleA(width: 10, height: 10) 方法调用使用第一个参数不需要指定外部参数名，而构造函数调用时不能省略第一个参数的外部参数名 构造函数重载Swift中的构造函数可以有多个，但它们的参数列表和返回值可以不同，这些构造函数构成重载 为了减少多个构造函数间的代码复用，在定义构造函数时可以通过调用其他构造函数来完成实例的部分构造过程，这个过程称为构造函数代理 由于类有继承关系，类构造函数代理比较复杂，分为横向代理和向上代理 横向代理类似于结构体类型构造函数代理，发生在同一类内部，这种构造函数称为便利构造函数，convienience表示便利构造函数 向上代理发生在继承情况下，在类的继承过程中要先调用父类构造函数，初始化父类的存储属性，这种构造函数称为指定构造函数 由于还未介绍类的继承，所以本节先讲解横向代理，横向代理用convenience关键字表示 class Rectangle { var width: Double var height: Double init(width: Double, height: Double) { self.width = width self.height = height } convenience init(length: Double) { self.init(length, length) } } 析构函数与构造过程相反，实例最后释放的时候需要清除一些资源，这个过程就是析构过程 析构过程中也会调用一种特殊的方法deinit，称为析构函数，析构函数的deinit没有返回值，也没有参数，也不需要参数的小括号，所以不能重载 deinit { ... } 类继承继承性是面向对象的重要特征之一，Swift中的继承只能发生在类上，不能发生在枚举和结构体上。在Swift中，一个类可以继承另一个类的方法、属性、下标等特征。当一个类继承其他类时，继承类叫做子类，被继承类叫做父类或超类，子类继承父类后，可以重写父类的方法、属性和下标等特征 从一个示例开始Swift中的继承与在OC等面向对象语言中的不同，OC中所有类的基类都是NSObject，Swift中没有规定这样的一个类 override init()是子类重写父类的构造函数 一般情况下，一个子类只能继承一个父类，这称为单继承，但有的情况下一个子类可以有多个不同的父类，这称为多重继承。在Swift中，类的继承只能是单继承，而多继承可以通过遵从多个协议实现。也就是说，Swift中，一个类只能继承一个父类，但可以遵循多个协议。 构造函数继承由于类有继承关系，类构造函数代理比较复杂，分为横向代理和向上代理，具体内容见上节，上节中也只介绍了横向代理，本节将介绍向上代理和指定构造函数调用 class Person { var name: String var age: Int func description() -&gt; String { return &quot;\(name) 年龄是\(age)&quot; } //便利构造函数 convenience init() { self.init(name: &quot;Tony&quot;) self.age = 18 } //便利构造函数 convenience init(name: String) { self.init(name: name, age: 18) } //指定构造函数 init(name: String, age: Int) { self.name = name self.age = age } } class Student: Person { var school: String //便利构造函数 convenience override init(name: name, age: Int) { self.init(name: name, age: age, school: &quot;清华大学&quot;) } //指定构造函数 init(name: String, age: Int, school: String) { self.school = school super.init(name: name, age: age) } } Swift限制构造函数之间代理调用的规则有3条，如下 指定构造函数必须调用其直接父类的指定构造函数 便利构造函数必须调用同一类中定义的其他构造函数 便利构造函数必须最终以调用一个指定构造函数结束 在Swift中，类的构造过程包含两个阶段 首先分配内存，初始化子类存储属性，沿构造函数链向上初始化父类存储属性，到达构造函数链顶部，初始化全部的父类存储属性 从顶部构造函数链往下，可以对每个类进行进一步修改存储属性、调用实例方法等处理 Swift编译器在构造过程中可以进行一些安全检查工作，这些工作可以有效地防止属性在初始化之前被访问，也可以防止属性被另一个构造函数意外地赋予不同的值。只有子类所有的存储属性初始化完成之后，才能调用父类构造函数初始化父类存储属性 为确保构造过程顺利完成，Swift提供了4种安全检查机制 指定构造函数必须保证其所在类的所有存储属性都初始化完成，之后才能向上调用父类构造函数代理 指定构造函数必须先向上调用父构造函数代理，然后再为继承的属性设置新值，否则指定构造函数赋予的新值将被父类中的构造函数所覆盖 便利构造函数必须先调用同一类中的其他构造函数代理，然后再为任意属性赋新值，否则便利构造函数赋予的新值将被同一类中的其他指定构造函数覆盖 构造函数在第一阶段构造完成之前不能调用实例方法，也不能读取实例属性，因为这时还不能保证要访问的实例属性已经被初始化 两段式构造过程中，第一阶段构造完成的标志是：调用完父类指定构造函数，即super.init语句，如果没有调用父类构造函数，则是调用完本身便利构造函数，即self.init语句 Swift中的子类的构造函数有两种来源：自己编写和从父类继承。但并不是父类的所有构造函数都能继承下来，能够从父类继承下来的构造函数是有条件的 如果子类没有定义任何指定构造函数，它将自动继承父类的所有指定构造函数 如果子类提供了所有父类指定构造函数的实现，无论是通过条件1继承过来的，还是通过自己编写实现的，它都将自动继承父类的所有便利构造函数 重写一个类继承另一个类的属性、方法、下标等特征后，子类可以重写override这些属性 重写实例属性的set/get访问器以及属性观察者需加override Class Person { var name: String = &quot;&quot; var age: Int = 0 } Class Student:Person { var school: String = &quot;哈佛&quot; override var age: Int { get { return super.age } set { super.age = newValue &lt; 8 ? 8 : newValue } } } Class Student:Person { var school: String = &quot;哈佛&quot; override var age: Int { willSet { print(&quot;学生年龄新值:\(newValue)&quot;) } didSet { print(&quot;学生年龄旧值:\(oldValue)&quot;) } } } static修改的静态属性不能被重写，class修改的静态属性可以被重写，如果要重写，前加override即可 class Account { class var staticProp: Double { return 0.0668 * 1000000; } } class TermAccount { override class var staticProp: Double { return 0.0700 * 1000000; } } 静态属性没有计算属性和存储属性之分 重写父类的实例方法需要在方法前加override static修改的静态方法不能被重写，class修改的静态方法可以被重写，如果要重写，前加override即可 下标是一种特殊属性。子类属性重写是重写属性的getter和setter访问器，对下标的重写也是重写下标的getter和setter访问器 class SquareMatrix: DoubleDimensionalArray { override subscript(row: Int, col: Int) { get { return super.grid[(row*col)+col] } set { super.grid[(row*col)+col] = newValue*newValue } } } 我们可以在类的定义中使用final关键字声明类、属性、方法和下标。final声明的类不能被继承，final声明的属性，方法和下标不能被重写 一个属性的willSet/didSet和getter/setter不能同时存在，重写的时候也不能同时存在，这是因为有willSet/didSet表示其是存储属性，有getter/setter表示其是计算属性 类型检查与转换is 操作符可以判断一个示例是否是某个类的类型，如果实例是目标类型，结果返回true，否则返回false 一般情况下，我们可以使用is操作符来判断它是哪一类的实例，然后在转换时我们可以使用as、as!或as?操作符将其进行类型转换。类型转换有两个方向：将父类类型转换为子类类型，这种转换称为向下转型(downcast)，将子类类型转换为父类类型，这种转换称为向上转型(upcast)，通常情况下的类型转换都是向下转型，而向上转型很少进行 原文中的讲解太不清晰，我们借用网上的一个来讲解as、as!、as? 这三种类型转换操作符的异同，以及各自的使用场景 as使用场合 从派生类转换为基类，向上转型（upcasts） class Animal {} class Cat: Animal {} let cat = Cat() let animal = cat as Animal 消除二义性，数值类型转换 let num1 = 42 as CGFloat let num2 = 42 as Int let num3 = 42.5 as Int let num4 = (42 / 2) as Double switch 语句中进行模式匹配（如果不知道一个对象是什么类型，你可以通过switch语法检测它的类型，并且尝试在不同的情况下使用对应的类型进行相应的处理） switch animal { case let cat as Cat: print(&quot;如果是Cat类型对象，则做相应处理&quot;) case let dog as Dog: print(&quot;如果是Dog类型对象，则做相应处理&quot;) default: break } as!使用场合 向下转型（Downcasting）时使用。由于是强制类型转换，如果转换失败会报 runtime 运行错误。 class Animal {} class Cat: Animal {} let animal :Animal = Cat() let cat = animal as! Cat as?使用场合 as? 和 as! 操作符的转换规则完全一样。但 as? 如果转换不成功的时候便会返回一个 nil 对象。成功的话返回可选类型值（optional），需要我们拆包使用。 由于 as? 在转换失败的时候也不会出现错误，所以对于如果能确保100%会成功的转换则可使用 as!，否则使用 as? let animal:Animal = Cat() if let cat = animal as? Cat { print(&quot;cat is not nil&quot;) } else { print(&quot;cat is nil&quot;) } Swift还提供了两种类型来表示不确定类型：AnyObject和Any。AnyObject可以表示任何类的类型，而Any可以表示任何类型，包括类和其他数据类型，也包括Int和Double等基本数据类型，当然也包括AnyObject类型 在Objective-C和Swift混合编程时，Objective-C的id类型和Swift的AnyObject类型可以互换，但是两者有本质区别。id类型是泛型，可以代表任何对象指针类型，编译时不检查id类型，是动态的。而Swift中的AnyObject类型是一个实实在在表示的类型，编译时编译器会检查AnyObject类型 原则上若能够使用具体的数据类型，则尽量不要使用AnyObject类型，更要少考虑使用Any类型。从集合取出这些实例时，请尽可能地将AnyObject或Any类型转换为特定类型，然后再进行接下来的操作 扩展扩展(extension)机制只在Swift和Objective-C两种语言中有，Objective-C中的称分类(category)机制 轻量级继承机制在Swift中可以使用一种扩展机制，在原始类型(类、结构体和枚举)的基础上添加新功能。扩展是一种轻量级的继承机制，即使原始类型被限制继承，我们仍然可以通过扩展机制继承原始类型的功能 扩展机制还有另外一个优势：它扩展的类型可以是类、结构体和枚举，而继承只能是类，不能是结构体和枚举 在设计基于Swift语言的程序时，我们要优先考虑扩展机制是否能够满足要求，如果不能再考虑继承机制 声明扩展//声明扩展的语法格式如下 extension 类型名 { //添加新功能 } 具体而言，Swift中的扩展机制可以在原始类型中添加的新功能包括 扩展实例计算属性和类型计算属性 //实例计算属性 extension Int { var errorMessage: String { var errorStr = &quot;&quot; switch self { case -2: errorStr = &quot;没有用户信息&quot; case -1: errorStr = &quot;用户名或密码错误&quot; case 0: errorStr = &quot;登录成功&quot; default: errorStr = &quot;&quot; } return errorStr } } let message = (-1).errorMessage print(&quot;Error Code : -1, Error Message : \(message)&quot;) //静态计算属性 structure Account { var amount: Double = 0.0 var owner: String = &quot;&quot; } extension Account { static var interestRate: Double { return 0.0668 } } 扩展中不仅可以定义只读计算属性、还可以定义读写计算属性、实例计算属性和静态计算属性，但是不能定义存储属性 扩展实例方法和类型方法 我们可以在原始类型上扩展方法，包括实例方法和静态方法。这些添加方法的定义与普通方法的定义是一样的。 扩展构造函数 扩展结构体和枚举等值类型和扩展引用类型（如类类型）有所区别。扩展类的时候能向类中添加新的便利构造函数，但不能添加新的指定构造函数或析构函数。指定构造函数和析构函数只能由原始类提供。而值类型的扩展没有此限制 扩展下标 可以把下标认为是特殊的属性，可以实现索引访问属性。我们可以在原始类型的基础上扩展下标功能 协议协议(protocol)是Swift和Objective-C语言中的名称，在Java语言中称为接口，在C++中是纯虚类 协议概念协议是高度抽象的，它只规定抽象方法名，参数列表和返回值等信息，不给出具体的实现，这种抽象方法由遵从该协议的遵从者实现，具体实现过程在Swift和Objective-C中称为遵从协议或实现协议 协议在Swift中，类、结构体和枚举类型都可以声明遵从一个或多个协议，并提供该协议所要求属性和方法的具体实现。 //协议定义语法 protocol 协议名 { //协议内容 } //声明遵从协议 类型 类型名: 协议1, 协议2 { //遵从协议内容 } //如果一个类继承父类的同时也要遵从协议，应当把父类放在所有协议之前 class 类型名: 父类, 协议1, 协议2 { //遵从协议内容 } 具体而言，协议可以要求其遵从者提供实例属性、静态属性、实例方法和静态方法等内容的实现 协议方法协议可以要求其遵从者实现某些指定方法，包括实例方法和静态方法。这些方法在协议中被定义，协议方法与普通方法类似，但不支持变长参数和默认值参数，也不需要大括号和方法体 实例方法 //定义 protocol Figure { func onDraw() } //遵从 class Rectangle: Figure { func onDraw() { print(&quot;绘制矩形...&quot;) } } 静态方法 //定义 protocol Account { static func interestBy(amount: Double) -&gt; Double } class ClassImp: Account { class func interestBy(amount: Double) -&gt; Double { return 0.0688 * amount } } 在协议中定义静态方法时前面要添加static关键字，那么遵从该协议的时候，遵从者静态方法前的关键字是class还是static呢？这与遵从者的类型有关系，如果遵从者是结构体或枚举，关键字就是static，如果遵从者是类，关键字可以使用class或static，使用class遵从者的子类中可以重写该静态方法，使用static遵从者的子类不可以重写该静态方法 静态方法定义和声明都比较麻烦，与具体的类型有关，使用的时候需要注意 在结构体和枚举类型中可以定义变异方法，而在类中没有这种方法，原因是结构体和枚举类型中的属性是不可以修改的，通过定义变异方法可以再变异方法中修改这些属性，而类是引用类型，不需要变异就可以修改自己的属性 在协议定义变异方法时，方法前面要添加mutating关键字。类、结构体和枚举类型都可以遵从变异方法，类遵从变异方法时，前面不需要关键字mutating，而结构体和枚举遵从变异方法时，前面需要关键字mutating 协议属性协议可以要求其遵从者实现某些指定的属性，包括实例属性和静态属性。在具体定义的时候，每一种属性都可以有只读和读写之分。 在协议中定义静态属性时前面要添加static关键字，那么遵从该协议的时候，遵从者静态属性前的关键字是class还是static呢？这与遵从者的类型有关系，如果遵从者是结构体或枚举，关键字就是static，如果遵从者是类，关键字可以使用class或static，使用class遵从者的子类中可以重写该静态属性，使用static遵从者的子类不可以重写该静态属性 面向协议编程在Swift中协议是作为数据类型使用的，这是面向协议编程具体实现的一个方面，协议可以出现在任意允许其他数据类型出现的地方，如下： 可以作为函数、方法或构造函数中的参数类型或者返回值类型 可以作为常量、变量或属性的类型 可以作为数组、字典和Set等集合的元素类型 协议作为类型使用，与其他类型没有区别，不仅可以使用as操作符进行类型转换，还可以使用is操作符判断类型是否遵从了某个协议。除了不能初始化，协议可以像其他类型一样使用。 协议的继承与类的继承一样 Swift2以后协议类型可以被扩展了，这也是面向协议编程非常重要的特征，这样我们就可以很灵活地将一些新功能添加到协议遵从者中去 protocol Person { var fullName: String {get} } extension Person { func printFullName() { print(&quot;Print full name : \(fullName)&quot;) } } 协议的扩展和类的扩展类似，在扩展的同时必须要实现其方法，而不是跟协议一样只是定义 多个协议可以临时合成一个整体，作为一个类型使用。首先要有一个类型在声明是遵从多个协议。 在扩展中也可以声明遵从某个协议，其语法如下： extension 类型名: 协议名, 协议名2 { //协议内容 } 泛型泛型可以使我们在程序代码中定义一些可变的部分，在运行的时候指定。使用泛型可以最大限度地重用代码、保护类型的安全以及提高性能，在Swift集合中数组、Set和字典都是泛型集合 //在函数名isEquals后面添加&lt;T&gt;，参数的类型也被声明为T，T称为占位符，函数在每次调用时传入实际类型才能决定T所代表的类型 //我们需要在占位符T后面添加冒号和协议类型，这种表示方式称为泛型约束，它能够替换T的类型，在本例中，T的类型必须遵从Comparable协议的具体类 func isEqual&lt;T: Comparable&gt;(a: T, b: T) -&gt; Bool { return (a == b) } //可以同时使用多种类型参数，我们需要提供多个占位符，之间用`，`分隔 func isEquals&lt;T, U&gt;(a: T, b: U) -&gt; Bool {...} //占位符不仅仅可以替代参数类型，也可以替代返回值类型 func isEquals&lt;T&gt;(a: T, b: T) -&gt; T {...} 泛型不仅可以再函数中使用，而且可以应用于类、结构体和枚举等类型定义，这些类型就是泛型类型，泛型类型一般都是与集合有关的类型，如数组、Set和字典等 泛型类型还可以支持扩展，这种情况下定义的扩展与其他普通扩展没有什么区别 Swift内存管理在iOS平台上Objective-C的内存管理经历过两个阶段：手动引用计数内存管理(Manual Reference Counting, MRC)和自动引用计数内存管理(Automatic Reference Counting, ARC)，MRC就是由程序员自己负责管理对象声明周期，负责对象的创建和销毁。ARC就是程序员不用关心对象释放的问题，编译器在编译时在合适的位置插入代码来释放对象的内存 Swift内存管理概述Swift在内存管理方面吸收了Objective-C的先进思想，采用了ARC(自动引用计数)内存管理模式 虽然ARC内存管理和值类型内存管理都不需要程序员管理，但两者在本质上还是有区别的。ARC和MRC一样都是针对引用类型的管理，引用类型与Objective-C中的对象指针类型一样，内存分配区域都是在堆上的，需要人为管理。而值类型内存分配区域是在栈上的，由处理器管理，不需要人为管理 强引用循环每个Swift类创建的对象都有一个内部计数器，这个计数器跟踪对象的引用次数称为引用计算(Reference Count, RC)，当对象被创建的时候，引用计数为1，每次对象被引用的时候其引用计算加1，当不需要的时候对象引用断开，其引用计数减1，当对象的引用次数为0的时候，对象的内存才被释放 当两个对象的存储属性互相引用对方的时候，一个对象释放的前提是对方先释放，另一个对象释放的前提也是对方先释放，这样就会导致类似“死锁”的状态，最后谁都不能释放，从而导致内存泄漏 打破强引用循环Swift提供了两种办法来解决强引用循环问题：弱引用(weak reference)和无主引用(unowned reference) 弱引用允许循环引用中的一个对象不采用强引用方式引用另外一个对象，这样就不会引起强引用循环问题 弱引用适用于引用对象可以没有值的情况，因为弱引用可以没有值，我们必须将每一个弱引用声明为可选类型，使用关键字weak声明为弱引用 无主引用与弱引用一样，允许循环引用中的一个对象不采用强引用方式引用另外一个对象，因此不会引起强引用循环问题 无主引用适用于引用对象永远有值的情况，它总是被定义为非可选类型，使用关键字unowned表示这是一个无主引用 闭包中的强引用循环由于闭包本质上是函数类型，所以也是引用类型，因此也可能在闭包和上下文捕获变量(或常量)之间出现强引用循环问题 并不是所以的捕获变量或常量都会发生强引用循环问题，只有将一个闭包赋值给对象的某个属性，并且这个闭包体中使用了该对象，才会产生闭包强引用循环 解决闭包强引用循环问题有两种方法：弱引用和无主引用。到底该采用弱引用还是无主引用，与两个对象之间的选择条件是：捕获的对象是否可以为nil 如果闭包和捕获的对象总是互相引用并且总是同时销毁，则将闭包内的捕获声明为无主引用。当捕获的对象有时可能为nil时，则将闭包内的捕获声明为弱引用。如果捕获的对象绝对不会为nil，那么应该采用无主引用 错误处理Swift语言的错误处理功能提供了处理程序运行时处理错误的能力。Swift2提供了新的do-try-catch错误处理模式：显示尝试操作，如果失败则处理错误，最后完成后释放资源 Cocoa错误处理模式每一种语言几乎都提供自己的错误处理模式，由于历史的原因Swift错误处理模式，在Swift1和Swift2中截然不同，Swift1中的错误处理代码如下： var err: NSError? let contents = NSString(contentsOfFile: filePath, encoding: NSUTF8StringEncoding, error: &amp;err) if err!=ni { //错误处理 } C语言中常将参数的地址传递给函数，然后在函数内部改变参数内容，当函数调用完成后该参数就有内容了，这种方式可以同时返回多个参数 do-try-catch错误处理模式事实上Cocoa和Swift1的错误处理模式存在很多弊端，例如为了在编程时省事，我们往往给error参数传递一个nil，或者方法调用完成后不去判断error是否为nil，不进行错误处理，因此一旦真的发生错误，程序就会奔溃。 完整的do-try-catch错误处理模式语法如下： do { try 语句 成功处理语句 } catch 匹配错误 { 错误处理语句 } 在Swift中错误类型必须遵从ErrorType协议，其次是考虑错误类型的匹配，它应该设计为枚举类型，因为枚举类型非常适合将一组相关值关联起来 enum DAOError: ErrorType { case NoData case PrimaryKeyNull } do { //try访问数据表函数或方法 } catch DAOError.NoData { print(&quot;没有数据&quot;) } catch DAOError.PrimaryKeyNull { print(&quot;主键为空...&quot;) } 能放到try后面调用的函数或方法都是有要求的，它们是有可能抛出错误，但你要在这些函数或方法声明的参数后加上throws关键字，表示这个函数或方法可以抛出错误 func remove(model: Note) throws { if (has no model) { throws DAOError.NoData } else if (no primary key) { throws DAOError.PrimaryKeyNull } } 产生并抛出错误有两种方式 在函数或方法中通过throw语句人为的抛出错误 在函数或方法中调用其他可以抛出错误的函数或方法，但是没有捕获处理，会导致错误被传播开来 我们在使用try进行错误处理的时候经常会看到try后面跟有问好(?)和感叹号(!)，它们有什么区别呢 try? 会将错误转换为可选值，当调用try?+函数或者方法语句时，如果函数或方法抛出错误，程序不会奔溃，而是函数是会返回一个nil，如果没有抛出错误，则返回可选值 try! 如果出现错误就会出现运行时错误，导致程序奔溃，所以使用try!时必须确保程序不会发生错误 try、try? 和 try! 使用都可以打破错误传播链条。错误抛出后被传播给它的调用者，这样就形成了一个传播链条，但有时我们确实不想让错误传播下去，这时便可以使用try、try? 和 try!语句 Swift编码规范本书中讲解到的编码规范太简洁，后边我会将编码规范作为一个专题来讲解]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC高级编程2]]></title>
    <url>%2F2015%2F05%2F29%2FObjective-C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B2(%E6%9C%AA%E5%AE%8C%E6%88%90)%2F</url>
    <content type="text"></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC高级编程1]]></title>
    <url>%2F2015%2F04%2F24%2FObjective-C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B1%2F</url>
    <content type="text"><![CDATA[自动引用计数自动引用计数(ARC, Automatic Reference Counting)：顾名思义，是指内存管理中对引用采取自动计数的技术。 在Objective-C中采用Automatic Reference Counting（ARC）机制，让编译器来进行内存管理。在新一代Apple LLVM编译器中设置ARC为有效状态，就无需再次键入retain或者release代码，这在降低程序奔溃，内存泄漏等风险的同时，很大程序上减少了开发程序的工作量。编译器完全清楚目标对象，并能立刻释放那些不在被使用的对象。如此一来，应用程序将具有可预测性，且能流畅运行，速度也将大幅提升。 在LLVM编译器中设置ARC为有效状态，就无需再次键入retain或者是release代码。 ARC的四个标准： 自己生成的对象，自己持有 使用以下名称开头的方法名意味着自己生成的对象只有自己持有alloc、new、copy、mutableCopy，如allocMyObject、newThatObject等，但对于以下名称，即使用alloc/new/copy/mutableCopy名称开头，并不属于同一类别的方法。allocate、newer、copying。 非自己生成的对象，自己也能持有 id obj = [NSMutableArray array];此例中，NSMutableArray类对象被赋值给变量obj，但变量obj自己并不持有该对象。使用retain方法可以持有该对象[obj retain]; 不再需要自己持有的对象时记得释放 id obj = [[NSObject alloc] init];[obj release];。 使用NSMutableArray类的array类方法等可以取得谁都不持有的对象，这些方法都是通过autorelease而实现的。此外，根据上下文的命名规范，这些用来取得谁都不持有的对象的方法名不能以alloc/new/copy/mutableCopy开头，如下例： - (id)object { id obj = [[NSObject alloc] init]; [obj autorelease]; return obj; } 非自己持有的对象不要释放 释放非自己持有的对象会造成程序奔溃。因此绝对不要去释放非自己持有的对象。 顾名思义，Autorelease就是自动释放。这看上去很像ARC，但实际上它更类似C语言中自动变量（局部变量）的特性。自动变量是在程序执行时，若某自动变量超出其作用域，该自动变量将会被自动废弃。Autorelease会像C语言的自动变量那样来对待对象实例。当超出其作用域时，对象实例的release方法会被调用。另外，同C语言的自动变量不同的是，编程人员可以设定变量的作用域。Autorelease的具体使用方法如下： 生成并持有NSAutoreleasePool对象 调用已分配对象的Autorelease实例方法 废弃NSAutoreleasePool对象 NSAutoreleasePool对象的生存周期相当于C语言变量的作用域。对于所有调用过Autorelease实例方法的对象，在废弃NSAutoreleasePool对象时，都将调用release实例方法。 另外，Cocoa框架中也有很多类方法用于返回Autorelease的对象。比如NSMutableArray类的arrayWithCapacity类方法id array = [NSMutableArray arrayWithCapacity:1];等同于如下代码id array = [[NSMutableArray arrayWithCapacity:1] autorelease]; 设置ARC有效的编译方法如下所示： 使用clang(LLVM编译器)3.0或以上版本 指定编译器属性为”-fobjc-arc” ARC有效时，id类型和对象类型同C语言其他类型不同，其类型上必须附加所有权修饰符，所有权修饰符一共有4种： __strong修饰符 __weak修饰符 __unsafe__unretained修饰符 __autoreleasing修饰符 __strong修饰符是id类型和对象类型默认的所有权修饰符。它修饰的变量，不仅只在变量作用域中，在赋值上也能够正确地管理其对象的所有者。 strong修饰符容易发生循环引用而引起内存泄漏。所谓内存泄漏就是应当废弃的对象在超出其生存周期后继续存在。weak修饰符与strong修饰符相反，提供弱引用。弱引用不能持有对象实例。weak修饰符还有另一优点，在持有某对象的弱引用时，若该对象被废弃，则此弱引用将自动失效且处于nil被赋值的状态(空弱引用)。像这样，使用weak修饰符可避免循环引用。通过检查附有weak修饰符的变量是否为nil，可以判断被赋值的对象是否已废弃。 遗憾的是，weak修饰符只能用于ios5以上以及OS X Lion以上版本的应用程序。在ios4以及OS X Snow Leopard的应用程序中可使用unsafe-unretained修饰符来代替 unsafe-unretained修饰符正如其名unsafe所示，是不安全的所有权修饰符。尽管ARC式的内存管理是编译器的工作，但附有unsafe-unretained修饰符的变量不属于编译器的内存管理对象。这一点要注意。在使用unsafe-unretained修饰符时，赋值给strong修饰符的变量时必须确定赋值对象的确实存在。 //ARC无效 NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; id obj = [[NSObject alloc] init]; [obj release]; [pool drain]; //ARC有效 @autoreleasepool { id __autoreleasing obj = [[NSObject alloc] init]; } 由于return使得对象变量超出其作用域，所以该强引用对应的自己持有的对象会被自动释放，但该对象作为函数的返回值，编译器就会自动将其注册到Autoreleasepool中。 在ARC有效的情况下编译源代码，必须遵守一定的规则。下面就是具体的ARC的规则： 不能使用retain/release/retainCount/autorelease 不能使用NSAllocateObject/NSDeallocateObject方法 必须遵守内存管理的方法命名规则 不要显式的调用dealloc方法 使用@Autoreleasepool块代替NSAutoreleasePool 不能使用区域(NSZone) 对象型变量不能作为C语言结构体的成员 显式转换”id”和”void *” void *类型的指针是有指向的指针，但它指向的数据的类型暂时不确定，所以先弄成void *类型，后期一般要强制转换。要把对象型变量加入到结构体成员中时，可强制转换为void *类型或是附加前边所述的unsafe-unretained修饰符。unsafe-unretained修饰符的变量不属于编译器的内存管理对象。如果管理时不注意赋值对象的所有者，便有可能遭遇内存泄漏或程序奔溃。这点在使用时应多加注意。 struct Data { NSMutableArray __unsafe__unretained *array; }; id类型或对象型变量赋值给void *或者逆向赋值时都需要进行特定的转换。如果只想单纯地赋值，则可以使用__bridge转换。 id obj = [[NSObject alloc] init]; void *p = (__bridge void *) obj; id o = (__bridge id)p; 但是转换为void *的__bridge转换，其安全性与赋值给__unsafe_unretained修饰符相近，甚至会更低。如果管理时不注意赋值对象的所有者，就会因悬垂指针而导致程序奔溃。 __bridge转换中还有另外两种转换，分别是__bridge__retained转换和__bridge_transfer转换，__bridge__retained转换可使要转换赋值的变量也持有所赋值的对象。__bridge_transfer转换提供与此相反的动作，被转换的变量所持有的对象在该变量被赋值给转换目标变量后随之释放。 Core Foundation对象主要使用在C语言编写的Core Foundation框架中，并使用引用计数的对象。在ARC无效时，Core Foundation框架中的retain/release分别是CFRetain/CFRelease。 Core Foundation对象与Objective-C对象的区别很小，不同之处只在于是由哪一个框架(Foundation框架还是Core Foundation)所生成的。无论是由哪种框架生成的对象，一旦生成之后，便能在不同的框架中使用。Foundation框架的API生成并持有的对象可以用Core Foundation框架的API释放。当然反过来也是可以的 因为Core Foundation对象与Objective-C对象没有区别，所以在ARC无效时，只用简单的C语言的转换也能实现互换。另外这种转换不需要使用额外的CPU资源，因此也被称为”免费桥”(Toll-Free-Bridge) 属性声明的属性与所有权修饰符的对应关系 assign __unsafe__unretained修饰符copy __strong修饰符retain __strong修饰符strong __strong修饰符unsafe-unretained __strong修饰符weak __weak修饰符]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AFNetworking源码解析]]></title>
    <url>%2F2015%2F03%2F27%2FAFNetworking%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[移动互联网技术中，最常用的一个技术点就是客户端和服务端之间的交互了，在这些技术和协议中，有个应用最广泛的的技术点就是超文本传输协议（HTTP，HyperText Transfer Protocol)。以前做Android的时候了解过此协议，它是一个客户端和服务器端请求和应答的标准（TCP），用于对数据进行格式化，让客户端和服务端两边都能懂得起。客户端向服务器发送一个请求，请求头包含请求的方法、URL、协议版本、以及包含请求修饰符、客户信息和内容的类似于MIME的消息结构。服务器以一个状态行作为响应，响应的内容包括消息协议的版本，成功或者错误编码加上包含服务器信息、实体元信息以及可能的实体内容。 HTTP简介通常HTTP消息包括客户机向服务器的请求消息和服务器向客户机的响应消息。这两种类型的消息由一个起始行，一个或者多个头域，一个指示头域结束的空行和可选的消息体组成。HTTP的头域包括通用头，请求头，响应头和实体头四个部分。每个头域由一个域名，冒号（:）和域值三部分组成。域名是大小写无关的，域值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。 HTTP报文由从客户机到服务器的请求和从服务器到客户机的响应构成。请求报文格式如下： 请求行 － 通用信息头 － 请求头 － 实体头 － 报文主体 请求行以方法字段开始，后面分别是 URL 字段和 HTTP 协议版本字段，并以 CRLF 结尾。SP 是分隔符。除了在最后的 CRLF 序列中 CF 和 LF 是必需的之外，其他都可以不要。有关通用信息头，请求头和实体头方面的具体内容可以参照相关文件。 应答报文格式如下： 状态行 － 通用信息头 － 响应头 － 实体头 － 报文主体 状态码元由3位数字组成，表示请求是否被理解或被满足。原因分析是对原文的状态码作简短的描述，状态码用来支持自动操作，而原因分析用来供用户使用。客户机无需用来检查或显示语法。有关通用信息头，响应头和实体头方面的具体内容可以参照相关文件。 iOS SDK中的HTTP框架 有的程序员老了,还没听过NSURLSession 有的程序员还嫩,没用过NSURLConnection 有的程序员很单纯,他只知道AFN. 引用别人的一首诗来介绍一下，NSURLConnection在iOS9被宣布弃用,NSURLSession从13年发展到现在,终于迎来了它独步江湖的时代.NSURLSession是苹果在iOS7后为HTTP数据传输提供的一系列接口,比NSURLConnection强大,坑少,好用.今天引用这位诗人的一篇文章来介绍一下iOS7中新出的类NSURLSession的用法，原文请参见此处 除了NSURLSession,文中还会频繁地出现NSURLSessionConfiguration和NSURLSessionTask两个类.先认识一下,混个脸熟吧. 使用NSURLSession,拢共分两步: 第一步 通过NSURLSession的实例创建task 第二步 执行task NSURLSessionTask可以简单理解为任务:如数据请求任务,下载任务,上传任务and so on.我们使用的是他的子类们: NSURLSessionTask(抽象类) NSURLSessionDataTask NSURLSessionUploadTask NSURLSessionDownloadTask 从这几个子类的名字就可以大概猜出他们的作用了.接下来我们就从不同类型的任务出发,来使用session NSURLSessionDataTask字面上看是和数据相关的任务,但其实dataTask完全可以胜任downloadTask和uploadTask的工作.这可能也是我们使用最多的task种类. 简单GET请求如果请求的数据比较简单,也不需要对返回的数据做一些复杂的操作.那么我们可以使用带block // 快捷方式获得session对象 NSURLSession *session = [NSURLSession sharedSession]; NSURL *url = [NSURL URLWithString:@&quot;http://www.daka.com/login?username=daka&amp;pwd=123&quot;]; // 通过URL初始化task,在block内部可以直接对返回的数据进行处理 NSURLSessionTask *task = [session dataTaskWithURL:url completionHandler:^(NSData *data, NSURLResponse *response, NSError error) { NSLog(@&quot;%@&quot;, [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:nil]); }]; // 启动任务 [task resume]; 注意: 所有类型的task都要调用resume方法才会开始进行请求. 简单POST请求POST和GET的区别就在于request,所以使用session的POST请求和GET过程是一样的,区别就在于对request的处理. NSURL *url = [NSURL URLWithString:@&quot;http://www.daka.com/login&quot;]; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url]; request.HTTPMethod = @&quot;POST&quot;; request.HTTPBody = [@&quot;username=daka&amp;pwd=123&quot; dataUsingEncoding:NSUTF8StringEncoding]; NSURLSession *session = [NSURLSession sharedSession]; // 由于要先对request先行处理,我们通过request初始化task NSURLSessionTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) { NSLog(@&quot;%@&quot;, [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:nil]); }]; [task resume]; NSURLSessionDataDelegate代理方法NSURLSession提供了block方式处理返回数据的简便方式,但如果想要在接收数据过程中做进一步的处理,仍然可以调用相关的协议方法.NSURLSession的代理方法和NSURLConnection有些类似,都是分为接收响应、接收数据、请求完成几个阶段. // 使用代理方法需要设置代理,但是session的delegate属性是只读的,要想设置代理只能通过这种方式创建session // configuration参数(文章开始提到的)需要传递一个配置,我们暂且使用默认的配置[NSURLSessionConfiguration defaultSessionConfiguration]就好,后面会说下这个配置是干嘛用的 // delegateQueue参数表示协议方法将会在哪个队列(NSOperationQueue)里面执行 NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[[NSOperationQueue alloc] init]]; // 创建任务(因为要使用代理方法,就不需要block方式的初始化了) NSURLSessionDataTask *task = [session dataTaskWithRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;http://www.daka.com/login?userName=daka&amp;pwd=123&quot;]]]; // 启动任务 [task resume]; //对应的代理方法如下: // 1.接收到服务器的响应 - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler { // 允许处理服务器的响应，才会继续接收服务器返回的数据 // 如果在接收响应的时候需要对返回的参数进行处理(如获取响应头信息等),那么这些处理应该放在前面允许操作的前面 completionHandler(NSURLSessionResponseAllow); } // 2.接收到服务器的数据（可能调用多次） - (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data { // 处理每次接收的数据 } // 3.请求成功或者失败（如果失败，error有值） - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error { // 请求完成,成功或者失败的处理 } NSURLSessionDownloadTask文件下载可以使用NSURLSessionDownloadTask这个子类 简单下载NSURLSessionDownloadTask同样提供了通过NSURL和NSURLRequest两种方式来初始化并通过block进行回调的方法.下面以NSURL初始化为例 NSURLSession *session = [NSURLSession sharedSession]; NSURL *url = [NSURL URLWithString:@&quot;http://www.daka.com/resources/image/icon.png&quot;] ; NSURLSessionDownloadTask *task = [session downloadTaskWithURL:url completionHandler:^(NSURL *location, NSURLResponse *response, NSError *error) { // location是沙盒中tmp文件夹下的一个临时url,文件下载后会存到这个位置,由于tmp中的文件随时可能被删除,所以我们需要自己需要把下载的文件挪到需要的地方 // response.suggestedFilename是从相应中取出文件在服务器上存储路径的最后部分,如数据在服务器的url为http://www.daka.com/resources/image/icon.png, 那么其suggestedFilename就是icon.png NSString *path = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:response.suggestedFilename]; // 剪切文件 [[NSFileManager defaultManager] moveItemAtURL:location toURL:[NSURL fileURLWithPath:path] error:nil]; }]; // 启动任务 [task resume]; NSURLSessionDownloadDelegate代理方法同样的,downloadTask也提供了配套的代理方法 // 每次写入调用(会调用多次) - (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite { // 可在这里通过已写入的长度和总长度算出下载进度 CGFloat progress = 1.0 * totalBytesWritten / totalBytesExpectedToWrite; NSLog(@&quot;%f&quot;,progress); } // 下载完成调用 - (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location { // location还是一个临时路径,需要自己挪到需要的路径(caches下面) NSString *filePath = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:downloadTask.response.suggestedFilename]; [[NSFileManager defaultManager] moveItemAtURL:location toURL:[NSURL fileURLWithPath:filePath] error:nil]; } // 任务完成调用 - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error { } NSURLSessionUploadTask在NSURLSession中,文件上传方式主要有以下两种: NSURLSessionUploadTask *task = [[NSURLSession sharedSession] uploadTaskWithRequest:request fromFile:fileName completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) { }]; 和 [self.session uploadTaskWithRequest:request fromData:body completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) { NSLog(@&quot;-------%@&quot;, [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:nil]); }]; 处于安全性考虑,通常我们会使用POST方式进行文件上传,所以较多使用第二种方式. 但是,NSURLSession并没有为我们提供比NSURLConnection更方便的文件上传方式.方法中body处的参数需要填写request的请求体(http协议规定格式的大长串).因为你有90%的可能性用了AFNetworking,即使是自己写的应该也是copy,所以代码就不贴了，我们只说方法. 断点下载NSURLSessionDownloadTask提供了与断点下载相关的几个方法: // 使用这种方式取消下载可以得到将来用来恢复的数据,保存起来 [self.task cancelByProducingResumeData:^(NSData *resumeData) { self.resumeData = resumeData; }]; // 由于下载失败导致的下载中断会进入此协议方法,也可以得到用来恢复的数据 - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error { // 保存恢复数据 self.resumeData = error.userInfo[NSURLSessionDownloadTaskResumeData]; } // 恢复下载时接过保存的恢复数据 self.task = [self.session downloadTaskWithResumeData:self.resumeData]; // 启动任务 [self.task resume]; 以目前我对NSURLSession的理解这种断点下载只支持应用内断点,如果程序在下载过程中途关闭,则不能恢复下载.(暂时对NSURLSession理解还不全面,不敢妄下断论,如有不妥简友们可以沟通下) 其他此外,task们自身有都拥有下面几个方法 - (void)suspend;//可以让当前的任务暂停 - (void)resume;//方法不仅可以启动任务,还可以唤醒suspend状态的任务 - (void)cancel;//方法可以取消当前的任务,你也可以向处于suspend状态的任务发送cancel消息,任务如果被取消便不能再恢复到之前的状态. NSURLSessionConfiguration简单地说,就是session的配置信息.如: NSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration]; // 超时时间 config.timeoutIntervalForRequest = 10; // 是否允许使用蜂窝网络(后台传输不适用) config.allowsCellularAccess = YES; // 还有很多可以设置的属性 有没有发现我们使用的Configuration都是默认配置:[NSURLSessionConfiguration defaultSessionConfiguration],其实它的配置有三种类型: //表示了NSURLSession几种不同的工作模式 + (NSURLSessionConfiguration *)defaultSessionConfiguration;//默认的配置会将缓存存储在磁盘上 + (NSURLSessionConfiguration *)ephemeralSessionConfiguration;//瞬时会话模式不会创建持久性存储的缓存 + (NSURLSessionConfiguration *)backgroundSessionConfigurationWithIdentifier:(NSString *)identifier;//后台会话模式允许程序在后台进行上传下载工作 除了支持任务的暂停和断点续传,我觉得NSURLSession之于NSURLConnection的最伟大的进步就是支持后台上传下载任务,这又是一个可以深入讨论的话题.但在这方面我还没有进行深入的研究,待后续了解之后另行开贴 三方框架对URLSession的封装(AFN)在iOS中，可以根据SDK提供的相关类库自己封装HTTP类，也可以运用第三方开源的一些库，比如以前比较火的ASIHTTPRequest，和现在经常使用的AFNetworking，其中ASIHTTPRequest已经弃用很久，AFNetworking一直在维护，底层代码的实现也是从刚开始的NSURLConnection更新到现在的NSURLSession。现在我们开始讲解AFNetworking的源码，请同学们把书先翻到88页，在讲解的同时，我们顺便也看一下AFNetworking中用到的一些常用技术 .h文件的封装在平时封装库的时候，应该在库中创建一个.h头文件，然后将一些常用的类导入进去，这样，如果其他开发者调用时，只需将此.h文件import，而不需要将用到的每个类import，简单了开发者的操作。如AFNetworking.h中： #import &lt;Foundation/Foundation.h&gt; #import &lt;Availability.h&gt; #import &lt;TargetConditionals.h&gt; #ifndef _AFNETWORKING_ #define _AFNETWORKING_ #import &quot;AFURLRequestSerialization.h&quot; #import &quot;AFURLResponseSerialization.h&quot; #import &quot;AFSecurityPolicy.h&quot; #if !TARGET_OS_WATCH #import &quot;AFNetworkReachabilityManager.h&quot; #endif #import &quot;AFURLSessionManager.h&quot; #import &quot;AFHTTPSessionManager.h&quot; #endif /* _AFNETWORKING_ */ 然后其他开发者调用的时候： #import &lt;AFNetworking/AFNetworking.h&gt; 注意，编译代码中有条件编译，如果不是OS_WATCH平台，才会导入AFNetworkReachabilityManager类，反之不然 Nonnull区域设置AFHTTPSessionManager.h中用了NS_ASSUME_NONNULL_BEGIN和NS_ASSUME_NONNULL_END，如果需要每个属性或每个方法都去指定nonnull和nullable，是一件非常繁琐的事。苹果为了减轻我们的工作量，专门提供了两个宏：NS_ASSUME_NONNULL_BEGIN和NS_ASSUME_NONNULL_END NS_ASSUME_NONNULL_BEGIN @interface TestNullabilityClass () @property (nonatomic, copy) NSArray * items; - (id)itemWithName:(nullable NSString *)name; @end NS_ASSUME_NONNULL_END 在上面的代码中，items属性默认是nonnull的，itemWithName:方法的返回值也是nonnull，而参数是指定为nullable的 我们都知道在swift中，可以使用!和?来表示一个对象是optional的还是non-optional，如view?和view!。而在Objective-C中则没有这一区分，view即可表示这个对象是optional，也可表示是non-optioanl。这样就会造成一个问题：在Swift与Objective-C混编时，Swift编译器并不知道一个Objective-C对象到底是optional还是non-optional，因此这种情况下编译器会隐式地将Objective-C的对象当成是non-optional。 为了解决这个问题，苹果在Xcode 6.3引入了一个Objective-C的新特性：nullability annotations。这一新特性的核心是两个新的类型注释：nullable和nonnull。从字面上我们可以猜到，nullable表示对象可以是NULL或nil，而nonnull表示对象不应该为空。当我们不遵循这一规则时，编译器就会给出警告 NSAssert和NSParameterAssert在AFHTTPSessionManager类中，用到了NSParameterAssert，它其实是一个宏定义，下面开始他的讲解，原文地址 - (void)setRequestSerializer:(AFHTTPRequestSerializer &lt;AFURLRequestSerialization&gt; *)requestSerializer { NSParameterAssert(requestSerializer); _requestSerializer = requestSerializer; } - (void)setResponseSerializer:(AFHTTPResponseSerializer &lt;AFURLResponseSerialization&gt; *)responseSerializer { NSParameterAssert(responseSerializer); [super setResponseSerializer:responseSerializer]; } NSAssert()是一个宏，用于开发阶段调试程序中的Bug，通过为NSAssert()传递条件表达式来断定是否属于Bug，满足条件返回真值，程序继续运行，如果返回假值，则抛出异常，并且可以自定义异常描述。 NSAssert()是这样定义的： #define NSAssert(condition, desc) condition是条件表达式，值为YES或NO；desc为异常描述，通常为NSString。当conditon为YES时程序继续运行，为NO时，则抛出带有desc描述的异常信息。NSAssert()可以出现在程序的任何一个位置 NSAssert的用法 int a = 1; NSCAssert(a == 2, @&quot;a must equal to 2&quot;); //第一个参数是条件,如果第一个参数不满足条件,就会记录并打印后面的字符串 运行则会崩溃并在控制台输出信息如下： *** Assertion failure in -[ViewController viewDidLoad](), /Users/yinwentao/Desktop/MYAssert/MYAssert/ViewController.m:32 *** Terminating app due to uncaught exception &apos;NSInternalInconsistencyException&apos;, reason: &apos;a must equal to 2&apos; NSParameterAssert的用法 - (void)assertWithPara:(NSString *)str { NSParameterAssert(str); //只需要一个参数,如果参数存在程序继续运行,如果参数为空,则程序停止打印日志 //further code ... } 如果 调用方法 assertWithPara: 传入参数为空则有如下日志 *** Assertion failure in -[ViewController assertWithPara:], /Users/yinwentao/Desktop/MYAssert/MYAssert/ViewController.m:45 *** Terminating app due to uncaught exception &apos;NSInternalInconsistencyException&apos;, reason: &apos;Invalid parameter not satisfying: str&apos; 日志中的数字是告诉你 第多少行代码出错了。 Xcode 已经默认将release环境下的断言取消了, 免除了忘记关闭断言造成的程序不稳定. 所以不用担心 在开发时候大胆使用。 自定义NSAssertionHandler NSAssertionHandler实例是自动创建的，用于处理错误断言。如果 NSAssert和NSCAssert条件评估为错误，会向 NSAssertionHandler实例发送一个表示错误的字符串。每个线程都有它自己的NSAssertionHandler实例。我们可以自定义处理方法，从而使用断言的时候，控制台输出错误，但是程序不会直接崩溃。 #import &quot;MyAssertHandler.h&quot; @implementation MyAssertHandler //处理Objective-C的断言 - (void)handleFailureInMethod:(SEL)selector object:(id)object file:(NSString *)fileName lineNumber:(NSInteger)line description:(NSString *)format,... { NSLog(@&quot;NSAssert Failure: Method %@ for object %@ in %@#%li&quot;, NSStringFromSelector(selector), object, fileName, (long)line); } //处理C的断言 - (void)handleFailureInFunction:(NSString *)functionName file:(NSString *)fileName lineNumber:(NSInteger)line description:(NSString *)format,... { NSLog(@&quot;NSCAssert Failure: Function (%@) in %@#%li&quot;, functionName, fileName, (long)line); } @end 给线程添加处理类 NSAssertionHandler *myHandler = [[MyAssertHandler alloc] init]; //给当前的线程 [[[NSThread currentThread] threadDictionary] setValue:myHandler forKey:NSAssertionHandlerKey]; 自定义NSAssertionHandler后,程序能够获得断言失败后的信息,但是程序可以继续运行,不会强制退出程序. #pragma 处理警告首先#pragma在本质上是声明，常用的功能就是注释，尤其是给Code分段注释，AFNetworking中也有用到，如AFHTTPSessionManager中的#pragma mark - NSCopying；而且它还有另一个强大的功能是处理编译器警告，但却没有上一个功能用的那么多。 clang/GCC diagnostic 是#pragma 第一个常用命令： #pragma clang/GCC diagnostic push #pragma clang/GCC diagnostic ignored &quot;-相关命令&quot; // 你自己的代码 #pragma clang/GCC diagnostic pop 相关命令包括： -Wdeprecated-declarations//忽略方法弃用的警告 -Wincompatible-pointer-types//忽略不兼容指针类型的警告 -Warc-retain-cycles//忽略循环引用的警告 -Wunused-variable//忽略未使用变量的警告 更多关于命令的信息请查阅此处 AFHTTPSessionManager.m 中POST方法： NSError *serializationError = nil; NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError]; if (serializationError) { if (failure) { #pragma clang diagnostic push #pragma clang diagnostic ignored &quot;-Wgnu&quot; dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^{ failure(nil, serializationError); }); #pragma clang diagnostic pop } return nil; } NSCoding &amp; NSSecureCodingNSCoding源文地址NSCoding是把数据存储在iOS和Mac OS上的一种极其简单和方便的方式，它把模型对象直接转变成一个文件，然后再把这个文件重新加载到内存里，并不需要任何文件解析和序列化的逻辑。如果要把对象保存到一个数据文件中（假设这个对象实现了NSCoding协议），那么你可以像下面这样做： @interface Foo : NSObject @property (nonatomic, assign) NSInteger property1; @property (nonatomic, assign) BOOL property2; @property (nonatomic, copy) NSString *property3; @end @implementation Foo - (id)initWithCoder:(NSCoder *)coder { if ((self = [super init])) { // Decode the property values by key, and assign them to the correct ivars _property1 = [coder decodeIntegerForKey:@&quot;property1&quot;]; _property2 = [coder decodeBoolForKey:@&quot;property2&quot;]; _property3 = [coder decodeObjectForKey:@&quot;property3&quot;]; } return self; } - (void)encodeWithCoder:(NSCoder *)coder { // Encode our ivars using string keys [coder encodeInteger:_property1 forKey:@&quot;property1&quot;]; [coder encodeBool:_property2 forKey:@&quot;property2&quot;]; [coder encodeObject:_property3 forKey:@&quot;property3&quot;]; } @end Foo *someFoo = [[Foo alloc] init]; [NSKeyedArchiver archiveRootObject:someFoo toFile:someFile]; 稍后再加载它： Foo *someFoo = [NSKeyedUnarchiver unarchiveObjectWithFile:someFile]; 详细观察一下上边的代码，我们会发现函数里会有很多相似的代码： // In the initWithCoder: method self.someProperty = [coder decodeObjectForKey:@&quot;someProperty&quot;]; // In the encodeWithCoder: method [coder encodeObject:self.someProperty forKey:@&quot;someProperty&quot;]; 我们可以通过KVC对这些相似代码进行统一处理，由于KVC本身就有拆箱和装箱的功能，所以我们不用担心使用哪种方法来操作 NSString *const PropertyName = @&quot;someProperty&quot;; // In the initWithCoder: method id value = [coder decodeObjectForKey:PropertyName]; [self setValue:value forKey:PropertyName]; // In the encodeWithCoder: method id value = [self valueForKey:PropertyName]; [coder encodeObject:value forKey:PropertyName]; 我们可以循环遍历类的属性，然后通过方法来encode或者decode这些属性 @interface CodableObject : NSObject &lt;NSCoding&gt; - (NSArray *)propertyNames; @end @implementation CodableObject - (NSArray *)propertyNames { // Override this in the subclass to return an array of property names return @[@&quot;property1&quot;, @&quot;property2&quot;, @&quot;property3&quot;]; } - (id)initWithCoder:(NSCoder *)aDecoder { if ((self = [self init])) { // Loop through the properties for (NSString *key in [self propertyNames]) { // Decode the property, and use the KVC setValueForKey: method to set it id value = [aDecoder decodeObjectForKey:key]; [self setValue:value forKey:key]; } } return self; } - (void)encodeWithCoder:(NSCoder *)aCoder { // Loop through the properties for (NSString *key in [self propertyNames]) { // Use the KVC valueForKey: method to get the property and then encode it id value = [self valueForKey:key]; [aCoder encodeObject:value forKey:key]; } } @end 每次有属性更改时只需要修改propertyNames方法中的属性即可，然而我们会发现，通过OC运行时的魔力，我们也可以动态获取这些属性的名称 // Import the Objective-C runtime headers #import &lt;objc/runtime.h&gt; - (NSArray *)propertyNames { // Get the list of properties unsigned int propertyCount; objc_property_t *properties = class_copyPropertyList([self class], &amp;propertyCount); NSMutableArray *array = [NSMutableArray arrayWithCapacity:propertyCount]; for (int i = 0; i &lt; propertyCount; i++) { // Get property name objc_property_t property = properties[i]; const char *propertyName = property_getName(property); NSString *key = @(propertyName); // Add to array [array addObject:key]; } // Remember to free the list because ARC doesn&apos;t do that for us free(properties); return array; } 这样的话便通过OC运行时的魔力完成了对类属性的遍历与保存，但是这样还是存在以下几个问题： 这些属性中没有包括从父类继承而来的一些属性，如Dog &gt; Animal &gt; CodableObject，当保存Dog对象时，只会encode Dog类的属性，而不会encode Animal类的属性 不是所有的property会被encode，如果属性没有变量并且只读（If a property is both virtual (not backed by an ivar) and readonly），则它不能用setValueForKey:，因为会crash，如果属性只读并且有变量，但是变量的名字和属性名称不匹配，setValueForKey:函数则不会被调用到。所以只有当属性名称和变量名称相同的时候才会被encode 不是所有的property会被encode，如果属性是指针或者结构体，或者对象，而它本身不支持NSCoding的话，它就不会被encode 有些时候我们想忽略一些属性，也不能完成 所以鉴于第一个和第二个问题，我们修改代码如下 - (NSArray *) propertyNames { // Loop through our superclasses until we hit NSObject NSMutableArray *array = [NSMutableArray array]; Class subclass = [self class]; while (subclass != [NSObject class]) { unsigned int propertyCount; objc_property_t *properties = class_copyPropertyList(subclass, &amp;propertyCount); for (int i = 0; i &lt; propertyCount; i++) { // Get property name objc_property_t property = properties[i]; const char *propertyName = property_getName(property); NSString *key = @(propertyName); // Check if there is a backing ivar char *ivar = property_copyAttributeValue(property, &quot;V&quot;); if (ivar) { // Check if ivar has KVC-compliant name NSString *ivarName = @(ivar); if ([ivarName isEqualToString:key] || [ivarName isEqualToString:[@&quot;_&quot; stringByAppendingString:key]]) { // setValue:forKey: will work [array addObject:key]; } free(ivar); } } free(properties); subclass = [subclass superclass]; } return array; } 对于第三个问题，我们尽量避免不支持NSCoding的指针、结构体、对象加入到类中作为一个属性，如果需要，则让他们先重写NSCoding来达到条件 对于第三个问题，我们如何消除某个属性不让encode呢，首先，如果是private的属性，我们只定义一个变量，而不是定义属性；其次，如果是public的属性，则需要把属性对应的变量名称修改一下即可 @synthesize foo = foo; // This *will* be encoded @synthesize foo = _foo; // So will this @synthesize foo = foo_; // But this *won&apos;t* be @synthesize foo = bar; // Nor will this 现在来说，获取类中的属性列表已经可以完成编码，但是，如果每次调用都要进行一次计算，会不会有些繁琐呢，我们以前了解过关联对象的使用， 现在，我们可以通过对象关联技术将propertyNames保存起来 - (NSArray *)propertyNames { // Check for a cached value (we use _cmd as the cache key, // which represents @selector(propertyNames)) NSMutableArray *array = objc_getAssociatedObject([self class], _cmd); if (array) { return array; } // Loop through our superclasses until we hit NSObject array = [NSMutableArray array]; Class subclass = [self class]; while (subclass != [NSObject class]) { unsigned int propertyCount; objc_property_t *properties = class_copyPropertyList(subclass, &amp;propertyCount); for (int i = 0; i &lt; propertyCount; i++) { // Get property name objc_property_t property = properties[i]; const char *propertyName = property_getName(property); NSString *key = @(propertyName); // Check if there is a backing ivar char *ivar = property_copyAttributeValue(property, &quot;V&quot;); if (ivar) { // Check if ivar has KVC-compliant name NSString *ivarName = @(ivar); if ([ivarName isEqualToString:key] || [ivarName isEqualToString:[@&quot;_&quot; stringByAppendingString:key]]) { // setValue:forKey: will work [array addObject:key]; } free(ivar); } } free(properties); subclass = [subclass superclass]; } // Cache and return array objc_setAssociatedObject([self class], _cmd, array, OBJC_ASSOCIATION_RETAIN_NONATOMIC); return array; } NSSecureCoding这样做对于编译进APP里的资源来说是可以的（例如nib文件，它在底层使用了NSCoding），但是使用NSCoding来读写用户数据文件的问题在于，把类对象编码到一个文件里，也就间接地给了这个文件访问你APP里面实例类的权限。 虽然你不能在一个NSCoded文件里（至少在iOS中的）存储可执行代码，但是一名黑客可以使用特制地文件骗过你的APP进入到实例化类中，这是你从没打算做的，或者是你想要在另一个不同的上下文时才做的。尽管以这种方式造成实际性的破坏很难，但是无疑会导致用户的APP崩溃掉或者数据丢失。 在iOS6中，苹果引入了一个新的协议，是基于NSCoding的，叫做NSSecureCoding。NSSecureCoding和NSCoding是一样的，除了在解码时要同时指定key和要解码的对象的类，如果要求的类和从文件中解码出的对象的类不匹配，NSCoder会抛出异常，告诉你数据已经被篡改了。 大部分支持NSCoding的系统对象都已经升级到支持NSSecureCoding了，所以能安全地写有关归档的代码，你可以确保正在加载的数据文件是安全的。实现的方式如下： // Set up NSKeyedUnarchiver to use secure coding NSData *data = [NSData dataWithContentsOfFile:someFile]; NSKeyedUnarchiver *unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data]; [unarchiver setRequiresSecureCoding:YES]; // Decode object Foo *someFoo = [unarchiver decodeObjectForKey:NSKeyedArchiveRootObjectKey]; 注意一下，如果要让编写归档的代码是安全的，那么存储在文件中的每一个对象都要实现NSSecureCoding协议，否则会有异常抛出。如果要告诉框架自定义的类支持NSSecureCoding协议，那么你必须在initWithCoder: method方法中实现新的解码逻辑，并且supportsSecureCodin方法要返回YES。encodeWithCoder:方法没有变化，因为与安全相关的事是围绕加载进行的，而不是保存 NSFoundationVersionNumber_iOS_8_0由于iOS的这个bug，大意是：在iOS8以前并发创建很多NSURLSessionTask，每个NSURLSessionTask的taskIdentifier不是唯一的。而要避免这个问题，只能通过串行队列去创建，所以为了规避iOS8.0以前系统bug，作者写出了这一段代码 //iOS8系统后定义了这么一段 #define NSFoundationVersionNumber_iOS_8_0 1140.11 #ifndef NSFoundationVersionNumber_iOS_8_0 #define NSFoundationVersionNumber_With_Fixed_5871104061079552_bug 1140.11 #else #define NSFoundationVersionNumber_With_Fixed_5871104061079552_bug NSFoundationVersionNumber_iOS_8_0 #endif static dispatch_queue_t url_session_manager_creation_queue() { static dispatch_queue_t af_url_session_manager_creation_queue; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ af_url_session_manager_creation_queue = dispatch_queue_create(&quot;com.alamofire.networking.session.manager.creation&quot;, DISPATCH_QUEUE_SERIAL); }); return af_url_session_manager_creation_queue; } static void url_session_manager_create_task_safely(dispatch_block_t block) { if (NSFoundationVersionNumber &lt; NSFoundationVersionNumber_With_Fixed_5871104061079552_bug) { // Fix of bug // Open Radar:http://openradar.appspot.com/radar?id=5871104061079552 (status: Fixed in iOS8) // Issue about:https://github.com/AFNetworking/AFNetworking/issues/2093 dispatch_sync(url_session_manager_creation_queue(), block); } else { block(); } } - (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler { __block NSURLSessionDataTask *dataTask = nil; url_session_manager_create_task_safely(^{ dataTask = [self.session dataTaskWithRequest:request]; }); [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler]; return dataTask; } 线程相关//为了保证创建队列线性安全的只执行一次，使用了dispatch_once_t来执行只需要运行一次的线程安全代码，group也同样 static dispatch_queue_t url_session_manager_processing_queue() { static dispatch_queue_t af_url_session_manager_processing_queue; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ af_url_session_manager_processing_queue = dispatch_queue_create(&quot;com.alamofire.networking.session.manager.processing&quot;, DISPATCH_QUEUE_CONCURRENT); }); return af_url_session_manager_processing_queue; } static dispatch_group_t url_session_manager_completion_group() { static dispatch_group_t af_url_session_manager_completion_group; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ af_url_session_manager_completion_group = dispatch_group_create(); }); return af_url_session_manager_completion_group; } //delegate在[NSURLSessionDataTask resume]时新开启的线程中运行 - (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error { AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task]; // delegate may be nil when completing a task in the background if (delegate) { [delegate URLSession:session task:task didCompleteWithError:error]; [self removeDelegateForTask:task]; } if (self.taskDidComplete) { self.taskDidComplete(session, task, error); } } - (void)URLSession:(__unused NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error { #pragma clang diagnostic push #pragma clang diagnostic ignored &quot;-Wgnu&quot; __strong AFURLSessionManager *manager = self.manager; __block id responseObject = nil; __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary]; userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer; //Performance Improvement from #2672 NSData *data = nil; if (self.mutableData) { data = [self.mutableData copy]; //We no longer need the reference, so nil it out to gain back some memory. self.mutableData = nil; } if (self.downloadFileURL) { userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL; } else if (data) { userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data; } if (error) { userInfo[AFNetworkingTaskDidCompleteErrorKey] = error; //如果URLSessionManager有设置完成的group，则使用其固有的group管理并发的异步线程，如果没有设置，则使用默认的dispatch_get_main_queue //如果URLSessionManager创建时有设置completionQueue，则回调的block在其设置的队列中执行，如果没有设置，则在主队列中完成操作 dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^{ if (self.completionHandler) { self.completionHandler(task.response, responseObject, error); } //不管当前队列是设置的队列还是主队列，分发通知的过程应该是主队列中去执行 dispatch_async(dispatch_get_main_queue(), ^{ [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo]; }); }); } else { //预处理response的队列，非主线程中进行 dispatch_async(url_session_manager_processing_queue(), ^{ NSError *serializationError = nil; responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError]; if (self.downloadFileURL) { responseObject = self.downloadFileURL; } if (responseObject) { userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject; } if (serializationError) { userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError; } //如果URLSessionManager创建时有设置completionQueue，则回调的block在其设置的队列中执行，如果没有设置，则在主队列中完成操作 dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^{ if (self.completionHandler) { self.completionHandler(task.response, responseObject, serializationError); } //不管当前队列是设置的队列还是主队列，分发通知的过程应该是主队列中去执行 dispatch_async(dispatch_get_main_queue(), ^{ [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo]; }); }); }); } #pragma clang diagnostic pop } 顺便提一下，看过很多其他人调用AFNetworking时的代码，发现有一部分人是这样写的： - (void)refreshUI { self.staffArray = [NSArray mj_objectArrayWithKeyValuesArray:[json objectForKey:@&quot;data&quot;]]; [self.shopMemberCollectionView reloadData]; } //方式1 - (void)getMerchantStaffFromServer { [CPServerAPIInstance shopStaff:@{@&quot;shopId&quot;:_merchantModel.shopId, @&quot;status&quot;:@&quot;3&quot;} success:^(id json) { [self performSelectorOnMainThread:@selector(refreshUI) withObject:nil waitUntilDone:YES]; } failure:^{ }]; } //方式2 - (void)getMerchantStaffFromServer { [CPServerAPIInstance shopStaff:@{@&quot;shopId&quot;:_merchantModel.shopId, @&quot;status&quot;:@&quot;3&quot;} success:^(id json) { dispatch_async(dispatch_get_main_queue(), ^{ [self refreshUI]; }); } failure:^{ }]; } 仅从线程的角度来讲，这两种方式的目的都是让succ block中的执行代码能在主线程中执行，然而我们在源码中发现，AFNetworking源码的作者已经考虑到了此处 //如果URLSessionManager创建时有设置completionQueue，则回调的block在其设置的队列中执行，如果没有设置，则在主队列中完成操作 dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^{ if (self.completionHandler) { self.completionHandler(task.response, responseObject, error); } //不管当前队列是设置的队列还是主队列，分发通知的过程应该是主队列中去执行 dispatch_async(dispatch_get_main_queue(), ^{ [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo]; }); }); 如果URLSessionManager创建时有设置completionQueue，则回调的block在其设置的队列中执行，如果没有设置，则在主队列中完成操作，所以这些都在主线程中分发任务到主线程，此举纯属多余，反倒会在当开发者设置了执行的manager.completionQueue时，没有在设置的队列中执行，而是分发到了主队列中去执行。 线程加锁先举个例子来说明，为什么要使用锁 - (BOOL)cash:(int)money { int totalMoney = getTotalMoney(); if (money&lt;=totalMoney) { totalMoney -= money; saveTotalMoney(totalMoney); return YES; } else { NSLog(@&quot;取钱数大于存款总数，不能获取&quot;); return NO; } } 如果有两个线程同时执行这段代码，我们知道这两个线程是并发执行，CPU随机执行两个线程并在每个线程的状态之间进行运行和挂起，假定存款总数100，两个线程每次取款数均是100，当第一个线程执行完if (money&lt;=totalMoney)判断后，发现成功，继续进行，如果此时线程1被挂起，线程2被激活，仍然判断if (money&lt;=totalMoney)，发现代码还是走进了成功代码块，所以会造成只有100元存款，却取出了200元而导致totalMoney变为负数的情况，这明显与现实不符。 虽然这种问题出现的概率极小，但是还是有可能会发生，所以为了解决这个问题，就保证线程安全性，需要对线程加锁，在AFNetworking中用到的锁有以下三种： - (AFURLSessionManagerTaskDelegate *)delegateForTask:(NSURLSessionTask *)task { NSParameterAssert(task); AFURLSessionManagerTaskDelegate *delegate = nil; [self.lock lock]; delegate = self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)]; [self.lock unlock]; return delegate; } - (NSArray *)tasksForKeyPath:(NSString *)keyPath { __block NSArray *tasks = nil; dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) { if ([keyPath isEqualToString:NSStringFromSelector(@selector(dataTasks))]) { tasks = dataTasks; } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(uploadTasks))]) { tasks = uploadTasks; } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(downloadTasks))]) { tasks = downloadTasks; } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(tasks))]) { tasks = [@[dataTasks, uploadTasks, downloadTasks] valueForKeyPath:@&quot;@unionOfArrays.self&quot;]; } dispatch_semaphore_signal(semaphore); }]; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); return tasks; } - (void)setNetworkActivityIndicatorVisible:(BOOL)networkActivityIndicatorVisible { if (_networkActivityIndicatorVisible != networkActivityIndicatorVisible) { [self willChangeValueForKey:@&quot;networkActivityIndicatorVisible&quot;]; @synchronized(self) { _networkActivityIndicatorVisible = networkActivityIndicatorVisible; } [self didChangeValueForKey:@&quot;networkActivityIndicatorVisible&quot;]; if (self.networkActivityActionBlock) { self.networkActivityActionBlock(networkActivityIndicatorVisible); } else { [[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:networkActivityIndicatorVisible]; } } } 为什么delegate的地方要设置lock呢，因为如果有很多线程同时访问self.mutableTaskDelegatesKeyedByTaskIdentifier，有的修改，有的访问，会导致执行的结果出现错误，就类似数据库的CoreData一样，不是线性安全的，有的插入，有的查询，则会引入一些不知名的错误。 多用类型常量，少用#define预处理指令不要用预处理指令定义常量。这样定义出来的常量不含类型信息，编译器只是会在编译前据此执行查找与替换操作。即使有人重新定义了常量值，编译器也不会产生警告信息，这将导致应用程序中的常量不一致。 在实现文件中使用static const来定义“只在编译单元内可见的常量”，由于此类常量不在全局符号表中，所以无须为其名称加前缀。 在头文件中使用extern来声明全局变量，并在相关实现文件中定义其值。这种常量要出现在全局符号表中，所以其名称应加以区隔，通常用与之相关的类名做前缀 如果需要兼容其他平台，则需要将extern替换成FOUNDATION_EXPORT，如果你在NSObjCRuntime.h中查看FOUNDATION_EXPORT会发现，FOUNDATION_EXPORT在C语言中将会被编译成extern，在C++中会被编译成extern &quot;C&quot;，在Win32中会被编译成其他内容，在iOS的大部分工程中extern和FOUNDATION_EXPORT没有区别 //In the header file extern/FOUNDATION_EXPORT NSString *const EOCStringConstant; //In the implementation file NSString *const EOCStringConstant = @“VALUE”; 应用则是在AFURLSessionManager类中的Notification和Key //In the header file FOUNDATION_EXPORT NSString * const AFURLSessionDownloadTaskDidFailToMoveFileNotification; FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidCompleteResponseDataKey; //In the implementation file NSString * const AFURLSessionDownloadTaskDidFailToMoveFileNotification = @&quot;com.alamofire.networking.session.download.file-manager-error&quot;; NSString * const AFNetworkingTaskDidCompleteSerializedResponseKey = @&quot;com.alamofire.networking.task.complete.serializedresponse&quot;; OC静态函数在函数的返回类型前加上关键字static，函数就被定义成为静态函数。 函数的定义和声明默认情况下是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。只能被本文件中的函数调用，而不能被同一程序其它文件中的函数调用 好处： 其他文件中可以定义相同名字的函数，不会发生冲突 静态函数不能被其他文件所用 如： static dispatch_queue_t url_session_manager_processing_queue() { static dispatch_queue_t af_url_session_manager_processing_queue; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ af_url_session_manager_processing_queue = dispatch_queue_create(&quot;com.alamofire.networking.session.manager.processing&quot;, DISPATCH_QUEUE_CONCURRENT); }); return af_url_session_manager_processing_queue; } static dispatch_group_t url_session_manager_completion_group() { static dispatch_group_t af_url_session_manager_completion_group; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ af_url_session_manager_completion_group = dispatch_group_create(); }); return af_url_session_manager_completion_group; } 块在AFNetworking中块的使用非常常见，如 typedef void (^AFURLSessionDidBecomeInvalidBlock)(NSURLSession *session, NSError *error); typedef void (^AFURLSessionTaskProgressBlock)(NSProgress *); typedef void (^AFURLSessionTaskCompletionHandler)(NSURLResponse *response, id responseObject, NSError *error); 按照块存储的位置，分为全局静态block，保存在堆中的block和保存在栈中的block 全局静态block不会访问任何外部静态变量：这种不捕捉外界变量的block是不需要内存管理的,这种block不存在于Heap或是Stack而是作为代码片段存在,类似于C函数 保存在栈中的block，当块执行完并返回时被销毁：这就是这次探索的重点了,需要涉及到外界变量的block在创建的时候是在stack上面分配空间的,也就是一旦所在函数返回,则会被摧毁。这就导致内存管理的问题,如果我们希望保存这个block或者是返回它,如果没有做进一步的copy处理,则必然会出现问题 保存在堆中的block，当引用计数未0时会被销毁：因此为了解决block作为Stack object的这个问题,我们最终需要把它拷贝到堆上面来。而此时NSConcreteMallocBlock扮演的就是这个角色。拷贝到堆后,block的生命周期就与一般的OC对象一样了,我们通过引用计数来对其进行内存管理 举个栈块引用的例子，具体的博客地址， - (void)viewDidLoad { [superviewDidLoad]; dispatch_async(dispatch_get_global_queue(0,0), ^{ NSString *str = self.NSString; NSLog(@“%@“,str); }); } 微博博主在此文中举了个例子，在上面代码中，self队形引用了block块，而block块又在内部引用了self，所以作者认为形成了一个保留环，具体的修改方式如下： - (void)viewDidLoad { [superviewDidLoad]; __weaktypeof(self) weakSelf = self; //问题一：通过定义弱指针，解决保留环的问题 dispatch_async(dispatch_get_global_queue(0,0), ^{ __strongtypeof(self) strongSelf = weakSelf; //问题二：通过定义强指针，解决在block调用完之前，self被释放掉了，从而block的所有调用均无效 NSLog(@&quot;%@&quot;,strongSelf.string); }); } 然而，通过我具体的测试，发现上述例子并未引入保留环，因为在pop此ViewController的时候，dealloc函数会被调用。从这点来说，作者的举例并不是很恰当。这是为什么呢？我们通过另一个案例说明此问题： @interface ViewController (){ void(^myBlock1)(void);//该block参数为void，返回值为void void(^myBlock2)(void); void(^myBlock3)(void); } @property (nonatomic,copy) NSString *person; @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; self.person = @&quot;frand&quot;; [self test]; } - (void)dealloc { NSLog(@&quot;ViewController delloc&quot;); } - (void)test { __weak __typeof(self) weakSelf = self; NSLog(@&quot;init--&gt; value:%@,address=%p,self=%p&quot;,self.person,self.person,self); dispatch_async(dispatch_get_global_queue(0,0), ^{ //未引入保留环，因为block持有self，而self未持有block NSLog(@&quot;%@&quot;,self.person); }); myBlock1 = ^(void){ //这样不会造成循环引用，因为self持有block，而block未强持有self NSLog(@&quot;execute1--&gt; value:%@,address=%p,weakSelf=%p&quot;,weakSelf.person,weakSelf.person,weakSelf); }; myBlock1(); myBlock2 = ^(void){ //这样会造成循环引用，因为self持有block，block也强持有self NSLog(@&quot;execute2--&gt; value:%@,address=%p,self=%p&quot;,self.person,self.person,self); }; myBlock2(); myBlock3 = ^(void){ //这样也不会造成循环引用,因为self持有block，而block未强持有self [weakSelf myBlock3Func]; }; myBlock3(); void(^myBlock4)(void); myBlock4 = ^(void){ //这样也不会造成循环引用，因为block持有self，而self未持有block NSLog(@&quot;execute2--&gt; value:%@,address=%p,self=%p&quot;,self.person,self.person,self); }; myBlock4(); } 从上边的这个案例可以得出一个结论，只有当引用造成一个环状的时候，才会导致对象相互持有，从而无法释放。我们可以从第一个案例中看出，self并未持有block，只是block在持有self，未形成环状引用，从而没有形成保留环，内存照样释放。而阻止引用环形成的一个方法就是应用weakSelf。weakSelf的意思就是对现有的self做一个弱引用，使block在引用的时候引用的不是self，而是weakSelf，这样的话，self便不受影响，可以随时释放。 我们再通过一个案例验证一下，并且学习一下如何在实战中分析引用环问题 场景1：Controller之间block传值 现在，我们声明两个控制器类，一个叫ViewController，另一个叫HYBAController。其中，ViewController有一个按钮，点击时会push到HYBAController下。 先看HYBAController： // 公开了一个方法 - (instancetype)initWithCallback:(HYBCallbackBlock)callback; // 非公开的属性，这里放出来只是告诉大家，HYBAController会对这个属性强引用 @property (nonatomic, copy) HYBCallbackBlock callbackBlock; 下面分几种小场景来看看循环引用问题： @interface ViewController () // 引用按钮只是为了测试 @property (nonatomic, strong) UIButton *button; // 只是为了测试内存问题，引用之。在开发中，有很多时候我们是 // 需要引用另一个控制器的，因此这里模拟之。 @property (nonatomic, strong) HYBAController *vc; @end // 点击button时 - (void)goToNext { HYBAController *vc = [[HYBAController alloc]initWithCallback:^{ [self.buttonsetTitleColor:[UIColor greenColor]forState:UIControlStateNormal]; }]; self.vc = vc; [self.navigationController pushViewController:vcanimated:YES]; } 现在看ViewController这里，这里在block的地方形成了循环引用，因此vc属性得不到释放。分析其形成循环引用的原因 可以简单说，这里形成了两个环： ViewController-&gt;强引用了属性vc-&gt;强引用了callback-&gt;强引用了ViewController ViewController-&gt;强引用了属性vc-&gt;强引用了callback-&gt;强引用了ViewController的属性button 对于此这问题，我们要解决内存循环引用问题，可以这么解： 不声明vc属性或者将vc属性声明为weak引用的类型，在callback回调处，将self.button改成weakSelf.button，也就是让callback这个block对viewcontroller改成弱引用。如就是改成如下，内存就可以正常释放了： - (void)goToNext { __weak __typeof(self) weakSelf = self; HYBAController *vc = [[HYBAController alloc]initWithCallback:^{ [weakSelf.buttonsetTitleColor:[UIColor greenColor]forState:UIControlStateNormal]; }]; // self.vc = vc; [self.navigationControllerpushViewController:vcanimated:YES]; } 场景2：Controller与View之间Block传值 我们先定义一个view，用于与Controller交互。当点击view的按钮时，就会通过block回调给controller，也就反馈到控制器了，并将对应的数据传给控制器以记录： typedef void(^HYBFeedbackBlock)(id model); @interfaceHYBAView: UIView - (instancetype)initWithBlock:(HYBFeedbackBlock)block; @end @interface HYBAView () @property (nonatomic, copy) HYBFeedbackBlock block; @end @implementation HYBAView - (void)dealloc { NSLog(@&quot;dealloc: %@&quot;, [[self class]description]); } - (instancetype)initWithBlock:(HYBFeedbackBlock)block { if (self = [super init]) { self.block = block; UIButton *button = [UIButtonbuttonWithType:UIButtonTypeCustom]; [buttonsetTitle:@&quot;反馈给controller&quot;forState:UIControlStateNormal]; button.frame = CGRectMake(50, 200, 200, 45); button.backgroundColor = [UIColor redColor]; [buttonsetTitleColor:[UIColor yellowColor]forState:UIControlStateNormal]; [buttonaddTarget:selfaction:@selector(feedback)forControlEvents:UIControlEventTouchUpInside]; [selfaddSubview:button]; } return self; } - (void)feedback { if (self.block) { // 传模型回去，这里没有数据，假设传nil self.block(nil); } } @end 接下来看HYBAController，增加了两个属性，在viewDidLoad时，创建了aView属性： @interface HYBAController() @property (nonatomic, copy) HYBCallbackBlock callbackBlock; @property (nonatomic, strong) HYBAView *aView; @property (nonatomic, strong) id currentModel; @end @implementation HYBAController - (instancetype)initWithCallback:(HYBCallbackBlock)callback { if (self = [super init]) { self.callbackBlock = callback; } return self; } - (void)viewDidLoad { [super viewDidLoad]; self.title = @&quot;HYBAController&quot;; self.view.backgroundColor = [UIColor whiteColor]; self.aView = [[HYBAView alloc]initWithBlock:^(id model) { // 假设要更新model self.currentModel = model; }]; // 假设占满全屏 self.aView.frame = self.view.bounds; [self.viewaddSubview:self.aView]; self.aView.backgroundColor = [UIColor whiteColor]; } - (void)viewDidAppear:(BOOL)animated { [superviewDidAppear:animated]; NSLog(@&quot;进入控制器：%@&quot;, [[self class]description]); } - (void)dealloc { NSLog(@&quot;控制器被dealloc: %@&quot;, [[self class]description]); } @end 所形成的环有： vc-&gt;aView-&gt;block-&gt;vc（self） vc-&gt;aView-&gt;block-&gt;vc.currentModel 解决的办法可以是：在创建aView时，block内对currentModel的引用改成弱引用： __weak __typeof(self) weakSelf = self; self.aView = [[HYBAView alloc]initWithBlock:^(id model) { // 假设要更新model weakSelf.currentModel = model; }]; 我见过很多类似这样的代码，直接使用成员变量，而不是属性，然后他们以为这样就不会引用self，也就是控制器，从而不形成环： self.aView = [[HYBAView alloc]initWithBlock:^(id model) { // 假设要更新model _currentModel = model; }]; 这是错误的理解，当我们引用了_currentModel时，它是控制器的成员变量，因此也就引用了控制器。要解决此问题，也是要改成弱引用： __block__weak __typeof(_currentModel) weakModel = _currentModel; self.aView = [[HYBAView alloc]initWithBlock:^(id model) { // 假设要更新model weakModel = model; }]; 这里还要加上__block哦！ 模拟循环引用 假设下面如此写代码，是否出现内存得不到释放问题？（其中，controller属性都是强引用声明的） @autoreleasepool { A*aVC = [[A alloc]init]; B*bVC = [[B allcok]init]; aVC.controller = bVC; bVC.controller = aVC; } 分析： aVC-&gt;强引用了bVC-&gt;强引用了aVC，因此形成了一个环，导致内存得不到释放。 从上面的例子中，我们得知，通过weakSelf可以不让block引用self，从而可以使self随时释放，不占用内存，也不会引用保留环，但是我们在很多地方看到了strongSelf，strongSelf的用途是什么呢？同样的，我们通过一个案例来分析 __weak __typeof(self)weakSelf = self; NSBlockOperation *op = [[[NSBlockOperation alloc] init] autorelease]; [op addExecutionBlock:^ { [weakSelf doSomething]; [weakSelf doMoreThing]; }]; 根据上面的例子，当你加了WeakSelf后，block中的self随时都会有被释放的可能，所以会出现一种情况，在调用doSomething的时候self还存在，在doMoreThing的时候self就变成nil了，所以为了避免这种情况发生，我们会重新strongify self。一般情况下，我们都建议这么做，这没什么风险，除非你不关心self在执行过程中变成nil，或者你确定它不会变成nil（比方说所以block都在main thread执行） 现在我们举个关于AFNetworking中，block使用的例子 [CPServerAPIInstance shopStaff:@{@&quot;shopId&quot;:_merchantModel.shopId, @&quot;status&quot;:@&quot;3&quot;} success:^(id json) { self.staffArray = [NSArray mj_objectArrayWithKeyValuesArray:[json objectForKey:@&quot;data&quot;]]; [self.shopMemberCollectionView reloadData]; } failure:^{ }]; 相信刚开始很多程序员在调用AFNetworking时都会对它再一次封装，然后在通过调用封装的类CPServerAPIInstance来调用方法，之后再回调succ和fail的block。这个block中的使用对不对呢 我们先分析一下有没有引入保留环： AFURLSessionManager引用块succ和fail，succ块引用了self，而self引用了AFURLSessionManager或succ块了吗？答案显然是没有，所以，此过程是没有引入保留环的，从保留环的角度来看的话，没有任何问题。所以如果我们在self中添加dealloc方法并打印，发现在self从navigationController中pop出去的时候dealloc方法是被调用了，这个更进一步验证我们刚才的结论。 在什么时候才会出现保留环呢？必须要self引用succ block或者AFURLSessionManager才可以，我们模拟一下引用block的情况，看一下是否出现了保留环 SuccessBlockHandler handler; handler = ^(id json) { id data = [json objectForKey:@&quot;data&quot;]; if (data) { CPMerchantNotice *notice = [CPMerchantNotice mj_objectWithKeyValues:data]; [self.merchantNoticeLabel setText:notice.noticeContent]; } }; - (void)getNoticeFromServer { [CPServerAPIInstance shopNotice:@{@&quot;shopId&quot;:_merchantModel.shopId, @&quot;noticeType&quot;:@&quot;1&quot;} success:handler failure:^{ }]; } 通过上边的代码，运行之后会发现dealloc函数未调用，证明引用的保留环。所以应该按照第一种方式来做处理，虽然在第一种方式中没有出现保留环，然而我们发现，很多程序员在用的时候依然是按照以下两种方式： [CPServerAPIInstance shopStaff:@{@&quot;shopId&quot;:_merchantModel.shopId, @&quot;status&quot;:@&quot;3&quot;} success:^(id json) { weakSelf.staffArray = [NSArray mj_objectArrayWithKeyValuesArray:[json objectForKey:@&quot;data&quot;]]; [weakSelf.shopMemberCollectionView reloadData]; } failure:^{ }]; 或 __weak __typeof(self) weakSelf = self; [CPServerAPIInstance shopStaff:@{@&quot;shopId&quot;:_merchantModel.shopId, @&quot;status&quot;:@&quot;3&quot;} success:^(id json) { __strong __typeof(self) strongSelf = weakSelf; strongSelf.staffArray = [NSArray mj_objectArrayWithKeyValuesArray:[json objectForKey:@&quot;data&quot;]]; [strongSelf.shopMemberCollectionView reloadData]; } failure:^{ }]; 这是为什么呢？我们分析一下这样写有什么不同，暂时把这三段代码根据顺序编码1，2，3。 代码1中在block没有被释放时，self也不会被释放，这就是为什么在block未执行完成的时候，pop self以后未打印出dealloc的原因。 然而在此例中，既然self已经被pop了，按此处的需求来说，self就不需要再存在了，所以应该在该释放的时候就被释放，不应该一直占着内存，所以会出现代码2片段，此时的self是可以在任何时候被系统回收的，回收后当执行到向weakSelf发送staffArray消息时，发现weakSelf是空的，所以weakSelf会接收此消息，但不会响应它。 但是如果正巧当weakSelf.staffArray这句调用完成之后weakSelf.shopMemberCollectionView还未调用时回收了weakSelf怎么办呢？一般情况下会只调用上边那句而不会调用下边的，在此例中，这个完全没有什么影响，然而当在别的例子，如操作数据库时，当我们买了一件东西时，上边的一句是从存款的减去此次消费的数据，而下边一句是将此次消费的数据加到总消费数据中去，所以这两句要么全执行， 要么全不执行，要不然会出现数据总额不统一的情况，为了这个所谓的事务的原子性特性，就引用了strongSelf来处理，也就是代码3片段，在此段中，self可以在strong typeof(self) strongSelf = weakSelf;这句前任何地方释放，但是在此句后边，self则不允许被释放了，直到block执行完成strongSelf的作用域完结才可以。 一般我们会采用第3种方式来在block中处理，因为这样既不会引入保留环，也不会占用多余内存，也考虑到了事务的原子性特性。当然如果在一些特殊需求下，或者一些有把握不会有问题的情况下，也可以用方式1或方式2来处理。 最后再举个比较实用的例子来总结一下： self.merchantCollectionView.mj_header = [MJRefreshHeader headerWithRefreshingBlock:^{ _currentPage = 0; [self requestMerchandiseFromServer]; }]; MJRefresh第三方控件相信大家都使用过，一般很多人写法是像上边的代码一样，然而，当添加此代码后，不管block里边的代码有没有调用，当pop这个ViewController时，你会发现，dealloc函数没有被调用，这是为什么呢？ 我们先分析一下里边的引用关系，self引用了collectionView，collectionView中引用了MJRefresh，MJRefresh中又引用了block，最后block回过头来又引用了self，这样就形成一个闭环，导致相互持有而最终无法释放。所以最后的解决办法是： weakSelf(self) self.merchantCollectionView.mj_header = [MJRefreshHeader headerWithRefreshingBlock:^{ _currentPage = 0; [weakSelf requestMerchandiseFromServer]; }]; 或 weakSelf(self) self.merchantCollectionView.mj_header = [MJRefreshHeader headerWithRefreshingBlock:^{ _currentPage = 0; strongSelf(weakSelf) [strongSelf requestMerchandiseFromServer]; }]; 然而，经过测试，上边代码还是不对，发现仍有保留环，最后将_currentPage = 0;改为weakSelf.currentPage = 0;才解决了问题 这两种的异同处前边已经分析过，此处不再赘述 NSNOTIFICATION &amp; KVOdispatch_async(dispatch_get_main_queue(), ^{ [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidResumeNotification object:task]; }); 在AFNetworking源码中，不止一次发送了通知，而大部分发送通知都是在主线程上发送，这是为什么呢？因为在哪个线程上边发送通知，就会在哪个线程上边接收并处理通知，这个不仅适用于NSNOTIFICATION，也适用于KVO。AFNetworking开发者为了使调用他们的程序员们在接收了进度通知后更方便的更新UI，而将每次发送通知放在了主线程上，我们先根据例子验证一下这个结论： - (void)viewDidLoad { [super viewDidLoad]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(test) name:@&quot;test&quot; object:nil]; NSLog(@&quot;thread %@&quot;, [NSThread currentThread]); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ NSLog(@&quot;thread %@&quot;, [NSThread currentThread]); [self test1]; }); dispatch_async(dispatch_queue_create(&quot;com.swift3.imageQueue&quot;, DISPATCH_QUEUE_SERIAL) , ^{ NSLog(@&quot;thread %@&quot;, [NSThread currentThread]); [self test2]; }); [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;test&quot; object:nil]; } - (void)test { NSLog(@&quot;=================test thread %@&quot;, [NSThread currentThread]); } - (void)test1 { NSLog(@&quot;=================test 1 thread %@&quot;, [NSThread currentThread]); } - (void)test2 { NSLog(@&quot;=================test 2 thread %@&quot;, [NSThread currentThread]); } 运行之后打印，查看log： 2016-12-22 17:19:07.521053 EasyPushDemo[3857:1591007] thread &lt;NSThread: 0x174067ec0&gt;{number = 1, name = main} 2016-12-22 17:19:07.521708 EasyPushDemo[3857:1591007] =================test thread &lt;NSThread: 0x174067ec0&gt;{number = 1, name = main} 2016-12-22 17:19:07.522903 EasyPushDemo[3857:1591129] thread &lt;NSThread: 0x1742637c0&gt;{number = 6, name = (null)} 2016-12-22 17:19:07.523223 EasyPushDemo[3857:1591129] =================test 1 thread &lt;NSThread: 0x1742637c0&gt;{number = 6, name = (null)} 2016-12-22 17:19:07.523733 EasyPushDemo[3857:1591066] thread &lt;NSThread: 0x174260100&gt;{number = 7, name = (null)} 2016-12-22 17:19:07.524009 EasyPushDemo[3857:1591066] =================test 2 thread &lt;NSThread: 0x174260100&gt;{number = 7, name = (null)} 可以验证出，因为在哪个线程上边发送通知，就会在哪个线程上边接收并处理通知。 我们先通过博客1和博客2来看看NSNotification和KVO的基本用法 观察者注册消息通知 //notificationObserver 观察者 : self //notificationSelector 处理消息的方法名: getUserProfileSuccess //notificationName 消息通知的名字: Notification_GetUserProfileSuccess //notificationSender 消息发送者 : 表示接收哪个发送者的通知，如果第四个参数为nil,接收所有发送者的通知 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(getUserProfileSuccess:) name:@&quot;Notification_GetUserProfileSuccess&quot; object:nil]; //observer:观察者,也就是KVO通知的订阅者。订阅着必须实现observeValueForKeyPath:ofObject:change:context:方法 //keyPath：描述将要观察的属性，相对于被观察者。 //options：KVO的一些属性配置；有四个选项。 * NSKeyValueObservingOptionNew：change字典包括改变后的值 * NSKeyValueObservingOptionOld: change字典包括改变前的值 * NSKeyValueObservingOptionInitial:注册后立刻触发KVO通知 * NSKeyValueObservingOptionPrior:值改变前是否也要通知（这个key决定了是否在改变前改变后通知两次） //context: 上下文，这个会传递到订阅着的函数中，用来区分消息，所以应当是不同的。 - (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context 发送消息通知 //notificationName 消息通知的名字: Notification_GetUserProfileSuccess //notificationSender 消息发送者: userProfile //userInfo 消息中带的参数 [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;Notification_GetUserProfileSuccess&quot; object:userProfile userInfo:nil]; //任何对keyPath属性的修改都视为发送消息通知 //self.keyPath = @&quot;&quot;; 观察者处理消息 //NSNotification 接受到的消息信息，主要含： //Name: 消息名称 Notification_GetUserProfileSuccess //object: 消息发送者 userProfile //userInfo: 消息传递的数据信息 - (void) getUserProfileSuccess: (NSNotification*) aNotification { self.userProfile = [aNotification object]; lblName.text = self.userProfile.Name; lblEENO.text = self.userProfile.EENO; lblNric.text = self.userProfile.NRIC; lblBirthday.text =self.userProfile.Birthday; lblHireDate.text = self.userProfile.Hiredate; txtMobilePhone.text = self.userProfile.Mobile; txtEmail.text = self.userProfile.Email; } //keyPath：被监听的keyPath , 用来区分不同的KVO监听。 //object： 被观察修改后的对象（可以通过object获得修改后的值） //change：保存信息改变的字典（可能有旧的值，新的值等） //context：上下文，用来区分不同的KVO监听 - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context; 观察者注销，移除消息观察者 //虽然在 IOS 用上 ARC 后，不显示移除 NSNotification Observer 也不会出错，但是这是一个很不好的习惯，不利于性能和内存。 //注销观察者有2个方法： //a. 最优的方法，在 UIViewController.m 中： -(void)dealloc { [[NSNotificationCenter defaultCenter] removeObserver:self]; } //b. 单个移除： [[NSNotificationCenter defaultCenter] removeObserver:self name:@&quot;Notification_GetUserProfileSuccess&quot; object:nil]; - (void)removeObserver:(NSObject *)anObserver forKeyPath:(NSString *)keyPath - (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath context:(void *)context 记得在货车帮面试时，有个考题是如果不用系统提供的NSNotification类，如何自己实现一个此功能的模块，会用到哪些技术？基于这个问题，我查到了一篇博客,现在现在来具体研究一下这篇博客： 创建两个新类HHNotification,HHNotificationCenter，这两个类的接口和苹果提供的接口完全一样，我将根据接口提供的功能给出实现代码。 要点是通知中心是单例类，并且通知中心维护了一个包含所有注册的观察者的集合，这里我选择了动态数组来存储所有的观察者，源码如下： + (HHNotificationCenter *)defaultCenter { static HHNotificationCenter *singleton; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ singleton = [[self alloc] initSingleton]; }); return singleton; } - (instancetype)initSingleton { if ([super init]) { _observers = [NSMutableArray array]; } return self; } 还定义了一个观察者模型用于保存观察者，通知消息名，观察者收到通知后执行代码所在的操作队列和执行代码的回调，模型源码如下： @interface HHObserverModel : NSObject @property (nonatomic, strong) id observer; @property (nonatomic, assign) SEL selector; @property (nonatomic, copy) NSString *notificationName; @property (nonatomic, strong) id object; @property (nonatomic, strong) NSOperationQueue *operationQueue; @property (nonatomic, copy) OperationBlock block; @end 向通知中心注册观察者，源码如下： - (void)addObserver:(id)observer selector:(SEL)aSelector name:(NSString *)aName object:(id)anObject { HHObserverModel *observerModel = [[HHObserverModel alloc] init]; observerModel.observer = observer; observerModel.selector = aSelector; observerModel.notificationName = aName; observerModel.object = anObject; [self.observers addObject:observerModel]; } - (id &lt;NSObject&gt;)addObserverForName:(NSString *)name object:(id)obj queue:(NSOperationQueue *)queue usingBlock:(void (^)(HHNotification * _Nonnull))block { HHObserverModel *observerModel = [[HHObserverModel alloc] init]; observerModel.notificationName = name; observerModel.object = obj; observerModel.operationQueue = queue; observerModel.block = block; [self.observers addObject:observerModel]; return nil; } 发送通知有三种方式，最终都是调用- (void)postNotification:(HHNotification *)notification，源码如下： - (void)postNotification:(HHNotification *)notification { [self.observers enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) { HHObserverModel *observerModel = obj; id observer = observerModel.observer; SEL selector = observerModel.selector; if ([observerModel.notificationName isEqualToString:notification.notificationName]) { if (!observerModel.operationQueue) { #pragma clang diagnostic push #pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; [observer performSelector:selector withObject:notification]; #pragma clang diagnostic pop } else { NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{ observerModel.block(notification); }]; NSOperationQueue *operationQueue = observerModel.operationQueue; [operationQueue addOperation:operation]; } } }]; } 其实也可以用KVC和KVO来实现，但是具体的实现步骤没有跟面试官讲清楚，现在将NSNotification和KVO的功能实现分别列举如下 + (HHNotificationCenter *)defaultCenter { static HHNotificationCenter *singleton; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ singleton = [[self alloc] initSingleton]; }); return singleton; } - (instancetype)initSingleton { if ([super init]) { } return self; } 还定义了一个观察者模型用于保存观察者，通知消息名，观察者收到通知后执行代码所在的操作队列和执行代码的回调，模型源码如下： @interface HHObserverModel : NSObject @property (nonatomic, strong) id observer; @property (nonatomic, assign) SEL selector; @property (nonatomic, copy) NSString *notificationName; @property (nonatomic, strong) id object; @property (nonatomic, strong) NSOperationQueue *operationQueue; @property (nonatomic, copy) OperationBlock block; @end 向通知中心注册观察者，源码如下： //在目标target上添加关联对象，属性名propertyname(也能用来添加block)，值value - (void)addAssociatedObjectPropertyName:(NSString *)propertyName withValue:(id)value { id property = objc_getAssociatedObject(target, &amp;propertyName); if(property == nil) { property = value; objc_setAssociatedObject(self, &amp;propertyName, property, OBJC_ASSOCIATION_RETAIN); } } //获取目标target的指定关联对象值 - (id)getAssociatedObjectWithPropertyName:(NSString *)propertyName { id property = objc_getAssociatedObject(self, &amp;propertyName); return property; } - (void)addObserver:(id)observer selector:(SEL)aSelector name:(NSString *)aName object:(id)anObject { HHObserverModel *observerModel = [[HHObserverModel alloc] init]; observerModel.observer = observer; observerModel.selector = aSelector; observerModel.notificationName = aName; observerModel.object = anObject; [self addAssociatedObjectPropertyName:name withValue:observerModel]; [self addObserver:self forKeyPath:name options:nil context:nil]; } 发送通知有三种方式，最终都是调用- (void)postNotification:(HHNotification *)notification，源码如下： - (id &lt;NSObject&gt;)addObserverForName:(NSString *)name object:(id)obj queue:(NSOperationQueue *)queue usingBlock:(void (^)(HHNotification * _Nonnull))block { HHObserverModel *observerModel = [[HHObserverModel alloc] init]; observerModel.notificationName = name; observerModel.object = obj; observerModel.operationQueue = queue; observerModel.block = block; [self setValue:observerModel forKey:name]; return nil; } - (void)postNotification:(HHNotification *)notification { NSString *notificationName = notification.name; [self setValue:notification forKey:[self valueForKey:notificationName]]; } -(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(voidvoid *)context{ HHObserverModel *observerModel = [self valueForKey:keyPath]; id observer = observerModel.observer; SEL selector = observerModel.selector; if ([observerModel.notificationName isEqualToString:notification.notificationName]) { if (!observerModel.operationQueue) { #pragma clang diagnostic push #pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; [observer performSelector:selector withObject:notification]; #pragma clang diagnostic pop } else { NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{ observerModel.block(notification); }]; NSOperationQueue *operationQueue = observerModel.operationQueue; [operationQueue addOperation:operation]; } } 在这里顺便说一下KVO的原理，当你观察一个对象时，一个新的类会动态被创建。这个类继承自该对象的原本的类，并重写了被观察属性的 setter 方法。自然，重写的 setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象值的更改。最后把这个对象的 isa 指针 ( isa 指针告诉 Runtime 系统这个对象的类是什么 ) 指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例，具体的博客地址如下。 内联函数inline在iOS中的一些框架中,inline是经常出现的关键字组合，这种关键字定义的函数就是内联函数 为了搞懂为什么会出现内联函数，我们先解释一下什么是函数 函数在内存中就是一段代码，起始位置叫函数入口，也就是函数地址，其他代码通过这个地址调用函数，有时候需要把函数提供给外部使用，就需要把函数地址列成一个表放在文件头部，这些列出的函数就叫导出函数。函数有很多种，除了普通的函数，还有类成员函数、类虚函数、类静态函数等，有的是访问权限不一样(比如类成员函数和类静态函数)，调用过程不一样(虚函数)，有的是编译期行为，有的是运行时行为，但这些函数本身的存在形式都是一样的，就是函数入口加上一段代码 从上面的描述中可知，函数就是在内存中的一段代码，当需要调用时会根据函数的地址去找到，然后执行 然而由于函数在调用时必须call，就有了参数的进栈出栈，会有内存和CPU的消耗，所以引入了内联函数的概念，内联函数会在编译时就将函数编译到代码里边去，从而会减少内存和CPU的开销，但是会增加二进制文件的大小，例如 inline int foo(int a, int b) { return a+b; } void bar(int a, int b) { NSLog(@&quot;%d&quot;, foo(a, b)); } //上边的代码编译后会成为 void bar(int a, int b) { NSLog(@&quot;%d&quot;, a+b); } 由此可以看出，内联函数相比于普通函数而言，有一些优点： inline函数避免了普通函数的,在汇编时必须调用call的缺点:取消了函数的参数压栈，减少了调用的开销,提高效率.所以执行速度确比一般函数的执行速度要快. 集成了宏的优点,使用时直接用代码替换(像宏一样); 这里提到了宏，我们发现它的特点相比于宏，确实有很大一部分类似，相比于宏，还是有一些优点 避免了宏的缺点:需要预编译.因为inline内联函数也是函数,不需要预编译. 编译器在调用一个内联函数时，会首先检查它的参数的类型，保证调用正确。然后进行一系列的相关检查，就像对待任何一个真正的函数一样。这样就消除了它的隐患和局限性。 内联函数可以使用所在类的保护成员及私有成员 内联函数既然相对于普通函数和宏都有这么多优点，为什么还没有被大量应用 内联函数只是我们向编译器提供的申请,编译器不一定采取inline形式调用函数. 内联函数不能承载大量的代码.如果内联函数的函数体过大,编译器会自动放弃内联. 内联函数内不允许使用循环语句或开关语句. 内联函数的定义须在调用之前. 内联函数会导致生成的二进制文件增大 load时的方法交换调试在运行期，可以向类中新增或替换选择子所对应的方法实现 使用另一份实现来替换原有的方法实现，这道工序叫方法调配，开发者常用此功能向原有实现中添加新功能 一般来说，只有调试程序的时候才需要在运行期修改实现方法，这种做法不宜滥用 AFNetworking中就用到了这种技术，在NSURLSessionTasks中，有什么方法能监听任务状态的改变呢？由于NSURLSessionTasks类是系统提供的类，我们没有他的源码，所以我们无法监听当其调用suspend或者resume方法，从而发送通知，只能通过一些技术从外部来想办法，这时，方法交换调试就是一个很好的技术选择： + (void)load { /** WARNING: Trouble Ahead https://github.com/AFNetworking/AFNetworking/pull/2702 */ if (NSClassFromString(@&quot;NSURLSessionTask&quot;)) { /** iOS 7 and iOS 8 differ in NSURLSessionTask implementation, which makes the next bit of code a bit tricky. Many Unit Tests have been built to validate as much of this behavior has possible. Here is what we know: - NSURLSessionTasks are implemented with class clusters, meaning the class you request from the API isn&apos;t actually the type of class you will get back. - Simply referencing `[NSURLSessionTask class]` will not work. You need to ask an `NSURLSession` to actually create an object, and grab the class from there. - On iOS 7, `localDataTask` is a `__NSCFLocalDataTask`, which inherits from `__NSCFLocalSessionTask`, which inherits from `__NSCFURLSessionTask`. - On iOS 8, `localDataTask` is a `__NSCFLocalDataTask`, which inherits from `__NSCFLocalSessionTask`, which inherits from `NSURLSessionTask`. - On iOS 7, `__NSCFLocalSessionTask` and `__NSCFURLSessionTask` are the only two classes that have their own implementations of `resume` and `suspend`, and `__NSCFLocalSessionTask` DOES NOT CALL SUPER. This means both classes need to be swizzled. - On iOS 8, `NSURLSessionTask` is the only class that implements `resume` and `suspend`. This means this is the only class that needs to be swizzled. - Because `NSURLSessionTask` is not involved in the class hierarchy for every version of iOS, its easier to add the swizzled methods to a dummy class and manage them there. Some Assumptions: - No implementations of `resume` or `suspend` call super. If this were to change in a future version of iOS, we&apos;d need to handle it. - No background task classes override `resume` or `suspend` The current solution: 1) Grab an instance of `__NSCFLocalDataTask` by asking an instance of `NSURLSession` for a data task. 2) Grab a pointer to the original implementation of `af_resume` 3) Check to see if the current class has an implementation of resume. If so, continue to step 4. 4) Grab the super class of the current class. 5) Grab a pointer for the current class to the current implementation of `resume`. 6) Grab a pointer for the super class to the current implementation of `resume`. 7) If the current class implementation of `resume` is not equal to the super class implementation of `resume` AND the current implementation of `resume` is not equal to the original implementation of `af_resume`, THEN swizzle the methods 8) Set the current class to the super class, and repeat steps 3-8 */ NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration]; NSURLSession * session = [NSURLSession sessionWithConfiguration:configuration]; #pragma GCC diagnostic push #pragma GCC diagnostic ignored &quot;-Wnonnull&quot; NSURLSessionDataTask *localDataTask = [session dataTaskWithURL:nil]; #pragma clang diagnostic pop IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([self class], @selector(af_resume))); Class currentClass = [localDataTask class]; while (class_getInstanceMethod(currentClass, @selector(resume))) { Class superClass = [currentClass superclass]; IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, @selector(resume))); IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, @selector(resume))); if (classResumeIMP != superclassResumeIMP &amp;&amp; originalAFResumeIMP != classResumeIMP) { [self swizzleResumeAndSuspendMethodForClass:currentClass]; } currentClass = [currentClass superclass]; } [localDataTask cancel]; [session finishTasksAndInvalidate]; } } + (void)swizzleResumeAndSuspendMethodForClass:(Class)theClass { Method afResumeMethod = class_getInstanceMethod(self, @selector(af_resume)); Method afSuspendMethod = class_getInstanceMethod(self, @selector(af_suspend)); if (af_addMethod(theClass, @selector(af_resume), afResumeMethod)) { af_swizzleSelector(theClass, @selector(resume), @selector(af_resume)); } if (af_addMethod(theClass, @selector(af_suspend), afSuspendMethod)) { af_swizzleSelector(theClass, @selector(suspend), @selector(af_suspend)); } } - (NSURLSessionTaskState)state { NSAssert(NO, @&quot;State method should never be called in the actual dummy class&quot;); return NSURLSessionTaskStateCanceling; } - (void)af_resume { NSAssert([self respondsToSelector:@selector(state)], @&quot;Does not respond to state&quot;); NSURLSessionTaskState state = [self state]; [self af_resume]; if (state != NSURLSessionTaskStateRunning) { [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:self]; } } - (void)af_suspend { NSAssert([self respondsToSelector:@selector(state)], @&quot;Does not respond to state&quot;); NSURLSessionTaskState state = [self state]; [self af_suspend]; if (state != NSURLSessionTaskStateSuspended) { [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:self]; } } NSCopying为了学习和理解NSCopying的用法，请参考这两篇博客：NSCopying和NSMutableCopying协议和Objective-C深复制和协议 //为何用self？如果编写一个类的copyWithZone:方法那么子类的方法应该先调用父类的copy方法以复制继承来的copy实例变量. -(id)copyWithZone:(NSZone *)zone { Student *stu = [[self allocWithZone:zone]initWithName:self.name Age:self.age]; return stu; }]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>iOS</tag>
        <tag>AFNetworking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS动态库和静态库]]></title>
    <url>%2F2015%2F02%2F14%2FiOS%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93%2F</url>
    <content type="text"><![CDATA[库是一段编译好的二进制代码，是共享程序代码的方式，一般分为静态库和动态库。iOS 中静态库是static Library，后缀名是 .a，动态库是dynamic library，后缀名是 .dylib。iOS 中的 Framework 称作框架，框架其实是一种打包方式，将库的二进制文件、头文件和有关的资源文件打包到一起，方便管理和分发，框架根据其在内存中的加载方式分类，可以是动态库，也可以是静态库。以前，系统的.framework是动态库，我们自己建立的.framework是静态库，从swift开始时，我们也可以建立自己的动态库了。 静态库链接时完整地拷贝至可执行文件中，被多次使用就有多份冗余拷贝 下边通过一个教程翻译，来更加了解静态库，源地址，内容如下： 创建静态库如果我们已经做了很长时间的iOS开发了，我们可能会有一些大多数APP都能共用的代码 如果要共用这些代码，最简单的方式就是拷贝粘贴源码，但是这将会对以后的维护产生巨大的困难，这时，就需要使用静态库，静态库是很多类、函数、定义和资源组成的一个包，用这个静态库包，你可以很容易的在其他工程中引用 在这个教程中，你将会学习用两种不同的方式创建你自己的静态库 为什么你会用静态库 你可能和你的小伙伴分享一系列常用类 你想将你的常用类归结到一个地方，这样的话利于修改bug和更新 你可能需要将你的代码和很多人分享，但是不想让他们看到你的代码 你持续开发等功能代码，可能需要给他们做一个版本快照 打开Xcode，选择File／New／Project，对话框中选择iOS／Framework&amp;Library／Cocoa Touch Static Library则会创建Static Library工程，写入.h和.m的代码，运行工程，则会在Products中看到.a文件，右击在资源管理器中显示文件，则会看到有两部分组成： Header files：在头文件文件夹中，你会发现这个库工程的公共头文件们，在等会儿你的工程中，你将会用到这些头文件，这样Xcode在编译的时候才会识别这些导出类 静态库生成的就是这个.a文件，如果你需要在你的应用中使用这个静态库，就需要链接这个.a文件 这两个部分就像你往工程中添加一个新的framework一样，你只需要添加framework的header就可以将framework的code链接到你的工程中去 默认情况下，这个.a文件只能在当前架构上编译，如果你需要在模拟器中编译，就需要包含i386的架构，其他情况架构情况，如下： arm64：iPhone5S及以后｜ iPad Air｜ iPad mini2(iPad mini with Retina Display) armv7s：iPhone5｜iPhone5C｜iPad4(iPad with Retina Display) armv7：iPhone3GS｜iPhone4｜iPhone4S｜iPad｜iPad2｜iPad3(The New iPad)｜iPad mini｜iPod Touch 3G｜iPod Touch4 armv6 设备： iPhone, iPhone2, iPhone3G, 第一代、第二代 iPod Touch（一般不需要去支持） i386:模拟器 从上边能看出，不同的设备需要不同架构编译出来的.a文件，这个应该怎么办呢？幸运的是，我们可以创建一个终极版本来支持各种架构 终极版本是一个比较特别的二进制文件，它包含各种架构的代码，如何制作这种终极版本呢，这就需要用到一种工具－lipo，lipo是一个命令行工具，它可以允许你操作终极文件，在此处，我们用lipo工具来将各个架构的.a文件合成一个多架构的.a文件。lipo可以在命令行执行，也可以在Xcode中执行，此教程中我们用Xcode来操作，具体步骤见原文，过程如下： 新建一个Aggregate target，这个Aggregate target的目的是可以一次性完成多个对象的build操作，方法是File／New／Target－》Other／Aggregate，选择刚创建的Aggregate Target，选择Build Phases，添加运行脚本，点击运行，然后在设置的路径就会看到iphoneos/iphoneSimulator/universal文件夹中的.a文件和include下的.h文件 顺便解释一下这个脚本的内容 # define output folder environment variable UNIVERSAL_OUTPUTFOLDER=${BUILD_DIR}/${CONFIGURATION}-universal # Step 1. Build Device and Simulator versions xcodebuild -target ImageFilters ONLY_ACTIVE_ARCH=NO -configuration ${CONFIGURATION} -sdk iphoneos BUILD_DIR=&quot;${BUILD_DIR}&quot; BUILD_ROOT=&quot;${BUILD_ROOT}&quot; xcodebuild -target ImageFilters -configuration ${CONFIGURATION} -sdk iphonesimulator -arch i386 BUILD_DIR=”${BUILD_DIR}” BUILD_ROOT=”${BUILD_ROOT}” # make sure the output directory exists mkdir -p &quot;${UNIVERSAL_OUTPUTFOLDER}&quot; # Step 2. Create universal binary file using lipo lipo -create -output &quot;${UNIVERSAL_OUTPUTFOLDER}/lib${PROJECT_NAME}.a&quot; &quot;${BUILD_DIR}/${CONFIGURATION}-iphoneos/lib${PROJECT_NAME}.a&quot; &quot;${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/lib${PROJECT_NAME}.a&quot; # Last touch. copy the header files. Just for convenience cp -R &quot;${BUILD_DIR}/${CONFIGURATION}-iphoneos/include&quot; “${UNIVERSAL_OUTPUTFOLDER}/&quot; UNIVERSAL_OUTPUTFOLDER：设置universal的路径 Step 1：分别编译iphoneos／iphoneSimulator架构生成.a文件 Step 2：lipo命令将两个.a文件合并成一个，放到universal的路径下 最后一步，将.h文件拷贝到universal的路径下 如何用静态库 直接用.h文件和.a文件 直接用.h文件和.a文件需要将告诉Xcode，.h文件和.a文件分别在那里。.h文件的告诉方法是project navigator／target／Build Settings／Header Search Paths。.a的告诉方式是Build Phases／Link Binary With Libraries／click the + button／Add Other… 告诉了之后，还要设置linker flag为-Objc，之所以使用该标志，和Objective-C的一个重要特性：类别（category)有关。根据这里的解释，Unix的标准静态库实现和Objective-C的动态特性之间有一些冲突：Objective-C没有为每个函数（或者方法）定义链接符号，它只为每个类创建链接符号。这样当在一个静态库中使用类别来扩展已有类的时候，链接器不知道如何把类原有的方法和类别中的方法整合起来，就会导致你调用类别中的方法时，出现”selector not recognized”，也就是找不到方法定义的错误。为了解决这个问题，引入了-ObjC标志，它的作用就是将静态库中所有的和对象相关的文件都加载进来 本来这样就可以解决问题了，不过在64位的Mac系统或者iOS系统下，链接器有一个bug，会导致只包含有类别的静态库无法使用-ObjC标志来加载文件。变通方法是使用-all_load 或者-force_load标志，它们的作用都是加载静态库中所有文件，不过all_load作用于所有的库，而-force_load后面必须要指定具体的文件。 将此库工程用作别的工程的子工程 将此库工程的工程文件拖入正在操作的工程中，此正在操作的工程中先将库工程的target设置为此工程的target Dependencies，步骤为：project root／target／Build Phases／Target Dependencies／Click on the + button 添加target 随后将.a文件也加载进来，步骤是Build Phases／Link Binary With Libraries／click the + button／Add Other…最后也是设置linker flag为－ObjC 第二种方法和第一种方法的不同之处是 第二种方法没有设置Header Search Paths 第二种方法本身生成的就是Universal library 为什么会这样，因为第二种方法，当添加xcodeprj作为子工程时Xcode会知道在哪里寻找.h和.a以及根据情况确定到底编译的时候用的哪种架构，所以第二种方法要简单许多，如果你有源码或工程，第二种方法是比较优先的使用方式 创建framework上一篇已经讲过，你为什么使用静态库以及如何使用静态库，我们可以看出，静态库的使用是比较繁琐的，需要导入.a和.h文件，如果.h比较多的话，就会显的很繁琐，怎么解决这个问题呢，下边我们跟着这个教程，来学习一下，如何将你的代码像iOS SDK的API一样根据模块来划分，从iOS8,Xcode6开始，苹果提供了直接创建Cocoa Touch Framework的模版，这种方法比以前要简单很多，framework要三个主要目的 对代码进行封装 对代码化分模块 对代码重用 你可以将你的framework与你的其它app，其它团队成员，第三方平台分享。当将swift的访问控制和framework结合起来后，framework可以在代码模块间定义强大的并且可测试的接口 在swift中，一个模块就是一些被编译出来的代码一起被发布。framework就是一种模块，一个app也是一种模块 跟着这篇博客，你会做下边几个事情 为这个环形控件创建一个工程（此处直接下载） 迁移现有的代码并且测试（将代码中的核心代码和资源分离出来，放到framework工程中去） 将所有的东西导入到app中（1，以引用子工程的形式将库工程导入到app中，将库工程编译出来的framework文件手动添加到主工程的Embedded Binary中，现在主工程的代码即可识别库工程中的类和对象 2，修改swift中的访问控制全部为public public表示全部可引用 Internal表示同一个framework中可用 private表示只在本类中能用 3，设置storyboard中的custom class的module属性，因为打成framework后，用类时不仅要知道view对应的类，也需要知道它在哪一个模块中 4，运行 5，如果有单元测试，在单元测试文件中添加import，告诉代码应该去哪个framework下去寻找） 将它放在超级便捷的cocoapods中 奖励：为你的framework设置目录 frameworks是一个包含一系列代码和资源的包，可以将它导入到任意多个app中去，就像其它语言的modules，packages，gems，jars等等 本篇文章也讲了如何将你的代码发布在第三方的平台cocoapods，因为不是本节相关内容，故暂且省略 制作静态库时的几点注意： 注意理解：无论是.a静态库还.framework静态库，我们需要的都是二进制文件+.h+其它资源文件的形式，不同的是，.a本身就是二进制文件，需要我们自己配上.h和其它文件才能使用，而.framework本身已经包含了.h和其它文件，可以直接使用。 图片资源的处理：两种静态库，一般都是把图片文件单独的放在一个.bundle文件中，一般.bundle的名字和.a或.framework的名字相同。.bundle文件很好弄，新建一个文件夹，把它改名为.bundle就可以了，右键，显示包内容可以向其中添加图片资源。 category是我们实际开发项目中经常用到的，把category打成静态库是没有问题的，但是在用这个静态库的工程中，调用category中的方法时会有找不到该方法的运行时错误（selector not recognized），解决办法是：在使用静态库的工程中配置other linker flags的值为-ObjC。 如果一个静态库很复杂，需要暴露的.h比较多的话，就可以在静态库的内部创建一个.h文件（一般这个.h文件的名字和静态库的名字相同），然后把所有需要暴露出来的.h文件都集中放在这个.h文件中，而那些原本需要暴露的.h都不需要再暴露了，只需要把.h暴露出来就可以了。 如何解决静态库中的图片资源问题最近在做静态库的封装，发现图片文件的加载没问题，但是加载xib时总是报 .bundle&gt; (not yet loaded)，很是头疼。 先说怎么加载图片，一定要带上bundle的包名，要不然找不到文件。如下：[UIImage imageNamed:@”FFTKeyBoardBundle.bundle/ps.png”]; 如何解决静态库中的xib问题 不用xib,纯代码写。 第一个方法实在让我不爽，折腾了好几天，查了好些资料总算解决了。 如下操作： 先给你的静态库新建一个bundle,这个很关键。File/New/Target/OS X Framework&amp;Library/Bundle 这个时候你就创建了一个bundle,但这个bundle是OS X的。要做下修改。Build Settings/Base SDK/Latest iOS 设置bundle里面的资源。Build Phases/copy Bundle Resources 到这里我们基本上是完成了。下面是最关键的地方。运行项目找到这个bundle.我是用下图的方法找的，不知道你们的路径写的是哪里，如果是默认的应该和我的一样。说的简单点Xcode需要的bundle是编译后的bundle. 用的话就这么用就可以了： NSBundle *bundle = [NSBundle bundleWithURL:[[NSBundle mainBundle] URLForResource:@&quot;FFTKeyBoardBundle&quot; withExtension:@&quot;bundle&quot;]]; self = [bundle loadNibNamed:@&quot;PassWordKeyBoard&quot; owner:nil options:nil].firstObject; 另：编译后的bundle文件如果有1x,和2X的图片我们可以看到变成了.tiff文件当然如果你使用的界面是纯代码的就不用这么麻烦了，直接把资源文件夹后缀改成.bundle就可以了 framework的热更新做法具体参见这几个博客热更新-动态加载framework、WWDC2014之iOS使用动态库、iOS的原生热更新做法 具体过程如下： 创建framework工程，在里边新建类及方法 新建Aggregate Target，添加run script，将代码在各个平台上编译后合并成一个.framework文件，注意demo的run script是不对的，需自己写 run Aggregate Target后生成.framework文件 将framework以资源包的形势添加到主工程中 代码实现 也可以将Framework放到远程，通过下载来实现其内部的代码 NSString * bundlePath = [[ NSBundle mainBundle] pathForResource: @&quot;Dylib&quot; ofType :@ &quot;framework&quot;]; NSError *error = nil; NSBundle *bundle = [NSBundle bundleWithPath:bundlePath]; NSLog(@&quot;%@&quot;, bundlePath); if([bundle loadAndReturnError:&amp;error]) { NSLog(@&quot;bundle load framework succ&quot;); } else { NSLog(@&quot;bundle load framework fail&quot;); } Class rootClass = NSClassFromString(@&quot;test&quot;); if (rootClass) { id object = [[rootClass alloc] init]; [object performSelector:@selector(runtestRun:) withObject:@&quot;哈哈，调用成功&quot;]; } 动态库链接时不复制，程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存 总结来说：其实就是加载时机和加载次数的不同 framework 一般情况下就是对library的封装，同时封装了对应的header文件、以及引用的资源文件(如果有) 静态库与动态库的区别 静态库：链接时完整地拷贝至可执行文件中，被多次使用就有多份冗余拷贝。 动态库：链接时不复制，程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Framework</tag>
        <tag>Library</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS工程框架]]></title>
    <url>%2F2015%2F01%2F30%2FiOS%E5%B7%A5%E7%A8%8B%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[当我们进入到新的公司的第一天，看到以前老员工编写的代码，找个东西累死人咧，那个抓耳挠腮的啊，一般情况下都有想揍人的赶脚。 不过，我们先想一下自己的代码！想一下自己写的代码怎么才能新来的人一眼就能看懂，想找什么，在几秒之内就能找到?这个就需要在前期创建项目的时候留神了，要保证项目的易读性、易维护性以及易扩展性等。 在我看来，作为一个项目开发的领头人，你可以从三个方面着手： 项目的代码架构 项目的组织框架 代码的规范 本章内容先来总结一下项目在初期规划时项目的组织框架，其他会在以后的文章中总结 PXSJ工作空间中的每个项目名称，一个工作空间可以有多个项目 PXSJ每个项目对应的代码主目录，此目录中的所有代码均为自己编写，第三方代码放置于此目录之外 Module 项目内的功能模块总文件夹，如账号模块，商品模块，支付模块等 Main 主模块文件夹，如果模块内文件较多，内容过大，一般在文件夹里边采用mvc三层框架结构（同样的规则也适用于其他的功能模块），如： Model：此模块内用到的各种数据模型，如服务器传回的json数据模型封装，以及需要自己封装来填充View的各种数据模型都放于此，注意，如果是全局共用到的一些Model，则需要放在和Module目录平级的公共Model目录中，如果是第三方的model，则放在外围的ThirdLib当中，同样的规则也适用于下边的View和Controller模块 View：此模块内的各种自定义View Controller：各种视图控制器 User 用户模块文件夹 Footprint 足迹模块文件夹 Street 街道模块文件夹 View 全局会用到的视图，包括继承UIView视图或者对UIView视图进行扩展的视图 Model 全局公用到的一些Model Helper 对于一些第三方库的二次封装，加入一些定制化符合我们的需求，更加利于我们使用，如HttpHelper，SnsHelper，AnimHelper，DBHelper等 Utility 公用的实用工具，比如操作字符串，获取手机信息等工具类型的操作，还有一些扩展、类型等实体类 Init main.storyboard、launch.storyboard、appDelegate、images.xcassets、xcdatamodeld etc等项目需要的资源内容 ThirdLib由于一些第三方源码没有在pod中注册，或者即便在pod中注册过，也需要我们手动修改而满足项目需求的，放在此位置，注意分组和文件夹位置对应 UnityUnity C#工程转换成为Unity OC工程后的工程存放地址，以供更容易的和APP工程相互调用 UnityTool将Unity工程导入此工作空间时的工具类 Products产品目录，系统自动生成 PodsPods配置目录 Frameworks项目引用到的框架目录 PodsPods项目目录]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Effective-OC2.0第二部分]]></title>
    <url>%2F2014%2F12%2F26%2FEffective-OC2.0%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[内存管理理解引用计数Retain递增保留计数 release递减保留计数 autorelease待清理自动释放池时，再递减保留计数 strong属性表示先retain，后release，再赋值 在自动释放池中的对象，不会立马释放，通常是在下一次事件循环时保留数递减 保留环是呈环状相互引用，这将导致内存泄露，因为循环中的对象其保留计数不会降为0 引用计数机制通过可以递增递减的计数器来管理内存，对象创建好之后，其保留计数至少为1。若保留计数为正，则对象继续存活。当保留计数降为0时，对象就被销毁了。 在对象生命周期中，其余对象通过引用来保留或释放此对象。保留与释放操作分别会递增及递减保留计数 以ARC简化引用计数ARC下不能调用以下方法 retain/release/autorelease/dealloc ARC下必须遵循方法命名规则，以alloc/new/copy/mutableCopy开头的方法返回的对象归调用者所有，需要在外部释放 有了ARC之后，程序员就无须担心内存管理问题了。使用ARC来编程，可省去类中的许多样板代码 ARC管理对象生命周期的办法基本上就是：在合适的地方插入保留及释放操作。在ARC环境下，变量的内存管理语义可以通过修饰符指明，而原来则需要手工执行保留及释放操作 由方法所返回的对象，其内存管理语义总是可以通过方法名来体现。ARC将此确定为开发者必须遵守的规则 ARC只负责管理OC对象的内存，尤其要注意：CoreFoundation对象不归ARC管理，开发者必须适时调用CFRetain/CFRelease 在dealloc方法中只释放引用并解除监听在dealloc方法中，应该做的事情就是释放指向其他对象的引用，并取消原来订阅的键值观测(KVO)或通知(NSNotification)，不要做其他事情 如果对象持有文件描述符等系统资源，那么应该专门编写一个方法来释放此种资源。这样的类要和其使用者约定，用完资源后必须调用close方法 执行异步任务的方法不应在dealloc中调用，只能在正常状态下执行的那些方法也不应在dealloc中调用，因为此时对象已处于正在回收的状态了 编写异常安全代码时留意内存管理问题捕获异常时，一定要注意将try块内所创立的对象清理干净 在默认情况下，ARC不生成安全处理异常所需清理的代码。开启编译器标志后-fobjc-arc-exceptions，可生成这种代码，不过会导致应用程序变大，从而会降低运行效率 以弱引用避免保留环将某些引用设为weak，可避免出现保留环 weak引用可以自动清空，也可以不自动清空。自动清空是随着ARC而引入的新特性，由运行期系统来实现。在具备自动清空功能的弱引用上，可以随意读取其数据，因为这种引用不会指向已经回收过的对象 以自动释放池块降低内存峰值自动释放池排布在栈中，对象收到autorelease消息后，系统将其放入最顶端的池里 合理运用自动释放池，可降低应用程序的内存峰值 @autoreleasepool{}这种新式的写法能创建出更为轻便的自动释放池 用僵尸对象调试内存管理问题系统在回收对象时，可以不将其真的回收，而是把它转换为僵尸对象。通过环境变量NSZombieEnabled可开启此功能 系统会修改对象的isa指针，另其指向特殊的僵尸类，从而使该对象变为僵尸对象。僵尸类能够响应所有的选择子，响应方式为：打印一条包含消息内容及其接收者的消息，然后终止应用程序 不要使用retainCount对象的保留技术看似有用，实则不然，因为任何给定时间点上的绝对保留计数都无法反映对象生命期的全貌 引入ARC后，retainCount方法就正式废止了，在ARC下调用该方法会导致编译器报错 块与大中枢派发理解块这一概念块是C、C++、OC中的词法闭包 块可以接受参数，也可以返回值 块可以分配在栈或堆上，也可以是全局的。分配在栈上的块可拷贝到堆里，这样的话，就和标准的OC对象一样，具备引用计数了。 为常用的块类型创建typedef以typedef重新定义块类型，可令块变量用起来更加简单 定义新类型时应遵循现有的命名习惯，勿使其名称与别的类型相冲突 不妨为同一个块签名定义多个类型别名。如果要重构的代码使用了块类型的某个别名，那么只需修改相应的typedef中的块签名即可，无须改动其他typedef 用handler块降低代码分散程度在创建对象时，可以使用内联的handler块将相关业务逻辑一并声明 在有多个实例需要监控时，如果用委托模式，那么经常需要根据传入的对象来切换，而若改用handler块来实现，则可直接将块与相关对象放在一起 设计API时如果遇到了handler块，那么可以增加一个参数，使调用者可以通过此参数来决定应该把块安排在哪个队列上执行 用块引用其所属对象时不要出现保留环如果块所捕获的对象直接或间接地保留了块本身，那么就得当心保留环问题 一定要找个适当的实际解除保留环，而不能把责任推给API的调用者 多用派发队列，少用同步锁派发队列可用来表述同步语义，这种做法要比使用@synchronized块或NSLock对象更简单 dispatch_queue_t _syncQueue = dispatch_queue_create(“com.effectiveobjectivec.syncQueue”, NULL); dispatch_queue_t _syncQueue = dispatch_queue_create(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); - (NSString*)someString { __block NSString *localSomeString; dispatch_sync(_syncQueue, ^{ localString=someString; }); return localSomeString; } 将同步与异步派发结合起来，可以实现与普通加锁机制一样的同步行为，而这么做却不会阻塞执行异步派发的线程 - (void)setSomeString:(NSString*)someString { dispatch_async(_syncQueue, ^{ _someString=someString; }); } 使用同步队列及栅栏块，可以令同步行为更加高效 -(void)setSomeString:(NSString*)someString { dispatch_barrier_async(_syncQueue, ^{ _someString=someString; }); } 多用GCD，少用performSelector系列方法performSelector系列方法在内存管理方面容易有疏失，它无法确定将要执行的选择子具体是什么，因而ARC编译器也就无法插入适当的内存管理方法 performSelector系列方法所能处理的选择子太过局限了，选择子的返回值类型及发送给方法的参数个数都要受限制 如果想把任务放在另一个线程上执行，那么最好不要用performSelector系列方法，而是应该把任务封装到块里，然后调用大中枢派发机制的相关方法来实现 掌握GCD及操作队列的使用时机在解决多线程的任务管理问题时，GCD并非唯一方案，还可以使用操作队列，即NSOperationQueue类，它有如下优点 取消某个操作 指定操作间的依赖关系 通过键值观测机制监控NSOperation对象的属性 指定操作的优先级 重用NSOperation对象，子类NSBlockOperation等 操作队列提供了一套高层的OC API，能实现纯GCD所具备的绝大部分功能，而且还能完成一些更为复杂的操作，那些操作若改用GCD来实现，则需另外编写代码 通过Dispatch Group机制，根据系统资源状况来执行任务一系列任务可归入一个dispatch group中，开发者可以在这组任务执行完毕时获得通知 通过dispatch group，可以在并发式派发队列里同时执行多项任务。此时GCD会根据系统资源状况来调度这些并发执行的任务。开发者若自己来实现此功能，则需编写大量代码 dispatch_group_t dispatchGroup = dispatch_group_create(); dispatch_queue_t _syncQueue = dispatch_queue_create(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_group_async(dispatchGroup, queue, block); dispatch_group_wait(dispatchGroup, dispatch_time_t timeout);//同步等待dispatch_group执行完毕 dispatch_group_notify(group, queue, block);//任务组执行完毕了发送通知，在线程上运行block 未必一定要用dispatch_group，也可以使用dispatch_apply(size iterations, dispatch_queue queue, void(^block)(size));然而，dispatch_apply会持续阻塞，直到所有任务都执行完毕为止 使用dispatch_once来执行只需要运行一次的线程安全代码经常需要编写“只需要执行一次的线程安全代码”，通过GCD所提供的dispatch_once函数，很容易能实现此功能 +(id)sharedInstance { static EOCClass *sharedInstance = nil; @sychronized(self) { if(!sharedInstance) { sharedInstance=[[self alloc] init]; } }; return sharedInstance; } +(id)sharedInstance { static EOCClass *sharedInstance = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ sharedInstance=[[self alloc] init]; }); return sharedInstance; } 标记应该声明在static或global作用域中，这样的话，把只需执行一次的块传给dispatch_once函数时，传进去的标记也是相同的 不要使用dispatch_get_current_queuedispatch_get_current_queue函数的行为常常与开发者所预期的不同，此函数已经废弃，只应做调试之用 由于派发队列是按层级来组织的，所以无法单用某个队列对象来描述当前队列这一概念 dispatch_get_current_queue函数用于解决由不可重入的代码所引发的死锁，然而能用此函数解决的问题，通常也能改用队列特殊数据来解决 系统框架熟悉系统框架许多系统框架都可以直接使用，其中最重要的是Foundation与CoreFoundation，这两个框架提供了构建应用程序所需的许多核心功能 很多常见的任务都能用框架来做，例如音频与视频处理、网络通信、数据管理等 请记住，用纯C写成的框架与用OC写成的一样重要，若想成为优秀的OC开发者，应该掌握C语音的核心概念 多用块枚举，少于for循环遍历collection有4种方式，最基本的办法是for循环，其次是NSEnumerator遍历及快速遍历法，最新、最先进的方式则是块枚举法 1. for(int i;i&lt;size;i++); 2. NSEnumerator *enumerator = [aArray keyEnumerator]; while((id key=[enumerator nextObject])!=nil){}; 3. for(id object in aArray); 4. [aArray enumerateObjectsUsingBlock:^(id object, NSUInteger index, BOOL *stop) {}; 块枚举法本身就是通过GCD来并发执行遍历操作，无须另行编写代码，而采用其他遍历方式则无法轻易实现这一点 若提前知道待遍历的collection含有何种对象，则应修改块签名，指出对象的具体类型 对自定义其内存管理语义的collection使用无缝桥接通过无缝桥接技术，可以在Foundation框架中的OC对象与CoreFoundation框架中的C语言数据结构之间来回转换 在CoreFoundation层面创建collection时，可以指定许多回调函数，这些函数表示此collection应如何处理其元素。然后可以运用无缝桥接技术，将其转换成具备特殊内存管理语句的OC collection 构建缓存时选用NSCache而非NSDictionary实现缓存时应选用NSCache而非NSDictionary对象，因为NSCache可以提供优雅的自动删减功能，而且是线程安全的，此外，它与字典不同，并不会拷贝键 可以给NSCache对象设置上限，用以限制缓存中的对象总个数及内存总大小，而这些尺度则定义了缓存删减其中对象的时机。但是绝对不要把这些尺度当成可靠的硬限制，它们仅对NSCache起作用 将NSPurgeableData与NSCache搭配使用，可实现自动清除数据的功能，也就是说，当NSPurgeableData对象所占的内存为系统所丢弃时，该对象自身也会从缓存中移除 如果缓存使用得当，那么应用程序的响应速度就能提高，只有那种重新计算起来很费事的数据，才值得放入缓存，比如那些需要从网络获取或从磁盘获取的数据 精简initialise与load的实现代码在加载阶段，如果类实现了load方法，那么系统就会调用它。分类里也可以定义此方法，类的load方法要比分类中的先调用。与其他方法不同，load方法不参与覆写机制，即如果某个类本身没有实现load方法，那么不管其各级超类是否实现此方法，系统都不会调用，程序在执行load方法时都会阻塞，不要在load方法里执行任何任务，load方法的真正用途仅在于调试 initialise是惰性调用的，只有当程序用到了相关的类时，才会调用。initialise方法是线程安全的，只有执行initialise的那个线程可以操作类或类的实例，其他线程都要先阻塞，等着initialise执行完。如果某个类未实现initialise方法，而其超类实现了，那么就会运行超类的实现代码 首次使用某个类之前，系统会向其发送initialise消息，由于此方法遵循普通的覆写规则，所以通常应该在里面判断当前要初始化的是哪个类 load与initialise方法都应该实现的精简一些，这有助于保持应用程序的响应能力，也能减少引入依赖环的几率 无法在编译器设定的全局常量，可以放在initialise方法里初始化 共同点： 在不考虑开发者主动使用的情况下，系统最多会调用一次 如果父类和子类都被调用，父类的调用一定在子类之前 这两个方法不适合做复杂的操作，应该是足够简单 在使用时都不要过重地依赖于这两个方法，除非真正必要。在使用时一定要注意防止死锁！ 都不需要调用[super load]、[super initialise] 不同点： load方法没有自动释放池，如果做数据处理，需要释放内存，则开发者得自己添加autoreleasepool来管理内存的释放 和load不同，即使子类不实现initialize方法，也会把父类的实现继承过来调用一遍。注意的是在此之前，父类的方法已经被执行过一次了，同样不需要super调用 别忘了NSTimer会保留其目标对象NSTimer对象会保留其目标，直到计时器本身失效为止，调用invalidate方法可令计时器失效，另外，一次性的计时器在触发完任务之后也会失效 反复执行任务的计时器，很容易引入保留环，如果这种计时器的目标对象又保留了计时器本身，那肯定会导致保留环。这种保留关系，可能是直接发生的，也可能是通过对象图里的其他对象间接发生的 可以扩充NSTimer的功能，用块来打破保留环。不过，除非NSTimer将来在公共接口里提供此功能，否则必须创建分类，将相关实现代码加入其中 @impletation NSTimer (EOCBlockSupport) + (NSTimer*)eoc_scheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(void(^)())block repeats:(BOOL)repeats { return [self scheduledTimerWithTimeInterval:interval target:self selector:@selector(eoc_blockInvoke:) userInfo:[block copy] repeats:repeats]; } + (void)eoc_blockInvoke:(NSTimer*)timer { void (^block)() = timer.userInfo; if(block) {block();} } @end - (void)startPolling { __weak EOCClass *weakSelf = self; NSTimer *_pollTimer = [NSTimer eoc_scheduledTimerWithTimeInterval:1 block:^{ EOCClass *strongSelf = weakSelf; [strongSelf p_doPoll];} repeats:YES]; }]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Effective-OC2.0第一部分]]></title>
    <url>%2F2014%2F11%2F28%2FEffective-OC2.0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[最近将《Effective Objective-C 2.0》这本书浏览了一遍，感觉这本书是ios进阶必看的一本书。如果书中的涉及的主题能够都掌握，那么绝对可以宣称自己是一个高级oc使用者。 熟悉OC了解OC语言的起源OC为C语言添加了面向对象特性，是其超集。OC使用动态绑定的消息结构，也就是说，在运行时才会检查对象类型。接收一条消息之后，究竟应执行何种代码，由运行期环境而非编译器来决定。 理解C语言的核心概念有助于写好OC程序。尤其要掌握内存模型与指针。 在类的头文件中尽量少引入其他头文件除非确有必要，否则不要引入头文件。一般来说，应在某个类的头文件中使用向前声明来提及别的类，并在实现文件中引入那些类的头文件。这样做可以尽量降低类之间的耦合。 有时无法使用向前声明，比如要声明某个类遵循一项协议。这种情况下，尽量把该类遵循某协议的这条声明移至”class-continuation分类”中，如果不行的话，就把协议单独放在一个头文件中，然后将其引入。 多用字面量语法、少用与之等价的方法应该使用字面量语法来创建字符串、数值、数组、字典。与创建此类对象的常规方法相比，这么做更加简明扼要。 应该通过取下标操作来访问数组下标或字典中的键所对应的元素。 用字面量语法创建数组或字典时，若值中有nil，则会抛出异常。因此，务必确保值里不含nil。 多用类型常量，少用#define预处理指令不要用预处理指令定义常量。这样定义出来的常量不含类型信息，编译器只是会在编译前据此执行查找与替换操作。即使有人重新定义了常量值，编译器也不会产生警告信息，这将导致应用程序中的常量不一致。 在实现文件中使用static const来定义“只在编译单元内可见的常量”，由于此类常量不在全局符号表中，所以无须为其名称加前缀。 在头文件中使用extern来声明全局变量，并在相关实现文件中定义其值。这种常量要出现在全局符号表中，所以其名称应加以区隔，通常用与之相关的类名做前缀。 //In the header file extern NSString *const EOCStringConstant; //In the implementation file NSString *const EOCStringConstant = @“VALUE”; 用枚举表示状态、选项、状态码应该用枚举来表示状态机的状态、传递给方法的选项以及状态码等值，给这些值起个易懂的名字。 如果把传递给某个方法的选项表示为枚举类型，而多个选项又可同时使用，那么就将各选项的值定义为2的幂，以便通过按位或操作将其组合起来。 用NS_ENUM与NS_OPTIONS宏来定义枚举类型，并指明其底层数据类型。这样做可以确保枚举是用开发者所选的底层数据类型实现出来的，而不会采用编译器所选的类型。 //For example typedef NS_ENUM(NSUInteger, EOCConnectionState) { EOCConnectionStateConnected, EOCConnectionStateConnecting, EOCConnectionStateDisconnected, }; typedef NS_OPTIONS(NSUInteger, EOCPermittedDirection) { EOCPermittedDirectionUp=1&lt;&lt;0, EOCPermittedDirectionDown=1&lt;&lt;1, EOCPermittedDirectionLeft=1&lt;&lt;2, EOCPermittedDirectionRight=1&lt;&lt;3, }; 在处理枚举类型的switch语句中不要实现default分支。这样的话，加入新枚举之后，编译器就会提示开发者：switch语句并未处理所有枚举。 对象、消息、运行期理解属性这一概念@interface EOCPerson:NSObject @property NSString *firstName; @property NSString *lastName; @end //same as @interface EOCPerson:NSObject - (NSString*)firstName; - (void)setFirstName:(NSString*)firstName; - (NSString*)lastName; - (void)setLastName:(NSString*)lastName; @end @implementation EOCPerson @synthesize firstName=_firstName; @synthesize lastName=_lastName; @end 若不想令编译器自动合成存取方法，就使用@dynamic关键字，它会告诉编译器，不要自动创建实现属性所用的实例变量，也不要为其创建存取方法。 属性的特质分为四类：原子性、读写权限、内存管理语义、方法名 原子性：默认情况下，由编译器所合成的方法会通过锁定机制确保其原子性(atomicity)，如果属性具备nonatomic特质，则不适用同步锁 读写权限：具备readwrite特质的属性拥有获取方法getter和设置方法setter，readonly特质的属性仅拥有获取方法 内存管理语义： assign 设置方法只针对纯量类型 strong 特质表明该属性定义了一种拥有关系，为这种属性设置新值时，设置方法会先保留新值，并释放旧值，然后再将新值设置上去 weak 特质表明该属性定义了一种非拥有关系，为这种属性设置新值时，设置方法既不保留新值，也不释放旧值，此特质同assign类似，然而在该属性所指的对象遭到摧毁时，属性值也会清空 unsafe_unretained特质的语义和assign相同，表示一种非拥有关系，当目标对象遭到破坏时，属性值不会自动清空，不安全 copy特质与strong类似，然而并不保留新值，而是将其拷贝，新值与其拷贝的值之间不公用内存空间 方法名：getter=/setter=指定获取和设置方法的方法名 可以使用@property语法来定义对象中所封装的数据 通过“特质”来指定存储数据所需的正确语义 在设置属性所对应的实例变量时，一定要遵从该属性所声明的语义 开发iOS程序时应该使用nonatomic属性，因为atomic属性会严重影响性能 如何给已经存在的对象添加属性： 通过运行时中的方法动态添加 通过valueForUndefinedKey动态添加 通过类别拓展属性，结合objc_getAssociatedObject(); 在对象内部尽量直接访问实例变量直接访问实例变量和通过属性访问有如下区别： 由于不经过OC的方法派发步骤，所以直接访问实例变量的速度当然比较快，这种情况下，编译器所生成的代码会直接访问保存对象实例变量的那块内存 直接访问实例变量时，不会调用其设置方法，这就绕过了为相关属性所定义的内存管理语句 如果直接访问实例变量，那么不会触发键值监听(KVO)通知，有可能会对app有影响 通过属性来访问有助于排查与之相关的错误，因为可以给获取方法和设置方法中新增断点，监控该属性的调用者及其访问时机 至于哪一种更优胜些，有一种折中方案，那就是，在写入实例变量时，通过其设置方法来做，而在读取实例变量时，则直接访问 由于子类可能覆写父类方法，所以在初始化方法及dealloc方法中，总是应该直接通过实例变量来读写数据 有时会使用惰性初始化技术配置某份数据，这种情况下，需要通过属性来读取数据 理解对象等同性这一概念若想检测对象的等同性，请提供isEqual:与hash方法 相同的对象必须具有相同的哈希码，但是两个哈希码相同的对象却未必相同，isEqual相同，则hash必相同，所以isEqual相同，则表明两者是相同对象 不要盲目地逐个检测每条属性，而是应该依照具体需求来制定检测方案 编写hash方法时，应该使用计算速度快而且哈希码碰撞率低的算法 以类簇模式隐藏实现细节如何向类簇中新增子类： 子类应该继承自类簇中的抽象基类 子类应该定义自己的数据存储方式 子类应该覆写超类文档中指明需要覆写的方法 类簇模式可以把实现细节隐藏在一套简单的公共接口后面 系统框架中经常使用类簇 从类簇的公共抽象基类中继承子类时要当心，若有开发文档，则应先阅读 在既有类中使用关联对象存放自定义数据关联对象，将value值关联到object对象中去，属性名为key void objc_setAssociatedObject(id object, void *key, id value, objc_AssociationPolicy policy) 关联类型objc_AssociationPolicy包括 OBJC_ASSOCIATION_ASSIGN assign OBJC_ASSOCIATION_RETAIN_NONATOMIC nonatomic,retain OBJC_ASSOCIATION_COPY_NONATOMIC nonatomic,copy OBJC_ASSOCIATION_RETAIN retain OBJC_ASSOCIATION_COPY copy 根据给定的键从某对象中获取相应的关联对象值 id objc_getAssociatedObject(id object, void *key) 移除指定对象的全部关联对象 void objc_removeAssociatedObjects(id object) 可以通过关联对象机制把两个对象连起来 定义关联对象时可指定内存管理语句，用以模仿定义属性时所采用的拥有关系与非拥有关系 只有在其他做法不可行时才应选用关联对象，因为这种做法通常会引入难于查找的bug 理解objc_msgSend的作用在OC中，如果向某对象传递消息，那就会使用动态绑定机制来决定需要调用的方法。在底层，所有方法都是普通的C语音函数，然而对象收到消息之后，究竟该调用哪个方法则完全于运行期决定，甚至可以在运行时改变，这使得OC成为一门真正的动态语言。 给对象发送消息可以这样来写：id returnValue = [someObject messageName:parameter];其中someObject叫做接收者，messageName叫做选择子(selector)，选择子与参数和起来成为消息(message)，编译器看到此消息后，将其转换为一条标准的C语言函数调用，所调用的函数乃是消息传递机制中的核心函数，叫做objc_msgSend，其原型如下：void objc_msgSend(id self, SEL cmd, …)，这是个参数个数可变的函数，能接受两个或两个以上的参数，第一个参数代表接收者，第二个参数代表选择子，也就是方法名称，后续参数就是消息中的那些参数，其顺序不变。 编译器会把刚才的函数转换为id returnValue = objc_msgSend(someObject, @selector(messageName:), parameter); objc_msgSend函数会依据接收者与选择子的类型来调用适当的方法，为了完成此操作，该方法需要在接收者所属的类中搜寻其方法列表，如果能找到与选择子名称相符合的方法，就跳至实现代码，顺便将匹配结果缓存在快速映射表里(每个类都有这样一块内存)，若是找不到，那就沿着继承体系继续向上查找，等找到再跳，若还是找不到，就会执行消息转发操作 objc_msgSend_stret 待发送的消息返回结构体，可交由此函数处理 objc_msgSend_fpret 待发送的消息返回浮点数，可交由此函数处理 objc_msgSendSuper 如果要给超类发消息，例如[super message:parameter]，可交由此函数处理 刚才曾提到，objc_msgSend等函数一旦找到应该调用的方法实现之后，就会跳转过去，之所以能这样做，是因为OC对象的每个方法都可以视为简单的C函数，其原型如下：&lt;return_type&gt; Class_selector(id self, SEL _cmd, …)，真正的函数名和上面写的可能不太一样，每个类里都有一张表格，其中的指针都会指向这种函数，而选择子的名称则是查表时所用的键，objc_msgSend等函数正是通过这张表格来寻找应该执行的方法并跳至其实现的 消息由接收者、选择子及参数构成，给某对象发送消息就相当于在该对象上调用方法 发给某对象的全部消息都要由动态消息派发系统来处理，该系统会查出对应的方法，并执行其代码 理解消息转发机制消息转发分为两个大阶段，第一阶段先征询接收者所属的类，看能否动态添加方法，以处理当前这个未知的选择子，这叫做动态方法解析，第二阶段涉及完整的消息转发机制，此又分为两小步，首先，请接收者看看有没有其他对象能处理这条消息，如果没有，则启动完整的消息转发机制，运行期系统会把与消息有关的全部细节都封装到NSInvocation对象中，再给接收者最后一次机会，令其设法解决当前还未处理的这条消息。 动态方法解析：对象在收到无法解读的消息后，首先将调用其所属类的下列类方法： +(BOOL)resolveInstanceMethod:(SEL)selector; +(BOOL)resolveClassMethod:(SEL)selector { NSString *selectorString = NSStringFormSelector(selector); if(/*selector is a @dynamic property*/) { if([selectorString hasPrefix:@“set”]) { class_addMethod(self, selector, (IMP)autoDictionarySetter, “v@:@”); } else { class_addMethod(self, selector, (IMP)autoDictionaryGetter, “@@:”); } } } 备援接收者：当前接收者还有第二次机会能处理未知的选择子，在这一步中，运行期系统会问它，能不能把这条消息转给其他接收者来处理，与之对应的处理方法如下：-(id)forwardingTargetForSelector:(SEL)selector;该对象可经由此方法将能够处理某选择子的相关内部对象返回，这样的话，在外界看来好像是该对象亲自处理了这些消息似的。 完整的消息转发：将消息等内容修改后重新封装于NSInvocation对象中，然后由消息派发系统重新派发给目标对象，此步骤会调用下列方法：-(void)forwardInvocation:(NSInvocation*)invocation;实现此方法时，若发现某调用操作不应由本类处理，则需要调用超类的同名方法，这样的话，继承体系中的每个类都有机会处理此调用的请求，直至NSObject，如果最后还是没有处理，则会调用doesNotRecognizerSelector:抛出异常，此异常表明选择子最终未能得到处理。 在一个函数找不到时，Objective-C提供了三种方式去补救： 调用resolveInstanceMethod给个机会让类添加这个实现这个函数 调用forwardingTargetForSelector让别的对象去执行这个函数 调用methodSignatureForSelector（函数符号制造器）和forwardInvocation（函数执行器）灵活的将目标函数以其他形式执行如果都不中，调用doesNotRecogniseSelector抛出异常 用方法调配技术调试黑盒方法以下方法可以实现两个方法的互换 Method originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString)); method_exchangeImplementations(originalMethod, swappedMethod); 以下操作再加上上述的方法互换操作可以为那些完全不知道其具体实现的黑盒方法增加日志记录功能，非常有助于调试 @interface NSString (EOCMyAdditions) - (NSString*)eoc_myLowercaseString; @end @implementation NSString (EOCMyAdditions) - (NSString*)eoc_myLowercaseString { NSString *lowercase = [self eoc_myLowercaseString]; NSLog(@“%@=&gt;%@”, self, lowercase); return lowercase; } @end 在运行期，可以向类中新增或替换选择子所对应的方法实现 使用另一份实现来替换原有的方法实现，这道工序叫方法调配，开发者常用此功能向原有实现中添加新功能 一般来说，只有调试程序的时候才需要在运行期修改实现方法，这种做法不宜滥用 理解类对象的用意每个实例都有一个指向Class对象的指针，用以表明其类型，而这些Class对象则构成了类的继承体系 如果对象类型在编译期无法确定，那么就应该使用类型信息查询方法来探知 尽量使用类型信息查询方法来确定对象的类型，而不要直接比较类对象，因为某些对象可能实现了消息转发功能 接口与API设计用前缀避免命名空间冲突选择与你公司、应用程序或二者皆有关联的名称作为类名的前缀，并在所有代码中均使用这一前缀 若自己开发的程序库中用到了第三方库，其应为其中的名称加上前缀 提供全能初始化方法在类中提供一个全能初始化方法，并于文档里指明。其他初始化方法均应调用此方法 若全能初始化方法与超类不同，则需覆写超类中的对应方法 如果超类的初始化方法不适用于子类，那么应该覆写这个超类方法，并在其中抛出异常 实现description方法实现description方法返回一个有意义的字符串，用以描述该实例 若想在调试时打印出更详尽的对象描述信息，则应实现debugDescription 尽量创建不可变对象尽量创建不可变对象 若某属性仅可于对象内部修改，则在class-continuation分类中将其由readonly属性扩展为readwrite属性 不要把可变的collection作为属性公开，而应提供相关方法，以此修改对象中的可变collection 使用清晰而协调的命名方式起名时应遵从标准的OC命名规范，这样创建出来的接口更容易为开发者所理解 方法名要言简意赅，从左至右读起来要像个日常用语中的句子才好 方法名里不要使用缩略后的类型名称 给方法起名时的第一要务就是确保其风格与你自己的代码或所要集成的框架相符 为私有方法起名加前缀给私有方法的名称加上前缀，这样可以很容易地将其同公共方法区别开 不要单用一个下划线做私有方法的前缀，因为这种做法是预留给苹果公司使用的 理解OC错误模型@throw [NSException exceptionWithName:@“NAME” reason:@“REASON” userInfo:UserInfo]; NSError *error = [NSError errorWithDomain:@“domain” code:code userInfo:userInfo]; domain错误发生的范围，其类型为字符串，也就是产生错误的根源，通常用一个特有的全局变量来定义 errorCode错误码，其类型为整数，独有的错误代码，用以指明发生何种错误，一般用枚举 userInfo用户信息，为字典类型，包括有关此错误的额外信息 -(BOOL)doSomething:(NSError**)error { if(/*there is an error*/) { *error = [NSError errorWithDomain:domain code:code userInfo:userInfo]; return NO; } else { return YES; } } 只有发生了可使整个应用程序奔溃的严重错误时，才应使用异常 在错误不那么严重的情况下，可以指派委托方法来处理，也可以把错误信息放在NSError对象里，经由输出参数返回给调用者 理解NSCopying协议若想令自己所写的对象具有拷贝功能，则需实现NSCopying协议 如果自定义的对象分为可变版本与不可变版本，那么就要同时实现NSCopying与NSMutableCopying协议 复制对象时需决定采用浅拷贝还是深拷贝，一般情况下应该尽量执行浅拷贝 如果你所写的对象需要深拷贝，那么可以考虑新增一个专门执行深拷贝的方法 协议与分类通过委托与数据源协议进行对象间通信委托模式为对象提供了一套接口，使其可由此将相关事件告知其他对象 将委托对象应该支持的接口定义成协议，在协议中把可能需要处理的事件定义成方法 当某对象需要从另外一个对象中获取数据时，可以使用委托模式，这种情况下，该模式亦称数据源协议 若有必要，可实现含有位段的结构体，将委托对象能否响应相关协议方法这一信息缓存至其中 将类的实现代码分散到便于管理的数个分类之中使用分类机制把类的实现代码划分成易于管理的小块 将应该视为私有的方法归入名叫private的分类中，以隐藏实现细节 总是为第三方类的分类名称加前缀向第三方类中添加分类时，总应给其名称加上你专用的前缀 向第三方类中添加分类时，总应给其中的方法名加上你专用的前缀 勿在分类中声明属性把封装数据所用的全部属性都定义在主接口里 在class-continuation分类之外的其他分类中，可以定义存取方法，但尽量不要定义属性，因为它不会自动生成存取方法，此时可以把存取方法声明为@dynamic，也就是说，这些方法等到运行期再提供，编译器是看不见的。所以必须在运行期才会提供方法，此时只能使用消息转发机制来实现 如果在分类中定义属性，则在实现中不能生成存取方法，会报warning(property requires method, use @dynamic or provide a method implementation in this category)，此时根据提示用dynamic，或者手动提供一个存取方法完成功能，内部用对象关联来实现功能 #import &quot;NSAttributedString+CHEmoj.h&quot; #import &lt;objc/runtime.h&gt; static const char *kKey = &quot;kKey&quot;; @implementation NSAttributedString (CHEmoj) - (void)setHaha:(NSString *)haha { objc_setAssociatedObject(self, kKey, haha, OBJC_ASSOCIATION_RETAIN_NONATOMIC); } - (NSString *)haha { return objc_getAssociatedObject(self, kKey); } @end 使用class-continuation分类隐藏实现细节通过class-continuation分类向类中新增实例变量 如果某属性在主接口中声明为只读，而类的内部又要用设置方法修改此属性，那么可以在class-continuation分类中将其扩展为可读写 把私有方法的原型声明在class-continuation分类里面 若想使类所遵循的协议不为人所知，则可于class-continuation分类中声明 通过协议提供匿名对象协议可在某种程度上提供匿名类型，具体的对象类型可以淡化成遵循某协议的id类型，协议里规定了对象所应实现的方法 使用匿名对象来隐藏类型名称或类名 如果具体类型不重要，重要的是对象能够响应定义在协议里的特定方法，那么可使用匿名对象来表示]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIScrollView的API及用法]]></title>
    <url>%2F2014%2F10%2F31%2FUIScrollView%E7%9A%84API%E5%8F%8A%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[UIScrollViewUIScrollView 类为那些比应用窗口大的显示内容提供一种支持，它可以让用户在区域内通过手势来滑动，捏合来缩放操作 概要UIScrollView 是 UITableView 和 UITextView 的基类 UIScrollView 对象最主要特征就是它的内部有一个可以调整位置的内容视图，它把内容视图剪切到它自己的框架位置，当手指移动时，它自动调整内容视图的位置。UIScrollView的内容视图会根据offset位置来绘制自己。UIScrollView只负责绘制横向和竖向滚动指示器，其他的不负责。UIScrollView必须要知道它的内容视图的大小，这样它才会知道什么时候应该停止滚动。默认的，当滑动超越了边界时，它会弹回来。 在 UIScrollView 中负责管理内容视图显示的对象应该也管理子视图，从而使视图不会超出屏幕的范围。当用户滑动的时候，这个对象应该持续添加和删除子视图。 由于 UIScrollView 没有滚动条，它又必须知道用户的触摸操作是滑动内容还是和它的内容视图的交互，所以基于这个目的，它暂时触发一个touch-down事件，同时开启一个Timer，在timer触发以前看指头是否有一些可观的移偏量，如果没有，UIScrollView 会将事件发送到子视图中，如果在timer触发之前，用户手指移动了一定距离，UIScrollView 就会取消和其子视图的交互并且触发自己的滑动操作。UIScrollView 的子类可以重写touchesShouldBegin:withEvent:inContentView:、pagingEnabled、touchesShouldCancelInContentView:方法，这些方法会影响 UIScrollView 如何处理那些滚动手势。 UIScrollView重载了hitTest方法，当手指touch的时候，UIScrollView会拦截所有event,然后等待150ms，在这段时间内，如果没有手指没有移动，当时间结束时，UIScrollView会发送tracking event到子视图上，并且自身不滑动。在时间结束前，手指发生了移动，那么UIScrollView就会进行滑动，从而取消发送tracking。 UIScrollView 也可以处理缩放和平移操作。当用户做捏合操作的时候，它会自动调整内容视图的位置和大小比例，当操作结束的时候，内容视图管理器会自动更新内容视图的子视图（注意当只有一个手指在视图上时，操作也会结束），当手势在进行时中，UIScrollView 不会向它的子视图发送操作。 UIScrollView 类可以有一个实现了协议 UIScrollViewDelegate 的委托，为了让缩放和平移有效果，必须实现viewForZoomingInScrollView:和scrollViewDidEndZooming:withView:atScale:方法，同时缩放的最大值(maximumZoomScale)和最小值(minimumZoomScale)必须不同 更多关于view基本行为的信息，请阅读View Programming Guide for iOS 状态保存在iOS6以及以后的版本中，如果你对 UIScrollView 的 restorationIdentifier 属性赋值了，它就会试着保存滑动相关的一些信息，比如zoomScale、contentInset和contentOffset等属性。在恢复的时候，UIScrollView会恢复那些属性以至于内容视图被显示在以前的位置。更多关于状态保存的恢复的内容，请阅读App Programming Guide for iOS 更多关于外观和行为的配置，请阅读Scroll Views 操作管理内容的显示 -setContentOffset:animated: contentOffset contentSize contentInset 管理滚动 scrollEnabled directionalLockEnabled 让用户每次只在一个方向上滚动，竖直或者水平，但是如果初始移动方向处于45°左右的时候，这个锁就失效了 scrollsToTop 击设备的状态栏时，使scrollsToTop == YES的控件滚动返回至顶部 每一个默认的UIScrollView的实例，他的scrollsToTop属性默认为YES，所以要实现某一UIScrollView的实例点击设备状态栏返回顶部，则需要关闭其他的UIScrollView的实例的scrollsToTop属性为NO。很好理解：若多个scrollView响应返回顶部的事件，系统就不知道到底要将那个scrollView返回顶部了，因此也就不做任何操作了。。。 -scrollRectToVisible:animated: pagingEnabled bounces 控制控件遇到边框是否反弹 alwaysBounceVertical alwaysBounceHorizontal -touchesShouldBegin:withEvent:inContentView: 子类重写此方法，当手指在显示内容中按下时自定义默认的行为 -touchesShouldCancelInContentView: 子类重写此方法，返回是否停止contentView的相关触摸方法并开始滚动UIScrollView -touchesShouldBegin:withEvent:inContentView:和-touchesShouldCancelInContentView:方法中有touches和contentView两个关键字，表示在UIScrollView中触摸contentView的内部时的一些处理 -touchesShouldBegin:withEvent:inContentView:是否将touch事件传入到contentView中去开始处理，如果返回YES说明是传入，此情况下UIScrollView不会接收事件，就不会滚动 -touchesShouldCancelInContentView: 是否取消将事件传入到contentView，如果返回YES说明取消，此情况下UIScrollView就会接收事件，从而发生滚动 canCancelContentTouches 这个BOOL类型的值控制content view里的触摸是否总能引发跟踪(tracking) 如果属性值为YES并且跟踪到手指正触摸到一个内容控件，这时如果用户拖动手指的距离足够产生滚动，那么内容控件将收到一个touchesCancelled:withEvent:消息，而scroll view将这次触摸作为滚动来处理。如果值为NO，一旦content view开始跟踪(tracking==YES)，则无论手指是否移动，scrollView都不会滚动。 简单通俗点说，如果为YES，就会等待用户下一步动作，如果用户移动手指到一定距离，就会把这个操作作为滚动来处理并开始滚动，同时发送一个touchesCancelled:withEvent:消息给内容控件，由控件自行处理。如果为NO，就不会等待用户下一步动作，并始终不会触发scrollView的滚动了。 delaysContentTouches 是否延迟内容视图的触摸 delaysContentTouches。默认值为YES；如果设置为NO，则无论手指移动的多么快，始终都会将触摸事件传递给内部控件；设置为NO可能会影响到UIScrollView的滚动功能。 decelerationRate UIScrollView 减速，它的值域是（0.0，1.0）,当decelerationRate设置为0.1时，当手指touch up时就会很慢的停下来 dragging 是否正在拖动 UIScrollView tracking 当touch后还没有拖动的时候值是YES,否则NO decelerating 当用户抬起手指后，判断UIScrollView的内容是否还在滑动 如何判断UIScrollView停止滑动:停止滑动有两种情况滑动ScrollView，当手指抬起时，此时会调用scrollViewDidEndDragging 如果是手指慢慢抬起，此时decelerate参数为NO，说明不会再减速了，也不会调用有关减速的delegate了 如果手指快速抬起，ScrollView会滑动一段距离减速停止，此时会调用delegate 的 scrollViewDidEndDecelerating函数 - (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate { if(!decelerate) { //OK,真正停止了，do something } } - (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView { //OK,真正停止了,do something } 管理滑动指示器 indicatorStyle UIScrollViewIndicatorStyleDefault/Black/White scrollIndicatorInsets 滚动指标点到滚动视图的边缘的距离,默认值为UIEdgeInsetsZero showsHorizontalScrollIndicator showsVerticalScrollIndicator -flashScrollIndicators 闪一下滚动条,暗示是否有可滚动的内容 缩放和平移 panGestureRecognizer 当UIScrollView想要更加精确的平移手势时会用到此属性 pinchGestureRecognizer -zoomToRect:animated: zoomScale 当前的缩放比例 -setZoomScale:animated: maximumZoomScale minimumZoomScale zoomBouncing 布尔值,表明缩放是否已超过了指定接收器的缩放限制 zooming 是否正在缩放 bouncesZoom 属性可以确保view的放缩比例超出设置比例范围时自动进行反弹 管理委托 delegate 管理键盘 keyboardDismissMode UIScrollViewKeyboardDismissModeNone/OnDrag/Interactive 在滚动的时候可以让键盘消失 常量 UIScrollViewIndicatorStyle UIScrollViewIndicatorStyleDefault/Black/White Deceleration Constants UIScrollViewDecelerationRateNormal/RateFast UIScrollViewKeyboardDismissMode UIScrollViewKeyboardDismissModeNone/OnDrag/Interactive 实例属性 directionalPressGestureRecognizer refreshControl UIScrollViewDelegate概要实现了UIScrollViewDelegate协议的对象可以被指定为UIScrollView的委托，UIScrollViewDelegate协议中的方法可以用来作为一些操作的回调，比如滚动、缩放、减速、滚动动画等操作 操作滚动和拖动操作的回调 -scrollViewDidScroll: 当用户滑动内容时 -scrollViewWillBeginDragging: -scrollViewWillEndDragging:withVelocity:targetContentOffset: -scrollViewDidEndDragging:willDecelerate: -scrollViewShouldScrollToTop: -scrollViewDidScrollToTop: -scrollViewWillBeginDecelerating: -scrollViewDidEndDecelerating: 管理缩放 -viewForZoomingInScrollView: -scrollViewWillBeginZooming:withView: -scrollViewDidEndZooming:withView:atScale: -scrollViewDidZoom: 滚动动画回调 -scrollViewDidEndScrollingAnimation:]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>UIScrollView</tag>
        <tag>UIKit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIView的API及用法]]></title>
    <url>%2F2014%2F09%2F26%2FUIView%E7%9A%84API%E5%8F%8A%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[UIViewUIView 类在屏幕上定义了一个长方形区域和及其接口，通过此方式来管理这个区域内的内容 概要在运行时，一个 view 对象负责对其区域内部的内容进行渲染，并且负责与其内部的内容进行交互。UIView 类为自己背景颜色的填充区域自己提供了基本的行为。通过继承UIView并实现一些必要的绘图和事件处理方法，可以完成更加复杂的内容和功能。UIKit 框架也提供了一些标准的子类来直接运用，比如从简单的buttons到复杂的tables，UILabel来负责绘制文字，UIImageView来负责绘图。 由于 view 对象是用户和应用交互的主要方式，所以他们有大量的方法：如 绘制和动画 通过技术(如UIKit，Core Graphics和OpenGL ES等)绘制矩形内的区域 view 声明的一些属性可以通过动画方式转换到另一个值 布局和子view管理 一个 view 可以包含0个或多个子 view 每个 view 都定义了他们同父 view 之间的放大缩小关系 一个 view 可以定义其内部子 view 的大小和位置 事件处理 一个 view 是一个可以处理触摸事件的响应者，其他的事件在其父类 UIResponser 中定义 可以用addGestureRecognizer方法为 view 添加公共的手势识别 View 可以嵌入其他的 View 来创建复杂的视图层次，这会在 view 之间创建一种父子关系。通常，子 view 的边界不会裁剪到他的父 view 的边界，不过你可以修改属性 clipsToBounds 来改变这种行为。一个父视图可以包含很多字视图，但是每个子视图只能有一个父视图，通过这个父视图来负责处理他的位置。 如题，有两个view： view1,view2，view2添加view1中，如果view2大于view1，或者view2的坐标不在view1的范围内，view2是盖着view1的，意思就是超出的部份也会画出来，UIView有一个属性，clipsTobounds 默认情况下是NO,如果，我们想要view2把超出的那部份隐藏起来的话，就得改变它的父视图也就view1的clipsTobounds属性值。view1.clipsTobounds = YES; 一个 view 的位置通过他的 frame，bounds 和 center 属性来定义，frame 属性定义了它在其父 view 的坐标系中的初始点和宽高像素点数，通常被用在布局时来调整其位置和大小。center 属性用来调整自己的位置，而不会改变其大小。bounds 属性定义了他在其自己的坐标系中的位置，通常被用在自定义绘制代码中。修改 view 的 size 属性时，frame 和 bounds 属性是一块更改。 更多关于如何使用 UIView 的详细信息，请阅读 View Programming Guide for iOS. 在 iOS2.x 的版本中，view 的最大的大小是 1024x1024，在 iOS3.0 以后，view 大小不再有严格的限制，但是仍然受内存的限制，应该尽力让 view 保持足够小，如果不考虑 iOS 版本的问题，你应该注意比屏幕大的那些 view 的内容。 创建一个视图如果用代码创建视图，可以用如下方法 CGRect viewRect = CGRectMake(10, 10, 100, 100); UIView* myView = [[UIView alloc] initWithFrame:viewRect]; 这段代码创建了一个视图，并将其放置在父视图的坐标系统的位置(10, 10)，为了添加视图到另一个视图中，你可以应用addSubview:方法。在 iOS 中，兄弟 view 可以相互覆盖而不会引起任何问题，也允许兄弟 view 之间相互替代。addSubview 方法会将指定的 view 添加到其他兄弟 view 的顶层，你可以通过运用 insertSubview:aboveSubview: 和 insertSubview:belowSubview: 将子 view 插入到指定的位置，也可以通过 exchangeSubviewAtIndex:withSubviewAtIndex: 方法将两个指定的 view 交换位置。 当创建一个 view 的时候，赋一个合适的值到 autoresizingMast 属性是非常重要的，这样可以保证 view 正常缩放。view 的缩放一般会发生在当你手机的方向发生变化的时候，很多时候也会发生其他情况，比如，调用 setNeedsLayout 方法强制来使 view 刷新布局。 视图绘制周期绘制视图是视图最基本的功能。布局改变时，当一个 view 第一次出现，或他所有的子部分出现的时候，系统会让 view 来绘制他自己的内容。对那些包括了通过 UIKit 或 Core Graphics 来自定义内容的 view，系统会调用 drawRect: 方法，此时你只需要实现此方法来绘制内容到当前的图像上下文 graphics context 当中去，系统会自动优先调用此方法来完成绘制，这将会创建一个静态的视图，这个视图会作为你 view 的内容而绘制到屏幕上去。 如果你运用 OpenGL ES 来绘制视图，你应该继承 GLKView 类，而不是 UIView 类。更多关于如何通过 OpenGL ES 绘制的问题，请阅读此处 在绘制周期中，更多关于视图绘制和视图角色的内容，请阅读此处 动画更改 view 的几项属性可以引起动画，也就是说，更改属性会创建动画，这些动画会在一段时间内给用户展现出效果。UIView 类会完成大部分的属性动画，但是你必须表明哪些属性的改变需要动画。一般有两种方式来初始化动画： 在 iOS4 或者以后，用基于块的动画方法.(推荐) 用 begin/commit 动画方法 基于块的动画方法，比如 animateWithDuration:animations:，极大的简化了动画的创建。运用一个方法就可以定义一个动画并设置其选项，然而，这个方法只能应用在 iOS4 或者以后的版本。如果你的应用需要在更早的版本上运行，你必须用 beginAnimations:context: 和 commitAnimations 类方法类完成动画的实现。 view 的以下几个属性均可以动画： frame bounds center transform alpha backgroundColor 更多关于如何配置动画的内容，请访问此处 线程考虑应用主界面的控制必须在主线程中发生。因此，你必须在应用的主线程中调用 UIView 的方法。唯一没有严格限制必须在主线程中进行的操作时创建 view 的时候，但是其他的操作必须在主线程中去实现。 继承注意事项UIView 是视图的继承基类，并且需要和用户交互。尽管关于继承 UIView 我们可以提出很多原因，但是我们建议只有在基本的 UIView 类或者系统提供的标准子类不满足需求情况的时候才去继承和自定义。继承需要你做很多工作来实现相应功能。 更多关于避免继承 UIView 的内容，请阅读Alternatives to Subclassing 重写方法当继承一个 UIView 的时候，根据你的需求，你应该重写很多方法，因为 UIView 是一个高度配置类，所以除过通过重写方法的方式实现以外，还有很多方式来完成一些复杂的视图行为，这将会在Alternatives to Subclassing这节中讨论，不过，可以考虑通过重写以下的几个方法来实现 初始化 initWithFrame: 建议你实现这个方法，也可以添加或者替代自定义的初始化方法 initWithCoder: 如果是从nib中加载而来的并且需要自定义初始化的view，则需要实现此方法 layerClass 只有当你想用不同的Core Animation layout来backing store时，会用到这个属性，比如你想用一小片区域来展示一个大的滑动区域，你可能会设置此属性为 CATiledLayer 类 绘制和打印 drawRect: 如果需要绘制自定义的内容，则需要实现此方法。如果不做一些自定义的绘制，则避免使用此方法 drawRect:forViewPrintFormatter: 仅当你想要在打印时绘制不同的内容，才会实现此方法 约束 requiresConstraintBasedLayout 如果你的 view 需要包含约束来正确运行，运用这个方法（我们应该在自定义View中重写这个方法。如果我们要使用Auto Layout布局当前视图,应该设置为返回YES） updateConstraints 如果需要在子 view 之间创建约束关系，则实现这个方法 alignmentRectForFrame:, frameForAlignmentRect: 实现这个方法来定义 view 是如何和其他 view 对齐的 布局 sizeThatFits: 如果你需要你的 view 在进行缩放操作时有一个默认的大小，而不是随意缩放，你需要实现此方法。比如，你可以运用这个方法来阻止收缩来保证子 view 可以正确的显示 layoutSubviews 如果需要根据约束或者自动缩放行为来更精确的控制子 view的布局，则需要调用此方法 didAddSubview:, willRemoveSubview: 当添加子 view 后或者移除子 view 前做的操作 willMoveToSuperview:, didMoveToSuperview 当被当做子 view 从父 view 中添加或移除时做的操作 willMoveToWindow:, didMoveToWindow 当从窗口中添加或移除时做的操作 事件处理 touchesBegan:withEvent:, touchesMoved:withEvent:, touchesEnded:withEvent:, touchesCancelled:withEvent: 如果你想要直接处理触摸事件，实现此方法（对于基于手势的处理，直接用gesture recognizers） gestureRecognizerShouldBegin: 询问一个手势接收者是否应该开始解释执行一个触摸接收事件 Alternatives to Subclassing很多视图行为可以不用通过继承就能完成。在你重写方法之前，考虑修改现有的属性就可以完成需要的行为。 addConstraint: 为 view 或其 subView 添加定义自动布局行为 autoresizingMask 当父 view 的 frame 改变时，提供自动布局行为。这些行为可以和自动布局的约束相结合 contentMode 为 view 的内容提供布局行为，跟 view 的 frame 相对应。这个属性也会影响当内容被缩放时如何自适应 view，和被缓存，被重绘。 hidden or alpha 将 view 和子 view 作为一个整体改变其透明度，而不是仅将透明度应用到 view 提供的内容中 backgroundColor 设置 view 的颜色而不是自己去绘制颜色 Subviews 不需要用 drawRect: 方法来绘制自己的内容，而是将 image 和 label 等子 view 嵌入到你想显示的 view 中去 Gesture recognizers 不需要继承 view 和自己处理触摸事件，可以运用手势识别来发送一个 Target-Action 到你的对象中去 Animations 用已经构造的内部动画，而不是自己来写动画。Core Animation 提供的动画又简单又快速 Image-based backgrounds 对于那些显示相对静态的内容，要考虑用 UIImageView 对象和手势识别，而不是直接继承 UIView 和自己绘制 image，选择性的，你可以用一般的 UIView 对象，并且将你的 image 作为内容赋值到这个 view 的 CALayer 的属性上去 动画是另一种可以使 view 可视中动态改变的方法，不需要你来继承类并完成复杂的绘制代码。UIView 类的许多属性有动画效果，这意味着这些属性的修改将会触发系统生成的动画。开始动画只需要很少量甚至一行代码来表明需要改变哪个属性。更多关于对于 view 的动画的信息，请阅读此处 更多关于外观和行为的配置，请阅读 About Views in UIKit User Interface Catalog 模块 API初始化View对象 initWithFrame: 配置View的外观 backgroundColor hidden alpha opaque 是否不透明，如果为YES，则表示是不透明，这时系统在绘制时会做一些优化来提升性能，比如不绘制其底部的视图。如果为NO，则系统不会自动优化。因此，如果视图部分或全部支持透明，那么你必须把opaque这个值设置为NO，否则会导致一些未知的结果 tintColor 色调颜色，是被使用在UIView中改变应用程序的外观的。默认tintColor的值为nil，这表示它将会运用父视图层次的颜色来进行着色。如果父视图中没有设置tintColor，那么默认系统就会使用蓝色。 tintAdjustmentMode 它可以使tint color变暗, 因此整个视图层次变暗 clipsToBounds 是指视图上的子视图,如果超出父视图的部分就截取掉 clearsContextBeforeDrawing 决定在视图重画之前是否先清理视图以前的内容,缺省值为YES，如果你把这个属性设为NO，那么你要保证能在 drawRect：方法中正确的绘画。如果你的代码已经做了大量优化，那么设为NO可以提高性能，尤其是在滚动时可能只需要重新绘画视图的一部分 maskView maskView主要是通过CAGradientLayer 或者 带有alpha的view来作为一个蒙版 view 来操作 layerClass 只有当你想用不同的Core Animation layout来backing store时，会用到这个属性 layer 配置事件行为 userInteractionEnabled multipleTouchEnabled exclusiveTouch 可以达到同一界面上多个控件接受事件时的排他性,从而避免一些问题。也就是说避免在一个界面上同时点击多个button 配置bounds和frame矩形 frame bounds center transform 管理View的层级 superview subviews window addSubview: bringSubviewToFront: sendSubviewToBack: removeFromSuperview insertSubview:atIndex: insertSubview:aboveSubview: insertSubview:belowSubview: exchangeSubviewAtIndex:withSubviewAtIndex: isDescendantOfView: 此 view 是否是指定 view 的子 view 配置缩放行为 autoresizingMask 当父 view 的bounds改变时，他如何缩放他自己来适配 autoresizesSubviews 当自己的 bounds 改变时，是否需要重新缩放他的子 view 来适配 contentMode 当自己的 bounds 改变时，如何重新布局他的内容 contentStretch（Deprecated） 定义了一个矩形来控制 view 的哪些区域可以被拉伸，哪些区域不可以 sizeThatFits: 给定一个矩形大小，从而返回一个最合适此矩形大小的矩形。此方法不会resize，只是计算一下下 sizeToFit 直接缩放并且移动内容来使其完全包括在里边，这样搞就直接改变了这个的宽和高，使它根据上面字符串的大小做合适的改变 布局子View layoutSubviews 布局子 view，在很多时候都会调用，一般需要重写 setNeedsLayout 标记使当前的布局无效，系统将会在下一个更新周期重新布局 layoutIfNeeded 立马更新布局 requiresConstraintBasedLayout 此 view 内部是否需要基于约束的布局系统 translatesAutoresizingMaskIntoConstraints 标志是否需要将自动缩放转换为自动布局种的约束 用Layout Anchors创建约束 bottomAnchor view 的底部边界 centerXAnchor centerYAnchor firstBaselineAnchor heightAnchor lastBaselineAnchor leadingAnchor leftAnchor rightAnchor topAnchor trailingAnchor widthAnchor 管理View的约束 constraints addConstraint: addConstraints: removeConstraint: removeConstraints: 运用Layout Guide addLayoutGuide: layoutGuides layoutMarginsGuide readableContentGuide 这个属性为View定义了一个可以放置用于阅读的内容的最佳区域 removeLayoutGuide: 在Auto Layout中测量 systemLayoutSizeFittingSize: 返回满足约束的 view 的大小，如UITableViewCell 中的 label systemLayoutSizeFittingSize:withHorizontalFittingPriority:verticalFittingPriority: intrinsicContentSize view 的固有大小 invalidateIntrinsicContentSize 废除视图原本内容的固有大小，使其重新计算 contentCompressionResistancePriorityForAxis: setContentCompressionResistancePriority:forAxis: contentHuggingPriorityForAxis: setContentHuggingPriority:forAxis: 在Auto Layout中对齐View alignmentRectForFrame: 返回给定框架的视图的对齐矩阵，和frameForAlignmentRect互逆 frameForAlignmentRect: alignmentRectInsets 大多数自定义视图只需要重写alignmentRectInsets以报告内容在其框架内的位置 viewForBaselineLayout（Deprecated） 可以通过实现 viewForBaselineLayout 来激活基线对齐 viewForFirstBaselineLayout viewForLastBaselineLayout Cocoa和Cocoa Touch还有其他几种表现对齐几何图形的方式。可以使用alignmentRectForFrame:、frameForAlignmentRect:、baselineOffsetFromBottom和alignmentRectInsets方法。使用这些方法可以让视图通过代码来声明和转换对齐矩形 触发Auto Layout needsUpdateConstraints 决定是否需要刷新约束 setNeedsUpdateConstraints 设置是否需要刷新约束 updateConstraints 刷新view的约束 updateConstraintsIfNeeded 刷新view及其子view的约束 调试Auto Layout更多关于自动布局向导的细节请参考调试基于约束的布局 constraintsAffectingLayoutForAxis: 返回基于给定方向的所有约束 hasAmbiguousLayout 此view是否有不明确的约束 exerciseAmbiguityInLayout 在调试时，在不同的有效值之间切换模糊布局来随机改变视图的frame 管理用户交互方向 semanticContentAttribute 语义内容属性，他决定了布局时是否有方向规则 effectiveUserInterfaceLayoutDirection 对于view来说，当前有效的布局方向 +userInterfaceLayoutDirectionForSemanticContentAttribute: 当创建一个view并且内容包含其他view时，可以用此方法来决定是否此view的子view可以被翻转，从而使内部的子view重新排序 +userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection: 配置内容边框 layoutMargins preservesSuperviewLayoutMargins 是否需要保存父view的边距，默认是NO layoutMarginsDidChange 边距被改变时的回调 绘制和更新View drawRect: setNeedsDisplay setNeedsDisplayInRect: contentScaleFactor 内容缩放因子，做多屏幕分辨率时会不同 tintColorDidChange 格式化View打印内容 viewPrintFormatter 返回view的打印格式 drawRect:forViewPrintFormatter: 绘制需要打印的view 管理手势识别 addGestureRecognizer: removeGestureRecognizer: gestureRecognizers gestureRecognizerShouldBegin: 询问一个手势接收者是否应该开始解释执行一个触摸接收事件，此方法在gesture recognizer视图转出UIGestureRecognizerStatePossible状态时调用，如果返回NO,则转换到UIGestureRecognizerStateFailed;如果返回YES,则继续识别触摸序列 用块对象实现View动画 +animateWithDuration:delay:options:animations:completion: +animateWithDuration:animations:completion: +animateWithDuration:animations: +transitionWithView:duration:options:animations:completion: +transitionFromView:toView:duration:options:completion: +animateKeyframesWithDuration:delay:options:animations:completion: +addKeyframeWithRelativeStartTime:relativeDuration:animations: +performSystemAnimation:onViews:options:animations:completion: 从带有动画的层级视图中移除一个视图的方法, 第一个参数使用。Delete（仅有的可用的第一个参数）。这会让那个视图变模糊、收缩和褪色, 之后再给它发送 removeFromSuperview 方法 +animateWithDuration:delay:usingSpringWithDamping:initialSpringVelocity:options:animations:completion: 弹性动画。Damping阻尼系数，范围 0~1 当它设置为1时，动画是平滑的没有振动的达到静止状态，越接近0 振动越大，Velocity弹性速率，就是形变的速度，从视觉上看可以理解弹簧的形变速度，到动画结束，该速度减为0，所以，velocity速度越大，那么形变会越快，当然在同等时间内，速度的变化（就是速率）也会越快，因为速度最后都要到0。 +performWithoutAnimation: 调用时使动画失效 View动画在iOS4或者以后的版本中这些方法不推荐使用，而应该使用块对象实现View动画 +beginAnimations:context: +commitAnimations +setAnimationStartDate: +setAnimationsEnabled: +setAnimationDelegate: +setAnimationWillStartSelector: 当动画开始时调用selector的方法 +setAnimationDidStopSelector: +setAnimationDuration: +setAnimationDelay: +setAnimationCurve: +setAnimationRepeatCount: +setAnimationRepeatAutoreverses: +setAnimationBeginsFromCurrentState: 是否从当前的状态开始动画 +setAnimationTransition:forView:cache: 设置动画方式，并指出动画发生的位置 areAnimationsEnabled 运用移动效果 -addMotionEffect: motionEffects -removeMotionEffect: UIInterpolatingMotionEffect *xAxis = [[UIInterpolatingMotionEffect alloc] initWithKeyPath:@&quot;center.x&quot; type:UIInterpolatingMotionEffectTypeTiltAlongHorizontalAxis]; self.effectGroup.motionEffects = @[xAxis, yAxis]; // 给view添加效果 [self addMotionEffect:self.effectGroup]; 保存和恢复状态 restorationIdentifier 这个标识符决定是否这个view支持状态保存 -encodeRestorableStateWithCoder: 为view压缩状态相关信息 -decodeRestorableStateWithCoder: 为view解压状态相关信息 抓取View快照 -snapshotViewAfterScreenUpdates: 返回一个view的内容的快照 -resizableSnapshotViewFromRect:afterScreenUpdates:withCapInsets: 返回一个view的指定区域的，刷新屏幕前后的，设置了可以缩放边界的内容快照 -drawViewHierarchyInRect:afterScreenUpdates: 它允许你截取一个UIView或者其子类中的内容，并且以位图的形式（bitmap）保存到UIImage中 -(UIImage *)snapshot:(UIView *)view { UIGraphicsBeginImageContextWithOptions(view.bounds.size, YES, 0); [view drawViewHierarchyInRect:view.bounds afterScreenUpdates:YES]; UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image; } 在运行时鉴定View tag -viewWithTag: 在View的坐标系统之间转换 -convertPoint:toView: -convertPoint:fromView: -convertRect:toView: -convertRect:fromView: 在View中点击测试 -hitTest:withEvent: 返回包含了指定点的最远层的子view（） -pointInside:withEvent: 返回一个Bool类型的值表明是否接收者包含了指定的接触点 hitTest:withEvent:方法的处理流程如下: 首先调用当前视图的pointInside:withEvent:方法判断触摸点是否在当前视图内； 若返回NO,则hitTest:withEvent:返回nil; 若返回YES,则向当前视图的所有子视图(subviews)发送hitTest:withEvent:消息，所有子视图的遍历顺序是从top到bottom，即从subviews数组的末尾向前遍历,直到有子视图返回非空对象或者全部子视图遍历完毕； 若第一次有子视图返回非空对象,则hitTest:withEvent:方法返回此对象，处理结束； 如所有子视图都返回非，则hitTest:withEvent:方法返回自身(self)。 结束一个View的编辑 -endEditing: 让这个view放弃第一个响应者的状态 监测View之间关系的变化 -didAddSubview: -willRemoveSubview: -willMoveToSuperview: -didMoveToSuperview -willMoveToWindow: -didMoveToWindow 监测焦点 canBecomeFocused inheritedAnimationDuration 继承到的动画持续时间 focused 常量 UIViewAnimationOptions 用block对象做动画时的选项 UIViewAnimationCurve 定义了支持的动画时间曲线 UIViewKeyframeAnimationOptions animateKeyframesWithDuration:delay:options:animations:completion:方法中会用到的选项 UIViewContentMode 当view大小变化时，怎么样去调整其内部的内容的选项 UILayoutConstraintAxis UILayoutConstraintAxisHorizontal/Vertical 在对象之间的约束是横向的还是竖向的定义选项 UIViewTintAdjustmentMode Tint颜色的调整模式选项 UISystemAnimation UISystemAnimationDelete，当动画结束时view从view层级中移除时的选项 Fitting Size systemLayoutSizeFittingSize: 方法中用到的view适配选项 UIView Intrinsic Metric Constant UIViewNoIntrinsicMetric UIViewAutoresizing view自动缩放时的选项 UIViewAnimationTransition 用块对象做过渡动画时的选项 UISemanticContentAttribute 视图的方向规则选项 为了在自定义视图中实现固有内容大小，你需要做两件事：重写 intrinsicContentSize为内容返回恰当的大小，无论何时有任何会影响固有内容大小的改变发生时，调用invalidateIntrinsicContentSize。如果这个视图只有一个方向的尺寸设置了固有大小，那么为另一个方向的尺寸返回UIViewNoIntrinsicMetric/NSViewNoIntrinsicMetric。 需要注意的是，固有内容大小必须是独立于视图frame的]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>UIKit</tag>
        <tag>UIView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UITableView的API及其应用]]></title>
    <url>%2F2014%2F08%2F29%2FUITableView%E7%9A%84API%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[UITableView在iOS开发中UITableView可以说是使用最广泛的控件，我们平时使用的软件中到处都可以看到它的影子，类似于微信、QQ、新浪微博等软件基本上随处都是UITableView。当然它的广泛使用自然离不开它强大的功能，这些天仔细看了一遍它的 API 开发文档，感觉内容很多，有一些还不是很理解，在网上搜了一圈中文文档，没有找出一个比较完全的资料，索性自己整理一个，供大家学习，特别是那些英文不好的同学。 概要UITableView 的目的就是为了展示和编辑一个信息列表 UITableView 将一系列信息展示在一个表格列中。UITableView 是 UIScrollView 的子集，它只允许用户竖直滑动表格。表格的每一项包括了一个 UITableViewCell 对象。UITableView 用这些 Cell 来绘制可视化界面。Cell 包括内容、标题、图片等，并且在最右端有一个附件视图。这个附件视图是更多按钮或详情按钮，这种形式形成了一个数据列表和数据详情的等级。附件视图可以是框架中的控件，比如switches和sliders，也可以是自定义控件。UITableView 可以进入编辑模式，此时，用户可以做一些插入、删除、排序的操作。 一个 UITableView 由零个或多个 sections 组成，每个 section 有他们自己的 rows。section 被用 index 的 section 属性区分，每个行被用 section 的 row 属性区分。任何 section 都可以选择性的有 section header 和 section footer。 一个 UITableView 有两种模式，UITableViewStylePlain 和 UITableViewStyleGrouped。当创建一个 UITableView 实例的时候，你必须定义一个 UITableViewStyle，这个属性在以后的运用中就不允许修改了。 UITableViewStylePlain 中，当某个 section 显示不完全的时候，section 的 header 和 footer 会浮动在页面上。这种 UITableView 在 视图的最右端可以浮现一个索引（比如‘A’到‘Z’），你可以通过点击这个索引快速定位到目标 section UITableViewStyleGrouped 提供了一个默认的背景色和一个默认的背景视图，这个背景视图为每个 section 提供了一个可视化的的 Cell 组，比如一个 Cell 组可以被用来显示一个人的姓名和标题，另一个 Cell 组可以被用来显示这个人的电话号码，另一个可以被用来显示 Email 账号等等。可以对比设置页面来详细观察它。还有一点，这种 style 的 UITableView 不能包含索引。 UITableView 的很多方法定义参数时有 NSIndexPath。UITableView 中可以通过一个 NSIndexPath 中的 row 属性和 section 属性来获得你想要的行，并且提供了通过 row 和 section 创建 NSIndexPath 的方法：indexPathForRow:inSection: 。特别是当 UITableView 有多个 section 的时候，你必须在你通过 index 来定义每个行之前，评估出 section 的 index。 一个 UITableView 对象必须有一个数据源和一个委托对象，典型的，他们可能是一个程序委托，更多情况下则是一个自定义的 UITableViewController 对象。数据源对象必须实现 UITableViewDataSource 协议，委托对象必须实现 UITableViewDelegate 协议。 当 UITableView 的行被增加、删除、重排序的时候，数据源对象必须提供创建和管理 UITableView 数据信息的功能。 UITableViewDelegate 的任务是管理表的配置、选择行为、重排序、高亮、附件视图和编辑行为。 当用 setEditing:animated: 方法设置 UITableView 时，它会进入编辑模式，此时，根据每个 Cell 的 editingStyle 的设置会显示出编辑或排序按钮。点击插入或删除按钮会引发 UITableViewDataSource 响应 tableView:commitEditingStyle:forRowAtIndexPath: 方法。提交删除或插入操作时就会引发响应 deleteRowsAtIndexPaths:withRowAnimation: 或 insertRowsAtIndexPaths:withRowAnimation: 方法。在编辑模式时，如果某个 Cell 的showReorderControl 属性被设置为 YES 并在移动时，UITableViewDataSource 会响应 tableView:moveRowAtIndexPath:toIndexPath: 方法。UITableViewDataSource 可以选择性的通过 tableView:canMoveRowAtIndexPath: 方法移除 Cell 的排序按钮。 UITableView 会缓存它的几个可视的 Cell。你可以自定义 UITableViewCell 对象里的内容和行为。 UITableView 重写了它的父类 UIView 的 layoutSubviews 方法，所以在你新建了一个 UITableView 的实例或为其添加数据源的时候会调用 reloadData 函数。重新加载 UITableView 会清除现在的状态，包括当前的选择项。尽管如此，如果你显式的调用 reloadData 方法，他会清除当前状态并调用 layoutSubviews 方法，但是在这个方法中，reloadData 方法将不再会被重复调用。 状态保存在 iOS6 以后，如果你为 UITableView 的 restorationIdentifier 属性赋值，它将会试着保存当前的选择行和第一个可视行。UITableViewDataSource 对象可能会实现 UIDataSourceModelAssociation 协议，UIDataSourceModelAssociation 协议可以提供了标记行内容的方法。如果一个 UITableViewDataSource 实现了 UIDataSourceModelAssociation 协议，当把最上部可视的 Cell 和被选择的 Cells 转换为标记内容来保存表状态时，这个UITableViewDataSource 将被调用。在恢复时，UITableViewDataSource 将被询问来将标记内容回转成最上部可视的 Cell 和被选择的 Cells，利用这些便可以重新恢复表的状态。如果 UITableViewDataSource 不实现 UIDataSourceModelAssociation 协议，表滑动的位置和被选择的 Cell 的 index paths 将被直接保存。 操作初始化 UITableView 对象 -initWithFrame:style: Designated Initializer 当你通过这个方法创建表的时候，你必须定义表的 style，并且后续不能修改。如果你通过 UIView 的方法 initWithFrame 来创建表时，style 属性会被默认为 UITableViewStylePlain。 配置 Table View style Property 表的样式 - numberOfRowsInSection: 某个 section 的 rows 数量 numberOfSections Property 表的 section 的数量 rowHeight Property 表的 cell 的高度，通过像素点数量来表达 你也可以通过表的 delegate 的 tableView:heightForRowAtIndexPath: 方法来设置，rowHeight 的默认值是 UITableViewAutomaticDimension。 注意，如果你在 xib 中创建了一个自定义高度的 Cell，rowHeight 的默认值会被设置为你 xib 中的 row 的高度。rowHeight 属性会覆盖 xib 的 Cell 高度，所以当你期望你设置的 xib 的 Cell 的高度起作用，必须将 rowHeight 的属性设置为 UITableViewAutomaticDimension 你也可以用 delegate 的 tableView:heightForRowAtIndexPath: 来覆盖 rowHeight 值，每次当 UITableView 要显示时，会调用每一行的 tableView:heightForRowAtIndexPath: 方法，这样，当有很多 Cell 的时候，会出现重大的显示问题。 separatorStyle Property Cell 之间分隔样式 分隔由 tableView:cellForRowAtIndexPath: 方法返回的 Cell，值包含 UITableViewCellSeparatorStyleNone/SingleLine/SingleLineEtched separatorColor Property Cell 之间的分隔符的颜色 separatorEffect Property 运用在 Cell 分隔符上的效果 backgroundView Property 背景视图 它会根据 UITableView 的大小，自动适配大小。这个视图被当做 UITableView 的子视图放在所有的 Cells，header views，footer views 之下。 separatorInset Propert 分隔线的边距 在 iOS7 以后，Cell 分隔符不会自动延伸到 UITableView 的边缘，这个属性定义了分隔符的默认边距，就像 rowHeight 设置默认的 Cell 的高度一样。它也可以被用来管理 plain 样式表的下方的分隔符。比如，如果需要定义分隔符的左边距为3个点，右边距11个点，则 tableView.separator = UIEdgeInsetsMake(0, 3, 0, 11); 可以实现。在一个从右向左的用户界面，左和右的值会自动切换。 cellLayoutMarginsFollowReadableWidth Property 决定 Cell 的边距是否会通过可读到的内容进行延伸 创建 Table View Cells - registerNib:forCellReuseIdentifier: 通过一个定义的 identifier 来注册一个 nib 文件，nib中包含了对应的类名。在取出任何 Cell 前，必须先调用此方法或 - registerClass:forCellReuseIdentifier: 方法来告诉 UITableView 当没有取出 Cell 的时候如何构造一个新的 Cell。如果在复用队列中没有 identifier 定义的相应的 Cell，则 UITableView 会用提供的信息来自动创建一个 Cell。如果你以前用某个 identifier 注册过一个 nib 或 class，现在又用相同的 identifier 来注册，后边的会覆盖前边的。如果你想注销，直接将 identifier 下注册的 nib 或 class 设置为空即可 - registerClass:forCellReuseIdentifier: 同 - registerNib:forCellReuseIdentifier: 方法一样 - dequeueReusableCellWithIdentifier:forIndexPath: 根据 identifier 返回一个可复用的 Cell 对象并将其添加到 UITableView 中去。由于显示的原因，UITableView 的 UIDataSource 会生成可复用的 Cell 对象，并将其赋值给 - tableView:cellForRowAtIndexPath: 方法返回。在 UITableView 的内部维护着一个 UITableViewCell 队列，这些 Cell 被标记用来复用。当被要求为 UITableView 提供一个 Cell 时，这个方法将被调用来返回一个 Cell，如果存在，则会直接返回，如果不存在，则会根据注册的 nib 或者 class 来生成一个 Cell，并添加到 UITableView中。所以，在调用此方法前，必须先注册一个 nib（- registerNib:forCellReuseIdentifier:） 或者 class（- registerClass:forCellReuseIdentifier:）。如果你定义了一个 identifier 标记了的 class 或 nib 并初次获取一个 Cell 时，Cell 会通过 - initWithStyle:reuseIdentifier: 方法初始化自己。如果是通过 nib 注册，则初始化方法会通过 nib 的内容来加载 Cell 的内容。如果一个可复用的 Cell 已经存在了，则直接调用 prepareForReuse 方法。 - dequeueReusableCellWithIdentifier: 同 dequeueReusableCellWithIdentifier:forIndexPath: 注意： dequeueReusableCellWithIdentifier:forIndexPath: 是 iOS6 以上，使用前必须先注册，dequeueReusableCellWithIdentifier:是 iOS2 以上，它使用前可以注册，也可以不用注册，不注册时返回空，然后判断是否为空，如果为空，初始化 Cell 获取 Header and Footer Views - registerNib:forHeaderFooterViewReuseIdentifier: 为 Cell 的 Header 或 Footer View 注册可复用对象。复用的逻辑同 Cell 的复用逻辑相同，也可以调用 - registerClass:forHeaderFooterViewReuseIdentifier: 来注册 - registerClass:forHeaderFooterViewReuseIdentifier: 同 - registerNib:forHeaderFooterViewReuseIdentifier: - dequeueReusableHeaderFooterViewWithIdentifier: iOS6 以后，同 - dequeueReusableCellWithIdentifier:forIndexPath: 此方法可以通过 identifier 根据复用 UITableViewCell 存在情况，取出一个 UITableViewHeaderFooterView 对象或空对象。同 UITableViewCell 一样，UITableViewHeaderFooterView 对象也会复用，且复用机制相同。 tableHeaderView Property UITableView 的 header view，默认为空，与 section header 不同 tableFooterView Property UITableView 的 footer view，默认为空，与 section footer 不同 sectionHeaderHeight Property section 的 header 的高度，会被 delegate 的 tableView:heightForHeaderInSection: 方法的值覆盖 sectionFooterHeight Property section 的 footer 的高度，会被 delegate 的 tableView:heightForFooterInSection: 方法的值覆盖 - headerViewForSection: 返回某个 section 的 header view - footerViewForSection: 返回某个 section 的 footer view 获取 Cells and Sections - cellForRowAtIndexPath: 返回某个 IndexPath 下对应的 Cell - indexPathForCell: 返回某个 Cell 对应的 IndexPath - indexPathForRowAtPoint: 给定某个点，返回此点落在的 IndexPath 位置 - indexPathsForRowsInRect: 给定某个矩形，返回此矩形处在哪些 IndexPath 中 visibleCells Property 返回可视的 Cell 数组，数组中每项都是一个 UITableViewCell 对象 indexPathsForVisibleRows Property 返回一个 IndexPath 数组，数组中每一项都代表一个 IndexPath 对象，如果不能看到任何 Cell，返回空 估算高度 - estimatedRowHeight Property UITableView 的 Cell 的高度的估算值 提供这个非负估算值可以提高表格的加载性能。如果这个表格包括很多项，当加载表时计算所有行的高度会是一项比较大的计算量。如果用了高度估算值，就会将高度的精确计算从加载表的时候推后到滑动表的时候。当你创建了一个自己控制大小的 Cell 时，你可能需要设置此属性并用约束来定义 Cell 的大小。此属性的默认值是0，代表没有估算值。 estimatedSectionHeaderHeight Property 同 estimatedRowHeight 属性 estimatedSectionFooterHeight Property 同 estimatedRowHeight 属性 滑动 Table View - scrollToRowAtIndexPath:atScrollPosition:animated: 将表滑动到某个 IndexPath 下。不像用户手动滑动表，调用此方法并不会回调 scrollViewDidScroll: 方法 - scrollToNearestSelectedRowAtScrollPosition:animated: 将某个选定的 Cell 滑动到某个特定的位置（最上、最下、中间等） 管理选择操作 indexPathForSelectedRow Property 返回被选择的 Cell 的 IndexPath，如果支持同时选择多个 Cell，则会返回选择数组的第一个值，这个值是所有 IndexPath 里边 section 和 row 最小的 indexPathsForSelectedRows Property 返回被选择的所有的 Cell 对应的 IndexPath 的数组 - selectRowAtIndexPath:animated:scrollPosition: 选择 IndexPath 对应的 Cell 选择的同时可设置是否动画和滑动位置参数，UITableViewScrollPositionNone 表示不需要滑动，其他值表示需要滑动。调用此方法并不会触发 - tableView:willSelectRowAtIndexPath: 或 - tableView:didSelectRowAtIndexPath: 方法，也不会发送 UITableViewSelectionDidChangeNotification 通知。 - deselectRowAtIndexPath:animated: 取消选择 IndexPath 对应的 Cell，此方法同样也不会回调 delegate 的方法和发送通知 allowsSelection Property 定义 UITableView 的 Cell 是否可以被选择，这个属性只在非编辑模式的情况下有效，如果在编辑模式下应该用 allowsSelectionDuringEditing 属性。 allowsMultipleSelection Property 定义 UITableView 的 Cell 在非编辑模式下是否可以被多选 allowsSelectionDuringEditing Property 定义 UITableView 的 Cell 在编辑模式下是否可以被选择 allowsMultipleSelectionDuringEditing Property 定义 UITableView 的 Cell 在编辑模式下是否可以被多选 插入、删除或移动 Rows and Sections - beginUpdates 开始一系列的增、删、选择方法的调用 如果想同时调用增、删、选择 Cell 动画，会调用这个方法。你也可以不用 reload 而使用 beginUpdates 和 endUpdates 组合的方式来使你的修改起作用。beginUpdates 和 endUpdates方法的组合可以嵌套使用。如果你不用这个属性，你修改的一些 UITableView 的属性可能不会起作用，比如 rowCount。在两个方法之间不应该调用 reloadData，如果调了，则需要你来自己设置你的动画了。 - endUpdates 完成一系列的增、删、选择方法的调用。当调用此方法时， UITableView 会自动处理这些操作的动画。 - insertRowsAtIndexPaths:withRowAnimation: 将一些 rows 插入 UITableView 对应的 IndexPath中 插入了以后，UITableViewCell 会立马调用相关的 delegate 和 dataSource 来重新获取 Cell。当这个方法被在 beginUpdates 和 endUpdates 中间调用时，UITableView 会先处理 rows 和 sections 的删除操作，再去处理他们的插入操作，而与他们调用的先后顺序无关。 - deleteRowsAtIndexPaths:withRowAnimation: 同 - insertRowsAtIndexPaths:withRowAnimation: - moveRowAtIndexPath:toIndexPath: 将某个 row 移动从指定的 IndexPath 移动到另一个 IndexPath 位置中去 你可以将移动操作看成将插入和删除操作放在一个 beginUpdates–endUpdates 块中而合成一个动画效果一样。这个方法不像其他插入或删除方法，它没有动画参数，而是默认的将动画设置为从开始位置到结束位置。也不像其他方法一样，它只允许每次执行一条数据的移动。如果想移动多个行，可以在 beginUpdates–endUpdates 块中重复调用它。 - insertSections:withRowAnimation: 在 UITableView 中插入一个或多个 sections，可以支持动画，类似 - insertRowsAtIndexPaths:withRowAnimation: - deleteSections:withRowAnimation: 在 UITableView 中删除一个或多个 sections，可以支持动画，类似 - deleteRowsAtIndexPaths:withRowAnimation: - moveSection:toSection: 将某个 section 移动从指定的 index 移动到另一个 index 位置中去，类似 - moveRowAtIndexPath:toIndexPath: 管理 Table Cells 的编辑模式 editing Property 决定 UITableView 是否能进入编辑模式，默认值是不能 NO。 进入编辑模式后，根据 Cell 的配置不同，可能会在 UITableView 的左侧会出现插入和删除按钮，在右边会出现移动按钮，点击任何按钮都会使 UITableView 的 delegate 回调 - tableView:commitEditingStyle:forRowAtIndexPath: 方法。 - setEditing:animated: 切换 UITableView 的普通模式和编辑模式 当值设置为 YES 时，会进入编辑模式，此时会调用每个 Cell 的 setEditing:animated: 方法，Cell 会根据配置情况，做出相应的操作。如果设置为 NO 时，它就会关闭编辑模式。 重新加载 Table View - reloadData 重新加载 UITableView 的 rows 和 sections 调用这个方法会重新加载 UITableView 的所有内容，包括 cells，section headers 和 footers，索引数组等。为了高效，它只会重新加载那些在显示在界面上的 cells。在调用此方法后 UITableView 会自动调整位置。UITableView 的 delegate 和 dataSource 调用此方法是为了完成一次完全的重新加载。它不能在插入或删除 rows的时候调用，特别是不能在 beginUpdates–endUpdates 之间调用。 - reloadRowsAtIndexPaths:withRowAnimation: 重新加载某个行 这个方法会让 UITableView 重新获取一个新的 cell，然后用动画将新的替换旧的，如果不需要通知用户，可以不用动画，直接替换值。如果此方法被在 beginUpdates–endUpdates 之间调用，它会跟 - deleteRowsAtIndexPaths:withRowAnimation: 方法的效果一样，因为 - reloadRowsAtIndexPaths:withRowAnimation: 方法会被拆分成 - insertRowsAtIndexPaths:withRowAnimation: 和 - deleteRowsAtIndexPaths:withRowAnimation: 方法，而 insert 方法又被推迟，所以只能看到 delete 方法的效果。 - reloadSections:withRowAnimation: 重新加载某个模块。同 - reloadRowsAtIndexPaths:withRowAnimation: 方法。 - reloadSectionIndexTitles 返回 UITableView 右侧的索引条的数据 当修改 sections 索引的时候，调用此方法可以更新索引的列表，而不用调用 reloadData 方法更新 UITableView 的所有内容。 获取 Drawing Areas of the Table View - rectForSection: 返回 UITableView 中指定 section 对应的绘制区域 - rectForRowAtIndexPath: 返回 UITableView 中指定 IndexPath 对应的绘制区域 - rectForFooterInSection: 返回 UITableView 中指定的某个 section 的 footer 对应的绘制区域 - rectForHeaderInSection: 返回 UITableView 中指定的某个 section 的 header 对应的绘制区域 管理 Delegate 和 Data Source dataSource Property 表示 UITableView 的数据源对象，它会遵循 UITableViewDataSource 协议，不会被保留（retain） delegate Property 表示 UITableView 的委托对象，它会遵循 UITableViewDelegate 协议，不会被保留（retain） 配置索引 sectionIndexMinimumDisplayRowCount Property 设置显示右侧索引的 rows 最小行数，默认是0。这个属性只在 UITableViewStylePlain 的 style 下有用。 sectionIndexColor Property 右侧索引的字体颜色 在 UITableView 的右侧会显示一个索引，通过点击这个索引，用户可以很容易的定位到指定区域。这个属性可以定义右侧索引的字体颜色，如果设置为 nil，则表示默认颜色。 sectionIndexBackgroundColor Property 当没有被触摸的时候，右侧索引的背景颜色，如果设置为空，则表示默认颜色。 sectionIndexTrackingBackgroundColor Property 当被触摸的时候，右侧索引的背景颜色，如果设置为空，则表示默认颜色。 管理焦点 remembersLastFocusedIndexPath Property 是否要记住焦点位置 如果设置为 YES，则当 UITableView 失去焦点的时候会记住此时的位置，从而当它重新获得焦点的时候，将焦点自动设置到记住的 IndexPath 上去。这个值默认设置为 NO。 常量UITableViewStyle当初始化 UITableView 的时候，必须要先定义 UITableViewStyle，并且后续不能修改 UITableViewStylePlain: 任何 section headers 或 footers 都被作为分隔显示在行内，当滑动 UITableView 时会浮动在上边 UITableViewStyleGrouped 每个 section 显示不同的分组，section headers 或 footers 不会浮动 UITableViewScrollPosition这个枚举将会在 - selectRowAtIndexPath:animated:scrollPosition:, - scrollToNearestSelectedRowAtScrollPosition:animated:, - cellForRowAtIndexPath:, 和 - indexPathForSelectedRow 方法的参数中用到 UITableViewScrollPositionNone UITableView 用最小的移动方式来让 row 完全显示出来，如果 row 已经完全显示出来了，则不作滑动操作，比如如果这个 row 在可视区域的上部，则 UITableViewScrollPositionNone 就相当于定义为 UITableViewScrollPositionTop，它一般都是默认属性 UITableViewScrollPositionTop 将 UITableView 的指定 row 滑动到最顶部 UITableViewScrollPositionMiddle 将 UITableView 的指定 row 显示在最中间 UITableViewScrollPositionBottom 将 UITableView 的指定 row 滑动到最底部 UITableViewRowAnimation这个枚举将会在 - insertRowsAtIndexPaths:withRowAnimation:, - insertSections:withRowAnimation:, - deleteRowsAtIndexPaths:withRowAnimation:,- deleteSections:withRowAnimation:, - reloadRowsAtIndexPaths:withRowAnimation:, 和 - reloadSections:withRowAnimation: 方法的参数中用到 UITableViewRowAnimationFade rows 将会在 UITableView 中做淡入淡出操作 UITableViewRowAnimationRight rows 将会在 UITableView 中从右边移入或从从右边移出 UITableViewRowAnimationLeft rows 将会在 UITableView 中从左边移入或从从左边移出 UITableViewRowAnimationTop rows 将会在 UITableView 中从上边移入或从从上边移出 UITableViewRowAnimationBottom rows 将会在 UITableView 中从下边移入或从从下边移出 UITableViewRowAnimationNone 插入或删除 rows 将会使用默认动画 UITableViewRowAnimationMiddle rows 将会在 UITableView 中从中间移入或从从中间移出 UITableViewRowAnimationAutomatic UITableView 将会自动选择合适的动画类型 Section Index Icons UITableViewIndexSearch 如果 sectionIndexTitlesForTableView: 返回的数组中包含这个常量，则在右侧的索引的相应位置会显示一个放大镜图标 Default Dimension UITableViewAutomaticDimension 自动的尺寸设置，如果在 UITableView 的 delegate 中请求一个默认的值，则用此常量。比如当 - tableView:heightForHeaderInSection: 或 - tableView:heightForFooterInSection: 返回 UITableViewAutomaticDimension 时，UITableView 会根据 - tableView:titleForHeaderInSection: 或 - tableView:titleForFooterInSection: 方法返回的值来决定高度。 通知UITableViewSelectionDidChangeNotification UITableViewSelectionDidChangeNotification 当选择了某一行 row 的时候，会发送此通知，并且其 userInfo 参数为空 UITableViewCellUITableViewCell 定义了在 UITableView 中重复出现的的对象的一些属性和行为。这个类的属性和方法用来设置和管理 cell 的内容和背景，管理 cell 的选择和高亮，管理附属视图，初始化 cell 的内容是否可修改。 概要当创建 cell 的时候，你可以自定义 cell 的样式或直接用系统预定义的样式，用系统预定义的样式是非常简单的方式，用这种方式，cell 会提供 label 和 image 这些子 view，而且这些子 view 的位置已经被调整过了，你只需要提供一个字串和一个图片内容来填充即可。如果用这种方式，你需要用函数initWithStyle:reuseIdentifier:初始化，或者直接用xib的方式完成界面的添加初始化。为了设置文字和图片，可以用这几个属性：textLabel, detailTextLabel 和 imageView。 如果你想用自定义的方式，你可以将你的子 view 添加到这个 cell 的 contentView 属性中去。当添加时，你必须自己设置好子 view 的位置并且设置好他们的内容。 不管是用哪种方式，你都可以用 backgroundView 属性或者继承父类的 backgroundColor 属性来改变 cell 的背景。在 iOS7中，cell 默认是白色的背景，在更早版本的 iOS 中，cell 的背景色继承于包含它自己的 tableView，如果你想改变 cell 的背景色，你通过 tableView 的 delegate 的 tableView:willDisplayCell:forRowAtIndexPath: 方法来设置。 更多关于创建 cell 的内容，请阅读关于Table View Programming Guide for iOS的文章A Closer Look at Table View Cells 操作初始化 UITableViewCell -initWithStyle:reuseIdentifier: -initWithCoder: cell 复用机制 reuseIdentifier -prepareForReuse 管理预定义内容 textLabel detailTextLabel imageView 访问 cell 内部的对象 contentView backgroundView selectedBackgroundView multipleSelectionBackgroundView 管理附属View accessoryType accessoryView editingAccessoryType editingAccessoryView 管理cell的选中和高亮 selected selectionStyle -setSelected:animated: highlighted -setHighlighted:animated: 编辑 cell editing -setEditing:animated: editingStyle UITableViewCellEditingStyleNone/Delete/Insert showingDeleteConfirmation 是否显示确认删除按钮 showsReorderControl 是否显示排序按钮 调整状态转换 -willTransitionToState: -didTransitionToState: 管理缩进 indentationLevel indentationWidth 缩进距离 = indentationLevel * indentationWidth shouldIndentWhileEditing separatorInset 管理焦点 focusStyle 当处于焦点时的外观 常量 UITableViewCellStyle UITableViewCellStyleDefault, UITableViewCellStyleValue1, UITableViewCellStyleValue2, UITableViewCellStyleSubtitle UITableViewCellSelectionStyle UITableViewCellSelectionStyleNone, UITableViewCellSelectionStyleBlue, UITableViewCellSelectionStyleGray, UITableViewCellSelectionStyleDefault UITableViewCellEditingStyle UITableViewCellEditingStyleNone, UITableViewCellEditingStyleDelete, UITableViewCellEditingStyleInsert UITableViewCellAccessory UITableViewCellAccessoryNone, UITableViewCellAccessoryDisclosureIndicator, UITableViewCellAccessoryDetailDisclosureButton, UITableViewCellAccessoryCheckmark, UITableViewCellAccessoryDetailButton UITableViewCellStateMask 用在did/willTransitionToState:中 UITableViewCellStateDefaultMask = 0, UITableViewCellStateShowingEditControlMask = 1 &lt;&lt; 0, UITableViewCellStateShowingDeleteConfirmationMask = 1 &lt;&lt; 1 UITableViewCellSeparatorStyle UITableViewCellSeparatorStyleNone, UITableViewCellSeparatorStyleSingleLine, UITableViewCellSeparatorStyleSingleLineEtched 虚线 UITableViewCellFocusStyle UITableViewCellFocusStyleDefault, UITableViewCellFocusStyleCustom Convenience Definitions for Table View Cells UITableViewCellSeparatorStyleDoubleLineEtched 两行虚线分界，只能用在grouped-style tableview 中 UITableViewCellStateEditingMask 当tableView处于编辑模式时cell的状态 UITableViewDataSourceUITableViewDataSource 协议被一个对象用来为 UITableView 提供需要的数据模型。UITableViewDataSource 提供了 tableView 需要的数据源并且创建和修改tableView 概要作为数据模型的代表，此数据源提供了 tableView 展示外观所需的最少信息，而另一个协议 UITableViewDelegate 为它的委托提供一些信息。 这个协议需要提供了一些方法将 cell 显示在 tableView 中，并且告诉tableView其有多少的section，每个section有多少个row等等。这个协议可能会实现一部分方法来设置tableView的很多方面的属性，如插入、删除、排序等 为了实现滑动删除的功能，你必须实现tableView:commitEditingStyle:forRowAtIndexPath:方法 很多方法会用到NSIndexPath对象作为参数，UITableView在NSIndexPath中声明了一个类别来使你获得想要的行序列和块序列，并且创建一个构造函数indexPathForRow:inSection:让你可以通过一个行序列和块序列来创建一个NSIndexPath 操作创建一个TableView -tableView:cellForRowAtIndexPath: -numberOfSectionsInTableView: -tableView:numberOfRowsInSection: -sectionIndexTitlesForTableView: 索引表的标题 -tableView:sectionForSectionIndexTitle:atIndex: //点击右侧索引表项时调用 -tableView:titleForHeaderInSection: 块首的标题，可以和索引表的不同 -tableView:titleForFooterInSection: 块尾的标题 - (NSInteger)tableView:(UITableView *)tableView sectionForSectionIndexTitle:(NSString *)title atIndex:(NSInteger)index { NSString *key = [sectionTitleArray objectAtIndex:index]; NSLog(@&quot;sectionForSectionIndexTitle key=%@&quot;,key); if (key == UITableViewIndexSearch) { [listTableView setContentOffset:CGPointZero animated:NO]; return NSNotFound; } return index; } 插入和删除行 -tableView:commitEditingStyle:forRowAtIndexPath: 当行被插入或删除时调用此方法,对编辑的状态下提交的事件响应 -tableView:canEditRowAtIndexPath: 重排序行 -tableView:canMoveRowAtIndexPath: -tableView:moveRowAtIndexPath:toIndexPath: 当行被重排序时调用此方法 UITableViewDelegateUITableView的委托对象必须实现UITableViewDelegate协议，此协议中可选的方法允许用户去管理选择操作，配置块头和块尾，删除或重排序cell和其他的一些操作。 概要很多方法会用到NSIndexPath对象作为参数或者返回值，UIKit在NSIndexPath中声明了一个类别来使你获得想要的行序列和块序列，并且创建一个构造函数indexPathForRow:inSection:让你可以通过一个行序列和块序列来创建一个NSIndexPath。由于行在块中，所以通常情况下，你要取出某行，必须先确定其所在的块 操作为TableView配置行 -tableView:heightForRowAtIndexPath: -tableView:estimatedHeightForRowAtIndexPath: -tableView:indentationLevelForRowAtIndexPath: 某行的缩进级别 -tableView:willDisplayCell:forRowAtIndexPath: 管理附属视图 -tableView:editActionsForRowAtIndexPath: 设置滑动删除时显示多个按钮 -tableView:accessoryTypeForRowWithIndexPath:(Deprecated) 对应位置的附件视图的种类 -tableView:accessoryButtonTappedForRowWithIndexPath: 当用户点击附件视图时的回调 tableView:editActionsForRowAtIndexPath: // 设置滑动删除时显示多个按钮 UITableViewRowAction // 通过此类创建按钮 我们在使用一些应用的时候，在滑动一些联系人的某一行的时候，会出现删除、置顶、更多等等的按钮，在iOS8之前，我们都需要自己去实现。But，到了iOS8，系统已经写好了，只需要一个代理方法和一个类就搞定了 iOS8的协议多了一个方法，返回值是数组的tableView:editActionsForRowAtIndexPath:方法，我们可以在方法内部写好几个按钮，然后放到数组中返回，那些按钮的类就是UITableViewRowAction 在UITableViewRowAction类，我们可以设置按钮的样式、显示的文字、背景色、和按钮的事件（事件在Block中实现） 在代理方法中，我们可以创建多个按钮放到数组中返回，最先放入数组的按钮显示在最右侧，最后放入的显示在最左侧 注意：如果我们自己设定了一个或多个按钮，系统自带的删除按钮就消失了… 在滑动手势删除某一行的时候，显示出更多的按钮，代码如下 - (NSArray *)tableView:(UITableView *)tableView editActionsForRowAtIndexPath:(NSIndexPath *)indexPath { // 添加一个删除按钮 UITableViewRowAction *deleteRowAction = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleDestructive title:@&quot;删除&quot; handler:^(UITableViewRowAction *action, NSIndexPath *indexPath) { NSLog(@&quot;点击了删除&quot;); // 1. 更新数据 [_allDataArray removeObjectAtIndex:indexPath.row]; // 2. 更新UI [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationAutomatic]; }]; // 删除一个置顶按钮 UITableViewRowAction *topRowAction = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleDefault title:@&quot;置顶&quot; handler:^(UITableViewRowAction *action, NSIndexPath *indexPath) { NSLog(@&quot;点击了置顶&quot;); // 1. 更新数据 [_allDataArray exchangeObjectAtIndex:indexPath.row withObjectAtIndex:0]; // 2. 更新UI NSIndexPath *firstIndexPath = [NSIndexPath indexPathForRow:0 inSection:indexPath.section]; [tableView moveRowAtIndexPath:indexPath toIndexPath:firstIndexPath]; }]; topRowAction.backgroundColor = [UIColor blueColor]; // 添加一个更多按钮 UITableViewRowAction *moreRowAction = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleNormal title:@&quot;更多&quot; handler:^(UITableViewRowAction *action, NSIndexPath *indexPath) { NSLog(@&quot;点击了更多&quot;); [tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationMiddle]; }]; moreRowAction.backgroundEffect = [UIBlurEffect effectWithStyle:UIBlurEffectStyleDark]; // 将设置好的按钮放到数组中返回 return @[deleteRowAction, topRowAction, moreRowAction]; } 管理选择操作 -tableView:willSelectRowAtIndexPath: -tableView:didSelectRowAtIndexPath: -tableView:willDeselectRowAtIndexPath: -tableView:didDeselectRowAtIndexPath: 修改块中的头和尾 -tableView:viewForHeaderInSection: -tableView:viewForFooterInSection: -tableView:heightForHeaderInSection: -tableView:estimatedHeightForHeaderInSection: -tableView:heightForFooterInSection: -tableView:estimatedHeightForFooterInSection: -tableView:willDisplayHeaderView:forSection: -tableView:willDisplayFooterView:forSection: 修改行 -tableView:willBeginEditingRowAtIndexPath: -tableView:didEndEditingRowAtIndexPath: -tableView:editingStyleForRowAtIndexPath: UITableViewCellEditingStyleDelete/Insert/None -tableView:titleForDeleteConfirmationButtonForRowAtIndexPath: -tableView:shouldIndentWhileEditingRowAtIndexPath: 编辑时是否需要缩进 行的重排序 -tableView:targetIndexPathForMoveFromRowAtIndexPath:toProposedIndexPath: 用户拖动某行经过目标行上方时，tableView会向delegate发送tableView:targetIndexPathForMoveFromRowAtIndexPath:toProposedIndexPath:(若delegate有实现)消息询问是否可移动到此位置（ProposedIndexPath），若不可移动到此位置则返回一个新的目的indexPath,可以的话直接将ProposedIndexPath返回即可。一般情况下不需实现此方法 监听cell的移除 -tableView:didEndDisplayingCell:forRowAtIndexPath: 通知委托指定的cell已经移出表视图,即拖动的时候移出视图的cell -tableView:didEndDisplayingHeaderView:forSection: -tableView:didEndDisplayingFooterView:forSection: 复制和粘贴行内容 -tableView:shouldShowMenuForRowAtIndexPath: 是否显示系统菜单选项 -tableView:canPerformAction:forRowAtIndexPath:withSender: 当用户选择某个选项时触发该方法判断是否需要被处理 -tableView:performAction:forRowAtIndexPath:withSender: 选择后如果可以被处理，在此处处理 - (BOOL)tableView:(UITableView *)tableView shouldShowMenuForRowAtIndexPath:(NSIndexPath *)indexPath { return YES; } - (BOOL)tableView:(UITableView *)tableView canPerformAction:(SEL)action forRowAtIndexPath:(NSIndexPath *)indexPath withSender:(id)sender { if (action == @selector(copy:)) { return YES; } return NO; } - (void)tableView:(UITableView *)tableView performAction:(SEL)action forRowAtIndexPath:(NSIndexPath *)indexPath withSender:(id)sender { if (action == @selector(copy:)) { [UIPasteboard generalPasteboard].string = [data objectAtIndex:indexPath.row]; } } 管理高亮效果 -tableView:shouldHighlightRowAtIndexPath: -tableView:didHighlightRowAtIndexPath: -tableView:didUnhighlightRowAtIndexPath: 管理焦点 -tableView:canFocusRowAtIndexPath: 一般关于focus的效果在TV上用的比较多 -tableView:shouldUpdateFocusInContext: -tableView:didUpdateFocusInContext:withAnimationCoordinator: -indexPathForPreferredFocusedViewInTableView: 不管是iPhone上的selected还是iTV上的focused，产生highlight的效果会比较好]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>UITableView</tag>
        <tag>UIKit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC 编码规范]]></title>
    <url>%2F2014%2F07%2F25%2FOC%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[作为一名苹果开发者，我们的工作就是开发出一个流畅的、高质量的 APP，如何保证 APP 的性能和质量，编码规范则是最基本的条件。在网上随便搜寻一下，每个公司都有自己的编码规范，如New York Times 编码规范、GitHub 编码规范、Raywenderlich 编码规范，这些编码规范其实内容都大同小异。 由于我是 Raywenderlich 团队的忠实粉丝，我以前也通过 Raywenderlich 团队学习过不少的技术和技巧，我自己的编码风格也或多或少被 Raywenderlich 团队的风格所影响，所以本篇文章将翻译 Raywenderlich 的编码规范来做个总结，规范约束自己以后在编码时的风格，保证自己能写出更优雅的代码。 Raywenderlich 编码规范介绍我们制定Objective-C编码规范的原因是我们能够在我们的书、教程和初学者工具包的代码保持优雅和一致。即使我们有很多不同的作者来完成不同的书籍。 这里编码规范有可能与你看到的其他Objective-C编码规范不同，因为它主要是为了打印和Web的易读性。为了打印出简单清晰的教程，我们做了以下编码规范。 感谢这编码规范的创建是由很多来自raywenderlich.com团队成员在Nicholas Waynik的带领下共同完成的。团队成员有：Soheil Moayedi Azarpour、Ricardo Rendon Cepeda、Tony Dahbura、Colin Eberhardt、Matt Galloway、Greg Heo、Matthijs Hollemans、Christopher LaPollo、Saul Mora、Andy Pereira、Mic Pringle、Pietro Rea、Cesare Rocchi、Marin Todorov、Nicholas Waynik和Ray Wenderlich。 我们也非常感谢 New York Times 和Robots &amp; Pencils’Objective-C编码规范的作者。这两个编码规范为本指南的创建提供很好的起点。 背景这里有些关于编码风格Apple官方文档，如果有些东西没有提及，可以在以下文档来查找更多细节： The Objective-C Programming Language Cocoa Fundamentals Guide Coding Guidelines for Cocoa iOS App Programming Guide 语言应该使用US英语 推荐： UIColor *myColor = [UIColor whiteColor]; 不推荐： UIColor *myColour = [UIColor whiteColor]; 代码组织在函数分组和protocol/delegate实现中使用#pragma mark -来分类方法，要遵循以下一般结构： #pragma mark - Lifecycle - (instancetype)init {} - (void)dealloc {} - (void)viewDidLoad {} - (void)viewWillAppear:(BOOL)animated {} - (void)didReceiveMemoryWarning {} #pragma mark - Custom Accessors - (void)setCustomProperty:(id)value {} - (id)customProperty {} #pragma mark - IBActions - (IBAction)submitData:(id)sender {} #pragma mark - Public - (void)publicMethod {} #pragma mark - Private - (void)privateMethod {} #pragma mark - Protocol conformance #pragma mark - UITextFieldDelegate #pragma mark - UITableViewDataSource #pragma mark - UITableViewDelegate #pragma mark - NSCopying - (id)copyWithZone:(NSZone *)zone {} #pragma mark - NSObject - (NSString *)description {} 空格 用两个空格进行缩进(当打印时会有较少的折行)，不要用tabs缩进，必须在 Xcode Preference 中设置此项（此项是打印需求，一般的编码风格会保持4个空格缩进） 方法大括号和其他大括号(if/else/switch/while 等.)总是在同一行语句打开但在新行中关闭 推荐： if (user.isHappy) { //Do something } else { //Do something else } 不推荐： if (user.isHappy) { //Do something } else { //Do something else } 在方法之间应该有且只有一行，这样有利于在视觉上更清晰和更易于组织。在方法内的空白应该分离功能，但通常都抽离出来成为一个新方法。 优先使用auto-synthesis。但如果有必要，@synthesize和@dynamic应该在实现中每个都声明新的一行。 应该避免以冒号对齐的方式来调用方法。虽然有时方法签名可能有3个以上的冒号和冒号对齐会使代码更加易读。但是请不要这样做，因为当冒号对齐的方法包含代码块时，Xcode的自动缩进和代码块结合将会使代码难以辨认。 推荐： // blocks are easily readable [UIView animateWithDuration:1.0 animations:^{ // something } completion:^(BOOL finished) { // something }]; 不推荐： // colon-aligning makes the block indentation hard to read [UIView animateWithDuration:1.0 animations:^{ // something } completion:^(BOOL finished) { // something }]; 注释当需要注释时，注释应该用来解释这段特殊代码为什么要这样做。任何被使用的注释都必须保持最新或被删除。 一般都避免使用块注释，因为代码尽可能做到自解释，允许写几行断断续续的注释。例外：这些注释不应该用来生成文档 命名Apple 的命名习惯应该被任何事情联系，特别是内容管理规则，一般提倡长的、描述性强的命名 推荐： UIButton *settingsButton; 不推荐： UIButton *setBut; 三个字符前缀应该经常用在类和常量命名，但在Core Data的实体名中应被忽略。对于官方的raywenderlich.com 的书、初学者工具包或教程，都应该使用前缀’RWT’。 常量应该使用驼峰式命名规则，并且所有的单词首字母大写。为了清楚，需要加上与类名有关的前缀。 推荐： static NSTimeInterval const RWTTutorialViewControllerNavigationFadeAnimationDuration = 0.3; 不推荐： static NSTimeInterval const fadetime = 1.7; 属性也是使用驼峰式，但首单词的首字母小写。一般对属性使用auto-synthesis，而不是手动编写@synthesize语句，不过偶尔在某些需求下也可以不受限制。 推荐： @property (strong, nonatomic) NSString *descriptiveVariableName; 不推荐： id varnm; 下划线当使用属性时，实例变量应该使用self.来访问和改变。这就意味着所有属性将会视觉效果不同，因为它们前面都有self.。 但有一个特例：在初始化方法里，实例变量(例如，_variableName)应该直接被使用来避免getters/setters潜在的副作用。 局部变量不应该包含下划线。 方法在方法签名中，应该在方法类型(-/+ 符号)之后有一个空格。在方法各个段之间应该也有一个空格(符合Apple的风格)。在参数之前应该包含一个具有描述性的关键字来描述参数。 不要用”and”这个词。它不应该用于多个参数来说明，就像initWithWidth:height以下这个例子： 推荐： - (void)setExampleText:(NSString *)text image:(UIImage *)image; - (void)sendAction:(SEL)aSelector to:(id)anObject forAllCells:(BOOL)flag; - (id)viewWithTag:(NSInteger)tag; - (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height; 不推荐： -(void)setT:(NSString *)text i:(UIImage *)image; - (void)sendAction:(SEL)aSelector :(id)anObject :(BOOL)flag; - (id)taggedView:(NSInteger)tag; - (instancetype)initWithWidth:(CGFloat)width andHeight:(CGFloat)height; - (instancetype)initWith:(int)width and:(int)height; // Never do this. 变量变量尽量以描述性的方式来命名。单个字符的变量命名应该尽量避免，除了在for()循环。 星号表示变量是指针。例如， NSString *text 既不是 NSString* text 也不是 NSString * text，除了一些特殊情况下常量。 私有变量应该尽可能代替实例变量的使用。尽管使用实例变量是一种有效的方式，但更偏向于使用属性来保持代码一致性。 除了在初始化方法(init, initWithCoder:, 等…)，dealloc 方法和自定义的setters和getters中使用以外，其他地方应该尽量避免通过使用’back’属性(_variable，变量名前面有下划线)直接访问实例变量。想了解关于如何在初始化方法和dealloc直接使用Accessor方法的更多信息，查看这里。 推荐： @interface RWTTutorial : NSObject @property (strong, nonatomic) NSString *tutorialName; @end 不推荐： @interface RWTTutorial : NSObject { NSString *tutorialName; } 属性特性所有属性特性应该显式地列出来，有助于新手阅读代码。属性特性的顺序应该是storage、atomicity，与在Interface Builder连接UI元素时自动生成代码一致。 推荐： @property (weak, nonatomic) IBOutlet UIView *containerView; @property (strong, nonatomic) NSString *tutorialName; 不推荐： @property (nonatomic, weak) IBOutlet UIView *containerView; @property (nonatomic) NSString *tutorialName; NSString应该使用copy而不是strong的属性特性。 为什么？即使你声明一个NSString的属性，有人可能传入一个NSMutableString的实例，然后在你没有注意的情况下修改它。 推荐： @property (copy, nonatomic) NSString *tutorialName; 不推荐： @property (strong, nonatomic) NSString *tutorialName; 点符号语法点语法是一种很方便封装访问方法调用的方式。当你使用点语法时，通过使用getter或setter方法，属性仍然被访问或修改。想了解更多，阅读这里。 点语法应该总是被用来访问和修改属性，因为它使代码更加简洁。[]符号更偏向于用在其他例子。 推荐： NSInteger arrayCount = [self.array count]; view.backgroundColor = [UIColor orangeColor]; [UIApplication sharedApplication].delegate; 不推荐： NSInteger arrayCount = self.array.count; [view setBackgroundColor:[UIColor orangeColor]]; UIApplication.sharedApplication.delegate; 字面值NSString、NSDictionary、NSArray和NSNumber的字面值应该在创建这些类的不可变实例时被使用。请特别注意nil值不能传入NSArray和NSDictionary字面值，因为这样会导致crash。 推荐： NSArray *names = @[@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;]; NSDictionary *productManagers = @{@&quot;iPhone&quot;: @&quot;Kate&quot;, @&quot;iPad&quot;: @&quot;Kamal&quot;, @&quot;Mobile Web&quot;: @&quot;Bill&quot;}; NSNumber *shouldUseLiterals = @YES; NSNumber *buildingStreetNumber = @10018; 不推荐： NSArray *names = [NSArray arrayWithObjects:@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;, nil]; NSDictionary *productManagers = [NSDictionary dictionaryWithObjectsAndKeys: @&quot;Kate&quot;, @&quot;iPhone&quot;, @&quot;Kamal&quot;, @&quot;iPad&quot;, @&quot;Bill&quot;, @&quot;Mobile Web&quot;, nil]; NSNumber *shouldUseLiterals = [NSNumber numberWithBool:YES]; NSNumber *buildingStreetNumber = [NSNumber numberWithInteger:10018]; 常量常量是容易重复被使用且无需通过查找和代替就能快速修改值。常量应该使用static来声明而不是使用#define，除非显式地使用宏。 推荐： static NSString * const RWTAboutViewControllerCompanyName = @&quot;RayWenderlich.com&quot;; static CGFloat const RWTImageThumbnailHeight = 50.0; 不推荐： #define CompanyName @&quot;RayWenderlich.com&quot; #define thumbnailHeight 2 枚举类型当使用enum时，推荐使用新的固定基本类型规格，因为它有更强的类型检查和代码补全。现在SDK有一个宏NS_ENUM()来帮助和鼓励你使用固定的基本类型。 例如： typedef NS_ENUM(NSInteger, RWTLeftMenuTopItemType) { RWTLeftMenuTopItemMain, RWTLeftMenuTopItemShows, RWTLeftMenuTopItemSchedule }; 你也可以显式地赋值(展示旧的k-style常量定义)： typedef NS_ENUM(NSInteger, RWTGlobalConstants) { RWTPinSizeMin = 1, RWTPinSizeMax = 5, RWTPinCountMin = 100, RWTPinCountMax = 500, }; 除非编写 Core Foundation C 的代码，否则旧的k-style常量定义应该被避免 enum GlobalConstants { kMaxPinSize = 5, kMaxPinCount = 500, }; Case语句大括号在case语句中并不是必须的，除非编译器强制要求。当一个case语句包含多行代码时，大括号应该加上。 switch (condition) { case 1: // ... break; case 2: { // ... // Multi-line example using braces break; } case 3: // ... break; default: // ... break; } 在很多时候，当相同代码被多个cases使用时，一个fall-through应该被使用。一个fall-through就是在case最后移除’break’语句，这样就能够允许执行流程跳转到下一个case值。为了代码更加清晰，一个fall-through需要注释一下。 switch (condition) { case 1: // ** fall-through! ** case 2: // code executed for values 1 and 2 break; default: // ... break; } 当在switch使用枚举类型时，’default’是不需要的。例如： RWTLeftMenuTopItemType menuType = RWTLeftMenuTopItemMain; switch (menuType) { case RWTLeftMenuTopItemMain: // ... break; case RWTLeftMenuTopItemShows: // ... break; case RWTLeftMenuTopItemSchedule: // ... break; } 私有属性私有属性应该在类的实现文件中的类扩展(匿名分类)中声明，除非是扩展其他类，否则命名分类(比如RWTPrivate或private)应该从不使用。匿名分类应该通过使用+Private.h文件的命名规则暴露给测试。 @interface RWTDetailViewController () @property (strong, nonatomic) GADBannerView *googleAdView; @property (strong, nonatomic) ADBannerView *iAdView; @property (strong, nonatomic) UIWebView *adXWebView; @end 布尔值Objective-C使用YES和NO。因此true和false应该只在CoreFoundation，C或C++代码使用。既然nil被解析成NO，所以没有必要再在条件语句中比较。不要拿某样东西直接与YES比较，因为YES被定义为1而且一个BOOL可以高达8位。 这是为了在不同文件保持一致性和在视觉上更加简洁而考虑。 推荐： if (someObject) {} if (![anotherObject boolValue]) {} 不推荐： if (someObject == nil) {} if ([anotherObject boolValue] == NO) {} if (isAwesome == YES) {} // Never do this. if (isAwesome == true) {} // Never do this. 如果BOOL属性的名字是一个形容词，属性就能忽略”is”前缀，但要指定get访问器的惯用名称。例如： @property (assign, getter=isEditable) BOOL editable; 文字和例子是从这里引用的Cocoa Naming Guidelines 条件语句条件语句主体为了防止出错应该使用大括号包围，即使条件语句主体能够不用大括号编写(如，只用一行代码)。这些错误包括添加第二行代码和期望它成为if语句；还有，even more dangerous defect可能发生在if语句里面一行代码被注释了，然后下一行代码不知不觉地成为if语句的一部分。除此之外，这种风格与其他条件语句的风格保持一致，所以更加容易阅读。 推荐： if (!error) { return success; } 不推荐： if (!error) return success; 或： if (!error) return success; 三元操作符当需要提高代码的清晰性和简洁性时，才会使用三元操作符?:。单个条件求值常常需要它。多个条件求值时，如果使用if语句或重构成实例变量，代码会更加易读。一般来说，最好使用三元操作符是在根据条件来赋值的情况下。 Non-boolean的变量与某东西比较，加上括号()会提高可读性。如果被比较的变量是boolean类型，那么就不需要括号。 推荐： NSInteger value = 5; result = (value != 0) ? x : y; BOOL isHorizontal = YES; result = isHorizontal ? x : y; 不推荐： result = a &gt; b ? x = c &gt; d ? c : d : y; Init方法Init方法应该遵循Apple自动生成的代码模板的风格。当类构造方法被使用时，它应该返回类型是instancetype而不是id。 - (instancetype)init { self = [super init]; if (self) { // ... } return self; } 类构造方法当类构造方法被使用时，它应该返回类型是instancetype而不是id。这样确保编译器正确地推断结果类型。 @interface Airplane + (instancetype)airplaneWithType:(RWTAirplaneType)type; @end 关于更多instancetype信息，请查看NSHipster.com CGRect函数当访问CGRect里的x, y, width, 或 height时，应该使用CGGeometry函数而不是直接通过结构体来访问。引用Apple的CGGeometry 在这个参考文档中所有的函数，接受CGRect结构体作为输入，在计算它们结果前隐式地标准化这些rectangles。因此，你的应用程序应该避免直接访问和修改保存在CGRect数据结构中的数据。而是使用这些函数来操纵rectangles和获取它们的特性。 推荐： CGRect frame = self.view.frame; CGFloat x = CGRectGetMinX(frame); CGFloat y = CGRectGetMinY(frame); CGFloat width = CGRectGetWidth(frame); CGFloat height = CGRectGetHeight(frame); CGRect frame = CGRectMake(0.0, 0.0, width, height); 不推荐： CGRect frame = self.view.frame; CGFloat x = frame.origin.x; CGFloat y = frame.origin.y; CGFloat width = frame.size.width; CGFloat height = frame.size.height; CGRect frame = (CGRect){ .origin = CGPointZero, .size = frame.size }; 黄金路径当使用条件语句编码时，靠近左边距的代码应该是好的路径。也就是说不要嵌套if语句，多个返回语句也是OK的。 推荐： - (void)someMethod { if (![someOther boolValue]) { return; } //Do something important } 不推荐： - (void)someMethod { if ([someOther boolValue]) { //Do something important } } 错误处理当方法通过引用来返回一个错误参数，判断返回值而不是错误变量。 推荐： NSError *error; if (![self trySomethingWithError:&amp;error]) { // Handle Error } 不推荐： NSError *error; [self trySomethingWithError:&amp;error]; if (error) { // Handle Error } 在成功的情况下，有些Apple的APIs记录垃圾值(garbage values)到错误参数(如果non-NULL)，那么判断错误值会导致false负值和crash。 单例模式单例对象应该使用线程安全模式来创建共享实例。 + (instancetype)sharedInstance { static id sharedInstance = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ sharedInstance = [[self alloc] init]; }); return sharedInstance; } 这会防止偶尔出现的崩溃问题 换行符换行符是一个很重要的主题，因为它的风格指南主要为了打印和网上的可读性。例如： self.productsRequest = [[SKProductsRequest alloc] initWithProductIdentifiers:productIdentifiers]; 一行很长的代码应该分成两行代码，下一行用两个空格隔开。 self.productsRequest = [[SKProductsRequest alloc] initWithProductIdentifiers:productIdentifiers]; 笑脸在 raywenderlich.com 网站上，笑脸是非常突出的一个特性！对编程话题来讲，用正确的笑脸表示欢乐是非常重要的。用后方括号，因为它可以捕获ascii码，并代表一个大笑。后圆括号代表一个三心二意的笑脸，所以将不会被推荐。 推荐： :] 不推荐： :) Xcode工程物理文件应该与Xcode工程文件保持同步来避免文件扩张。任何Xcode分组的创建应该在文件系统的文件体现。代码不仅是根据类型来分组，而且还可以根据功能来分组，这样代码更加清晰。 尽可能在target的Build Settings打开 Treat Warnings as Errors，并启用以下 additional warnings。如果你需要忽略特殊的警告，使用Clang’s pragma feature。 其他Objective-C编码规范如果我们的编码规范不符合你的口味，可以查看其他的编码规范： Robots &amp; Pencils New York Times Google GitHub Adium Sam Soffes CocoaDevCentral Luke Redpath Marcus Zarra 由于 Raywenderlich 的编码规范中对命名的规范内容比较少，我根据网上资料和自己的一些经验做一些补充 Raywenderlich 规范命名补充基本原则 仿照 Cocoa 风格来，使用长命名风格 命名空间 类名、协议名、C 函数、常量、结构体和枚举应带有命名空间前缀 类或实例的方法不要带前缀；结构体字段也不要带前缀 类的命名类名（以及类别、协议名）应首字母大写，并以驼峰格式分割单词。最开头是命名空间，然后越重要、区别度越大的语素越要往前放。经典的结构是：作用范围+限定修饰+类型 类名的前缀 类名应带有命名空间前缀 根据功能模块可以在给功能模块的类添加功能模块的名称前缀 类名的后缀 所有 protocol 定义时，都加上后缀 Delegate 或 DataSource 所有的控制器都加上Controller，所有的通知名都加上Notification 所有的控制器都加上Controller 列表控制器统一使用 ListController，不指明是 table 还是 collection view 控制器命名的一般顺序是 Model名 + 限定修饰 + ListController/DetailController/Controller/Displayer UIView 级别的组件不要以 Controller 或 Displayer 结尾，如果起到管理作用可以使用 control 结尾 类别命名 类名+标识+扩展（UIImageView+HP+Web） 协议命名好的协议名应能立刻让人分辨出这不是一个类名，除了以常用的 delegate、dateSource 做结尾外，还可以使用 …ing 这种形式，如：NSCoding、NSCopying、NSLocking 枚举命名正宗的iOS开发者当然要以Objective-C的方式命名枚举，如 typedef NS_ENUM(NSInteger, UIViewAnimationTransition) { UIViewAnimationTransitionNone, UIViewAnimationTransitionFlipFromLeft, UIViewAnimationTransitionFlipFromRight, UIViewAnimationTransitionCurlUp, UIViewAnimationTransitionCurlDown, }; 方法名 方法名应遵守小驼峰原则，首字母小写，其他单词首字母大写,每个空格分割的名称以动词开头 执行性的方法应该以动词开头，小写字母开头，返回性的方法应该以返回的内容开头，但之前不要加get 代理方法应以发送代理的对象类名作为代理方法名的开始（去掉类名的前缀，并且小写开头） 私有方法命名以“命名空间”开头，类别的方法名也应以“命名空间”开头，苹果的私有方法是以下划线开头 通知命名基本命名格式是：[与通知相关的类名] + [Did | Will] + [UniquePartOfName] + Notification NSApplicationDidBecomeActiveNotificationNSWindowDidMiniaturizeNotificationNSTextViewDidChangeSelectionNotificationNSColorPanelColorDidChangeNotification const 常量命名 以小写k开头，后面单词首字母大写，其余小写，如const float kMaxHeigt = 100.0f; 如果是特殊含义的常量也建议加上后缀，如通知加上Notification为后缀，如：extern NSString * Const kLoginSuccessNotification 属性、变量命名变量命名推荐的命名语素顺序是：最开头是命名空间简写，然后越重要、区别度越大的语素越要往前放。经典的结构是：作用范围+限定修饰+类型。 变量名使用小驼峰法, 使变量名尽量可以推测其用途属性具有描述性 别一心想着少打几个字母，让你的代码可以迅速被理解更加重要 每个属性命名都加上类型后缀，如，按钮就加上Button 成员变量用小驼峰法命名并前缀下划线，如:UIButton *_submitButton; 局部变量名遵守小驼峰命名规则，如：NSInteger numCompletedConnections = 3; 临时变量可以写得很短，如 i、k、vc 这样 临时变量可以使用匈牙利前缀，但数据类型不可以作为前缀，如ix(序号，起始为0)/in(序号，起始为1)/if(类型为浮点的“序号”)/x(坐标)/y(坐标)/w(宽度)/h(高度)/vc(视图控制器)/v(视图) 资源文件命名（图片、本地化文件）图片资源命名方式，以功能为组织形式，是一个很好的习惯，有利于查看资源文件 采用单词全拼，或者大家公认无岐义的缩写(比如：nav，bg，btn等) 采用“模块+功能”命名法，模块分为公共模块、私有模块 公共模块主要包括统一的背景，导航条，标签，公共的按钮背景，公共的默认图等等；私有模块主要根据app的业务功能模块划分，比如用户中心，消息中心等 例如用户中心用户头像图片的命名可以为：uc_imageview_user_icon 命名中的大小写 类名采用大驼峰（UpperCamelCase） 类成员、方法小驼峰（lowerCamelCase） 局部变量大小写首选小驼峰，也可使用小写下划线的形式（snake_case） C函数的命名用大驼峰 其他 可以使用广泛使用的缩写，如 URL、JSON，并且缩写要大写 文件夹命名和segue命名以大写开头，驼峰式命名方式 i，j专用于循环变量标号]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[疯狂iOS下册第二部分]]></title>
    <url>%2F2014%2F06%2F27%2F%E7%96%AF%E7%8B%82iOS%E4%B8%8B%E5%86%8C-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[本篇主要接着《疯狂iOS讲义》下册第一部分的内容将下册第二部分的重点知识列举一下，包括:iOS网络应用编程、使用CoreLocation定位、使用MapKit开发地图服务、推送机制、iCloud服务与应用五大部分。 iOS网络应用编程检测网络状态检测设备的网络状态，需要两个步骤： 下载、添加Reachability 添加SystemConfiguration框架 代码实现： Reachability *reach = [Reachability reachabilityWithHostName:site]; switch([reach currentReachabilityWithHostName:site]) { case NotReachable: break; case ReachableViaWWAN: break; case ReachableViaWiFi: break; } if([[Reachability reachabilityForLocalWiFi] currentReachabilityStatus]!=NotReachable) if([[Reachability reachabilityForInternetConnection] currentReachabilityStatus]!=NotReachable) 监听网络状态的改变,在[application:didFinishLaunchingWithOptions:]中增加 [[NSNotificationCentre defaultCentre] addObserver:self selector:@selector(reachabilityChanged:) name:kReachabilityNotification object:nil]; Reachability *reach = [Reachability reachabilityWithHostName:@“www.crazyit.org”]; [reach startNotifier]; -(void)reachabilityChanged:(NSNotification *)note { Reachability *curReach = [note object]; NetWorkStatus status = [curReach currentReachabilityStatus]; } 使用CFNetwork实现TCP协议的通信TCP/IP通信协议是一种可靠的网络协议，它在通信的两端各建立一个通信接口，从而在通信的两端之间形成网络虚拟链路。一旦建立的虚拟的网络链路，两端的程序就可以通过虚拟链路进行通信。CFNetwork对基于TCP协议的网络通信提供了良好的封装，CFNetwork使用CFSocket来代表两端的通信接口，还可通过CFStream读/写数据。 IP地址用于唯一地标识网络中的一个通信实体，这个通信实体既可以是一台主机，也可以是一台打印机，或者是路由器的某个端口，在基于IP协议的网络传输的数据包，都必须使用IP地址来进行标识 IP协议是Internet上使用的一个关键协议，它的全称是Internet Protocol，即网络协议，通过使用IP协议，使Internet成为一个允许连接不同类型的计算机和不同操作系统的网络，IP协议是用于将多个包交换网络连接起来的，它在源地址和目的地址之间传送一种称之为数据包的东西，它还提供对数据大小的重新组装功能，以适应不同网络对包大小的要求，它的责任就是把数据从源传送到目的地。它不负责保证传送可靠性，流控制，包顺序和其它对于主机到主机协议来说很普通的服务 TCP协议负责收集这些信息包，并将其按适当的次序放好传送，在接收端收到后再将其正确的还原，TCP协议保证了数据包在传输中准确无误，而且TCP协议会使用重发机制，保证数据包不会漏掉 使用CFSocket实现TCP服务器端 创建一个监听SocketAccept(Socket链接)的CFSocket，并为kCFSocketCallBack事件绑定回调函数 CFSocketRef _socket = CFSocketCreate(kCFAllocatorDefault, PF_INET,//指定协议族，如果该参数为0或者负数，则默认为PF_INET，也可以是AF_INET6或AF_UNSPEC SOCK_STREAM,//指定socket类型，默认为SOCK_STREAM，如果使用UDP协议，则使用SOCK_GGRAM IPPRTO_TCP,//指定通信协议，如果前一个参数为SOCK_STREAM，则用TCP协议，如果SOCK_GGRAM则用UDP kCFSocketAcceptCallBack,//指定下一个回调函数所监听的事件类型 TCPServerAcceptCallBack);//连接成功或失败时的回调函数,NULL void TCPServerAcceptCallBack(CFSocketRef socket,CFSocketCallBackType type//kCFSocketAcceptCallBack,CFDataRef address,const void *data//传入的数据, void *info) 调用CFSocketSetAddress函数，将服务端的CFSocket绑定到本地IP地址和端口 CFSocketSetAddress(_socket,address)==kCFSocketSuccess) CFSocket作为source添加到指定线程的CFRunLoop上，并运行该线程的CFRunLoop，从而保证该CFSocket能持续不断地接收来自客户端的链接 CFRunLoopSourceRef source = CFSocketCreateRunLoopSource(kCFAllocator, _socket, 0); CFRunLoopAddSource(CFRunLoopGetCurrent(), source, kCFRunLoopCommonModes);CFRunLoopRun(); 以上步骤，相当于Java中的： ServerSocket ss = new ServerSocket(3000); while(true) { final Socket s = ss.accept(); new Thread() { @Override public void run() { InputStream is = s.getInputStream; } }; OutputStream os = s.getOutputStream(); } 使用CFSocket实现TCP客户端 创建一个不监听任何事件或监听connection的CFSocket，如果要监听connection，则需要为kCFSocketCallBack事件绑定回调函数 CFSocketRef _socket = CFSocketCreate(kCFAllocatorDefault, PF_INET,//指定协议族，如果该参数为0或者负数，则默认为PF_INET SOCK_STREAM,//指定socket类型，默认为SOCK_STREAM，如果使用UDP协议，则使用SOCK_GGRAM IPPRTO_TCP,//指定通信协议，如果前一个参数为SOCK_STREAM，则用TCP协议，如果SOCK_GGRAM则用UDP kCFSocketNoCallBack,//指定下一个回调函数所监听的时间类型 nil);//回调函数,NULL 调用CFSocketConnectToAddress()函数，将客户端的CFSocket链接到指定IP的地址和端口的服务器上 CFSocketError result = CFSocketConnectToAddress(_socket,address//指定远程服务器的IP地址和端口,5//指定链接超时时长，如果为负，则把链接操作放在后台进行);//当socket消息类型为kCFSocketConnectCallBack时，将会在连接成功或失败时在后台触发回调函数); 得到客户端CFSocket后，既可以直接使用CFSocket对应的CFSocketNativeHandler进行读/写，也可以通过CFSocket获取CFReadStreamRef、CFWriteStreamRef后进行读/写 while(hasRead=recv(CFSocketGetNative(_socket), buffer, sizeOf(buffer), 0)){ //buffer; } send(CFSocketGetNative(_socket), data, strlen(data)+1, 1); 直接使用CFSocket虽然可以实现基于TCP协议的网络通信，但采取这种方式进行编程十分繁琐，为了降低直接使用CFSocket编程的复杂度，另外有开发者提供了一套开源的CocoaAsyncSocket库，CocoaAsyncSocket库封装了CFNetwork底层的CFSocket和CFStream，并提供了异步操作，从而可简化Socket网络编程，CocoaAsyncSocket不仅支持TCP协议的网络编程，也支持UDP协议的网络编程，其git地址为https://github.com/robbiehanson/CocoaAsyncSocket，CocoaAsyncSocket主要有以下特性： 非阻塞方式的读和写，而且可设置超时时长 自动的Socket接收，如果调用它接受连接，它将为每个连接启动新的实例，当然也可以立即关闭这些连接 委托支持，错误、连接、接收、完整的读取、完整的写入、进度以及断开连接等，都可以通过委托模式调用 所有的操作都封装在一个类中，开发者无须操作Socket或流，该类封装了所有操作 从git地址中的目录可以看出，该目录下的source为封装的源码文件夹，此文件夹下包括RunLoop、GCD和Vendor文件夹 RunLoop目录下包括了AsyncSocket、AsynUdpSocket两个类文件，GCD和RunLoop类似，只是类名变成了GCDAsyncSocket和GCDAysncUdpSocket，不同点在于此两类是用GCD实现的，Vendor目录中是保存的其他相关的类 AsyncSocket *socket = [[AsyncSocket alloc] initWithDelegate:self]; [socket connectToHost:host onPort:port withTimeout:2 error:&amp;error]; -(void)onSocket:(AsyncSocket*)socket didConnectToHost:(NSString*)host port:(UInt16)port { [socket readDataWithTimeout:-1 tag:0]; } -(void)onSocket:(AsyncSocket*)socket didReadData:(NSData*)data withTag:(long)tag { [socket writeData:data withTimeout:-1 tag:0]; } 使用NSURLConnection如果只是为了读取HTTP等服务器数据，或向服务器提交数据，iOS还提供了NSURLConnection类，NSURLConnection使用NSURLRequest向远程服务器发送同步或异步请求，并获取服务器响应的数据，除NSURLRequest外，还可用NSMutableURLRequest，他们包含的方法有： -(NSURLRequest*)originalRequest;/-(NSURLRequest*)currentRequest; +sendSynchronousRequest:returningResponse:error: +connectionWithRequest:delegate: -initWithRequest:delegate: -initWithRequest:delegate:startImmediately:/-start: +sendAsynchronousRequest:queue:completionHandler:需要额外指定NSOperationQueue，表明交给其处理 调用方法： NSULRequest *request = [NSURLRequest requestWithURL:url cachePolicy:NSURLRequestReloadIgnoringLocalCacheData timeoutInterval:5]; NSURLConnection *conn = [NSURLConnection connectionWithRequest:request delegate:self]; Delegate回调： -(void)connection:(NSURLConnection*)connection didReceiveResponse:(NSURLResponse*)response; -(void)connection:(NSURLConnection*)connection didReceiveData:(NSData*)data; -(void)connection:(NSURLConnection*)connection didFailWithError:(NSError *)error; -(void)connectionDidFinishLoading:(NSURLConnection*)connection; 如果需要请求服务器时添加请求头和请求参数，则需要使用NSMutableURLRequest来请求 -addValue:forHTTPHeaderField: -setAllHTTPHeaderFields: -setHTTPBody: -setHTTPBodyStream: -setHTTPMethod: -setHTTPShouldHandleCookies: -setValue:forHTTPHeaderField: XML解析XML文件是一种平台无关的数据交换格式，当iOS应用需要与其他应用或应用服务器进行通信时，如果数据量较小，使用简单的文本数据，但当数据量较大且数据之间有严格的结构关系时，可以选择XML文档作为数据交换格式，也可选择JSON作为数据交换格式 为了利用XML文档的结构化特征进行解析，现有两套比较流行的规范： DOM：Document Object Model，即文档对象模型，是由W3C推荐的处理XML文档的规范，它会一次性地读取整个XML文档，而且程序运行期间常驻内存，可随意修改，但系统开销过大 SAX：Simple API for XML，并不是W3C推荐的标准，但是却是整个XML行业的事实规范，它采用事件机制的方式来解析 基于这两种规范，iOS解析XML文件有很多原生的或者开源的类库可选：如 NSXMLParser:iOS自带，基于SAX解析，纯OC实现 -parserDidStartDocument:(开始解析) -parserDidEndDocument:(解析结束) -parser:didStartElement:namespaceURI:qualifiedName:attributes:(开始处理XML元素) -parser:didEndElement:namespaceURI:qualifiedName:(结束处理XML元素) -parser:resolveExternalEntityName:systemID:(开始处理外部实体) -parser:parseErrorOccurred:(解析出现错误) -parser:validationErrorOccurred:(验证遇到错误) -parser:foundCharacters:(遇到字符串时) -parser:foundIgnorableWhiteSpace:(解析遇到空白时) -parser:foundProcessingInstructionWithTarget:data:(解析文档的处理指令时) -parser:foundComment:(处理注释时) -parser:foundCDATA:(处理CDATA时) NSXMLParser *parser = [[NSXMLParser alloc] initWithContentsOfURL:fileURL]; parser.delegate = self; [parser parse]; libxml2:iOS自带，开源解析器，可同时支持DOM和SAX，性能好，C实现，用起来不大方便，步骤如下： 添加libxml2.dylib库 添加头文件的搜索路径/usr/include/libxml2 创建对象 获取信息 xmlTextReaderPtr reader = xmlNewTextReaderFilename(xmlPath);//通过文档创建对象 xmlTextReaderPtr reader = xmlReaderForMemory(memory, size, NULL, “UTF-8”, 0);//通过内存创建对象 if(xmlTextReaderNodeType(reader)==XML_READER_TYPE_ELEMENT) { xmlTextReaderConstName(reader)//获取元素名 xmlTextReaderGetAttribute(reader,(xmlChar*)”id”)//获取元素属性名 xmlTextReaderReadString(reader)//获取元素中的文本内容 }; GDataXML:第三方开源，基于DOM和SAX，性能快，非常流行，对libxml2的封装，将XML文档解析成对象 GDataXMLDocument *doc = [[GDataXMLDocument alloc] initWithData:data option:0 error:nil]; GDataXMLElement *rootElement = [doc rootElement]; NSArray *bookElements = [rootElement elementsForName:@“book”]; for(GDataXMLElement *book in bookElements) { [bookElement attributeForName:@“id”]; [bookElement elementsForName:@“title”]; } 将对象保存成XML文档 GDataXMLElement *rootElement = [GDataXMLNode elementWithName:@“books”]; GDataXMLElement *otherElement = [CDataXMLNode elementWithName:@“title” stringValue:book]; [rootlet addChild:otherElement]; GDataXMLDocument *doc = [[GDataXMLDocument alloc] initWithRootElement:rootElement]; [doc.XMLData writeToFile:self.xmlPath atomically:YES]; TBXML:轻量级的，基于DOM，性能好，内存占用少，只能读不能改，不支持XPath方式查询 TouchXML:扩展TBXML，可以支持XPath方式查询 KissXML:基于TouchXML，可支持修改 JSON解析JSON的全称JavaScript Object Notation，即JS对象符号，也是一种广泛使用的轻量级数据交换格式，同样具有跨平台、跨语言的优势，而且JSON的数据传输量更小 使用iOS自带的NSJSONSerialisation处理JSON数据 +JSONObjectWithData:options:error: +JSONObjectWithStream:options:error: +dataWithJSONObject:options:error: +writeJSONObject:toStream:options:error: +isValidJSONObject: 使用SBJson处理JSON数据，此框架属于第三方框架，主要有两个类：SBJsonParser和SBJsonWriter -objectWithData: -objectWithString: -objectWithString:error: -stringWithObject: -dataWithObject: -stringWithObject:error: 使用JSONKit处理JSON数据 -(id)objectFormJSONXxxWithParseOptions:/error:将该JSON解析为OC对象，Xxx代表String或Data -(id)mutableObjectFromJSONXxx/WithParseOptions:/error:将该JSON解析为可变的OC对象 -(NSData)JSONData;-(NSString)JSONString; 还有其他一些方式，如JSONModel，MJExtension等 使用AFNetworking实现网络通信AFNetworking默认支持JSON和Plist数据类型的响应，即服务端支持application/json,text/json,application/x-plist类型的返回，所以无须指定服务器响应解析器，如果其他类型，则需要指定 AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; manager.responseSerializer = [[AFHTTPResponseSerializer alloc] init]; [manager GET:url parameters:params success:^(NSURLSessionDataTask *task, id responseObject) { NSXMLParser *parser=responseObject; parser.delegate=self; [parser parse];//如果返回的是xml数据 } failure:^(NSURLSessionDataTask *task, NSError *error) { //NSLog(error); }]; AFNetworking上传文件 -appendPartWithFileURL:name:(fileName:mimeType)error: -appendPartWithInputStream:name:fileName:length:mineType: -appendPartWithFileData:name:fileName:mimeType: [manager POST:url parameters:params constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; data) { [data appendPartWithFileURL:filePath name:@“file” mimeType:@“image/png” error:nil } success:^(NSURLSessionDataTask *task, id responseObject) { } failure:^(NSURLSessionDataTask *task, NSError *error) { }]; 使用ASIHTTPRequest框架实现网络编程ASIHTTPRequest对iOS SDK的CFNetwork API进行了封装，它和AFNetworking是竞争关系，作用相同，ASIHTTPRequest是NSOperation的子类，所以此处同样可以使用NSOperationQueue来管理多个ASIHTTPRequest，使用步骤： 设置delegate处理返回数据 添加代码块处理返回数据 示例代码： ASIHTTPRequest *request = [ASIHTTPRequest requestWithURL:url]; -addRequestHeader:value(添加请求头) [ASIFormDataRequest setPostValue:forKey:]//添加post参数 -setFile:withFileName:andContentType:forKey: -setData:withFileName:andContentType:forKey: -(void)requestFinished:(ASIHTTPRequest*)request;/[request setCompletionBlock:^{}]; -(void)requestFailed:(ASIHTTPRequest*)request;/[request setFailedBlock:^{}]; 用responseStatusCode/responseStatusMessage/responseHeaders可以获取服务器返回的其他信息，如果程序需要取消某个异步请求，则可调用方法：-cancel:/-clearDelegatesAndCancel: 使用CoreLocation定位iOS的定位支持CoreLocation框架(CoreLocation.framework)可用于定位设备当前经纬度，通过该框架，应用程序可通过附近的蜂窝基站，WiFi信号或者GPS等信息计算用户位置，iOS SDK提供了CLLocationManager/CLLocationManagerDelegate来处理设备的定位信息(CLLocation)，获取设备的方向(CLHeading)以及进行区域检测(CLRegion)等 GPS定位需要能收到卫星信号才行，与基站定位、WiFi定位相比，GPS定位耗电量最大，速度最慢，但精度最高 基站定位可以采用无网络定位(有网络精度更高)，将基站信息在本地或发送到苹果云端服务器查询，特点是速度快，耗电量少，但是误差较大 WiFi定位和基站定位的原理大致相似，其速度、耗电量和精度都介于GPS和基站定位之间 获取定位信息CLLocationManager:定位管理器类 +locationServicesEnabled: +deferredLocationUpdatesAvailable:返回延迟定位更新是否可用 +significantLocationChangeMonitoringAvailable:返回重大位置改变是否可用 +headingAvailable:返回是否支持磁力计算方向 +isRangingAvailable:返回蓝牙信号范围服务是否可用 在开始定位之前，可用设置如下属性： -pausesLocationUpdatesAutomatically:是否自动暂停定位更新来节省电池电量 -distanceFilter:设置其自动过滤的距离，只有当设备在水平方向位置改变超过时，才会生成一次位置改变 -desiredAccuracy:设置定位服务的精度，支持kCLLocationAccuracyBestForNavigator/Best/NearestTenMeters/HundredMeters/kilometer/ThreeKilometers -activityType:定位数据的用途，CLActivityTypeOther/AutomotiveNavigation/Fitness/ 在调用-startUpdatingLocation:定位完成之后，可以用如下属性取出值： -altitude:(海拔) -coordinate:(CLLocationCoordinate2D结构变量，包含经纬度信息) course:(表示设备前进方向，0表示向北，90表示向东) -horizontalAccuracy:(水平准确度) -verticalAccuracy:(垂直精度) -timeStamp:(定位信息的返回时间) -speed:(设备的移动速度) CLLocationManagerDelegate:管理器的delegate协议 -(void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray *)locations: -(void)locationManager:(CLLocationManager *)manager didFailWithError:(NSError *)error; CLLocation:包含经度、纬度、高度、速度、路线等信息 CLHeading:设备的移动方向 CLRegion代表一个区域，一般用CLCircularRegion(圆形区域)、CLBeaconRegion(蓝牙信号区) 方向监听-(void)locationManager:(CLLocationManager *)manager didUpdateHeading:(CLHeading *)newHeading; 在监听开始前，可以设置如下属性： -(CLLocationDegrees)headingFilter:设置只有当方向属性改变超过此值时，才调用delegate方法 -(CLDeviceOrientation)headingOrientation:设置设备当前方向 当调用-startUpdatingHeader方法后，可以调用以下属性获取值 —magneticHeading:该设备与慈悲方向的相对方向 -trueHeading:该方向与磁北方向的相对方向 -headingAccuracy:方向值的精确度 -timeStamp:值的生成时间 x、y、z:在各个方向上的磁力值 区域监测CLRegion *region = [[CLCircularRegion alloc] initWithCentre:CLLocationCoordinate radius:500 identifier:@“fit”]; [_locationManager startMonitoringForRegion:region]; -(void)locationManager:(CLLocationManager *)manager didEnterRegion:(CLRegion *)region; -(void)locationManager:(CLLocationManager *)manager didExitRegion:(CLRegion *)region; 使用MapKit开发地图服务使用MapKit框架MapKit.framework使用MKMapView类代表地图控件，开发者只要在应用界面上添加并显示该控件，就可增加地图功能，如果希望控制该地图的行为，则可通过设置属性进行定制，如果需要响应MKMapView事件，则可通过为MKMapView指定delegate来实现：MKMapView类常用的属性如下: -mapType:设置或返回地图的类型，MKMapTypeStandard/Satellite/Hybrid(混合地图) -zoomEnabled -scrollEnabled -rotateEnabled -region显示区域 -centreCoordinate中心位置 -visibleMapRect显示区域 -annotations地图上的所有标注 -showUserLocation是否显示用户位置 -userLocationVisible用户位置是否可见 -userLocation用户位置，属性为MKUserLocation对象 userTrackingMode用户轨迹的跟踪模式 MKUserTrackingModeNone，MKUserTrackingModeFollow，MKUserTrackingModeFollowWithHeading -delegate MKMapView delegate常用的回调函数如下： -(void)mapView:(MKMapView*)mapView regionWill/didChangeAnimated:(BOOL)animated; -(void)mapViewWillStart/DidFinish/DidFailLoadingMap:(MKMapView *)mapView; -(void)mapViewWillStart/DidFinishRenderingMap:(MKMapView *)mapView; iOS7新增MKMapCamera作为地图视点，用于模拟从指定位置、指定高度看向地图的某个点，从而增加3D体验 MKMapCamera *camera = [MKMapCamera cameraLookingAtCentreCoordinate:to fromEyeCoordinate:from eyeAltitude:70] _mapView.camera = camera; 根据地址定位地址解析：把普通的地址信息转换为经、纬度反向地址解析：把经纬度转换成普通的地址信息 iOS为地址解析提供了CLGeocoder工具类，该工具提供三个方法来进行地址解析和反向地址解析 -geocodeAddressString:completionHandler:^(NSArray *placemarks,NSError *error){} -geocodeAddressString:inRegion:completionHandler: -reverseGeocodeLocation:completionHandler: place marks里边装的对象为CLPlacemark，该对象代表一个定位点，它包含如下属性 -location:CLLocation类型的值，代表了经纬度 -name:地址名称 -addressDictionary:地址详情 -ISOCountryCoe:国家编码 -postalCode:邮编 -administrativeArea:行政区域 -subAdministrativeArea:次级行政区域 -locality:城市名 -subLocality:下一级城市名 -thoroughfare:地址的道路名 -subThoroughfare:下一级地址的道路名 在地图上添加锚点很多时候，希望在地图上添加锚点，当用户点击该锚点时显示该地址的详细信息，这时需用到MKAnnotation MKAnnotation是一个协议，该协议中定义了3个属性，coordinate，title，subtitle iOS为MKAnnotation协议提供了一个类实现：MKPointAnnotation，该类实现了该协议的所有方法 MKPointAnnotation *annotation = [[MKPointAnnotation alloc] init]; annotation.title/.subtitle/.coordinate = CLLocationCoordinate2D; [_mapView addAnnotation:annotation]; 可根据手势在地图上的触摸位置，算出手势在实际地图中的坐标： CGPoint pos = [gesture locationInView:_mapView]; CLLocationCoordinate2D coord = [_mapView convertPoint:pos toCoordinateFromView:_mapView]; 地图上默认的锚点的样式是MKPINAnnotation，如果需要自定义地图上锚点的样式，则需要重写delegate的方法 -(MKAnnotationView *)mapView:(MKMapView*)mapView viewForAnnotation:(id)annotation { MKAnnotationView *annoView = [[MKAnnotationView alloc] initWithAnnotation:annotation reusedIdentifier:identifier]; annoView.image/.canShowCallout/.rightCalloutAccessoryView; return annoView; } 在地图上添加覆盖层除了添加锚点之外，有时候需要添加更丰富的信息，这些信息可通过覆盖层(MKOverlay)来实现：覆盖层与地图锚点有相同的设计，每个覆盖层实际是由两部分组成 覆盖物的位置，集合，形状等信息 覆盖物控件，MKOverlay只是一个协议，因此iOS还为该协议提供了如下实现类： MKCircle:圆形覆盖层，对应控件为MKCircleView，推荐使用MKCircleRenderer MKPolygon:多边形覆盖层，对应控件为MKPolygonView，推荐使用MKPolygonRenderer MKPolyline:多线段覆盖层，对应控件为MKPolylineView，推荐使用MKPolylineRenderer MKTileOverlay:位图平铺覆盖层，没有覆盖层控件，推荐使用MKTileOverlayRenderer 创建了覆盖层以后，接下来可以将覆盖层添加到MKMapView中去 * -addOverlay(s):level:将单个、多个覆盖层添加到指定的层级 * -addOverlay(s):将单个、多个覆盖层加到到默认层级 MKOverlayLevel类型是一个枚举类型，该枚举类型支持MKOverlayLevelAboveRoads/Labels; 添加后回调MKMapViewDelegate协议中的方法，返回MKOverlayRenderer负责绘制覆盖层控件 -(MKOverlayRenderer*)mapView:(MKMapView*)mapView rendererForOverlay:(id)overlay; 完整代码示例： MKCircle *circle = [MKCircle circleWithCentreCoordinate:coord radius:100]; //MKTileOverlay *overlay = [[MKTileOverlay alloc] initWithURLTemplate:url]; [_mapView addOverlay:circle level:MKOverlayLevelAboveLabels]; -(MKOverlayRenderer *)mapView:(MKMapView *)mapView rendererForOverlay:(id)overlay { MKCircle *c = (MKCircle*)overlay; MKCircleRenderer *render = [[MKCircleRenderer alloc] initWithCircle:c]; render.alpha/render.fillColour/render.strokeColor return render; } 使用iOS7新增的MKDirections获取导航路线可以通过MKDirections类导航路线，该类通过MKDirectionsRequest向Apple服务器发送导航请求，服务器会返回多条导航路线，然后通过覆盖层把其中一条或多条导航路线绘制在地图上 创建MKDirectionsRequest对象，并为该对象设置导航起始点、结束点等必要信息，还可为其设置transportType属性，该属性支持MKDirectionsTransportTypeAutomobile/Walking/Any 以MKDirectionsRequest为参数，创建MKDirections对象 调用MKDirections的-calculateDirectionsWithCompletionHandler:调用时需要传入代码块，当获取路线成功之后会激发该代码块，在该代码块中可处理返回的路线并将路线显示在地图上 示例代码如下： MKDirectionsRequest *request = [[MKDirectionsRequest alloc] init]; request.source = [MKMapItem mapItemForCurrentLocation]; request.destination = [[MKItem alloc] initWithPlacemark:placemark]; MKDirections *directions = [[MKDirection alloc] initWithRequest:request]; [directions calculateDirectionsWithCompletionHandler:^void(MKDirectionsResponse *response, NSError *error) { MKRoute *route = response.routes[0]; MKPolyline *polyline = route.polyline; [_mapView addOverlay:polyline level:MKOverlayLevelAboveLabels]; } 推送机制本地通知和远程推送通知都可以向不在前台运行的应用发送消息，它们在程序界面上的显示效果相同，都可能显示为一段警告信息或应用程序图标上的徽标向用户提醒，提醒用户即将要做的事情，也可将服务器数据发送给iOS客户端 使用NSNotificationCenter通信NSNotificationCenter实现了观察者模式，允许应用的不同对象之间以松耦合的方式进行通信，NSNotificationCenter相当于一个“消息中心”，首先由Observer组件向NSNotificationCenter进行注册，当Poster向NSNotificationCenter发送NSNotification之后，所有在NSNotificationCenter上注册过的NSNotification都会被激发，NSNotification不能跨进程通信，它包括如下属性： -observer:监听者对象 -name:通知名称 -object:该通知的poster userInfo:NSDictionary对象，包含附加信息 NSNotification *noti = [NSNotification notificationWithName:PROGRESS object:nil userInfo:nil]; NSNotificationCenter提供了defaultCenter类方法获取系统默认的通知中心对象，然后通过如下方法注册监听者 -addObserver:selector:name:object: -removeObserver: -removeObserver:name:object: 通过如下方法发送通知 -postNotification: -postNotificationName:object: -postNotificationName:object:userInfo: iOS本地通知本地推送和远程推送不同于前面介绍的NSNotification，这种通知属于应用界面编程的内容，他们都可以向不在前台运行的应用发送消息，然后显示一段警告信息或应用程序上的徽标，当应用点击通知时，可以启动相应的应用程序查看详情 本地和远程的区别在于：本地通知由本应用负责调用，从当前设备发出，远程通知由服务器发送到Apple Push Notification Service(APNs)，再由APNs把消息推送至设备上的对应程序 本地通知是一个UILocalNotification对象，它有如下常用属性： -fireDate:触发时间 -repeatInterval:重复发送的时间间隔 -alertBody:本地通知的消息体 -alertAction:当设备处于锁屏状态，显示通知的警告框下方的title -hasAction:是否显示Action -alertLaunchImage:当用户通过该通知启动对应的应用时，该属性设置为加载图片 -applicationIconBadgeNumber:应用程序的图标的徽标中的数字 -soundName:通知的声音 -userInfo:通知携带的附加信息 创建了UILocalNotification对象之后，接下来就可以通过UIApplication的如下两个方法发送通知： -scheduleLocalNotification:指定调度通知，通知将会于fireDate指定的时间触发，而且会按repeatInterval指定的时间间隔重复触发 -presentLocalNotification:now:指定调度立即触发，该方法会忽略UILocalNotification的fireDate属性 如果系统发出通知时，应用程序处于前台运行，系统将会触发应用程序委托类的application:didReceiveLocalNotification方法 iOS远程推送通知Provider-&gt;notification-&gt;APNs-&gt;notification-&gt;iPhone-&gt;notification-&gt;Client App 对于开发iOS Push服务而言，完整的过程如下： 应用程序注册远程推送通知 当注册成功或者失败时，回调应用程序委托类的对应方法，可获取注册成功后的deviceToken 应用程序将deviceToken发送给Push服务端程序 服务端程序向APNs发送通知 APNs发送通知给iOS设备，iOS设备将推送转发给对应的程序 Push客户端应用需要3个组件 1，App ID 2，Provisioning Profile 3，device token Push服务端程序需要两个组件 1，SSL Certificate 2，Private Key 注册远程推送通知的过程 -registerForRemoteNotificationTypes:/-unregisterForRemoteNotifications: -application:didReceiveRemoteNotification: -application:didRegisterForRemoteNotificationsWithDeviceToken: -application:didFailToRegisterForRemoteNotificationsWithError: iCloud服务与应用iCloud入门iCloud是Apple公司提供的云端服务，用户可以将个人数据(如通讯录、备忘录、邮件、照片、音乐、视频等)备份到云端服务器，打开应用的iCloud项目配置开关，即可在该项目增加一个CloudTest.entitlements文件，里边可以配置各种目录，iCloud支持的核心API是UIDocument，需要保存在云端的对象应该继承UIDocument类，它包含如下常用方法： -closeWithCompletionHandler:关闭UIDocument，如果有未保存的修改，则关闭前会自动保存 -saveToURL:forSaveOperation:completionHandler:将该UIDocument保存到指定URL -openWithCompletionHandler:打开并读取UIDocument在云端的数据 -readFromURL:error:从指定的url读取数据 -(id)contentsForType:error:需重写，该方法负责把UIDocument内的数据转换为NSData或NSFileWrapper -loadFromContents:ofType:error: 该方法需要被重写，该方法负责吧云端下载到的NSData或NSFileWrapper转换为UIDocument数据 查询文档： _query = [[NSMetadataQuery alloc] init]; _query.predicate = [NSPredicate predicateWithFormat:@“%K like ‘*.diary’”, NSMetadataItemFSNameKey]; _query.searchScopes = [NSArray arrayWithObject:NSMetadataQueryUbiquitousDocumentsScope]; [[NSNotificationCentre defaultCentre] addObserver:self selector:@selector(updateUbiquitousDocuments:) name:NSMetaDataQueryDidFinishGatheringNotification/NSMetadataQueryDidUpdateNotification object:nil]; [_query startQuery];-&gt;NSMetadataItem *item = _query.result[0]; NSURL *url = [item valueForAttribute:NSMetadataItemURLKey]; 将文档添加到iCloud NSFileManager *fileManager = [NSFileManager defaultManager]; NSURL *url=[[fileManager URLForUbiquityContainerIdentifier:nil] urlByAppendingPathComponent:@“name”]; [_chosenDiary saveToURL:url forSaveOperation:UIDocumentSaveForCreating completionHandler:^(BOOL success) {} 删除文档 [[NSFileManager defaultManager] removeItemAtURL:url error:nil]; 使用iCloud保存云端首选项iCloud保存首选项和NSUserDefault类似，但是它可以将其保存到云端，需开启iCloud云端支持并勾选User key-value store，然后用NSUbiquitousKeyValueStore来保存 NSUbiquitousKeyValueStore *defaults = [NSUbiquitousKeyValueStore defaultStore]; [defaults setString:_password forKey:@“password”]; [defaults synchronise]; [defaults stringForKey:@“password”];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[疯狂iOS下册第一部分]]></title>
    <url>%2F2014%2F05%2F30%2F%E7%96%AF%E7%8B%82iOS%E4%B8%8B%E5%86%8C-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[本篇主要接着《疯狂iOS讲义》上册的内容将下册第一部分的重点知识列举一下，包括:多点触摸与手势检测、国际化、iOS的数据存储与IO、多媒体应用开发、管理手机、加速剂与陀螺仪、多线程七大部分。 多点触摸与手势检测响应者链事件的传递顺序：First Responder-&gt;First Responder的视图控制器-&gt;父容器-&gt;父容器的视图控制器-&gt;UIWindow-&gt;UIApplication-&gt;应用程序的委托对象 一般来说，如果已经经过完整的传播过程依然没有被处理，那么该事件就会被丢弃，上面响应者链的任何响应者处理该事件，该事件就会停止传播，如果某个响应者截获了某个事件，那么该响应者要根据条件决定是否处理该事件，如果处理不掉，则需要在处理方法中手动传递该事件到下一个响应者： -(void)handleTapEvent:(UIEvent *)event { if (condition) { //***; } else { [self.nextResponder handleTapEvent:event] } }; 响应触碰方法如果希望自定义控件可以响应用户的触碰事件，则可以通过UIResponser的如下4个方法来实现： -touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event; -touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event; -touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event; -touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event; 使用手势处理器(UIGestureRecogniser)手势处理器有如下子类:UITap/Pinch/Rotation/Swipe/Pan/LongPressGestureRecogniser 手势处理器有如下方法和属性: -locationInView:(UIView *)view; -locationOfTouch:(NSUInteger)touchIndex inView:(UIView *)view; -numberOfTouches:; -view 激发该手势的UI控件; -enabled 该手势处理器是否可用; -state 该手势所处的状态; -userInteractionEnabled; -multiTouchEnabled; UITapGestureRecogniser 还提供了两个属性： -numberOfTapsRequired;指定该手势处理器只处理几次触碰事件 -numberOfTouchesRequired;指定该手势只处理几个手指的触碰事件 UIPinchGestureRecogniser 定义了如下两个信息来获取捏合相关信息 -scale:捏合比例; -velocity;捏合速度 UIRotationGestureRecogniser 有两个属性来获取旋转相关信息: -rotation:旋转角度 -velocity;旋转速度 UISwipeGestureRecogniser 两个属性: direction 方向枚举 numberOfTouchesRequired 几个指头 UIPanGestureRecogniser 两个属性: max/minimumNumberOfTouches: 最多/最少支持几个指头拖动 两个方法 -translationInView:在指定控件上的位移 -velocityInView:在指定控件上的速度 UILongPressGestureRecogniser 三个属性： minimumPressDuration:按下多少秒后才会触发，默认0.5 numberOfTouchesRequired：指定必须使用几个手指 allowableMovement:指定允许移动的最大距离 创建和使用自定义手势处理器 创建继承UIGestureRecogniser的子类 重写4个方法，通过这些方法识别用户的手势，当用户手指划过的痕迹符合要求时，将该手势的state设为UIGestureRecogniserStateEnded即可 国际化Internationalisation简称I18N,本地化Localisation简称L10N iOS应用国际化的基础iOS应用的国际化得靠OC来实现，而OC的国际化主要通过NSLocale和NSLocalisedString(NSString *key, NSString *comment)来实现 通过Finder打开任意一个项目，即可在项目文件结构下看到如下子文件夹：en.lproj/Base.lproj/zh-Hans.lproj等，他们是本地化文件夹，其命名规范有两种形式：language-country.lproj和language.lproj 国际化界面设计文件可以对xib，storyboard界面设计文件提供国际化支持，有两种方式 Interface Builder Cocoa Touch Storyboard：表示系统要对整个界面设计文件进行国际化支持 Localisable Strings：表明只对界面设计文件上的字符内容进行国际化 国际化应用程序的显示名称应用程序的显示名称可通过XXX-Info.plist文件里边的key值CFBundleDisplayName来设置，而InfoPlist.strings文件就是控制对XXX-Info.plist国际化的，所以在InfoPlist.strings(Chinese)文件中添加一行代码即可 “CFBundleDisplayName” = “国际化测试”; 其他的字段控制同理 国际化图片应用程序的图片国际化可通过如下方式： 添加一张图片到工程，找到图片的文件导航器下的Localization按钮并点击，弹出国际化列表框并选择后即可将图片移动到对应的国际化文件夹中去 同样的方式添加第二张图片即可 国际化文本国际化文本可通过两种方式： File-&gt;New-&gt;Resource-&gt;String File-&gt;Localisable.strings-&gt;放入不同的国际化子目录下 启动OS X Terminal窗口，cd到iOS项目所在目录，执行命令：genstrings *.m，该命令可以提供所有.m文件中通过NSLocalizedString()函数用过的国际化消息key，此时生成资源文件并将这些key添加到资源文件中 iOS的数据存储与IO应用程序沙盒iOS应用程序只能在系统为该应用所分配的文件区域下读、写文件，这个文件区域就被称为该应用的沙盒，这种机制保证每个应用程序只能访问本沙盒内的数据，避免与其他应用形成冲突。 任何应用程序的文件夹都有如下文件结构： Document:除了NSUserDefaults的首选项设置以外，应用程序的数据、文件都保存在该目录下 Library:基于NSUserDefaults的首选项参数保存在Library/Preferences目录下 tmp:该目录供应用程序存储临时文件，当iOS同步执行时，iTunes不会备份tmp目录下的文件 获取Document目录：其中NSUserDomainMask代表仅搜索应用程序沙盒 NSString *documentPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES) objectAtIndex:0]; 获取tmp目录：NSTemporaryDirectory(); 应用程序参数与用户默认设置创建Settings Bundle：File-&gt;New-&gt;File-&gt;Resource-&gt;Setting Bundle，其中包括一个en.lproj文件夹和一个Root.plist文件，en.lproj负责国际化，Root.plist文件负责界面设计与键值保存，里边有Preferences Items与Strings Filename两大项，String Filename的作用是告诉系统到*.lproj中去找Root.plist文件作为国际化资源文件，PreferencesItems里边包括多个item,每个Item用于设置一个应用程序参数 每个Item通常可指定如下4个通用项目： Title，参数的显示标题 Type，支持一下几个属性值 a,PSTextFieldSpecifier,指定应用程序参数是一个文本框，可由用户输入该参数的值 b,PSTitleValueSpecifier,指定应用程序参数与显示标题相同 c,PSToggleSwitchSpecifier,指定应用程序参数表现为UISwitch控件，通过此可设置参数为YES或NO d,PSSliderSpecifier,指定参数表现为UISlider控件，其参数是一个浮点型 e,PSMultiValueSpecifier,指定参数为一个可供选择的列表，其参数是列表中的一个值 f,PSGroupSpecifier,指定该参数是一个分组 g,PSChildPanSpecifier,指定参数是一个子视图，系统会打开新的设置页面，必须要重新指定一个plist key，指定保存应用程序参数的key DefaultValue，用于指定参数的默认值 通过Settings Bundle设置的应用参数，还可以通过NSUserDefaults进行读取、保存，NSUserDefaults是一个单例类，每个程序只有一个NSUserDefaults对象，获得方法如下： NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults]; -xxxForKey:(NSString *)key: -setXxx:xxx forKey:(NSString *)key; -synchronise 属性列表对于只需要保存简单数据的应用而言，使用属性列表是一个不错的选择 NSArray、NSDictionary对象都提供了writeToFile:(NSString *)filePath atomically:(BOOL)flag方法，该方法可以把NSArray和NSDictionary包含的数据写入属性文件，当恢复这些数据时，只要调用NSArray或NSDictionary的xxxWithContentsOfFile:(NSString *)filePath方法执行初始化即可，但需要注意，如果NSArray或NSDictionary中保存了其他类型的或自定义类型的对象，则不能用writeToFile执行保存 对象归档和原生I/O API（详情参照上册第八章内容）如果需要保存一个自定义类的实例，则可让该类实现NSCoding协议，并实现该协议中定义的-(void)encodeWithCoder:(NSCoder *)coder、-(id)initWithCoder:(NSCoder *)coder两个方法，接下来即可使用NSKeyedArchiver进行归档，当程序需要恢复该对象时，可使用NSKeyedUnarchiver进行恢复 使用SQLite3数据库SQLite是一个嵌入式的轻量级的数据库，只是一个文件，不需要服务器进程，iOS的SQLite编程并没有使用OC面向对象的语法，而是使用了原生的C函数库，操作之前必须先做两个操作 增加函数库libsqlite3.dylib 在类中导入#import &lt;sqlite3.h&gt; 接着就可以使用SQLite的API执行数据库访问了 -int sqlite3_open(const char *fileName,sqlite3 **ppDb) 打开与fileName文件关联的数据库连接，并让ppDb参数引用被打开的数据库连接 -int sqlite3_exec(sqlite3 *db,const char *sql, int(*callback)(void *,int,char**,char**),void*,char**err) 执行没有任何返回的sql语句，sqlite3代表数据库，sql代表要执行的sql语句，callback表示回调函数，第四个参数表示传给回调函数的参数，第五个参数封装sql语句出错时的信息 -int sqlite3_prepare/_v2(sqlite3*db,const char*zSql,int nByte,sqlite3_stmt**ppStmt,const char**pTail) 对SQL语句预编译，db表示打开的数据库连接，zSql表示SQL语句，nByte表示SQL语句的最大长度，ppStmt表示预编译SQL产生的sqlite3_stmt,pTail表示sql中未使用的部分 -int sqlite3_bind_xxx(sqlite3_stmt*,int,NSString*) 用于为sqlite3_stmt中的占位符参数绑定参数值 -int sqlite3_step(sqlite3_stmt*) 用于执行sqlite3_stmt，如果返回SQLITE_DONE表示sqlite3_stmt执行成功，如果返回SQLITE_ROW,表明sqlite3_stmt正在逐行提取查询结果集 -int sqlite3_column_xxx(sqlite3_stmt*, int iCol) 返回当前的行指定列的数据 -int sqlite3_reset(sqlite3_stmt*) 销毁sqlite3_stmt，并回收资源 -int sqlite3_close(sqlite3 *db) 关闭数据库链接，关闭前需释放资源，否则返回SQLITE_BUSY Mac OS X系统自带了sqlite3工具，它是一个简单的SQLite数据库管理工具，类似于MySQL提供的命令行窗口，有些时候，开发者可以利用该工具来查询，管理数据库 sqlite3 myWords.db .databases查看当前数据库 .tables查看当前数据库的数据表 .help查看sqlite3支持的命令 也可以使用SQLite Manager等其他可视化窗体SQLITE数据库管理器 使用Core Data框架iOS提供的Core Data框架，其本质就是一个ORM框架，它允许开发者以面向对象的方式持久化操作SQLite Core Data应用中的核心API有如下几个： 托管对象模型(NSManagedObjectModel) 该对象负责管理整个应用的所有实体以及实体之间的关联关系，当开发者使用Xcode的图形界面设计了实体与实体的关联关系之后，需要使用该对象来加载、管理应用的托管对象模型 持久化存储协调器(NSPersistentStoreCoordinator) 负责管理底层的存储文件 托管对象上下文(NSManagedObjectContext) Core Data的核心对象，应用程序对实体所做的增删改查操作都需要通过该对象来完成 实体描述(NSEntityDescription)该对象代表了关于某个实体的描述信息，是对该对象的抽象 抓取请求(NSFetchRequest)该对象封装了查询实体的请求，包括程序需要查询那些实体，查询条件、排序规则等 File-&gt;New-&gt;File-&gt;Core Data-&gt;Data Model即可为项目创建一个实体模型文件 Editor-&gt;Create NSManagedObject Subclass创建实体模型文件对应的NSManagedObject的子类 NSURL *modelURL = [[NSBundle mainBundle] URLForResource:@“xx” withExtension:@“momd”]; _managedObjectModel = [[NSManagedObjectModel alloc] initWithContentsOfURL:modelURL]; _persistentStoreCoordinator = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel: _managedObjectModel]; _managedObjectContext = [[NSManagedObjectContext alloc] init]; [_managedObjectContent setPersistentStoreCoordinator: _persistentStoreCoordinator]; 打开Xcode项目导航面板中的xcdatamodeld文件，打开实体模型开始编辑，Xcode将会显示如下属性 实体(属性，关联关系，抓取属性) 抓取请求 配置 添加实体 FKEvent *event = [NSEntityDescription insertNewObjectForEntityName:@“FKEvent” inManagedObjectContext:_managedObjectContext] [_managedObjectContext save] 删除实体 [_managedObjectContext deleteObject:event] 修改实体 [_managedObjectContext save] 查询实体 NSFetchRequest *request = [[NSFetchRequest alloc] init] NSEntityDescription *entity = [[NSEntityDescription entityForName:@“FKEvent” inManagedObjectContext:_managedObjectContext] request.entity = entity; request.predicate = [NSPredicate predicateWithFormat:@“”] NSArray *result = [[_managedObjectContext executeFetchRequest:request error:&amp;error] mutableCopy] Core Data除了可用于管理单独的实体之外，还可用于管理实体与实体之间的关联关系，这些关联关系同样可通过.xcdatamodeld文件设计，接下来Core Data应用完全可以利用实体之间的关联执行删除、查找等 Core Data提供的关联关系有一对一，一对多，多对多，相互关联的实体支持如下选项： 1，No Action,当主实体被删除时，关联的目标实体没有任何改变 2，Nullify，当主实体被删除时，关联的目标实体的外键值被设为null 3，Cascade，当主实体被删除时，关联的目标实体也被级联删除 4，Deny，当主实体被删除时，如果关联的目标实体依然存在，则删除失败 多媒体应用开发音频和视频的播放使用System Sound Services播放音效，需要AudioToolbox框架的支持 #import &lt;AudioToolbox/AudioToolbox.h&gt; SystemSoundID crash; NSURL *crashUrl = [[NSBundle mainBundle] URLForResource:@“crash” withExtension:@“wav”]; AudioServicesCreateSystemSoundID((_bridge CFURLRef)crashUrl, &amp;crash); static void completionCallback(SystemSoundID Sid) { AudioServicesPlaySystemSound(Sid) }; AudioServicesAddSystemSoundCompletion(crash,NULL,NULL,(void*)completionCallback,NULL); AudioServicesPlaySystemSound(crash)/AudioServicesPlayAlertSound(crash)(自带震动) 使用System Sound Service播放只是适合播放一些很小的提示或警告音频，并且有如下的限制： 声音长度不能超过30秒 声音文件必须是PCM或者IMA4格式 打包成.caf/.aif/.wav的文件 不能控制播放进度 调用后立即播放声音 没有循环播放和立体声控制 使用AVAudioPlayer播放音乐 AVAudioPlayer是一个属于AVFoundation.framework的类，它的作用类似于一个功能强大播放器，它支持广泛的音频格式，有如下方法 -play: 开始或恢复播放,如果该音频还没有准备好，程序会隐式先执行prepareToPlay方法 -playAtTime: 在指定时间开始或恢复播放 -pause 暂停 -stop 停止 prepareToPlay 准备开始播放 -initWithContentsOfURL:error -initWithData:error 初始化AVAudioPlayer对象 还支持其他的一些属性或方法，如： playing 是否正在播放 volume 音量增益 pan 立体声平衡，左音道为负，右音道为正 rate 播放速率 enableRate 是否允许修改速率 numberOfLoops 播放的循环次数 delegate 设置 AVAudioPlayer 代理对象 numberOfChannels 音频的声道数目 duration 音频的持续时间 currentTime 音频的播放点 deviceCurrentTime 设备播放音频的时间 url 音频的URL data 音频的数据 其中，delegate的 回调有： -(void)audioPlayerDidFinishPlaying:(AVAudioPlayer *)player{} -(void)audioPlayerBeginInterruption:(AVAudioPlayer *)player{} 使用MPMediaPickerController选择系统音乐 MPMediaPickerController *mediaPickerController = [MPMediaPickerController alloc] initWithMediaTypes:MPMediaTypeAnyAudio/Music/Podcast/AudioBook/AudioITunesU] allowPickingMultipleItems/showsCloudItems/delegate/mediaTypes/prompt -mediaPicker:didPickMediaItems: 使用MPMusicPlayerController播放音乐 //注意：前者是与iPod播放器内的信息相关，退出后不会停止播放，后者是内部播放器，退出后会停止 MPMusicPlayerController *musicPlayer = [MPMusicPlayerController iPodMusicPlayer/applicationMusicPlayer] musicPlayer.currentPlaybackTime 设置音乐播放时间点 currentPlaybackRate 设置音乐播放速率 nowPlayingItem playbackState 当前播放状态(播放/停止/暂停/快进/快退) repeatMode/shuffleMode随机模式/volume musicPlayer play/pause/stop/beginSeekingForward/beginSeekingBackward/endSeeking/skipToNextItem/skipToBegin/skipToPreviousItem 使用MPMoviePlayerController播放视频 MPMoviePlayerController与MPMusicPlayerController相似，它们都是一个简单的播放器，而且都实现了MPMediaPlayback协议，因此都有相同的play,stop,pause等播放方法，MPMoviePlayerController播放器播放的视频需要被显示出来，该对象的view属性代表它的播放器视图 MPMoviePlayerController *moviePlayer = [MPMoviePlayerController moviePlayer] moviePlayer.contentURL/movieMediaTypes/allowsAirPlay airPlayVideoActive 是否处于无线播放模式 nutralSize/fullScreen/scalingMode/controlStyle控制条风格 duration/playableDuration 已下载部分的持续时间 使用AVAudioRecorder录制音频AVAudioRecorder与AVAudioPlayer类似，都属于AVFoundation.framework的类，AVAudioRecord相当于一个录音器 -prepareToRecord/-record/recordAtTime: recordAtTime:forDuration:/pause/stop/prepareToPlay -initWithURL:settings:error:指定将录制的音频存入URL对应的音频文件，Settings参数是一个NSDictionary对象，包含大量key-value对，用于设置录制音频的相关信息，其中key必须是AVFormatIDKey(格式),AVSampleRateKey(采样率),AVNumberOfChannelsKey(声道数),AVLinearPCMBitDepthKey(样点的位数),AVLinearPCMIsBigEndianKey(高位优先) -(void)audioRecorderBeginInterruption:(AVAudioRecorder *)recorder{} -(void)audioRecorderDidFinishRecording:(AVAudioRecorder *)recorder{} 拍照和录制视频使用UIImagePickerController拍照和录制视频 UIImagePickerController是一个功能强大的视图控制器类，它继承了UINavigationController，因此完全可以作为视图控制器使用，它有如下属性 sourceType，控制是选取相册中的图片还是调用摄像头，UIImagePickerControllerSourceTypeLibrary/Camera allowsEditing，控制拍摄的照片是否允许编辑 mediaTypes，是一个NSArray值，录视频时控制它只支持哪些类型的多媒体数据，比如kUTTypeImage/Movie/Video videoQuality，设置录制视频的质量UIImagePickerControllerQualityTypeHigh/Low videoMaximumDuration，录视频时的最大录制时间 showCameraControls，是否显示拍摄按钮等控件 cameraViewTransform，对预览画面进行变换的变换矩形 cameraDevice，控制设备使用哪个摄像头 UIImagePickerControllerCameraDeviceRear/Front cameraCaptureMode，拍摄模式是拍照还是录制 cameraFlashMode，控制闪光灯模式 delegate，用于为UIImagePickerController设置委托对象 -takePicture/-startVideoCapture/-stopVideoCapture 使用AVFoundation拍照和录制视频 使用UIImagePickerController拍照和录制视频虽然简单，但由于这种方式完全依赖于iOS的控制器，因此灵活性不足 AVFoundation提供了一些类来完成拍照和视频的录制 AVCaptureDevice:该对象代表物理输入设备，包括摄像头和麦克风，开发者可以通过该对象来配置底层物理设备的属性，如摄像头的对焦模式、闪光灯模式、曝光补偿、白平衡等，在配置前，必须先调用lockForConfiguration执行锁定，配置完后调用unlockForConfiguration方法解锁，可以通过类的devices/defaultDeviceWithMediaType:/devicesWithMediaType:AVMediaTypeVideo/Audio AVCaptureDeviceInput/AVCaptureScreenInput:AVCaptureInput的子类，会被添加给AVCaptureSession管理 AVCaptureSession:该对象负责把AVCaptureDevice捕捉到的视频或声音数据输出到输出设备中，不管是实时录制还是离线录制，都必须创建AVCaptureSession对象，并为对象添加输入设备(负责捕捉数据)和输出端(负责接收数据) AVCaptureAudioData/AudioPreview/File/StillImage/VideoDataOutput都是AVCaptureOutput的子类，用于接收各种数据，该对象也会被添加给AVCaptureSession管理 AVCaptureAudio/MovieFileOutput:都是AVCaptureFileOutput的子类，分别代表输出到音频文件、电影文件的输出端 AVCaptureVideoPreviewLayer:该对象是CALayer的子类，只要创建它的实例，并为它设置AVCaptureSession就可以非常方便的用它来实现拍摄预览 AVCaptureDevice *device = [[AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeMovie]; AVCaptureDeviceInput *input = [AVCaptureDeviceInput deviceInputWithDevice:device error:&amp;e]; AVCaptureSession *session = [[AVCaptureSession alloc] init]; [session addInput:input]; AVCaptureStillImageOutput *output = [[AVCaptureStillImageOutput alloc] init]; [session addOutput:output]; NSData *imageData = [AVCaptureStillImageOutput jpegStillImageNSDataRepresentation:imageDataSampleBuffer]; AVCaptureVideoPreviewLayer *layer = [AVCaptureVideoPreviewLayer layerWithSession:session]; layer.frame = CGRectMake(***); [self.view.layer addSublayer:layer]; 使用AVFoundation生成视频缩略图 AVURLAsset：该类是AVAsset的子类，AVAsset类专门用于获取多媒体的相关信息，包括多媒体画面、声音等信息 AVAssetImageGenerator:该类专门用于截取视频指定帧的画面 AVURLAsset *asset = [[AVURLAsset alloc] initWithURL:videoURL options:nil]; AVAssetImageGenerator *generator = [[AVAssetImageGenerator alloc] initWithAsset:asset]; CGImageRef image = [generator copyCGImageAtTime:time actualTime:&amp;actualTime error:&amp;error]; //获取指定时间点的视频截图，time用于指定获取哪个时间点的视频截图，actualTime用于获取实际截图位于哪个时间点 CMTime是专门用于表示电影时间的结构体，通常有两个函数来创建 CMTimeMake(int64_t value, int32_t timescale) value表示第几帧图，timescale表示每秒的帧数，因此实际截取的时间点是value/timescale CMTimeMakeWithSeconds(Float64 seconds,int32_t preferredTimeScale)seconds 代表第几秒，preferredTimeScale表示每秒的帧数 管理手机使用AddressBook管理联系人iPhone手机通常都有一个自带的Contacts应用，该应用用于管理用户的联系人信息，通常Contacts应用管理的联系人数据将保持在自己的应用程序沙盒中，其他应用不能访问它们，但有些时候其他应用程序需要访问这些数据，所以iOS系统提供了如下两个框架： AddressBook.framework，通过该框架提供的系列函数，开发者可以开发程序界面对手机中的联系人信息进行增删改查 AddressBookUI.framework，该框架以AddressBook.framework为基础，包含4个视图控制器类以及相应的委托协议 AddressBook框架主要由如下4组API组成 1，ABAddressBook，实例代表地址簿对象，该对象提供了一个通用的编程接口，允许开发者无须理会底层，直接面向ABAddressBook(ABAddressBookRef)编程，里边的数据包括联系人和组，并且是多对多的关系 -(ABAddressBookRef)ABAddressBookCreateWithOptions(CFDictionaryRef options,CFErrorRef*error) -(ABAuthorizationStatus)ABAddressBookGetAuthorisationStatus(void)获取iOS应用访问地址簿的授权状态 -(void)ABAddressBookRequestAccessWithCompletion(ABAddressBookRef addressBook,ABAddressBookRequestAccessCompletionHandler completion)发送访问请求，如果同意或拒绝会执行代码块 -(bool)ABAddressBookHasUnsavedChanges(ABAddressBookRef addressBook)判断AddressBook是否未保存修改 -(bool)ABAddressBookSave/Revert(ABAddressBookRef addressBook, CFErrorRef*error)保存/撤销修改 -(bool)ABAddressBookAdd/RemoveRecord(ABAddressBookRef addBook,ABRecordRef record,CFError*e) -(void)ABAddressBookRegister/UnregisterExternalChangeCallback(ABAddressBookRef addressBook,ABExternalChangeCallback callback,void *context)，为AddressBook注册/移除一个监听改变的代码块 2，ABRecord，代表一个通用的记录对象，每个记录在底层数据库中都有一个ID，可以通过ABRecordGetRecordID()函数获取指定记录的ID，此记录可以是一个联系人，也可以是一个组，可以通过ABRecordGetRecordType()获取该记录的类型,ABPersonType(0)和ABGroupType(1)，实际编程时，总是面向ABRecord(ABRecordRef)编程 -(bool)ABRecordSetValue(ABRecordRef record,ABPropertyID property,CFTypeRef value,CFErrorRef *error)将record记录中的property属性设置为value值，其中property必须是由ABPerson，ABGroup定义的常量，用于表示预置的各种属性，而且不同的属性需要的属性值类型不同，如kABPersonFirstNameProperty(string),kABPersonPhoneProperty(ABMutableMultiValue) -(CFTypeRef)ABRecordCopyValue(ABRecordRef record,ABPropertyId property)返回record记录中property属性的值 -(bool)ABRecordRemoveValue(ABRecordRef record,ABPropertyID property,CFErrorRef*error)删除record记录中property属性的值，返回删除是否成功 -(CFStringRef)ABRecordCopyCompositeName(ABRecordRef record)返回该record记录中复合姓、名、组织信息 -(ABRecordID/ABRecordType)ABRecordGetRecordID/Type(ABRecordRef record) 3，ABPerson，代表联系人信息4，ABGroup，代表分组 ABMutableMultiValue相当于一个集合，每个对象都可以添加多个电话号码，多个电子邮件或多个住址，然后将该对象设置为ABRecord的一个属性，这样就可以为该记录对应的联系人设置多个值，其提供了如下常用函数 -(ABMutableMultiValueRef)ABMultiValueCreateMutable(ABPropertyType type)创建一个管理type类型的属性值的对象 -(bool)ABMultiValueAddValueAndLabel(ABMutableMultiValueRef multiValue,CFTypeRef value,CFStringRef label,ABMultiValueIdentifier*outIdentifier)向multiValue中添加一个属性值 -(bool)ABMultiValueReplaceValueAtIndex(ABMutableMultiValueRef multiValue,CFTypeRef value,CFIndex index)将multiValue中index索引处的属性替换为新的value值 -(bool)ABMultiValueReplaceLabelAtIndex(ABMutableMultiValueRef multiValue,CFStringRef label,CFIndex index)将multiValue中index索引处的出行标签替换为新的label值 -(bool)ABMultiValueInsertValueAndLabelAtIndex(ABMutableMultiValueRef multiValue,CFTypeRef value,CFStringRef label,CFIndex index,ABMultiValueIdentifier*outIdentifier)向multiValue的index索引处插入一个属性值，value代表属性值，label代表属性值的标签 -(bool)ABMultiValueRemoveValueAndLabelAtIndex(ABMutableMultiValueRef multiValue,CFIndex index)删除multiValue中index索引处的属性值 从iOS9开始，AddressBook框架被CNContact框架替代，因为AddressBook框架调用的C函数，没有基于OC的API，非常难用，所以苹果引入了CNContact框架，CNContact的框架的核心类是CNContact，代表一个联系人，它包括很多属性，常用的有identifier，contactType，namePrefix，imageData，phoneNumbers，emailAddresses等 使用AddressBookUI管理联系人iOS用AddressBook管理联系人非常繁琐，要注意很多细节，如果应用程序对界面的要求不高，可直接使用AddressBookUI框架，它为iOS提供了如下特殊的视图控制器： 1，ABPersonViewController用于显示指定联系人数据的视图控制器 -personViewController:shouldPerformDefaultActionForPerson:property:identifier:方法，当用户选中某个联系人的某个属性时激发该方法，如果希望激活默认动作返回YES，否则返回NO 2，ABNewPersonViewController用于新增联系人的视图控制器 -newPersonViewController:didCompleteWithNewPerson:点击取消或完成时激活该方法 3，ABPeoplePickerViewController用于让某个用户选择某个联系人的视图控制器 —peoplePickerNavigationController:shouldContinueAfterSelectingPerson:当用户选中某个联系人激活该方法，如果希望激活默认动作返回YES，否则返回NO -peoplePickerNavigationController:shouldContinueAfterSelectionPerson:property:identifier:当用户选中某个联系人的某个属性后激活该方法，如果希望激活默认动作返回YES，否则返回NO -peoplePickerNavigationController:didCancel:当用户取消选择时激活该方法 4，ABUnknownPersonViewController用于通过一组联系人信息来添加联系人记录 -unknownPersonViewController:didResolveToPerson:当用户将未知联系人数据添加为新的联系人时激活该方法 四个视图控制器包含的常用属性有： -displayedPerson:/-displayedProperties:/-addressBook: -allowActions:(设置是否在联系人界面显示动作按钮，比如打电话，发短信) -allowsEditing:/-allowsAddingToAddressBook 一般情况下，四个视图控制器最好被UINavigationController包裹一下才能加入项目中 从iOS9开始，CNContactUI框架已替换AddressBookUI框架，此框架主要包括两个类 CNContactPickerViewController，选择通讯录，有相应的委托类CNContactPickerDelegate: contactPickerDidCancel: contactPicker:didSelectContact: contactPicker:didSelectContactProperty: contactPicker:didSelectContacts: contactPicker:didSelectContactProperties: CNContactViewController，显示通讯录的某条记录，有相应的委托类CNContactViewControllerDelegate: contactViewController:shouldPerformDefaultActionForContactProperty: contactViewController:didCompleteWithContact: 使用UIApplication打电话、发短信如果应用希望直接启用iOS系统内置的打电话、发短信、发邮件、浏览网页应用程序，则可调用UIApplication的openURL方法打开特定URL，这个方法将会根据NSURL的前缀不同而启动对应的应用程序，如sms:(//)\tel:(//)\mailto:\http:(//) 使用MFMessageComposeViewController发送短信+canSendText/+canSendAttachments/+canSendSubject/-recipients(NSArray值，多个收件人号码)/-subject/-body/-attachment/-messageComposeDelegate -(void)messageComposeViewController:(MFMessageComposeViewController*)controller didFinishWithResult:(MessageComposeResult)result(MFMessageComposeResultCancelled/Sent/Failed); 使用MFMailComposeViewController发送邮件+canSendMail/-toRecipients(NSArray值，多个收件人地址)/-ccRecipients(抄送)/-bccRecipients(秘密抄送)/-setMessageBody:isHTML:(邮件正文)/-addAttachmentData:mimeType:fileName:(附件)/mailComposeDelegate -(void)mailComposeController:didFinishWithResult:error:(MFMailComposeResultCancelled/Sent/Failed); 加速剂与陀螺仪iOS支持的加速计、陀螺仪和磁感应基于代码方式获取加速度、陀螺仪和磁感应数据 CMMotionManage *manager = [[CMMotionManager alloc] init]; if(manager.accelerometerAvailable/manager.gyroAvailable/magnetometerAvailable) { manager.accelerometer/gyro/magnetometerUpdateInterval = 0.1; manager.startAccelerometer/Gyro/MagnetometerUpdatesToQueue:[[NSOperationQueue alloc] init] withHandler:^(CMAccelerometer/CMGyro/CMMagnetometerData *data, NSError *error) { if(error) { manager.stopAccelerometer/Gyro/MagnetometerUpdates]; } else { NSLog(data.acceleration.x/y/z,rotationRate.x/y/z,magneticField.x/y/z); } } } 主动请求获取加速度、陀螺仪和磁感应数据 if(manager.accelerometerAvailable/manager.gyroAvailable/magnetometerAvailable) { manager.startAccelerometer/Gyro/MagnetometerUpdates; } NSTimer *updateTimer = [NSTimer scheduledTimerWithTimeInterval:0.1 target:self selector:@selector(updateDisplay) userInfo:nil repeats:YES]; NSLog(manager.accelerometer/gyro/magnetometerData.acceleration.x/y/z,rotationRate.x/y/z,magneticField.x/y/z); 感知设备移动除了获取加速度、陀螺仪和磁感应数据外，CMMotionManager还可以用于感知设备移动数据，方法无任何差别，关键词为DeviceMotion，其属性有 attitude，该属性返回该设备的方位信息，是一个CMAttitude类型的对象，包含roll，pitch，yaw3个欧拉角的值，通过这三个值即可获取该设备的空间方位 roll:表示手机左侧或右侧翘起的角度，当手机绕着Y轴倾斜时，该值发生变化 pitch:表示手机顶部或尾部翘起的角度，当手机绕着X轴倾斜时，该值发生变化 yaw:表示手机顶部转过的夹角，当手机绕着Z轴倾斜时，该值发生变化 rotationRate，返回原始的陀螺仪信息，该属性是CMRotationRate结构体变量，值基本等同于陀螺仪数据 gravity，返回地球重力对该设备在X、Y、Z轴上施加的重力加速度 userAcceleration，返回用户外力对该设备在X、Y、Z轴上施加的重力加速度 magneticField，返回校准后的磁场信息，值是一个CMCalibratedMagneticField结构体变量，变量包括field和accuracy两个字段，其中field代表X、Y、Z轴上的磁场强度，accuracy表示磁场强度的精度 iOS7新增的计步器if([CMStepCounter isStepCountingAvailable]) { stepCounter = [[CMStepCounter alloc] init]; [stepCounter startStepCountingUpdatesToQueue:[[NSOperationQueue alloc] init] updateOn:5 withHandler:^(NSInteger numberOfSteps,NSDate *timeStamp,NSError *error) { NSLog(numberOfSteps);//updateOn参数表示设置每行走多少步执行一次代码块 }]; [stepCounter queryStepCountStartingFrom:(NSDate *) to:(NSDate *) toQueue:(NSOperationQueue *) withHandler:^() } iOS7新增的CMMotionActivityManagerCMMotionActivityManager可以返回用户的运动信息，反应用户当前处于步行、跑步、驾驶车辆或处于静止状态 if(CMMotionActivityManager.isActivityAvailable) { [motionActivityManager startActivityUpdatesToQueue:queue withHandler:^(CMMotionActivity *activity) { activity.stationary(是否静止)/.walking/.running/.automotive(驾车)/unknown/startDate(开始日期)/confidence(可信度) }] [motionActivityManager queryActivityStartingFromDate:toDate:toQueue:withHandler:]; } 多线程线程概述所有运行中的任务通常对应一个进程(process)，当一个程序进入内存运行后，即变成一个进程，进程是处于运行过程中的程序，并且具有一定的独立功能，进程是系统进行资源分配和调度的一个独立单位，一般而言，进程包含如下3个特征： 独立性：进程是系统中独立存在的实体，它可以拥有自己独立的资源，每一个进程都有自己私有的地址空间 动态性：进程与程序的区别在于，程序只是一个静态的指令集合，而进程是一个正在系统中活动的指令集和 并发性：多个进程可以在单个处理器上并发执行，多个进程之间不会相互影响 并发(concurrency)和并行性(parallel)是两个概念，并行指在同一时刻，有多条指令在多个处理器上同时执行，并发指在同一时刻，只能有一条指令执行，但多个进程指令被快速轮换执行，使得宏观上具有多个进程同时执行的效果 多线程则扩展了多进程的概念，使得同一个进程可以同时并发处理多个任务，线程(Thread)也被称作轻量级进程(Lightweight Process)，线程是进程的执行单元，但程序被初始化后，主线程就被创建了，一般也只有一个主线程，我们也可以在进程中创建其他线程 线程是进程的组成部分，一个进程可以拥有多个线程，一个线程必须只有一个父进程，线程拥有自己的堆栈，变量等，但不再独自拥有系统资源，它与父进程的其它线程共享该进程所拥有的全部资源，因此变成更加方便，但必须更加小心，确保线程不会妨碍其它线程 操作系统可以同时执行多个任务，每个任务就是进程，进程可以同时执行多个任务，每个任务就是线程 iOS大致提供了如下3中多线程编程的技术： 使用NSThread实现多线程 使用NSOperation和NSOperationQueue实现多线程 使用GCD(Grand Central Dispatch)实现多线程 使用NSThread实现多线程NSThread *thread=[[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil]; [thread start]; [NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil]; 上面的方式的本质都是将target对象的selector方法转换为线程执行体，其中selector方法最多可以接受一个参数，而arg就代表传给selector方法的参数 [NSThread currentThread][NSThread setName:@“”];-isExecuting/-isFinished; 线程的状态：线程不可能一直霸占着CPU独自运行，所以CPU需要在多个线程之间进行切换，线程状态也会多次在运行、就绪状态之间切换，当创建时处于新建状态，当调用了start方法之后，处于就绪状态，当系统开始调度资源执行时，处于运行状态 如果程序希望调用子线程的start方法后子线程立即开始执行，程序可以使用[NSThread sleepForTimeInterval:0.001] 当主线程结束时，其他线程不受任何影响，并不会随之结束，一旦子线程启动起来后，它就拥有和主线程相同的地位，不会受主线程影响 线程会以以下3种方式之一结束，结束后就处于死亡状态 线程执行完正常结束 执行过程中出现错误 exit方法主动结束 在主线程中调用[thread cancel];对应线程if(NSThread currentThread].isCancelled) {[NSThread exit];} 如果需要让正在执行的线程暂停一段时间，并进入阻塞状态，则可以调用NSThread类的sleepXxx类方法来完成 +(void)sleepUntilDate:(NSDate *)date; +(void)sleepForTimeInterval:(NSTimeInterval)ti; iOS不允许在非UI线程中修改UI控件属性，这是因为：加入程序允许任意子线程访问、修改UI控件的属性，这就需要对多个新线程的并发访问进行同步，否则，多个线程会破坏UI控件内部状态的完整性 如果需要在子线程中修改UI控件，则需要调用[self performSelectorOnMainThread:@selector(updateUI:) withObject:image waitUntilDone:YES]; 每个线程都具有一定的优先级，优先级高的线程获得较多的执行机会，反之亦然，每个子线程默认的优先级为0.5 +threadPriority/-threadPriority/+setThreadPriority/-setThreadPriority 线程同步与线程通信多线程编程很容易出现“错误情况”，这是由于系统的线程调度具有一定随机性。其中解决的办法之一是使用@synchronized实现线程同步 @synchronized(obj) { //此处的代码就是同步代码块 } 但是这些都是以降低程序的运行效率为代价的，为了减少，需采取： 不要对线程安全类的所有方法都进行同步，只对那些会改变竞争资源的方法进行同步 如果可变类有两种运行环境：单线程环境和多线程环境，则应该为可变类提供两种版本，线程不安全版本和线程安全版本 除了用synchronized保证线程同步外，还可以使用NSLock对象显式的加锁，释放锁 NSLock *lock = [[NSLock alloc] init]; [lock lock]; //同步代码块; [lock unlock]; 当线程在系统内运行，程序通常无法准确控制线程的轮换执行，但我们可以通过一些机制来保证线程协调运行，就是线程之间的通信 Foundation提供了一个NSCondition类来处理线程通信，NSCondition也实现了NSLocking协议，因此也可以调用lock、unlock来实现线性同步，除此之外，NSCondition可以让那些已经锁定NSCondition对象却无法继续执行的线程的线程释放NSCondition对象，也可以唤醒其他处于等待状态的线程，NSCondition提供了如下3个方法： -wait，该方法导致当前线程一直等待，直到其他线程调用该NSCondition的signal方法或broadcast方法来唤醒该线程 -signal，唤醒在此NSCondition对象上等待的任意一个线程 -broadcast，唤醒在此NSCondition对象上等待的所有线程 使用GCD实现多线程使用NSThread实现多线程比较复杂，需要程序员自己控制多线程的同步、多线程的并发，稍不留神，就会出现错误，为了简化开发，iOS提供了GCD来实现多线程，GCD的两个核心概念如下 队列：队列负责管理开发者提交的任务，GCD队列始终以先进先出FIFO的方式来处理队列，队列可以是串行的也可以是并发的，串行队列每次只处理一个任务，并发队列可以同时处理多个任务，队列的底层会维护一个线程池来处理用户提交的任务，线程池的任务就是管理队列，串行队列底层的线程池只需要维护一个线程即可，并发队列的底层则需要维护多个线程 任务：任务就是用户提交给队列的工作单元，这些任务将会提交给队列底层的线程池执行 对于打算使用GCD的开发者来说，只要遵守两个步骤即可： 创建队列，GCD的队列可分为两种，串行队列和并发队列 dispatch_queue_t dispatch_get_current_queue(void)获取当前线程所关联的队列 dispatch_queue_t dispatch_get_global_queue(long priority, unsigned long flags)根据指定的优先级、额外的标识来获取系统的全局并发队列 DISPATCH_QUEUE_PRIORITY_HIGH(2)/_DEFAULT(0)/_LOW(-2)/BACKGROUND() dispatch_queue_t dispatch_get_main_queue(void)获取应用主线程所关联的串行队列 dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)根据指定字符串标签创建队列，第二个参数可以控制创建串联还是并发队列DISPATCH_QUEUE_SERIAL/CONCURRENT,在没有启用ARC机制下，通过这种方式创建的队列需要调用dispatch_release()函数释放引用计数 const char* dispatch_queue_get_label(dispatch_queue_t queue); 将任务提交给队列，iOS提供了如下函数向队列提交任务，这些函数一般有两个版本，一个接收代码块作为参数的版本，一个接收函数作为参数的版本，其中接收函数作为参数的函数名后多了_f后缀，而且会多一个参数，用于向函数传入应用程序的上下文定义 void dispatch_async(dispatch_queue_t queue,dispatch_block_t block)异步方式提交代码块给队列 void dispatch_async_f(dispatch_queue_t queue,Void *context,dispatch_function_t function)函数 void dispatch_sync(dispatch_queue_t queue,dispatch_block_t block)同步方式提交代码块给队列 void dispatch_after(dispatch_time_t when,dispatch_queue_t queue,dispatch_block_t block)将代码块以异步方式提交给队列，队列将在when指定的时间点执行该代码块 void dispatch_apply(size_t iterations,dispatch_queue_t queue,void(^block)(size_t))将代码块以异步的方式提交给指定队列，该队列底层的线程池将会多次重复执行该代码块 void dispatch_once(dispatch_once_t *predicate,dispatch_block_t block)将代码块提交给指定队列，该队列底层的线程池控制应用的某个生命周期内仅执行该函数一次，predicate是一个指向dispatch_once_t变量的指针，该变量判断代码是否已经执行过，dispatch_once函数无须传入队列，这意味着系统将直接用主线程执行该函数提交的代码块 后台运行当应用进入后台时，系统会自动回调应用程序委托方法-applicationDidEnterBackground方法，应用可以在该方法中完成转入后台前需要做的准备工作，其中包括 释放所有可以释放的资源 保存用户数据或状态信息 应用进入后台时占用的内存越少，则越容易存活下来，因为iOS系统会优先终止那些占用内存大的应用 当应用转入后台后，不要在主线程中执行超过5秒的任务，如果应用进入后台花费了太多时间，应用可能会从内存中被删除，如果有耗时操作，正确的做法是：以applicationDidEnterBackground方法为平台，告诉系统进入后台还有更多的任务需要完成，从而向系统申请更多的后台时间，一般是10分钟 [[NSNotificationCentre defaultCentre] addObserver:self selector:@selector(enterBack:) name:UIApplicationDidEnterBackgroundNotification object:[UIApplication sharedApplication]; -(void)enterBack:(NSNotification *)notification { _block UIBackgroundTaskIdentifier backTaskId; UIApplication *app = [UIApplication sharedApplication]; backTaskId = [app beginBackgroundTaskWithExpirationHandler:^{ //出现异常或在10分钟内仍然没有完成任务 [app endBackgroundTask:backTaskId]; } dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ //耗时操作 [app endBackgroundTask:backTaskId]; }); } 使用NSOperation与NSOperationQueue实现多线程除了使用GCD实现多线程以外，NSOperation与NSOperationQueue也是一种简单的多线程实现方式 NSOperationQueue：代表一个FIFO的队列，它负责管理系统提交的多个NSOperation，它底层维护着一个线程池，会按顺序启动线程来执行提交给该队列的NSOperation任务 NSOperation：代表一个多线程任务，类似于Java中的Runnable，NSOperation有NSInvocationOperation子类和NSBlockOperation子类，NSOperation有两种使用方式，自定义实现NSOperation的子类或直接使用其已有子类 使用步骤： 创建NSOperationQueue队列，并为该队列设置相关属性 +currentQueue/+mainQueue -(void)addOperation:(NSOperation*)operation -(void)addOperations:(NSArray*)ops waitUntilFinished:(BOOL)wait;如果wait是yes，将会阻塞，一个一个加，如果是NO，全加然后直接返回 -operations:/-operationCount:/-cancelAllOperations:/-setSuspended: -waitUntilAllOperationsAreFinished:/-(NSInteger)maxConcurrentOperationCount:最大并发数量 创建NSOperation并添加到NSOperationQueue 创建NSOperation方式有两种： 直接使用其已有子类创建 NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(downloadImageFromURL) object:nil]; NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{//异步执行的代码块} FKDownImageOperation *operation = [[FKDownImageOperation alloc] initWithURL:url imageView:imageView]; [queue addOperation:operation]; 自定义NSOperation子类并重写其main方法]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[疯狂iOS上册第二部分]]></title>
    <url>%2F2014%2F04%2F25%2F%E7%96%AF%E7%8B%82iOS%E4%B8%8A%E5%86%8C-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[本篇主要接着《疯狂iOS讲义》上册的内容将第二部分的重点知识列举一下，包括:iOS应用的界面编程、管理iOS应用的运行、图形/图像和动画三大部分。 iOS应用的界面编程UI控件概述iOS的UI控件可以大致分为如下三类 活动控件：大部分活动控件都继承了UIControl基类，活动控件可以与用户交互，触发事件，如UIButton 静态控件：静态控件通常只继承了UIView类，并不继承UIControl，只显示应用状态，不执行任何操作，如UILabel 被动控件：可以接受用户操作，但不会激发任何IBAction方法，如UITextField 活动控件：与通过Interface Builder关联IBAction方法本质相同的是，程序也可通过代码为UIControl的子类控件绑定事件处理方法 -(void)addTarget:(id)target action:(SEL)action forControlEvents:(UIControlEvents)events; 活动控件有且仅有4种不同的状态 普通状态(UIControlStateNormal)，所有控件的默认状态 高亮(highlighted)，当控件需要突出显示时，处于高亮状态 禁用(disabled)，当UI控件被关闭时，处于禁用状态 选中状态(selected)，标示该控件已启用或被选中 触碰UIControl时如果需要定制其外观，可以通过重写UIControl控件的如下方法实现: - (BOOL)beginTrackingWithTouch:(UITouch *)touch withEvent:(nullable UIEvent *)event UIView包括的属性有 Mode:控制该UI控件内图片的对齐方式，常用的值有Centre/ScaleToFit/AspectFit/AspectFill Tag Interaction:User Interface Enable/MultiTouch Alpha Background/Drawing: Opaque 如果选择，则当alpha为1时，后边的控件不会再绘制 Hidden Clears Graphics Context 用于控制清除该控件所覆盖的区域 Clip Subviews 当子控件超出范围时是否裁剪子控件 Autoresize Subviews 该选项控制是否自动调整子控件大小 Stretching UILabel支持的属性 Text Color Font Alignment Lines Behaviour Enabled,Highlighted LineBreak 文字超出控件时，对前边/中间/尾部截断用…表示 Auto-shrink FixFontSize不改变字体大小/MinimumFontScale/MinimumFontSize Highlighted Shadow ShadowOffset 按钮(UIButton:UIControl:UIView)除可以设置UIControl和UIView的属性外，还可设置 Type Custom,System,Detail Disclosure(“i”图标),InfoLight/Dark(也是“i”图标)) State Default/Highlighted/Selected/Disabled Title Font Text color Shadow color Image 设置此属性时，标题会不起作用，默认自适应大小 Background 不影响标题，默认拉伸 Shadow Offset Line break Edge 以Content/Image/Title作为边界 Inset 文本框(UITextField:UIControl:UIView)除可以设置UIControl和UIView的属性外，还可设置 placeholder Border style clear button Min font size Adjust to fit 改变字号适应大小 Capitalisation correction 自动更正功能 spell checking keyboard type return key Auto-enable Return Key 勾选后默认禁用，当输入文字时才显示Return键 Secure Text Entry 密码框，将以黑点代替输入 多行文本框(UITextView:UIScrollView:UIView)UITextView和UITextField的不同 UITextView 是一个多行文本框 UITextView 没有继承UIControl控件，因此不能绑定IBAction事件 UITextView 继承了UIScrollView，具有scrollView的功能和行为 UIScrollView支持如下三个控制显示区域的属性 contentSize，CGSize类型的值，表示该ScrollView内容的完整宽度和高度 contentInset，UIEdgeInsets类型的值，表示需要显示的内容在上下左右四个方向的留白 contentOffset，CGPoint类型的值，表示可视区域相对于内容区域的滚动距离 UIScrollView还可以设置如下属性： Show Horizontal/Vertical Indicator Scrolling Enabled Paging Enabled 会自动分页，每次只能停留在固定页上 Direction Lock Enabled 锁定滑动方向，只能在第一次滑动的方向上水平或垂直滑动 Bounce Horizontal/Vertical 如果勾选时，手动拖动到边界会有弹性效果 Zoom 设置该UIScrollView的最小可缩放比例和最大可缩放比例 Touch Bounce zoom 对UIScrollView内容缩放超过最大最小时，会短暂超过限制而迅速回弹 Delays Content Touches 真正确定滚动意图的时候才会回调滚动处理方法 Cancellable content Touches 确定滚动意图后如果意图变化，则会调用cancelled方法 UITextViewDelegate回调方法： - (BOOL)textViewShouldBeginEditing:(UITextView *)textView; - (BOOL)textViewShouldEndEditing:(UITextView *)textView; - (void)textViewDidBeginEditing:(UITextView *)textView; - (void)textViewDidEndEditing:(UITextView *)textView; - (BOOL)textView:(UITextView *)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text; - (void)textViewDidChange:(UITextView *)textView; - (void)textViewDidChangeSelection:(UITextView *)textView; 还可以自定义选择UITextView内容后的菜单，方法是用UIMenuItem初始化菜单，然后将菜单列表添加到[UIMenuController sharedMenuController]中去,然后重写UIResponser类的canPerformAction:withSender方法调用 开关按钮(UISwitch:UIControl:UIView)UISwitch代表一个开关按钮，应用程序可以通过监控该控件的Value Changed事件来检测开关按钮的状态切换或属性isOn来获取当前值 分段控件(UISegmentedControl:UIControl:UIView)除可以设置UIControl和UIView的属性外，还可以设置 Style State Momentary 如果为true，selected状态时不会高亮显示 segments数量 Title Image Behaviour Enabled/Selected 图像控件(UIImageView:UIView)UIImageView的主要属性： image highlightedImage animationImages highlightedAnimationImages animationDuration animationRepeatCount startAnimating stopAnimating isAnimating UIImageView的mode属性即为缩放模式，支持以下列表项 Scale To Fill,不保持纵横比例缩放，使图片完全适应该UIImageView控件 Aspect fit，保持纵横比例缩放，使图片的长边能完全显示出来 Aspect fill，保持纵横比例缩放，只保证图片的短边能完全显示出来 Centre/Top/Bottom/Left/Right/TopLeft/TopRight/BottomLeft/BottomRight，不缩放，以规则对齐 如果控件未继承UIControl，则没有IBAction方法，也没有addTarget方法，但是可以通过添加手势检测处理器的方式来处理事件 [imageView addGestureRecogniser:[[UITapGestureRecogniser alloc] initWithTarget:self action:@selector(tapped:)]; - (void)tapped:(UIGestureRecogniser *)recogniser; - (IBAction)remove:(id)sender; UIImageView可以以动画方式显示多张图片，只需要为该UIImageView的animationImages属性赋值一个UIImage对象的NSArray集合，再设置与动画相关的一些属性，如animationDuration,animationRepeatCount，最后调用startAnimating方法即可 进度条(UIProgressView:UIView/UIActivityIndicatorView:UIView)UIProgressView控件支持的属性： Style(默认和bar类型) Progress progress tint 已完成进度的颜色 track tint 轨道颜色 progress image 已完成进度的背景图片 track image 轨道背景图片 很多时候，iOS应用需要让某个控件显示图片，但是图片大小不符合要求，这时为了精准地控制只对指定区域进行缩放，可通过UIImage来创建可拉伸图片，当通过一个UIEdgeInsets结构体定义图片拉伸区域后，程序可把拉伸图片放到UI控件上，iOS系统只对图片的指定区域进行缩放 UIActivityIndicatorView控件支持的属性 Style LargeWhite/White/Grey Color Behaviour Animation显示时立即开始转动 Hides when stopped 停止转动时立即隐藏 拖动条(UISlider:UIControl:UIView)UISlider和UIProgressView非常相似，仅比UIProgressView多一个Thumb滑动块属性 setMinimum/MaximumTrackImage:forState 设置进度条已完成/未完成进度的轨道图片 setThumbImage:forState 设置拖动条上滑块的图片 UIAlertView与UIActionSheet(UIAlertController)UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@&quot;更多操作&quot; message:@&quot;&quot; preferredStyle:UIAlertControllerStyleActionSheet/UIAlertControllerStyleAlert]; UIAlertAction *helpAlert = [UIAlertAction actionWithTitle:@&quot;求助好友&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction *action) {}]; [alertController addAction:helpAlert]; [self presentViewController:alertController animated:YES completion:nil]; UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@“提示” message:@“” delegate:self cancelButtonTitle:@“取消” otherButtonTitle:nil]; [alert show]; 当点击对话框按钮时，可以触发回调 - (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex; 和UIAlertView类似，只是UIActionSheet显示在屏幕底部 日期选择器(UIDatePicker:UIControl:UIView)用来选择日期和时间，还可以作为倒计时控件，可以设置的属性有： Mode 模式，如Date,Time,Date and Time,Count Down Timer Locale Interval 时间点的间隔 Constrains 设置最大时间与最小时间 Timer 控制器剩下的秒数 选择器(UIPickerView:UIView)UIPickerView常用的属性和方法如下: numberOfComponents showsSelectionIndicator 被选中时是否显示高亮背景 numberOfRowsInComponent: rowSizeForComponent: selectRow:inComponent:animated selectedRowInComponent viewForRow:forComponent UIPickerView控件只是负责该控件的通用行为，而控件包含多少列，各列包含多少项则由UIPickerViewDataSource对象负责 - (NSInteger)numberOfComponentsInPickerView:(UIPickerView \*)pickerView;决定应该包括多少列 - (NSInteger)pickerView:(UIPickerView *)pickerView numberOfRowsInComponent:(NSInteger)component:决定每列应该包括多少项 如果程序需要控制UIPickerView中各列的宽度、各列表项的大小外观或为UIPickerView的选中事件提供响应，则需要为其设置UIPickerViewDelegate委托对象，并根据需要实现委托对象中的如下方法： - (CGFloat)pickerView:(UIPickerView *)pickerView widthForComponent:(NSInteger)component - (CGFloat)pickerView:(UIPickerView *)pickerView rowHeightForComponent:(NSInteger)component - (NSString *)pickerView:(UIPickerView *)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component - (UIView *)pickerView:(UIPickerView *)pickerView viewForRow:(NSInteger)row forComponent:(NSInteger)component reusingView:(nullable UIView *)view - (void)pickerView:(UIPickerView *)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component iOS8新增的(UIVisualEffectView:UIView)此控件用于为原有控件增加模糊效果，用只读属性effect控制模糊效果，该属性的类型是UIVisualEffect类型，其有两个子类：UIBlurEffect(较常用)和UIVibrancyEffect 可设置此控件的如下属性：BlurStyle(UIBlurEffectStyleLight/ExtraLight/Dark)、Vibrancy 这个控件的目的是iOS应用可以通过模糊效果，把用户实现转移到指定的控件上 UIBlurEffect *light = [UIBlurEffect effectWithStyle:UIBlurEffectStyleLight]; UIVisualEffectView *lightView = [[UIVisualEffectView alloc] initWithEffect:light]; [_imageView addSubview:lightView]; 微调器(UIStepper:UIControl:UIView)支持的属性 Value Minimum,Maximum,Current,Step Behaviour Autorepeat不松手一直变化,Continuous交互时一直调用ValueChanged方法,Wrap当到最小值或最大值时会转头 setDecrement/IncrementImage:forState 为该控件的特定状态设置图片 网页控件(UIWebView:UIView)可配置的常用属性有： scalesPagesToFit: 控制是否缩放网页以适应控件 dataDetectorTypes:自动检测内容，可以连接电话邮箱等，如UIDataDetectorTypeAddress/PhoneNumber/Link/CalendarEvent 常用方法有： - (void)loadHTMLString:(NSString *)string baseURL:(nullable NSURL *)baseURL; - (void)loadRequest:(NSURLRequest *)request; - (NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script;执行JavaScript字串并返回执行结果 还可以进行一些导航操作,如goBack,goForward,reload,stopLoading 当程序加载网页时，程序可为UIWebView设置一个UIWebViewDelegate委托，回调以下方法 - (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType; - (void)webViewDidStartLoad:(UIWebView *)webView; - (void)webViewDidFinishLoad:(UIWebView *)webView; - (void)webView:(UIWebView *)webView didFailLoadWithError:(nullable NSError *)error; 工具条(UIToolbar:UIView)工具条通常仅作为多个UIBarButtonItem的容器，每个UIBarButtonItem代表工具条上的一个控件，有两个常用属性 barStyle UIBarStyleDefault/Black/BlackOpaque/BlackTranslucent items 只需要将控件封装成UIBarButtonItem，即可添加到UIToolbar中去，封装的方法如下 —initWithTitle:style:target:action -initWithImage:style:target:action -initWithBarButtonSystemItem:target:action -initWithCustomView 表格(UITableView:UIScrollView)与表格控制器(UITableViewController)本节只简单介绍UITableView的属性和常用的方法，更加详细的教程请参考UITableView API 详解 可以设置UITableView的属性： Content 动态表格还是静态表格 Prototype Cells 表格cell的种类数目 Style Plain/Grouped Separator 分割线样式颜色 Selection 支持多选/单选/不选 Editing 编辑状态时是否支持选中 rowHeight backgroundView tableHeaderView tableFooterView numberOfRowsInSection numberOfSections 必须为UITableView设置UITableViewDataSource来控制数据源 - (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView; - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section; - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath; 默认的UITableViewCell中包含三个可配置的属性:textLabel,detailTextLabel,image 根据这三个属性的位置，有几种不同的布局风格: UITableViewCellStyleSubtitle UITableViewCellStyleDefault UITableViewCellStyleValue1/2 还可以设置UITableViewCell的accessoryType，如UITableViewCellAccessoryDetailDisclosureButton/Checkmark/DisclosureIndicator 获取UITableView控件后，可通过如下方法访问表格控件的表格行和分区 - cellForRowAtIndexPath: - indexPathForCell: - indexPathForRowAtPoint: 该表格中指定点所对应的indexPath - (NSArray)indexPathsForRowsInRect: 该表格中指定区域内的所有indexPath组成的数组 - visibleCells: - (NSArray)indexPathsForVisibleRows: 也可以通过如下方法来控制表格控件的滚动 - scrollToRowAtIndexPath:atScrollPosition:animated - scrollToNearestSelectedRowAtScrollPosition:animated 控制表格滚动到选中表格行的顶端、中间或下方 可以运用如下方法来处理单元格的选中 - indexPathForSelectedRow - indexPathsForSelectedRows - selectRowAtIndexPath:animated:scrollPosition: - deselectRowAtIndexPath:animated: 可以运用如下方法来响应表格行的选中事件 - tableView:willSelectRowAtIndexPath: - tableView:didSelectRowAtIndexPath: - tableView:willDeselectRowAtIndexPath: - tableViewDidDeselectRowAtIndexPath: 如果需要自定义UITableView的表格行 继承UITableViewCell定制表格行 - (UITableViewCell *)initWithStyle:reuseIdentifier: 使用动态单元格原型定制表格行 - tableview:dequeueReusableCellWithIdentifier: dequeueReusableCellWithIdentifier:与dequeueReusableCellWithIdentifier:forIndexPath:的区别： 前者不必向tableView注册cell的Identifier，但需要判断获取的cell是否为nil 后者则必须向tableView注册cell，可省略判断获取的cell是否为空，因为无可复用cell时runtime将使用注册时提供的资源去新建一个cell 如何注册？ 如果是storyboard方式，系统默认注册 如果是xib方式且自定义UITableViewCell，需要registerNib:，初始化时会调用- (void)awakeFromNib 如果是代码方式，使用registerClass:注册，初始化时会调用- (id)initWithStyle:withReusableCellIdentifier: 如果用户需要编辑表格：setEditing属性设置表格是否属于编辑状态，除此之外，UITableView提供了如下方法来插入、删除、移动表格行 - beginUpdate: 对表格控件执行增删改之前，会先调用该方法 - endUpdate: - insertRowsAtIndexPaths:withRowAnimation - moveRowAtIndexPath:toIndexPath: - insertSections:withRowAnimation - deleteSections:withRowAnimation - moveSection:toSection: 如果需要用户动态编辑表格，必须实现UITableView对应的dataSource对象中的如下方法 - tableView:canEditRowAtIndexPath: - tableView:commitEditingStyle:forRowAtIndexPath: - tableView:canMoveRowAtIndexPath: - tableView:moveRowAtIndexPath:toIndexPath: 除此之外，UITableViewDelegate也为编辑表格定义了一些方法 - tableView:willBeginEditingRowAtIndexPath: - tableView:didEndEditingRowAtIndexPath: - tableView:editingStyleForRowAtIndexPath:决定对该表格行的可操作,如UITableViewCellEditingStyleDelete - tableView:titleForDeleteConfirmationButtonForRowAtIndexPath: - tableView:shouldIndentWhileEditingRowAtIndexPath: 当处于编辑状态时表格行是否应该缩进 如果希望UITableView建立多分区表格和多分区索引，则需要回调以下方法 - numberOfSectionInTableView: - (NSArray&lt;NSString*&gt;*)sectionIndexTitlesForTableView: 该方法可以在表格右边建立一列浮动的索引 - tableView:titleForHeaderInSection: - tableView:titleForFooterInSection: 如果应用界面中只需要显示一个表格，那么让用户控制器直接继承UITableViewController即可，它已经实现了UITableViewDataSource和UITableViewDelegate协议，因此使用起来更加方便 如果程序只想固定显示几行数据，则推荐使用更加方便的静态单元格，虽然不需要UITableViewDataSource，但可响应UITableViewDelegate 当程序使用UITableViewController创建表格时，该控制器类可指定一个refreshControl属性，该属性值应该是一个UIRefreshControl控件，其可用于刷新表格数据，UIRefreshControl可设置如下属性 tintColor attributedTitle endRefreshing _refreshControl = [[UIRefreshControl alloc] init]; _refreshControl.attributedTitle = @“下拉刷新”; [_refreshControl addTarget:self action:@selector(refreshData) forControlEvents:UIControlEventValueChanged]; _refreshControl.attributedTitle = @“正在刷新”; [_refreshControl endRefreshing]; _tableView reloadData]; 搜索条(UISearchBar)和搜索控制器(UISearchDisplayController)搜索条由一个文本框和几个按钮组成，当用户在文本框内输入部分内容之后，程序即可按指定的规则执行搜索，包括的属性有 Show Search Results Button 勾选后在右侧会有向下箭头，单机箭头可激发特定的事件 Shows Bookmarks Button 勾选后在右侧会有图书的书签按钮，可单机该按钮激发特定的事件 Shows Cancel Button 同理 Show Scope Bar 勾选后会在搜索框下方显示一个分段条，接下来的Scope Titles将用于设置各分段的标题 UISearchBarDelegate: - searchBar:textDidChanged - searchBarBookmarkButtonClicked: - searchBarCancelButtonClicked: - searchBarSearchButtonClicked: 点击键盘上的search按钮时触发 - searchBarResultsListButtonClicked: 点击搜索条上的查询结果按钮时触发 - searchBar:selectedScopeButtonIndexDidChange: 当用户单击分段条上的分段按钮时触发 使用UISearchDisplayController searchBar 绑定到界面的UISearchBar控件 searchContentsController 该属性用于绑定控件的控制器 searchResultDataSource UITableViewDataSource searchResultDelegate UITableViewDelegate UISearchDisplayDelegate - searchDisplayControllerWillBegin/DidBegin/WillEnd/DidEndSearch:(UISearchDisplayController *)controller` - searchDisplayController:(UISearchDisplayController *)controller willShow/didShow/willHide/didHideSearchResultsTableView:(UITableView *)tableView` UISearchDisplayController已经在iOS8中被UISearchController替换 _searchController = [[UISearchController alloc] initWithSearchResultsController:nil]; _searchController.searchResultsUpdater = self; _searchController.delegate = self; _searchController.searchBar.delegate = self; UISearchControllerDelegate: - willPresent/didPresent/willDismiss/didDismissSearchController:(UISearchController *)searchController; - presentSearchController:(UISearchController *)searchController; UISearchResultsUpdating: - updateSearchResultsForSearchController:(UISearchController *)searchController(刷新searchResultsController) 导航条(UINavigationBar:UIView)与导航控制器(UINavigationController)UINavigationBar通常位于屏幕的顶端，以stack的形式管理多个UINavigationItem，提供的方法有： - pushNavigationItem:animated: - popNavigationItem:animated: - setItems:animated: - items: - topItem: - backItem UINavigationItem也可以作为一个容器，它由标题、左边N个按钮，右边N个按钮组成，每个按钮都是UIBarButtonItem控件 UINavigationItem的属性和方法： title hidesBackButton titleView leftBarButtonItems leftBarButtonItem rightBarButtonItems rightBarButtonItem UINavigationController使用栈的形式来管理多个ViewController，它提供了如下属性和方法来操作其内部的UIViewController topViewController: visibleViewController: viewControllers: setViewControllers:animated: pushViewController:animated: popViewController:animated: popToRootViewController:animated: popToViewController:animated: UINavigationController提供了如下属性和方法来设置导航条 navigationBar navigationBarHidden toolbar 导航过程不仅可以根据UINavigationController，而且可以根据Segue来导航，导航类型包括 show:相当于调用UIViewController的showViewController:sender:方法切换到新的视图控制器，使用UINavigationController视图控制器过渡时通常使用这种类型的segue show detail:相当于调用UIViewController的showDetailViewController:sender:方法切换到新的视图控制器 present modally:以完全覆盖的方式切换到新的视图控制器 popover presentation:以浮动窗口呈现新的视图控制器，通常只在iPad这种屏幕应用中使用这种类型的segue custom:只有当开发者打算使用自定义segue时才选择这种类型 下边提供的方法已过时 push:相当于将VC推入NavigationController中，调用[self.navigationController pushViewController: animated:] modal:相当于以完全覆盖的方式切换到新的视图控制器[self presentViewController: animated:] popover:以浮动窗口呈现新的视图控制器，通常在iPad下使用 replace:替换当前的场景，一般在iPad下使用，如SplitViewController 不仅可以通过storyboard中的segue链接各VC，也可以用代码控制segue的跳转链接 [performSegueWithIdentifier: sender:] [prepareForSegue:(UIStoryboardSegue *)segue sender]，segue对象的source/destinationViewController/identifier iOS7开始更改了导航条的界面坐标计算方式，并添加了translucent属性，默认为true，表示从顶部开始计算屏幕高度，如果translucent属性为false的时候，VC中的布局就会回到iOS 6以前那样，y==0的位置是navigationbar底部。相比iOS 7以后从屏幕顶部开始计算刚好相差64像素 网格(UICollectionView:UIScrollView:UIView)与网格控制器(UICollectViewController)UICollectView支持的属性有： Items:单元格原型数量 Layout:Flow/Custom,可设置layout的cellSize,headerSize,FooterSize,MinSpacing,sectionInset,scrollDirection,header/footerReferenceSize ScrollDirection Accessories:是否显示页眉和页脚 跟UITableView类似，UICollectionView可以继承UICollectViewDataSource和UICollectionViewDelegate，UICollectionView的显示需要回调自定义UICollectionViewCell，并且定义UICollectionViewFlowLayout确定各cell的排版 UICollectionViewFlowLayout排版出来的单元格大小间距都是相同的，如果要有更好的效果需借助UICollectionViewDelegateFlowLayout，UICollectionViewDelegateFlowLayout继承了UICollectionViewDelegate协议，其中包括的回调函数有： - collectionView:layout:sizeForItemAtIndexPath: - collectionView:layout:insetForSectionAtIndexPath: - collectionView:layout:minimumLine/interitemSpacingForSectionAtIndex:控制行/列间距 - collectionView:layout:referenceSizeForHeader/FooterInSection:控制指定分区页眉页脚的大小 一般可以设置UICollectionView的collectionViewLayout属性为UICollectionViewFlowLayout，但也可以继承UICollectionViewLayout自定义布局风格，通常需要重写如下方法： - prepareLayout 开始布局时调用该方法执行准备工作 - layoutAttributesForElementsInRect: 该方法的返回值控制指定NSRect区域内所有单元格的大小和位置等布局信息 - layoutAttributesForItemAtIndexPath: 该方法返回值控制指定NSIndexPath对应的单元格大小和位置等布局信息 - layoutAttributesForSupplementaryViewOfKind:atIndexPath: 返回值控制指定分区的页眉页脚控件的大小和位置信息 - layoutAttributesForDecorationViewOfKind:atIndexPath: 指定分区的装饰控件的大小和位置信息 - initialLayoutAttributesForAppearingItemAtIndexPath: 每当单元格动态增加时，自动调用该方法 - initialLayoutAttributesForAppearingSupplementaryElementOfKind:atIndexPath: 页眉页脚动态增加时调用的方法 - initialLayoutAttributesForAppearingDecorationElementOfKind:atIndexPath: 分区的装饰控件动态增加时调用的方法 -finalLayoutAttributesForDisappearingItem/DisappearingSupplementaryElementOfKind: -finalLayoutAttributesForDisappearingDecorationElementOfKind:AtIndexPath: 动态消失时调用 标签条(UITabBar)与标签页控制器(UITabBarController)UITabBar代表一个标签条，它是UITabBarItem的容器，用于组合多个UITabBarItem对象，它包含的标签项有： Tint ImageTint items selectedItem setItems:animated: 创建UITabBarItem：[initWithTabBarSystemItem:tag:],[initWithTitle:image:tag:]，可在右上角显示徽标badgeValue 可以监听UITabBarDelegate的tabBar:didSelectItem:方法监听用户的点击事件 页控件(UIPageControl:UIControl:UIView)与页控制器(UIPageViewController)UIPageControl是一个比较简单的控件，由N个小圆点组成，每个圆点代表一个页面，当前页面以高亮圆点显示,包括的属性有： pages current Hides for single page 只有一页时隐藏 Defers page display 延迟显示当前页，当用户单击该控件，使该控件跳转到某个新页面时，控件必须等到updatePageIndicator方法执行完成后，控件界面才会执行更新 tint color current page color UIPageControl经常和UIScrollView结合使用，此时他的功能有：显示ScrollView在第几页，点击时控制ScrollView滚动 运用UIScrollView的- scrollViewDidEndDecelerating:(UIScrollView*)scrollView和UIPageControl的valueChanged方法完成效果 程序要使用UIPageController控件，必须实现UIPageViewControllerDataSource协议的方法： - pageViewController:viewControllerBefore/AfterViewController - setViewControllers:direction:animated:completion iPad应用开发UISplitViewController,当iPad处于横向模式时，UISplitViewController的左侧将会显示320点宽的侧栏，该栏通常用于显示页面的导航栏，右侧通常用于显示导航栏对应的详情；当切换回纵向时，原来位于左侧的导航栏不再固定显示在左边，而是需要单击某个按钮来激活，此时将会使用一个浮动窗口来显示导航栏。当界面切换发生变化时，UISplitViewController会分别激发其Delegate方法 - splitViewController:willHideViewController:withBarButtonItem:forPopoverController: - splitViewController:willShowViewController:invalidatingBarButtonItem: UIPopoverController代表浮动导航栏，实际上UIPopoverController的作用就是包装一个UIViewController，使之成为浮动窗口 [[UIPopoverController alloc] initWithContentViewController:] [popoverController presentPopoverFromBarButtonItem:permittedArrowDirections:animated] [popoverController presentPopoverFromRect:inView:permittedArrowDirections:animated:property] 管理iOS应用的运行自动旋转机制 可以通过项目Target-&gt;General-&gt;Device Orientation设置，或info.plist中的supported interface orientations 也可根据视图控制器viewController中的shouldAutorotate方法来重新控制 初始化时重写preferredInterfaceOrientationForPresentation指定该视图控制器的初始默认屏幕方向 当发生旋转时，如果希望支持某一个显示方式，则重写supportedInterfaceOrientations来重新设置 一般比较常用到的回调函数有： - willRotateToInterfaceOrientation:duration - willAnimateRotationToInterfaceOrientation:duration - didRotateFromInterfaceOrientation 当旋转时，一般在willAnimateRotationToInterfaceOrientation:duration方法中对应用界面进行调整，调整方式有两种：旋转时重构用户界面和为不同的显示方式提供不同的界面设计文件 还有一种运用sizeClass自动调整界面的方式，通过设置xib或storyboard的横屏和竖屏分别对应的相对布局规则，即可完成要求 应用程序状态 Not running(未运行):未启动或者被终止状态 Inactive(不活动):前台运行，但不能接收事件处理，当切换状态时，中途过渡会短暂停留在此状态 Active(活动):程序在前台运行且能接收到事件 Background(后台):应用处在后台运行，并且还在执行代码，当切换到Suspended状态时会短暂停留在此状态 Suspended(挂起):应用处在后台，并且没有执行任何代码 在这几个状态之间转换时，会回调的函数有： application:willFinishLaunchingWithOptions: 应用程序将要启动时自动调用该方法 application:didFinishLaunchingWithOptions: 应用程序启动完成后自动调用该方法 applicationWillEnterForeground:应用程序从后台转入前台运行状态，但还未达到Active时 applicationDidBecomeActive:应用程序在转入前台，并进入活动状态时回调该方法 applicationWillResignActive:应用程序正要从前台运行状态离开时调用该方法 applicationDidEnterBackground:应用程序处于Background状态，且随时可能进入Suspended状态时 applicationWillTerminate:应用程序即将被终止时调用该方法 中断处理中断会导致用户暂时失去对应用的控制，虽然应用依然在前台运行，但是不再接收任何触碰事件，所以在applicationWillResignActive:方法中应该中断一些任务，如 停止timers并终止其他周期性的任务 停止任何正在运行的元数据查询 不要初始化任何新的任务 暂停电影播放 游戏进入暂停状态 减少OpenGL ES帧率 暂停所有执行非关键代码的调度队列和操作队列 当应用恢复Active状态时，需要在applicationDidBecomeActive方法中恢复刚刚取消的操作，除游戏手动恢复外 applicationDidEnterBackground方法中完成转入后台前要做的工作 保存用户数据或状态信息 释放所有可以释放的内存 applicationWillEnterForeground方法应该恢复applicationDidEnterBackground方法中所做的工作 Main Run LoopMain Run Loop负责处理所有与用户相关的事件，UIApplication对象在程序启动时启动Main Run Loop，并用它来处理事件和处理更新基于视图等操作。事件通过Main Run Loop提交给应用程序处理，各种事件会交给UIResponser对象处理，如UIApplication、UIWindow、UIViewController以及UIView ViewController介绍1，ViewController分为两类，展示内容的controller和控制其他controller的controller2，ViewController的生命周期，init-&gt;loadView-&gt;viewDidLoad-&gt;viewWillAppear-&gt;viewDidAppear-&gt; viewWillLayoutSubviews-&gt; viewDidLayoutSubviews-&gt;viewWillDisappear-&gt;viewDidDisappear-&gt;viewDidUnload-&gt;receiveMemoryWarning-&gt;dealloc iOS8增强的自动布局功能自动布局是从iOS6开始引进的新功能，而iOS8在原有自动布局的基础上增加了Size Class的概念，从而增强了自动布局功能，它的精髓是相对布局 为UI控件添加自动布局的约束可通过如下三种方式 通过Xcode中Editor菜单的Align、Resolve Auto Layout Issue或pin子菜单添加 通过Interface Builder右下角的按钮来添加 在Interface Builder中通过control+快捷键添加 iOS8使用SizeClass对iOS设备的屏幕尺寸进行了抽象，它将屏幕的宽度和高度分别分成三种情况：compact(紧凑)、Regular(普通)、Any(任意) 图形、图像和动画使用UIImage和CGImage处理位图[UIImage imageNamed:@“”]加载指定名称的图片，该方法有缓存机制，如果该方法试图加载的文件不存在，它才会去加载图片文件并缓存它，如果系统已经缓存过，则直接使用已缓存的图片，故而当程序需要频繁的加载或卸载图片文件时，不应该使用此方法。所以遇到大图，或者频繁进出内存时，应该用[UIImage imageWithContentsOfFile] UIImage提供了以下方法 + imagedNamed: + imageWithContentsOfFile: + imageWithData: + imageWithData:scale: + imageWithCGImage: + imageWithCGImage:scale:orientation: 对图片旋转、镜像变换 + animatedImageNamed:duration: 根据指定的图片名来加载一系列图片 + animatedImageWithImages:duration: UIImage不能对图片进行缩放、旋转、挖取操作，这些功能可借助于CGImageRef指针来实现； CGImageRef ciRef = [image CGImage]; UIImage *image = [UIImage imageWithCGImage:ciRef]; Quartz 2D绘图使用Quartz 2D绘图的关键步骤有两步：获取CGContextRef，调用CGContextRef的方法进行绘图； 如果开发自定义UIView，则在重写drawRect:方法时可用CGContextRef context = UIGraphicsGetCurrentContext(); 如果需要在创建位图时获取，则调用 UIGraphicsBeginImageContext(CGSizeMake(320,480)) CGContextFillRect(CGContextRef, CGRect) CGContextDrawImage(CGContextRef, CGRect, CGImageRef) CGContextSetFontSize(CGContextRef,CGFloat) CGContextShowTextAtPoint(CGContextRef,CGFloat,CGFloat) CGContextSetShadow(CGContextRef,CGSize,CGFloat(,CGColorRef)) 图形变换在绘图前可以对其进行绘图变换的操作，CGContextTranslate/Scale/RotateCTM(CGContextRef,CGFloat x,CGFloat y)将坐标系统进行平移、缩放、旋转操作 控制叠加模式默认情况下，后面绘制的图形将会完全覆盖前面绘制的图形，但有些情况下需要设置叠加效果CGContextSetBlendMode(CGContextRef, CGBlendMode) 处理填充Quartz 2D允许使用颜色渐变填充和模式填充两种方式填充指定区域，渐变填充包括线性渐变和圆形渐变 获取填充的gradient CGGradientCreateWithColorComponents(CGColourSpaceRef space, const CGFloat components[],const CGFloat locations[],size_t count): space指定该渐变所使用的颜色空间(如RGB、CMYK、Grey等颜色空间)、components用于根据不同的渐变空间设置多种颜色，locations指定各颜色点的分布位置，为null时表示均匀分布，count指定该渐变色包含几种颜色 CGColorSpaceRef colorSpace = CGColourSpaceCreateDeviceRGB(); CGFloat colours[] = {1,0,0,1, 0,1,0,1, 0,0,1,1}; _gradient = CGGradientCreateWithColourComponents(colorSpace, colours, NULL, sizeOf(colours)/sizeOf(colours[0])*4)) 填充gradient到指定内容 CGContextDrawLinearGradient(CGContextRef context,CGGradientRef gradient, CGPoint startPoint,CGPoint endPoint,CGGradientDrawingOptions options); CGContextDrawRadialGradient(CGContextRef context,CGGradientRef gradient, CGPoint startCentre,CGFloat startRadius,CGPoint endCentre, CGFloat endRadius,CGGradientDrawingOptions options); 模式填充可以采用类似于“铺瓷砖”的方式进行填充或绘制边框，包括两种方式 CGColourCreateWithPattern()函数创建代表模式填充的CGColourRef后，用该颜色填充指定区域或绘制边框 创建CGPatternRef，在绘制时调用CGContextSetFillPattern或CGContextSetStrokePattern函数设置填充模式 使用Core Image滤镜Core Image可以非常容易地对图片进行各种特效处理，包括色彩调节、降噪、扭曲等。步骤如下： 创建CIContext对象，基于CPU，基于GPU，基于OPENGL 创建过滤器[CIFilter filterWithName:@“CGPixellate”]并赋值，如inputImage，inputRadius属性 [CIContext createCGImage:[filter outputImage] fromRect:[filter outputImage].extent]获取CIImage [UIImage imageWithCGImage:ciImage]即可获取UIImage完成滤镜效果 动画Quartz Core中的CoreAnimation动画使用CALayer来创建和动画用户界面。优点： CoreAnimation在单独的线程中完成，不会阻塞主线程 CoreAnimation只会重绘界面上变化的部分（局部刷新） CAAnimation是所有动画的基类，它实现了CAMediaTiming协议，提供了动画的持续时间，速度和重复计数等，它还实现了CAAction协议，该协议为CALayer动画触发的动作提供标准化响应 CATransition是CAAnimation的子类CATransition可以通过预置的过渡效果来控制CALayer层的过渡动画 CATransition *transition = [CATransition animation]; transition.duration/type/subtype = kCATransitionMoveIn/FromLeft; [_view.layer addAnimation:transition forKey:@“animation”]; CAPropertyAnimation是CAAnimation的子类CAPropertyAnimation代表一个属性动画，可通过animationWithKeyPath:类方法来创建属性动画实例，该方法需要指定一个CALayer支持动画的属性，然后通过它的子类(CABasicAnimation、CAKeyframeAnimation)控制CALayer的动画属性慢慢改变，即可实现CALayer动画 CABasicAnimation是CAPropertyAnimation的子类CABasicAnimation简单控制CALayer层的属性慢慢改变，从而实现动画效果，很多CALayer层的属性值的修改默认会执行这个动画类，比如大小、透明度、颜色等 CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@“position”]; animation.fromValue = [NSValue valueWithCGPoint:fromPoint]; animation.toValue = [NSValue valueWithCGPoint:toPoint]; animation.duration = 0.5; [_imageLayer addAnimation:animation forKey:nil]; CAKeyframeAnimation是CAPropertyAnimation的子类CAKeyframeAnimation除过可以通过values属性指定动画过程中多个值之外，还可以通过path属性指定CALayer的移动路径，该属性就是CGPathRef，通过这种方式即可控制CALayer按照指定的轨迹移动 CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@“position”]; CGMutablePathRef movePath = CGPathCreateMutable(); animation.path = movePath; [_imageLayer addAnimation:animation]; CAAnimationGroup是CAAnimation的子类，用于将多个动画组合在一起执行 CAAnimationGroup *animationGroup = [CAAnimationGroup animation]; animationGroup.animations = @[animation1,animation2]; [_imageLayer addAnimation:animationGroup]; 变换：要在一个层中添加一个3D或仿射变换，可以分别设置层的transform或affineTransform属性；变形：Quartz Core的渲染能力，使二维图像可以被自由操纵，就好像是三维的显式动画和隐式动画隐式动画：我们并没有指定任何动画的类型。我们仅仅改变了一个属性，然后Core Animation来决定如何并且何时去做动画显式动画：它能够对一些属性做指定的自定义动画，或者创建非线性动画，比如沿着任意一条曲线移动 UIView和CALayer的联系与区别： UIView有个layer属性，可以返回它的主CALayer实例，一般情况下是 UIView 拥有 CALayer，CALayer 的 Delegate 是 UIView通过（(void)drawLayer:(CALayer *)layer inContext:(CGContextRef)context）请求绘图通过- (nullable id&lt;CAAction&gt;)actionForLayer:(CALayer *)layer forKey:(NSString *)event请求动画； UIView的CALayer类似UIView的子View树形结构，也可以向它的layer上添加子layer，来完成某些特殊的表示； UIView可以响应事件（如 – touchesBegan:withEvent:），Layer不可以，因为UIView直接或间接地继承自UIResponder类，而 CALayer直接继承NSObject类； UIView的layer树形在系统内部，被维护着三份copy。分别是逻辑树，这里是代码可以操纵的；动画树，是一个中间层，系统就在这一层上更改属性，进行各种渲染操作；显示树，其内容就是当前正被显示在屏幕上得内容； 动画的运作：对UIView的subLayer（非主Layer）属性进行更改，系统将自动进行动画生成； 坐标系统：CALayer的坐标系统比UIView多了一个anchorPoint属性，使用CGPoint结构表示，值域是0~1，是个比例值； 渲染：当更新层，改变不能立即显示在屏幕上。当所有的层都准备好时，可以调用setNeedsDisplay方法来重绘显示；]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[疯狂iOS上册第一部分]]></title>
    <url>%2F2014%2F03%2F28%2F%E7%96%AF%E7%8B%82iOS%E4%B8%8A%E5%86%8C-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[最近看了李刚的疯狂系列书籍之疯狂iOS，基本将整个iOS知识体系涵盖在内，本篇主要将《疯狂iOS讲义》上册的第一部分的重点知识列举一下，包括 iOS应用与开发环境、数据类型和运算符、流程控制与数组、C语言特性、面向对象（上）、面向对象（下）、Foundation框架详解、文件I/O、iOS应用开发入门 这几章知识点。 iOS应用与开发环境OC与iOS简介搭建iOS开发环境第一个OC程序熟悉Xcode 左边导航面板从左到右依次是：项目导航、符号导航、搜索导航、问题导航、测试导航、调试导航、断点导航、日志导航，快捷键是command+1/2 右边检查器面板包括：文件检查器、快速帮助检查器、身份检查器、属性检查器、大小检查器、连接检查器,快捷键是command+option+1/2 右下端库面板包括：文件模板库、代码片段库、对象库、媒体库，快捷键是control+option+command+1; Xcode的帮助系统：1，利用快速帮助面板 2，直接利用搜索 3，利用编辑区的快速帮助（按住option键） 数据类型和运算符OC是一门强类型的语言，强类型的含义包含两个方面 所有变量必须先声明后使用 指定类型的变量只能接收类型与之匹配的值 强类型的语言可以在编译过程中发现源代码的错误，从而保证程序更加健壮 注释在编写程序时，应该为程序添加一些注释，用以说明某段代码的作用，或者说明某个类的用途，某个方法的功能，以及该方法的参数和返回值的数据类型和意义等，对于一份规范的程序源代码而言，注释应该占到源代码的1/3以上，注释包括两种，单行注释(//abc)和多行注释(/*abc*/) 标识符和变量分隔符包括分号(;)、花括号({})、方括号([])、圆括号(())、空格( )、圆点(.) 标识符就是用于给程序中变量、类、方法命名的符号，OC语言的标识符必须以字母、下划线、美元符开头、后面可以跟任意数目的字母、数字、下划线和美元符 数据类型分类OC数据类型包括: 基本类型(包括整型、字符型、浮点型（float/double类型） 枚举型(定义类型：enum season {spring, summer, fall, winter} 定义变量 enum season myLove,yourLove)) 构造类型(包括数组类型、结构体类型、共用体类型) 指针类型 type varName; 基本数据类型类型转换OC程序中，不同的基本类型的值经常需要相互转换，一般有两种转换方式 自动类型转换（系统支持） 强制类型转换(运算符是圆括号) 运算符运算符是一种特殊的符号，用于表示数据的运算、赋值和比较。OC运算符包括： 算数运算符 赋值运算符 比较运算符 逻辑运算符 位运算符 类型相关运算符 运算符的优先级：分隔符(各种括号)&gt;单目运算符&gt;强制类型转换符&gt;乘除求余&gt;加减法&gt;移位运算符&gt;关系运算符&gt;等价运算符&gt;按位与&gt;按位异或&gt;按位或&gt;条件与&gt;条件或&gt;三目运算符&gt;赋值&gt;逗号运算符 不要把一个表达式写得过于复杂，如果比较复杂，则应该分成几步来处理 不要过多依赖运算符的优先级来控制表达式的执行顺序，这会降低程序的可读性，应尽量使用()来控制表达式的执行顺序 流程控制与数组顺序结构顺序结构就是程序从上到下一行一行地执行，中间没有任何判断和跳转 分支结构 if语句使用布尔表达式或布尔值作为分支条件来进行分支控制 if () { } else if () { } else { } switch语句则用于对多个值进行匹配（byte、short、char、int），从而实现分支控制 switch() { case:condition1 { ***; break； } case:condition2 { ***; break； } default: { ***; } } 循环结构循环结构包含如下4个部分 初始化语句 循环条件 循环体 迭代语句 [init_statements]; while(test_expression) { statements; [iteration_statements]; } [init_statements]; do { statements; [iteration_statements; } while(test_expression) for([init_statements];[test_expression];[iteration_statement]) { statements; } 控制循环结构OC提供了continue和break来控制循环语句，除此之外，return可以结束整个方法，当然也就结束了一次循环 break用于完全结束一个循环，continue的功能和break有点类似，区别是continue只是终止本次循环，接着开始下一次循环，而return是结束整个循环体并结束整个函数，效果范围从小到大依次是continue-&gt;break-&gt;return goto语句goto语句功能非常强大，它被称为无条件跳转，但由于goto语句功能太强大，而且这种跳转是随心所欲的，因此过度使用会导致程序的可读性大幅度降低，所以建议尽量少用goto语句 数组数组定义 type arrayName[length] 元素的地址, = 首地址 + 数组变量所占的内存大小 * 索引 C语言特性函数函数返回值 函数名(形参列表){//由零条到多条可执行性语句组成的函数}函数的传值一般都是值传递，将实参的值拷贝一份传入函数 根据函数能否被其他源文件调用，可以将函数分为内部函数和外部函数，内部函数由static修饰，外部函数由extern修饰 局部变量与全局变量函数内部定义的变量是局部变量，局部变量在该函数内部有效；函数外部定义的变量是全局变量，全局变量可以被该源文件中的所有函数访问 局部变量根据定义的形式不同又分三种：1，形参 2，函数局部变量 3，代码块局部变量 在函数内部，如果局部变量和全局变量同名，则局部变量会覆盖全局变量，即在函数内部，全局变量会失效 extern 修饰的变量称外部全局变量 static 修饰的变量称内部全局变量 从变量的存储机制来看，C语言的变量可分为动态存储变量和静态存储变量，动态：程序运行时动态分配内存 静态：运行开始就分配了固定内存 就C语言程序运行的内存来说，大致分为五部分： 程序区(存放函数体的二进制代码) 栈(由编译器自动分配释放 ，存放函数的参数值，局部变量的值等) 堆区(一般由程序员alloc/malloc分配释放， 若程序员不释放，程序结束时可能由OS回收) 全局区(全局/静态变量) 文字常量区(常量字符串就是放在这里的。 程序结束后由系统释放) 静态存储区存放：全局变量和static修饰的局部变量 动态存储区存放：函数的形参变量，非static修饰的局部变量，函数执行现场数据 为了指定变量的存储类型，可以在定义变量时指定存储类别 auto自动存储动态存储区 static静态存储区 register寄存器内 extern外部变量声明 静态局部变量会一直占据固定的内存，所有通常应该慎重使用，一般有两种情况 需要变量能保留上一次调用结束时的值 希望变量只是被初始化一次，以后只是被引用，而不希望对其重新赋值 预处理在编译器对程序进行编译之前，编译器会对这些预处理命令进行处理，然后将这些预处理的结果与源程序一起进行编译，预处理命令通常有两个特征 预处理命令都必须以#开头 预处理命令通常位于程序开头部分 #define 的作用就是为字符串起一个名字，宏名称通常会全大写，宏定义不是变量，也不是常量，没有=，也没有；，其实质是查找替换的过程，如果希望提前结束宏定义，则可以使用如下语句 #undef 宏名称 #ifdef、#ifndef、#else、#endif可执行条件编译 #if、#elif、#else、#endif可执行条件编译 #import比#include更加智能，可判断并且避免重复导入。 #import “”先搜索当前路径，再搜索Xcode项目设置的预处理程序的搜索路径 #import &lt;&gt;直接去搜索特定系统头文件路径中找，而不是在当前路径搜索 指针系统需要为内存中的每个单元格编号，32位操作系统最大只能支持4GB的内存，这是因为2的32次方等于4 294 967 296 定义指针变量的语法格式如下：类型 *变量名 整个语法代表定义一个指向特定类型的变量的指针变量，他保存的不是普通的值，而是一个地址 &amp;：取地址运算符 *：取变量运算符 指针与数组数组变量的本质就是一个指针常量 字符串与指针函数与指针C语言允许定义一个指针变量来指向函数，然后通过该指针变量来调用函数 定义 函数返回值 (* 指针变量名)(); 赋值 指针变量名=函数名 调用 (*函数指针变量)(参数) int (*fnPt)() = max; int a = (*fnPt)(data, params); 当函数返回指针时需要注意，如果返回的指针指向的是函数中的局部变量，这将非常危险，因为函数调用结束后，该函数中局部变量所占用的内存已经释放了，那么该指针指向的内存单元格中存储的数据是不确定的 指针数组和指向指针变量的指针指针数组的定义 类型 *数组变量[长度]，主要不要写成 类型 (*数组变量)[长度] 此表示指向一个一维数组的指针 指向指针的指针 类型 **变量名 结构体定义结构体 struct 结构体类型名{//成员列表} 定义结构体变量 struct 结构体类型名 变量名； struct 结构体类型名{//成员列表}结构体变量1，结构体变量2； 每次定义结构体变量都会很繁琐 可以使用#define POINT struct 结构体类型名 来预编译 也可以使用typedef来为已有的结构体类型定义新的名词 typedef struct 结构体类名 POINT C语言要求在定义结构体变量时执行初始化，一旦初始化完成，或定义结构体变量时没有执行初始化，那么程序以后就不能对结构体变量整体赋值了，但可以将一个结构体变量赋值给另一个结构体变量 块(Block)块(Block)是OC对C语言做的扩展，使用块可以更好地简化OC编程，而且OC的很多API都依赖于块 块的定义语法：^[块返回值类型](形参类型1 形参1，形参类型2 形参2，…){//块执行体} 块定义与函数定义的区别 ^开头 返回值类型可省略 无需指定块名 参数部分的括号不可省略，如果没参数，用void代替 可以定义块变量：块返回值类型 (^块变量名)(形参类型1，形参类型2，…); _block修饰的局部变量表示，无论何时，块都会直接使用该局部变量本身，而不是将局部变量的值赋值到块范围内 可以直接使用块作为函数的参数 使用typedef可以定义块类型，用途主要有二 1，复用块类型，可以定义出多个块变量 2，使用块类型定义函数参数 定义块类型的语法格式：typedef 块返回值类型 (^块类型)(形参类型1 形参1， 形参类型2 形参2，…); 面向对象（上）类和对象我们可以把类当成一种自定义数据类型，可以使用类来定义变量，这种类型的变量相当于指针类型的变量。OC中定义类分为两个步骤： 接口部分：定义该类包含的成员变量和方法 实现部分：为该类的方法提供实现 OC将类分为接口部分和实现部分体现了良好的封装意识，在接口部分定义的内容(包括成员变量和方法)都是可以暴露且可供用户调用的部分，实现部分则属于类的内部实现，对于外界而言是隐藏的，不能供外界调用 OC语言关于方法调用有两种说法，调用方法和发送消息，对于[person abc]语句，可以说成person对象调用abc方法，此时person是方法调用者，也可以说成向person发送abc消息，此时person是消息接收者 类是一种指针类型的变量，因此，程序中定义的FKPerson类型只是存放一个地址值，被保存在动态存储区，它指向实际的FKPerson对象，而真正的FKPerson存放在堆内存中 OC提供了一个id类型，这个类型可以代表所有的对象的类型，程序在编译时不需要确定类型，而在运行时才确定变量类型和调用的方法 方法详解如果在定义方法时，在最后一个形参名后增加逗号和三点，则表明该形参可以接受多个参数值 va_list 这是一个类型，用于定义指向可变参数列表的指针变量 va_list argList; va_start 这是一个函数，该函数指定开始处理可变形参的列表，并让指针变量指向可变形参的第一个参数 va_start(argList, name); va_arg 这是一个函数，该函数返回指针当前指向的参数的值，并将指针移动到指向下一个参数 NSString *arg = va_arg(argList, id); va_end 结束处理可变形参，释放指针变量 va_list argList; va_start(argList, name);//name为传入的第一个参数名 NSString *arg=va_arg(argList, id); while(arg) { NSLog(@“arg=%@”,arg); arg=va_arg(argList, id); } va_end(argList); 成员变量OC中根据定义变量位置不同，可以将变量分成三大类，成员变量，局部变量和全局变量，成员变量是指在类的接口部分或实现部分定义的变量 虽然OC也提供了static关键字，但这个static关键字不能用于修饰成员变量，它只能修饰局部变量、全局变量和函数 static修改局部变量表示将该局部变量存储到静态存储区 static修改全局变量用于限制改全局变量只能在当前文件源中访问 static修饰函数用于限制该函数只能在当前源文件中调用 为了模拟类变量，可以在类实现部分定义一个static修改的全局变量，并提供一个类方法来暴露该全局变量 在某些时候，程序多次创建某个类的对象没有任何意义，还可能造成系统性能下降，此时程序需要保证该类只有一个实例 static id instance; + (id)instance { if(!instance) { instance=[[super alloc] init]; } return instance; } 隐藏和封装封装(Encapsulation)是面向对象的三大特征之一(另外两种是继承和多态),它指的是对象的状态信息隐藏在对象内部 不允许外部程序直接访问对象内部信息 而是通过该类所提供的方法来实现对内部信息的操作和访问 OC提供了4个访问控制符：@private当前类访问权限 @package相同映像访问权限 @protected子类访问权限 @public公共访问权限 所谓相同映像，简单的说，就是编译后生成的同一个框架或同一个执行文件(.out文件) 每个类常常就是一个小的模块，模块的设计需要遵循高内聚，低耦合的原则 键值编码(KVC)与键值监听(KVO)KVC(key Value Coding)键值编码，允许以字符串形式间接操作对象的属性 -setValue:forKey:/-valueForKey:程序先考虑调用SetName:方法，再找_name的成员变量，然后再找name的成员变量，最后调用setValue:forUndefinedKey:方法返回异常 -(void)setValue:(id) value forUndefinedKey:(id)key { NSLog(@“您尝试设置的key值不存在”); } -(id)valueForUndefinedKey:(id)key { NSLog(@“您尝试访问的key并不存在”); } 如果为基本类型设置属性为nil，会出现异常，同样需要通过 -(void)setNilValueForKey:(id)key { if([key isEqualToString:@“price”]) { _price=0; } else { [super setNilValueForKey:key]; } } KVO(Key Value Observing)键值监听，iOS应用将程序组件分开成数据模型组件和视图组件，当数据模型组件发送变化时，可通过KVO监听其变化从而修改视图组件的属性 -(Object \*)addObserver:forKeyPath:options:context:/-removeObserver:forKeyPath:/context:添加、删除监听 -(void)observeValueForKeyPath:ofObject:change:context: 对象初始化alloc分配内存，init完成初始化，还可以提供更多的便利初始化，如-(id)initWithBrand:(NSString \*)brand; 类的继承OC只能单继承，每个子类最多只有一个直接父类，方法的重写必须注意方法签名关键字要完全相同，也就是方法名和方法签名中的形参标签都需要完全相同，否则就不能算方法重写或方法覆盖 无论父类接口部分的成员变量使用何种访问控制符限制，子类接口部分定义的成员变量都不允许与父类接口部分定义的成员变量重名 在类实现部分定义的成员变量将被限制在该类内部，因此，父类在类实现部分定义的成员变量对子类没有任何影响，子类此时会隐藏父类的变量 多态OC指针类型的变量有两个，一个是编译时类型，一个是运行时类型。编译时的类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。如果编译时类型和运行时类型不一致，就可能出现所谓的多态(Polymorphism)，即相同类型的变量调用同一个方法呈现出多种不同的行为特征。指针变量在编译阶段只能调用其编译时类型所具有的方法，但运行时则执行其运行时类型所具有的方法 指针变量的强制类型转换：(type \*)variable; 当把子类对象赋值给父类指针变量时，被称为向上转型(upcasting)，这种转型总是可以成功的，执行方法时，依然表现出子类对象的行为模式，但把一个父对象赋值给子类指针变量时，就需要进行强制类型转换，而且还可能运行时产生错误，所以在强制转换之前需要先判断 -isMemberOfClass:(是否为实例) -isKindOfClass:(是否为类或子类) -isSubClassOfClass:(子类) 面向对象(下)OC的包装类在开发iOS时，可能会遇到NSInteger、NSUInteger、CGFloat类型，它的存在是为了更好的兼容不同的平台 #if \_LP64\_ typedef long NSInteger #else typedef int NSInteger #endif [NSNumber numberWithXXX] [number initWithXXX] [number XXXValue] 处理对象NSLog(@“%@”, p)输出的是p类的description方法返回值 -(NSString \*)description{return @“”}; == 如果是判断基本类型，只要两个变量的值相等即可，如果是两个指针类型的变量，他们必须指向同一个对象 isEqual默认也是比较地址，但一般需要重写才用，重写后要满足下列条件 自反性[x isEqual:x]返回真 对称性[y isEqual:x]则[x isEqual:y] 传递性若[x isEqual:y][y isEqual:z]则[x isEqual:z] 一致性，判断多次结果一定 [x isEqual:nil]假 扩展与类别由于OC并没有提供抽象类的语法支持，而在实际项目开发中，总需要有抽象类的时候，此时就会定义一个父类，并以该父类派生多个子类，其他程序使用这些类时，总是面向父类编程，当程序调用父类的初始化方法、类方法来返回对象时，实际上返回的是子类的实例，这一系列的类被称为一个类簇(cluster)，这个父类也就模拟了抽象类的功能。 OC的动态特征允许使用类别为现有的类添加新方法，并且不需要创建子类，不需要访问原有类的源代码 @interface 已有类 (类别名) @end @impletation 已有类 (类别名) @end 类别可以重写原有类中的方法，但通常并不推荐这么做，如果需要重写原有类方法，一般通过原有类派生子类，在子类中重写父类原有的方法 通过类别为指定类添加新方法后，这个新方法还会添加到这个类的子类当中去，一个类可以增加多个类别，这些类别都可增加原有类的方法 类别的用法： 对类进行模块化设计 使用类别调用私有方法 使用类别实现非正式协议 扩展与类别相似，扩展相当于匿名类别 @interface 已有类() @end 但就用法来看，类别通常有单独的.h和.m文件，扩展则用于临时对某个类的接口进行扩展，类实现部分同时实现类接口部分定义的方法和扩展中定义的方法，在定义类的扩展时，可以额外增加实例变量，也可以使用@property来合成属性，但定义类的类别时，则不允许额外定义实例变量，也不能用@property合成属性 协议(protocol)与委托(delegate)协议定义的是多个类共同的公共行为规范，这些行为是与外部交流的通道，这就意味着协议里通常是定义一组公共方法，但不会为这些方法提供实现，方法的实现交给类去完成，即委托该类去调用方法完成任务。 利用类别可以实现非正式协议，这种类别以NSObject为基础，为NSObject创建类别，创建类别即可指定该类别应该新增的方法。当某个类实现NSObject的该类别时，就需要实现该类别下的所有方法，这种基于NSObject定义的类别即可认为是非正式协议。需要指出的是，对于实现非正式协议的类而言，OC编译器并不强制实现该协议中的所有方法，但如果不实现，运行时该程序就会引起错误 正式协议不再使用@interface、@implementation关键字，而是使用@protocol关键字@protocol协议名&lt;父协议1，父协议2&gt;{} 协议名应与类名有相同的命名规则，一个协议可以有多个直接父协议，协议定义的方法只有方法签名，没有方法实现，可包含类方法和实例方法 如果需要使用协议来定义变量，则有如下两种语法： NSObject&lt;协议1，协议2&gt; \*变量=\*\*\*; id&lt;协议1，协议2&gt; 变量=\*\*\*; 对比正式协议和非正式协议，不难发现存在如下差异 非正式协议通过NSObject创建类别来实现，而正式协议则直接使用@protocol创建 遵守非正式协议通过继承带特定类别的NSObject来实现，而遵守正式协议则有专门的OC语法 遵守非正式协议不要求实现协议中定义的所有方法，而遵守正式协议则必须实现协议中定义的所有方法 为了弥补正式协议必须实现协议的所有方法造成的灵活性不足，OC2.0新增了optional和required两个关键字 使用@try处理异常OC的异常机制并不作为常规的编程实践，通常只是作为一种程序调试排错机制 @try { 代码操作; } @catch (异常1 ex) { ex.name; ex.reason; ex.userInfo; } @catch (异常2 ex) { } @finally { 回收资源; } 如果在某些时候，某些数据与业务规则不匹配，系统无法抛出这种异常，则需要在程序中使用@throw语句自行抛出异常，也可以抛出继承于NSException的自定义异常来@catch OC反射机制OC提供了3种编程方式与运行环境交互 直接通过OC的源代码 通过NSObject类中定义的方法进行动态编程 直接调用运行时函数进行动态编程 在OC中获得Class的方式有3种 使用Class NSClassFromString(NSString \*className) 调用某个类的class方法来获取该类对应的Class 调用某个对象的Class方法来获取该类对应的class 检查继承关系： -isKindOfClass -isMemberOfClass conformsProtocol:@protocol(ProtocolName)/NSProtocolFromString(ProtocolName) 如果需要调用类中的变量，则可根据KVC机制来设置，访问 如果程序需要判断某个对象是否可调用某个方法，可通respondsToSelector:@selector(selectorName)/NSSelectorFromString(selectorName)来判断 如果程序需要动态调用对象的普通方法，则可通过几种方式来实现 [self performSelector:@selector(selectorName)/NSSelectorFromString(selectorName) withObject:] objc_msgSend(self, @selector(selectorName)/NSSelectorFromString(selectorName), …) IMP方法的函数指针 -(IMP)methodForSelector:@selector(selectorName)/NSSelectorFromString(selectorName) double (*addSpeed)(id, SEL, double); 返回值类型 (*指针变量名)(方法调用者, 方法， 方法参数); addSpeed = (double(*)(id, SEL, double))[car methodForSelector:NSSelectorForString(@“addSpeed:”)]; double speed = addSpeed(car, @selector(addSpeed:), 2.4); 在开发了大量iOS项目之后，就会发现有大量代码是类似的，如果把这些通用的代码抽取成为更通用的框架，那么程序将会拥有更好的架构，当需要开发出那些具有通用性质的框架时，这些框架代码无法预先知道被调用组件的实现类，以及具有哪些方法，这些信息可能是通过配置文件给的，而这些框架必须动态地根据字符串来创建对象，根据字符来决定要初始化哪个类，调用哪个方法，这些功能都必须借助OC的反射、动态机制来实现。 手动内存管理如果一直在分配内存，而没有回收他们，就会出现内存泄露。OC的内存回收机制有3种 手动引用计数和自动释放池 自动引用计数(ARC) 自动垃圾回收(Mac应用独有) OC采用一种被称为引用计数（Reference Counting）的机制来跟踪对象的状态，每个对象都有一个与之关联的整数，被称为引用计数 当程序调用方法名以alloc、new、copy、mutableCopy开头的方法来创建对象时，该对象的引用计数加1 调用对象的retain方法时，该对象的引用计数加1，调用对象的release方法时，引用计数减1，当引用计数为0时，系统自动dealloc销毁 -autorelease：不改变该对象的引用计数的值，只是将该对象添加到自动释放池中 -retainCount返回该对象的引用计数的值 所谓自动释放池，就是一个存放对象的容器，自动释放池会保证延迟释放该池中所有的对象。-(id)autorelease:添加到自动释放池中 NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; [pool release]; 对于Foundation框架中的类而言，当调用方法创建对象时，只要这些方法不是以alloc，new，copy，mutableCopy（本来不会自动释放）开头的，系统就会默认创建自动释放对象，当自动释放池释放时，该对象就被自动释放，可称之为临时对象 在iOS的事件循环时，步骤1，创建自动释放池 2创建事件处理方法 3销毁自动释放池 4处理完成，所以在iOS事件循环中，应避免临时对象的出现，或通过如下方式避免事件结束时对象被回收 在将临时对象赋值之前，先调用临时对象的retain方法将它的引用计数加1 把临时对象赋值给retain、strong或copy指示符修饰的属性 手动内存管理的规则总结： 调用对象的release方法并不是销毁该对象，而是将该对象的引用计数减1，当一个对象的引用计数为0时，系统自动调用dealloc来销毁 当自动释放池被回收时，自动释放池会依次调用每个对象的release方法，如果release后引用计数为0则销毁，否则该对象可以活下来 程序使用以alloc，new，copy，mutableCopy开头的方法创建对象，该对象引用计数为1，当不再使用，需release或autorelease 如果使用retain方法为对象增加过引用计数，则需要调用release来减少该对象的引用计数，并保证retain次数和release次数相等 如果在自动释放池中创建了一个临时对象，则系统会自动回收该对象，如果程序需要保留此对象，则需手动调用retain来增加引用计数 Foundation框架详解字符串(NSString与NSMutableString)- (NSString *)substringFromIndex:(NSUInteger)from;- (void)getCharacters:(unichar *)buffer range:(NSRange)range;- (BOOL)hasSuffix:(NSString *)str;- (NSRange)rangeOfString:(NSString *)searchString;- (NSString *)stringByAppendingString:(NSString *)aString;- (NSString *)uppercaseStringWithLocale:(nullable NSLocale *)locale;- (NSArray&lt;NSString *&gt; *)componentsSeparatedByString:(NSString *)separator;- (void)replaceCharactersInRange:(NSRange)range withString:(NSString *)aString;- (nullable id)initWithContentsOfFile:(NSString *)path; 日期与时间NSDate: - [NSDate date]- [[NSDate alloc] initWithTimeIntervalSinceNow:]- [NSDate dateWithTimeIntervalSince1970]- [date timeIntervalSinceDate:]- [date timeIntervalSinceNow:] NSDateFormatter: - [NSDateFormatter setDateFormat:]- [NSDateFormatter stringFromDate:]- [NSDateFormatter dateFromString:] NSDateComponents(日期组件)和NSDate之间可以通过NSCalendar进行相互转换，它包括如下两个方法： - (NSDateComponents \*)components:(指定年月日)fromDate:- (NSDate \*)dateFromComponents: NSTimer: - [NSTimer scheduledTimerWithTimeInterval:invocation:repeats:]- [NSTimer scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:] NSInvocation对象也是封装target和selector的 对象复制NSObject类提供了copy和mutableCopy方法来复制已有对象的副本，copy方法返回该对象的不可修改的副本，mutableCopy返回该对象可修改的副本，如果是自定义类，则必须实现NSCopying或NSMutableCopying协议的copyWithZone:或mutableCopyWithZone:方法 如果程序只复制指针的地址而不是复制指针所指的对象，称之为浅度复制，深度复制不仅会复制对象本身，且会递归复制每个指针类型的属性，直到两个对象没有任何共用的部分，一般来说，深度复制的实现难度大很多，Foundation框架中的类大部分都只实现了浅复制。 setter方法的复制选项可以使用copy指示符，即 - (void)setName:(NSMutableString \*)name { name = [name copy]; } OC集合概述OC集合大致分为NSArray，NSSet和NSDictionary 数组(NSArray与NSMutableArray)数组代表元素有序、可重复的一个集合，集合中每个元素都有其对应的顺序索引 - array:- arrayWithContentsOfFile:- initWithContentsOfFile:- arrayWithObject/s:- initWithObject/s: NSArray如何判定集合是否包含指定元素？只有某个集合元素与被查找元素通过isEqual方法比较返回YES时，认为包含该元素 NSArray可以对集合中所有的元素或部分元素整体调用方法 - [array makeObjectsPerformSelector:]- [array makeObjectsPerformSelector:withObject:]- [array enumerateObjects/WithOptions:UsingBlock:]- [array enumerateObjectsAtIndexes:options:usingBlock:]- [array sortedArrayUsingFunction:context:/UsingSelector:/UsingComparator:] 使用枚举器遍历 - [array objectEnumerator]- [array reverseObjectEnumerator]- [en allObjects]- [en nextObject] NSArray允许KVC编码 - setValue:forKey:(全部修改)- (NSArray *)valueForKey: NSArray支持KVO监听 - addObserver:forKeyPath:options:context:- removeObserver:forKeyPath:- addObserver:toObjectsAtIndexPath:forKeyPath:options:context:- removeObserver:fromObjectsAtIndexes:forKeyPath: 集合(NSSet与NSMutableSet)NSSet集合里多个对象之间没有明显的顺序，且每个元素不会相同 - setByAddingObject:- setByAddingObjectsFromSet:- setByAddingObjectsFromArray:- allObject:- anyObject:- containsObject:- member:(判断该集合是否包含与该参数相等的元素)- objectsPassingTest:(参数为一个代码块，选出满足该代码块条件的集合元素)- objectsWithOptions:passingTest:(与前者功能相似，只是额外传入一个NSEnumerationOptions迭代参数选项，NSArray也提供了这两个方法，只不过这些方法返回的是符合条件的集合元素的索引组成的NSIndexSet集合)- isSubsetOfSet:- intersectsSet:- isEqualToSet: NSSet判断两个元素相等的标准 两个对象通过isEqual方法比较返回YES 两个对象的hash方法返回值相等 hash方法的基本规则 同一个对象多次调用hash方法返回相同的值 如果isEqual方法返回YES，则hash返回值也应该相等 对象中作为isEqual方法比较标准的成员变量，都应该用来计算hashcode值 NSSet 包含的常用方法有： - addObject:- removeObject:- removeAllObjects:- addObjectsFromArray:- unionSet:- minusSet:- intersectSet: NSCountedSet 是 NSMutableSet 的子类，它为每个元素额外维护一个添加次数的标记 - countForObject: 有序集合(NSOrderedSet与NSMutableOrderedSet)NSOrderedSet既不允许元素重复，又可以保持顺序添加 字典(NSDictionary与NSMutableDictionary)NSDictionary用于保持具有映射关系的数据，因此，NSDictionary集合里保存着两组值，一组用于保存NSDictionary里的key，另一组用户保存NSDictionary里的value，key和value都可以是任何引用类型的数组，Map的key不允许重复 - dictionary:- dictionaryWithContentsOfFile:- initWithContentsOfFile:- dictionaryWithDictionary:- dictionaryWithObject:forKey:- dictionaryWithObjects:forKeys:- dictionaryWithObjectsAndKeys:- count:- allKeys:- allKeysForObject:(指定该对象对应的全部key)- allValues:- objectForKey:- objectForKeyedSubscript:(允许NSDictionary通过下标方法来获取指定key对应的value)- valueForKey:- keyEnumerator:- objectEnumerator:- enumerateKeysAndObjectsUsingBlock:迭代执行集合中的所有键值对- enumerateKeysAndObjectsWithOptions:usingBlock:- writeToFile:atomically- (NSArray *)keysSortedByValueUsingSelector:- keysSortedByValue/WithOptions:UsingComparator:- (NSSet *)keysOfEntriesPassingTest:(key, value, isEnumerator)使用代码块处理，对key过滤，第一个是key，第二个是value，第三个是是否还需要继续迭代，如果为NO，则会立即停止迭代- (NSSet *)keysOfEntriesWithOptions:passingTest: 如果使用自定义类作为NSDictionary的key值，则自定义类必须满足两个要求 正确重写过isEqual:和hash方法 实现了copyWithZone方法，即继承了NSCopying协议，因为为了保持NSDictionary的键值不被破坏，NSDictionary总会先调用该key的copy方法来复制该对象的不可变副本 NSMutableDictionary中常用的方法有: - setObject:forKey:- setObject:forKeyedSubscript:- addEntriesFromDictionary:- setDictionary:- removeObjectForKey:- removeAllObjects:- removeObjectsForKeys: 谓词NSPredicate用于定义一个逻辑条件，通过该条件可以执行搜索或内存中的过滤操作 三个子类：NSComparisonPredicate/NSCompoundPredicate/NSExpresion - [NSPredicate predicateWithFormat:]- [predicate predicateWithSubstitutionVariables:]//为占位符参数设置参数值- [predicate evaluateWithObject:] 使用谓词过滤不可变集合时，方法将会返回符合条件的集合元素组成的新集合，过滤可变集合时，方法直接删除不符合谓词条件的元素 在NSArray中的用法: (NSArray)filteredArrayUsingPredicate:(返回符合条件的元素组成的心数组) NSMutableArray: -filterUsingPredicate:使用指定的谓词过滤NSArray集合，删除不符合条件的元素 NSSet: -(NSSet)filteredSetUsingPredicate: NSMutableSet: -filterUsingPredicate: 如果需要在谓词表达式中使用变量,则可以在谓词表达式中使用占位符参数,参数支持三个占位符参数 %K动态传入属性名 %@动态设置属性值 $SUBSTR设置变量 [NSPredicate predicateWithFormat:@“%K contains %@”, @“name”, @“value”]; [NSPredicate predicateWithFormat:@“%K contains $SUBSTR”, @“name”]; [predicate predicateWithSubstitutionVariables:[NSDictionary dictionaryWithObjectsAndKeys:@“1”,@“SUBSTR”]; [predicate evaluateWithObject:substitutionVariables:[NSDictionary dictionaryWithObjectsAndKeys:]; 谓词表达式由表达式、运算符和值组成 比较运算符： =/==/&gt;=/=&gt;/&lt;=/=&lt;/&gt;/&lt;/!=/&lt;&gt;/BETWEEN 逻辑运算符： AND/&amp;&amp;/OR/||/NOT/! 字符串比较运算符： BeginWith/EndWith/CONTAINS/LIKE(\*代表任意多个字符，?代表一个字符)/MATCHES 操作集合运算符 ANY/SOME/ALL/NONE/IN 直接量 FALSE/NO/TRUE/YES/NULL/NIL/SELF 保留字 FIRST/LAST/SIZE/ANYKEY/CAST/TruePredicate/FalsePredicate 文件I/O使用NSData与NSMutableDataNSData与NSMutableData代表OC的数据缓冲区，可以通过类的方法来创建，也可以通过实例的方法来创建 - [NSData data]- [NSData dataWithBytes:length:]- [[NSData alloc] initWithBytes:length:]- [NSData dataWithBytesNoCopy:length:]- [[NSData alloc] initWithBytesNoCopy:length] //NSData销毁自己时程序会释放该数组- [NSData dataWithBytesNoCopy:length:freeWhenDone] freeWhenDone为YES，销毁自己时程序会释放该数组- [NSData dataWithContentsOfFile:]- [[NSData alloc] initWithContentsOfFile] 根据文件内容来初始化NSData- [NSData dataWithContentsOfURL:]- [[NSData alloc] initWithContentsOfURL] 根据URL关联的内容初始化NSData- [NSData dataWithData:]- [[NSData alloc] initWithData:] 使用NSData初始化另一个NSData- bytes 返回NSData所包含的数据- getBytes:length 获取NSData所包含的指定长度的数据并将其写入byte数组- getBytes:range 获取NSData所包含的指定范围的数据并将其写入byte数组- subdataWithRange 获取指定范围的NSData对象- writeToFile:atomically 将NSData的数据写入文件- writeToURL:atomically 将NSData的数据写入URL对应的资源 使用NSFileManager管理文件和目录绝对路径：以斜线开头的路径 相对路径：不以斜线开头的路径 ~代表当前用户的home路径 .代表当前目录 ..代表上一级目录 - fileExistsAtPath: 文件是否存在- fileExistsAtPath:isDirectory: 后一个参数返回是否为目录- isReadable/Writable/Executable/DeletableFileAtPath: 判断文件是否可读，可写，可执行，可删除- componentsToDisplayForPath: 获取文件的各个路径组件- displayNameAtPath: 获取文件的简单文件名- attributesOfItemAtPath:error: 获取文件属性- attributesOfFileSystemForPath:error: 获取文件系统的属性- contentsAtPath: 获取指定的路径的NSData内容- contentsEqualAtPath:andPath: 判断两个文件内容是否相同- createDirectoryAtURL:withIntermediateDirectories:attributes:error:根据指定的URL创建目录- createDirectoryAtPath:withIntermediateDirectories:attributes:error: 根据路径创建目录，父目录不存在则创建- createFileAtPath:content:attributes: 根据指定的路径、内容、属性创建文件- removeItemAtURL:error:- removeItemAtPath:error:- copyItemAtURL:toURL:error:- copyItemAtPath:toPath:error:- moveItemAtURL:toURL:error:- moveItemAtPath:toPath:error:- (NSArray&lt;NSString&gt;)contentsOfDirectoryAtPath:error: 获取指定目录下的所有文件和子目录，对于子目录，不会递归枚举- (NSDirectoryEnumerator)enumeratorAtPath: 获取指定目录下的文件和子目录枚举器，调用skipDescendants阻止递归子目录- (NSArray&lt;NSString&gt;)subpathsOfDirectoryAtPath:error: 递归获取指定路径包含的所有目录及子目录- subpathsAtPath: 使用NSPathUtilities.h管理路径NSPathUtilities.h对NSString类扩展了如下方法: - +pathWithComponents:components: 根据components中的元素构造有效的路径- pathComponents:- isAbsolutePath:- lastPathComponent:- pathExtension:- stringByAbbreviatingWithTildeInPath: 将路径中当前用户的home路径替换为~，将路径中用户的home路径替换为~user形式,Abbreviating简写，Tilde波浪符- stringByAppendingPathComponent:path:- stringByAppendingPathExtension:ext:- stringByDeletingLastPathComponent:- stringByDeletingPathExtension:- stringByExpandingTildeInPath: 将~和~user替换为绝对路径- stringByResolvingSymlinksInPath: 解析路径中的符号链接，返回解析后的路径- stringByStandardisingPath 解析路径中的~/./..，返回解析后的路经，standardising解析- NSUserName()- NSFullUserName()- NSHomeDirectory()- NSHomeDirectoryForUser(user)- NSTemporaryDirectory() 使用NSProcessInfo获取进程信息NSProcessInfo info = [NSProcessInfo processInfo]; - info.arguments 程序运行时传入的参数- environment 环境变量- processIdentifier 进程标识符- globallyUniqueString 进程的全局唯一子串- processName 进程名- hostName 主机名- operatingSystemVersion 操作系统版本- operatingSystemVersionString 操作系统版本号- isOperatingSystemAtLeastVersion 操作系统版本是否不低于给定版本- physicalMemory 系统物理内存- processorCount CPU数量- activeProcessorCount 激活状态的CPU数量- systemUptime 系统已运行的时间 使用NSFileHandle处理文件IONSFileHandle没有创建文件的功能，它提供了处理文件IO的相关方法 +fileHandleForReadingAtPath: +fileHandleForReadingFromURL:error: +fileHandleForWritingAtPath: +fileHandleForWritingToURL:error: +fileHandleForUpdatingAtPath: +fileHandleForUpdatingURL:error: `+fileHandleWithStandardError/Input/Output/NullDevice:1 (标准输入，即键盘，标准输出，即屏幕) -fileDescriptor: -availableData: -readDataToEndOfFile: -readDataOfLength:length: -writeData: -offsetInFile: -seekToEndOfFile: -seekToFileOffset:offset: -closeFile: -truncateFileAtOffset:offset 使用NSURL读取网络资源URL(Uniform Resource Locator)对象代表统一资源定位器，它是指向互联网资源的指针.通常为scheme://host:port/path 使用NSBundle处理项目相关资源如果应用使用绝对或相对路径地址去访问文件，则会导致程序的可移植性降低，可以把项目资源文件放在应用中，让应用自己包含这些资源文件，接下来就可以使用NSBundle来访问这种应用包含的资源文件了。NSBundle *bundle = [NSBundle mainBundle]; - URLForResource:withExtension:subdirectory:- URLForResource:withExtension:- pathForResource:ofType:- URLsForResourcesWithExtension:subdirectory:- pathForResource:ofType:inDirectory:- pathsForResource:ofType:inDirectory:- resourcePath: 返回该NSBundle的子目录所包含资源的完整路径 对象归档所谓对象归档，就是类似于其他语言的序列化机制，归档就是用某种格式把一个或多个对象保存到指定文件中，方便以后从文件中恢复他们。 +(NSData \*)archivedDataWithRootObject: +(BOOL)archiveRootObject:toFile: +(id)unarchiveObjectWithData: +(id)unarchiveObjectWithFile: 如果需要将自定义的类进行归档和解档操作，则自定义类必须实现NSCoding协议，两个方法 -encodeWithCoder: -initWithCoder: 可以结合NSData完成很多对象的自定义归档 NSKeyArchiver \*arch = [NSKeyArchiver alloc] initForWritingWithMutableData:[NSMutableData data]]; [arch encodeObject:forKey:]; [arch finishEncoding]; [data writeToFile:]; NSKeyUnarchiver \*un = [[NSKeyUnarchiver alloc] initForReadingWithData:[NSData dataWithContentsOfFile:]] [un decodeObjectForKey:]; [un finishDecoding]; 可以利用归档来完成对象的深度复制 NSData *data = [NSKeyedArchiver archiveDataWithRootObject:dict]; NSDictionary *dicCopy = [NSKeyedArchiver unarchiveObjectWithData:data]; iOS应用开发入门从iOS项目开始 Xcode工作区左侧的导航图标的快捷键是command+1/2; 工作区右侧的视图图标的快捷键是command+option+1/2; 对象库面板的快捷键是control+option+command+1; 每个Scene下边都有first response和View controller MVCMVC是所有面向对象程序设计语言都应该遵守的规范，MVC思想将一个应用分成三个基本部分：Model(模型),View(视图)和Controller(控制器)，这三个部分以最少的耦合协同工作，从而提高应用的可扩展性和可维护性。 事件机制程序获取控件的两种方式：1，通过IBOutlet获取 2，通过Tag属性获取 iOS应用常见的事件处理机制有三种 通过IBAction绑定控件的特定事件 通过程序为UI控件绑定事件 自带的delegate回调事件 storyboard控制UI界面代码控制UI界面 -initWithFrame -initWithCoder -drawRect -layoutSubviews -didAddSubview -willRemoveSubview -willMoveToSuperview -didMoveToSuperview -willMoveToWindow -didMoveToWindow -touchesBegan:withEvent -touchesMoved:withEvent -touchesEnded:withEvent -touchesCancelled:withEvent 美化iOS应用]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git的基本使用]]></title>
    <url>%2F2014%2F02%2F28%2Fgit%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本篇文章是建立在技术大牛“偶尔的网事”的一篇博客的基础上的,然后对其做了一些优化和扩展 GIT入门 Git是神马？ 一个开源的分布式版本控制系统，可以有效的高速的控制管理各种从小到大的项目版本。他的作者就是大名鼎鼎的Linux系统创始人Linus。 分布式又是神马？ 集中式就是把版本库集中放在某个中央服务器上（可以是局域网），然后每个人每次要使用时跟服务器进行通信 分布式和集中式最大的区别就是它没有中央服务器这么一说，每台电脑都是一个服务器，每台电脑都拥有一个完整的版本库 Git经典的开发流程 其它版本控制系统 Git的安装 Git的使用 设置用户名和Email git config –global user.name “Your Name” git config –global user.email “YourEmail@example.com“ 或：修改.git\config [user] name = YourName emai= YourEmail@example.com GIT概念 分支（Braches） 一个分支意味着它是一个独立拥有自己历史版本信息的代码线。你可以从已有的代码中生成一个新的分支，这个分支与其余的分支完全独立。默认的分支叫做master。用户可以选择一个分支，选择一个分支叫做Checkout. 提交（Commit） 当你提交你的更改到Git库中，它将创建一个新的提交对象。这个提交对象会有一个新版本的唯一标识。本次修订后，可以检索，例如，如果你想看到一个旧版本的源代码。每个提交对象中都会包含修改者和提交者，从而有可以确定是谁做了改变。修改者和提交者，可以是不同的人。 头（HEAD） 头是一个象征性的参考，最常用以指向当前选择的分支。 仓库（Repository） 仓库包含了随着时间的推移和各种不同的分支和标签不同版本历史。在Git仓库的每个副本是一个完整的信息库。你可以从仓库中获取你的工作副本. 修订（Revision） 表示代码的一个版本状态。Git通过用SHA1 hash算法表示的ID来标识不同的版本。每一个 SHA1 ID都是160位长，16进制标识的字符串。 标记（Tags） 标记指的是某个分支某个特定时间点的状态。通过标记，可以很方便的切换到标记时的状态。 URL URL决定了仓库所在的位置。 工作树/区（Working tree） 工作区中包含了仓库的工作文件。您可以修改的内容和提交更改作为新的提交到仓库。 暂存区（Staging area） 暂存区是工作区用来提交更改（commit）前可以暂存工作区的变化。暂存区包含了工作区的一系列更改快照，这些快照可以用来创建新的提交。 索引（Index） 索引是暂存区的另一种术语。 工作区，暂存区和版本库的关系 工作区(添加选择的改变/git add)-&gt;暂存区(提交改变/git commit)-&gt;版本库 一些常用的git指令 add Add file contents to the index bisect Find by binary search the change that introduced a bug branch List, create, or delete branches checkout Checkout a branch or paths to the working tree clone Clone a repository into a new directory commit Record changes to the repository diff Show changes between commits, commit and working tree, etc fetch Download objects and refs from another repository grep Print lines matching a pattern init Create an empty Git repository or reinitialize an existing one log Show commit logs merge Join two or more development histories together mv Move or rename a file, a directory, or a symlink pull Fetch from and integrate with another repository or a local branch push Update remote refs along with associated objects rebase Forward-port local commits to the updated upstream head reset Reset current HEAD to the specified state rm Remove files from the working tree and from the index show Show various types of objects status Show the working tree status tag Create, list, delete or verify a tag object signed with GPG 创建仓库 创建一个空目录 《git init》用于初始化版本仓库 进入d盘目录 $ cd /d 创建JackyGit文件夹 $ mkdir JackyGit 进入JackyGit文件夹 $ cd JackyGit #显示当前所在路径 $ pwd 创建Git仓库 初始化当前目录作为Git仓库 $ git init Initialized empty Git repository in d:/JackyGit/.git/ 添加文件到仓库中 创建JackyDir目录 $ mkdir JackyDir 添加JackyData.txt $ touch JackyDir/JackyData01.txt 添加JackyData01，并把当前目录信息输入 $ ls&gt;Jackydata01 添加JackyData02，并输入HelloJacky $ echo “HellloJacky” &gt;JackyData02 添加JackyData02，并输入HiJacky $ echo “HiJacky” &gt; JackyData03 看一下当前Git仓库的状态吧 《git status》用于显示当前版本库状态 确认当前git仓库状态，可以看到untracked文件和目录为红色（高亮） $ git status # On branch master # # Initial commit # # Untracked files: # (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) # # JackyData02 # JackyData03 # JackyDir/ # Jackydata01 nothing added to commit but untracked files present (use &quot;git add&quot; to track) 增加文件到暂存区 《git add 文件》用于添加文件到暂存区 增加所有文件到暂存区 $ git add . 再看一下当前Git仓库的状态 确认当前git仓库状态，可以看到变成了待提交的更改，文件和目录也变为绿色（高亮） $ git status # On branch master # # Initial commit # # Changes to be committed: # (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) # # new file: JackyData02 # new file: JackyData03 # new file: JackyDir/JackyData.txt # new file: Jackydata01 提交更改 《git commit -m “提交信息”》用于提交更改 “init AddFiles”是本次提交的注释，4个文件被改变，4个新插入 $ git commit -m &quot;init AddFiles&quot; [master (root-commit) aea0365] init AddFiles 4 files changed, 4 insertions(+) create mode 100644 JackyData02 create mode 100644 JackyData03 create mode 100644 JackyDir/JackyData.txt create mode 100644 Jackydata01 再看一下状态没意见吧 在主分支上没东西可以提交了，工作目录是干净的 $ git status # On branch master nothing to commit, working directory clean 注意 回车(CR, ASCII 13, \r) ，换行(LF, ASCII 10, \n)。这两个ACSII字符不会在屏幕有任何输出，但在Windows中广泛使用来CRLF（回车换行）标识一行的结束。而在Linux/UNIX系统中只有LF（换行符）。 操作项目 查看操作日记 《git log》用于查看操作日记详情。因为Git是分布式的，采用SHA1这样的版本号可有效的防止版本冲突 查看操作日记，底下那串长长的数据就是SHA1 ID，表示当前版本号 $ git log commit aea0365712908805bc28540b4db9fd2f15360a8b Author: Jacky &lt;fusijie@vip.qq.com&gt; Date: Fri Sep 27 15:15:48 2013 +0800 init AddFiles 修改项目内容 修改JackyData01内容 $ echo &quot;HelloGit&quot; &gt; JackyData01 查看当前状态 查看版本库状态，可以看到红色的JackyData01被修改过 $ git status # On branch master # Changes not staged for commit: # (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) # (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) # # modified: Jackydata01 # no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 提交修改 这里使用《git commit -a -m “提交信息”》可以省掉先放到暂存区的操作，直接提交。 直接提交修改 $ git commit -a -m &quot;modify JackyData01&quot; [master cba8800] modify JackyData01 1 file changed, 1 insertion(+), 2 deletions(-) 查看操作日记 还用《git log》，不过这次我们给它添加一个参数，这样浏览起来会方便很多。 单行显示，只显示版本号和备注 $ git log --pretty=oneline cba8800f2daaf4075a506b6d763798ea15ba11cc modify JackyData01 aea0365712908805bc28540b4db9fd2f15360a8b init AddFiles 查看不同 《git diff》用于比较上一次提交和当前版本的差异。 修改JackyData02的内容为HelloGit $ echo “HelloGit” &gt; JackyData02 使用Git diff查看差异，可以看到HelloJacky被删除了，而HelloGit被添加了 $ git diff diff --git a/JackyData02 b/JackyData02 index 85d5336..1da19b8 100644 --- a/JackyData02 +++ b/JackyData02 @@ -1 +1 @@ -HellloJacky +HelloGit 提交修改并打开Git GUI界面 《gitk –all》用于打开Git的GUI界面 提交修改 $ git add . &amp;&amp; git commit -m &quot;modify JackyData02&quot; [master a5f6601] modify JackyData02 1 file changed, 1 insertion(+), 1 deletion(-) 打开GUI界面 $ gitk --all 修改提交信息 使用《git commit –amend》可以修改上次提交的信息。 重新修改上次提交信息 $ git commit --amend -m &quot;amend modify JackyData02&quot; [master a25c588] amend modify JackyData02 1 file changed, 1 insertion(+), 1 deletion(-) 最后一次的提交信息被修改 $ git log --pretty=oneline a25c58804cb3f4045564fc0ec6a4e6eb4dae7072 amend modify JackyData02 cba8800f2daaf4075a506b6d763798ea15ba11cc modify JackyData01 aea0365712908805bc28540b4db9fd2f15360a8b init AddFiles 删除项目内容 删除了某一项版本控制下的内容，使用《git add .》无法在索引中删除该文件。需使用《git commit -a -m “提交信息”》或者《git add -A . git commit -m “提交信息”》才能达到删除的目的。 移除JackyData03文件 $ rm JackyData03 使用git add . 提示警告，同时调用git status，发现并没有正常提交 $ git add . &amp;&amp; git commit -m &quot;remove JackyData03&quot; warning: You ran &apos;git add&apos; with neither &apos;-A (--all)&apos; or &apos;--ignore-removal&apos;, whose behaviour will change in Git 2.0 with respect to paths you removed. Paths like &apos;JackyData03&apos; that are removed from your working tree are ignored with this version of Git. * &apos;git add --ignore-removal &lt;pathspec&gt;&apos;, which is the current default, ignores paths you removed from your working tree. * &apos;git add --all &lt;pathspec&gt;&apos; will let you also record the removals. Run &apos;git status&apos; to check the paths you removed from your working tree. # On branch master # Changes not staged for commit: # (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed) # (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) # # deleted: JackyData03 # no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 使用git commit -a -m 提交删除 $ git commit -a -m &quot;remove JackyData03&quot; [master c5c83cf] remove JackyData03 1 file changed, 1 deletion(-) delete mode 100644 JackyData03 版本管理 版本回退 git reset用于版本回退，首先我们必须先知道当前版本是哪个，git用HEAD来表示当前版本。HEAD^表示上一个版本，HEAD^^表示上上个版本，HEAD~100表示往前100个版本 回退到上一个版本 $ git reset --hard HEAD^ HEAD is now at a25c588 amend modify JackyData02 注意： –hard参数会把源码也给回退到指定版本，如果不用–hard，源码不会修改，只会回退，这时候如果想回退源码，需要再用git checkout命令恢复。 reset只对本地仓库有效，而对远程仓库无效。如果要reset远程版本，可以这么做： 先不要在本地reset，而是先创建一个分支old_master，并切换到old_master分支。 push old_master分支到远程仓库。 在old_master分支上reset版本，并删除本地的master分支和远程的master分支。 创建本地分支master，推送到远程分支master，此时远程分支会新建master。 删除本地old_master分支和远程old_master分支。 以上操作都是属于比较危险的操作，需谨慎处理。 版本选择 $ git reflog c5c83cf HEAD@{0}: reset: moving to c5c83c a25c588 HEAD@{1}: reset: moving to HEAD^ c5c83cf HEAD@{2}: commit: remove JackyData03 a25c588 HEAD@{3}: commit (amend): amend modify JackyData02 a5f6601 HEAD@{4}: commit: modify JackyData02 cba8800 HEAD@{5}: commit: modify JackyData01 aea0365 HEAD@{6}: commit (initial): init AddFiles 还是使用reset，直接选择要切换的版本号 $ git reset --hard c5c83c HEAD is now at c5c83cf remove JackyData03 撤销修改 工作区 git checkout –file可以撤销工作区的修改 撤销JAckydata01的改动$ git checkout – Jackydata01 看一下当前Git仓库的状态，干净的 $ git status On branch master nothing to commit, working directory clean 暂存区 撤回到工作区的修改 $ git reset HEAD Jackydata01 Unstaged changes after reset: M Jackydata01 已提交到版本库 如果已经提交到版本库，那么使用1.版本回退功能吧 其他撤销指令 其他撤销指令诸如git clean和git revert请自行尝试。 远程仓库 创建一个本地远程仓库 使用git clone –bare来创建一个本地远程仓库。 1个点表示当前目录，2个点表示父目录 $ git clone --bare . ../remote-jackygit.git Cloning into bare repository &apos;../remote-jackygit.git&apos;... done. 推送更改到远程仓库 使用git push推送到远程仓库 修改Jackydata01 $ echo &quot;HelloRemoteJackyRepo&quot; &gt; JackyData01 提交更改 $ git commit -a -m &quot;modify to remotejackyrepo&quot; [master e14f4a3] modify to remotejackyrepo 1 file changed, 1 insertion(+), 1 deletion(-) 推送到远程仓库 $ git push ../remote-jackygit.git Counting objects: 5, done. Delta compression using up to 2 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 282 bytes | 0 bytes/s, done. Total 3 (delta 1), reused 0 (delta 0) To ../remote-jackygit.git 03150c9..e14f4a3 master -&gt; master 添加远程仓库 添加一个远程仓库，取名为testremote $ git remote add testremote ../remote-jackygit.git 查看远程仓库信息 这里使用git remote，git remote -v和git remote show即可。 查看远程仓库 $ git remote testremote 查看远程仓库详细信息 $ git remote -v testremote ../remote-jackygit.git (fetch) testremote ../remote-jackygit.git (push) 查看远程仓库详细信息 $ git remote show testremote * remote testremote Fetch URL: ../remote-jackygit.git Push URL: ../remote-jackygit.git HEAD branch: master Remote branch: master tracked Local ref configured for &apos;git push&apos;: master pushes to master (up to date) 克隆仓库 把一个远程仓库克隆到本地,，还是一样使用git clone命令。 返回上级目录 $ cd .. 新建jackygit2目录 $ mkdir jackygit2 进入jackygit2目录 $ cd jackygit2 将远程仓库克隆到当前目录（jackygit2） $ git clone ../remote-jackygit.git . Cloning into &apos;.&apos;... done. Push和Pull （1）Push：jackygit先将修改内容推送给远程仓库。 修改JackyData01内容 $ echo “Hi Jackygit2” &gt;jackydata01 提交更改 $ git commit -a -m &quot;hi jackygit2&quot; [master 6937dbd] hi jackygit2 1 file changed, 1 insertion(+), 1 deletion(-) 推送到远程仓库，这里就可以直接使用testremote $ git push testremote Counting objects: 5, done. Delta compression using up to 2 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 267 bytes | 0 bytes/s, done. Total 3 (delta 1), reused 0 (delta 0) To ../remote-jackygit.git 8ad0c22..6937dbd master -&gt; master （2）Pull：jackygit2从远程仓库中拉取最新版本。 进入jackygit2目录 $ cd ../jackygit2 拉取远程仓库最新版本 $ git pull origin remote: Counting objects: 5, done. remote: Compressing objects: 100% (2/2), done. remote: Total 3 (delta 1), reused 0 (delta 0) Unpacking objects: 100% (3/3), done. From d:/jackygit2/../remote-jackygit 8ad0c22..6937dbd master -&gt; origin/master Updating 8ad0c22..6937dbd Fast-forward Jackydata01 | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) 查看版本库状态，干净的 $ git status # On branch master nothing to commit, working directory clean 移除远程仓库 移除远程仓库使用git remote rm即可 移除testremote $git remote rm testremote 注意 如果在使用git push的时候，出现如下警告： warning: push.default is unset; its implicit value is changing in Git 2.0 from &apos;matching&apos; to &apos;simple&apos;...... git config --global push.default simple GIT和GITHUB github是神马？ 注册帐号 设置SSH 添加github仓库 $ git remote add git_github git@github.com:fusijie/JackyGit.git $ git remote add http_github https://github.com/fusijie/JackyGit.git 本地库推送到github $ git push -u git_github master 从github克隆到本地 返回上级目录 $ cd .. 新建jackygit3目录 $ mkdir jackygit3 进入jackygit3目录 $ cd jackygit3 从github克隆到本地库 $ git clone git@github.com:fusijie/JackyGit.git Cloning into &apos;JackyGit&apos;... remote: Counting objects: 38, done. remote: Compressing objects: 100% (15/15), done. remote: Total 38 (delta 9), reused 38 (delta 9) Receiving objects: 100% (38/38), done. Resolving deltas: 100% (9/9), done. Checking connectivity... done 分支管理 分支又是神马？ 分支就是一个我们能通过它创建出独立代码副本的东东 显示分支 通过《git branch》可以显示分支，前面带*号的表示当前所在的分支 显示分支 $ git branch * master 创建分支 通过《git branch 分支名》可以创建一个新的分支 创建分支br $ git branch br 切换分支 切换到br分支 $ git checkout br Switched to branch &apos;br&apos; 修改分支内容并提交 修改br分支中的Jackydata01 $ echo &quot;Im in br now&quot; &gt; Jackydata01 提交br分支中的修改 $ git commit -a -m &quot;modify in br&quot; [br 9ad62b7] modify in br 1 file changed, 1 insertion(+), 1 deletion(-) 显示br中Jackydata01内容，成功修改 $ cat jackydata01 Im in br now 返回主分支，确认修改 发现主分支master的内容并无修改，在分支中修改提交内容并不会影响其他分支 #切换到master $ git checkout master Switched to branch &apos;master&apos; #显示br中Jackydata01内容，无修改 $ cat jackydata01 Hi Jackygit2 推送分支到远程仓库 默认情况下，git只会推送已匹配的分支，所以如果新建分支，需要手动推送到远程仓库 #推送br到github的br上，如果不存在则新建，存在则更新 $ git push git_github br:br Counting objects: 5, done. Delta compression using up to 2 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 265 bytes | 0 bytes/s, done. Total 3 (delta 1), reused 0 (delta 0) To git@github.com:fusijie/JackyGit.git * [new branch] br -&gt; br 本地合并分支 使用git merge 分支名来合并分支，不过前提是要先切换到master上，如果在br上合并是没用的 #合并br到主分支上 $ git merge br Updating 6937dbd..9ad62b7 Fast-forward Jackydata01 | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) 合并本地分支到远程分支 #把本地的br分支合并到远程仓库的master中 $ git push git_github br:master Total 0 (delta 0), reused 0 (delta 0) To git@github.com:fusijie/JackyGit.git 61a92ec..be39e3f br -&gt; master 删除分支 删除分支使用《git branch -d 分支名》来删除，如果分支被修改提交过但是没有被合并，那需要使用《git branch -D 分支名》来删除 #删除br分支 $ git branch -d br Deleted branch br (was 9ad62b7). #确认当前分支 $ git branch * master 删除远程分支 #删除远程br分支 $ git push git_github :br To git@github.com:fusijie/JackyGit.git - [deleted] br 显示远程分支 可以使用-a显示所有分支或-r参数来显示远程分支 #显示远程分支 $ git branch -a * master remotes/git_github/master testremote/maste 克隆远程分支到本地 《git checkout -b 分支名》表示本地创建分支并切换到该分支 清理远程分支 git remote prune origin 把本地不存在的远程分支删除 解决冲突 多人协作冲突 （1）修改jackygit2 在jackygit2中修改jackydata01，提交修改并推送到远程仓库（这里使用本地远程仓库）。正常，没问题 #切换到jackygit2本地库，这是远程仓库那节建立的，从本地远程仓库克隆而来 $ cd ../jackygit2 #修改jackygit2/Jackydata01 $ echo &quot;It&apos;s modified in jackygit2&quot; &gt; jackydata01 #提交jackygit2的修改 $ git commit -a -m &quot;jackygit2 modify&quot; [master 15a6406] jackygit2 modify 1 file changed, 1 insertion(+), 1 deletion(-) #推送到远程仓库origin $ git push origin Counting objects: 5, done. Delta compression using up to 2 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 283 bytes | 0 bytes/s, done. Total 3 (delta 1), reused 0 (delta 0) To d:/jackygit2/../remote-jackygit.git c0449de..15a6406 master -&gt; master （2）修改jackygit 切换到jackygit仓库，同样修改jackydata01，提交修改并推送到远程仓库。这时候就出错了，提示有人改过这个文件了。推送不成功。 #切换到jackygit $ cd ../jackygit #修改jackygit/Jackydata01 $ echo &quot;It&apos;s modified in jackygit&quot; &gt;jackydata01 #提交jackygit的修改 $ git commit -a -m &quot;jackygit modify&quot; [master 9ab7206] jackygit modify 1 file changed, 1 insertion(+), 1 deletion(-) 推送到远程仓库testremote，这个仓库和上面的origin是同一个远程仓库 $ git push testremote To ../remote-jackygit.git ! [rejected] master -&gt; master (fetch first) error: failed to push some refs to &apos;../remote-jackygit.git&apos; hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: (e.g., &apos;git pull ...&apos;) before pushing again. hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details. （3）抓取远程仓库内容 #抓取远程仓库中的文件，需要指定分支 $ git pull testremote master From ../remote-jackygit * branch master -&gt; FETCH_HEAD Auto-merging Jackydata01 CONFLICT (content): Merge conflict in Jackydata01 Automatic merge failed; fix conflicts and then commit the result. （4）查看冲突文件内容 冲突用&lt;&lt;&lt;&lt;&lt;&lt; ====== &gt;&gt;&gt;&gt;&gt;&gt;隔开冲突代码，上面的是当前修改内容，下面的则是别人修改的内容。 #输出当前jackydata01内容 $ cat jackydata01 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD It&apos;s modified in jackygit ======= It&apos;s modified in jackygit2 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 15a6406ed7f889bab7e812f9e6bedb6e78431232 （5）解决冲突 #修改Jackydata01产生的冲突 $ echo &quot;there is no conflict now&quot; &gt; jackydata01 #提交修改冲突后文件 $ git commit -a -m &quot;there is no confilct now&quot; [master ac2846f] there is no confilct now #推送到远程仓库testremote $ git push testremote Counting objects: 10, done. Delta compression using up to 2 threads. Compressing objects: 100% (4/4), done. Writing objects: 100% (6/6), 567 bytes | 0 bytes/s, done. Total 6 (delta 2), reused 0 (delta 0) To ../remote-jackygit.git 15a6406..ac2846f master -&gt; master 分支合并冲突 这种情况和多人协作冲突处理办法是相似的。在这里也模拟一下 （1）创建分支并修改内容 #创建并跳转到分支br $ git checkout -b br Switched to a new branch &apos;br&apos; #修改br分支中的Jackydata01 $ echo &quot;It&apos;s modified in br&quot; &gt; jackydata01 #提交br分支中的修改 $ git commit -a -m &quot;br modify&quot; [br 32c8755] br modify 1 file changed, 1 insertion(+), 1 deletion(-) （2）跳转到主分支，同样进行内容修改 #跳转到master分支 $ git checkout master Switched to branch &apos;master&apos; #修改master分支中的jackydata01 $ echo &quot;It&apos;s modified in master&quot; &gt; jackydata01 #提交master分支中的修改 $ git commit -a -m &quot;master modify&quot; [master ed84e67] master modify 1 file changed, 1 insertion(+), 1 deletion(-) （3）合并分支 #合并br到主分支上 $ git merge br Auto-merging Jackydata01 CONFLICT (content): Merge conflict in Jackydata01 Automatic merge failed; fix conflicts and then commit the result. （4）显示冲突文件内容，冲突隔开方式如上所述 #显示br中Jackydata01内容 $ cat jackydata01 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD It&apos;s modified in master ======= It&apos;s modified in br &gt;&gt;&gt;&gt;&gt;&gt;&gt; br （5）解决冲突，重新提交 修改Jackydata01产生的冲突 $ echo &quot;It&apos;s no conflict now&quot; &gt; jackydata01 #提交修改冲突后文件 $ git commit -a -m &quot;It&apos;s no conflict now&quot; [master eb073a6] It&apos;s no conflict now （6）删除无效分支 #删除br分支 $ git branch -d br Deleted branch br (was 32c8755). Rebase Rebase提交 rebase命令允许你编辑你的提交历史，比如你可以把多个提交（commit）联合成一个，可以对它重新排序，跳掉某个提交或者编辑提交信息。这是非常有用的，当你要再推送到远程仓库之前要想重新编辑提交信息。以下举个例子把多个提交联合成一个。 #重复做一些无聊的修改和提交 $ echo &quot;test_rebase1&quot; &gt; jackydata01 $ git commit -a -m &quot;test_rebase1&quot; [master 128a2f5] test_rebase1 1 file changed, 1 insertion(+), 1 deletion(-) #看一下log $ git log --pretty=oneline 897fa79def2cf256b7f14d0ec0fcb67e8f61a814 test_rebase5 7dff3e4ad7416f0370b4579393a0c8a8fc02efbd test_rebase4 37be873b514afd9d8f6536cd893eadc3e32b4966 test_rebase3 5ae88f5a0454066d820f6c1687b6d01f59f39dbd test_rebase2 128a2f5cdb325bcbdb26b35741fad2a2fba49832 test_rebase1 ...还有很多 #利用《git rebase》把最后5个（如上）提交联合为1个 git rebase -i HEAD~5 Rebase分支 对多个分支进行rebase操作，rebase命令为一个分支的更改生成一个补丁，然后把这个补丁应用到另外一个分支上，那么最后的源代码和merge是一样的，使用这种方式进行分支的合并更为合理。 #创建并跳转到分支br $ git branch br $ git checkout br Switched to branch &apos;br&apos; #修改br分支中的Jackydata01 $ echo &quot;this wiil be rebase to master&quot; &gt;jackydata01 #提交br分支中的修改 $ git commit -a -m &quot;rebase to master&quot; [br 5c2a431] rebase to master 1 file changed, 1 insertion(+), 1 deletion(-) #跳转到master分支 $ git checkout master Switched to branch &apos;master&apos; Your branch is ahead of &apos;origin/master&apos; by 1 commit. (use &quot;git push&quot; to publish your local commits) #使用rebase把br的改变应用到master $ git rebase br First, rewinding head to replay your work on top of it... Fast-forwarded master to br. #显示master中jackydata01的内容 $ cat jackydata01 this wiil be rebase to master 标签管理标签是啥？标签就是给某个版本的一个标记。 为当前版本创建标签 使用《git tag 标签名》来给当前标签命名 切换到master $ git checkout master Switched to branch &apos;master&apos; 给master当前版本添加一个标签v1.0.0.0 $ git tag v1.0.0.0 给指定版本创建标签 使用《git tag 标签名 版本号》来给指定版本创建标签 显示提交日记 $ git log --pretty=oneline eb073a62baf60ef7bf9952da5254aaf1d5736f45 It&apos;s no conflict now ed84e67e7f509e127a8379be18ddbfc16c7c0359 master modify 32c87551dca76216a24bb93e5cdbc05cefc07e63 br modify ac2846f459eb9acee95d78c7954e0f58758b6d52 there is no confilct now 9ab72067ba2ff1efca3999a40cc3ed1d981b01ad jackygit modify 15a6406ed7f889bab7e812f9e6bedb6e78431232 jackygit2 modify ... 给eb073a创建标签v0.9.0.0 $ git tag v0.9.0.0 eb073a 查看标签 使用《git tag》查看标签 显示所有标签 $ git tag v0.9.0.0 v1.0.0.0 创建带有说明的标签 使用《git tag -a 标签名 -m “标签说明” 版本号》来创建带有说明的标签。 创建带有说明的标签 $ git tag -a v0.8.0.0 -m &quot;beta version&quot; ed84e6 显示标签详情 使用《git show 标签》来显示标签详情 显示标签说明 $ git show v0.8.0.0 tag v0.8.0.0 Tagger: Jacky &lt;fusijie@vip.qq.com&gt; Date: Mon Sep 30 08:40:25 2013 +0800 beta version commit ed84e67e7f509e127a8379be18ddbfc16c7c0359 Author: Jacky &lt;fusijie@vip.qq.com&gt; Date: Sun Sep 29 15:43:08 2013 +0800 master modify diff --git a/Jackydata01 b/Jackydata01 index 276eae7..79e383b 100644 --- a/Jackydata01 +++ b/Jackydata01 @@ -1 +1 @@ -there is no conflict now +It&apos;s modified in master 删除标签 使用《git tag -d 标签名》来删除某个标签。 删除某个标签 $ git tag -d v0.9.0.0 Deleted tag &apos;v0.9.0.0&apos; (was eb073a6) 显示标签 $ git tag v0.8.0.0 v1.0.0.0 推送某个标签到远程仓库 标签默认是存储在本地的，所以如果要推送到远程仓库，必须使用《git push 远程仓库名 标签名》 推送某个标签到远程仓库 $ git push git_github v0.8.0.0 Counting objects: 35, done. Delta compression using up to 2 threads. Compressing objects: 100% (21/21), done. Writing objects: 100% (31/31), 2.58 KiB | 0 bytes/s, done. Total 31 (delta 11), reused 0 (delta 0) To git@github.com:fusijie/JackyGit.git * [new tag] v0.8.0.0 -&gt; v0.8.0.0 推送所有标签到远程仓库 推送所有标签到远程仓库 $ git push git_github --tags Counting objects: 10, done. Delta compression using up to 2 threads. Compressing objects: 100% (4/4), done. Writing objects: 100% (6/6), 551 bytes | 0 bytes/s, done. Total 6 (delta 2), reused 0 (delta 0) To git@github.com:fusijie/JackyGit.git * [new tag] v1.0.0.0 -&gt; v1.0.0.0 从远程仓库删除标签 从远程仓库删除标签，先从本地删除标签，然后再删除远程仓库标签，其实就是同步的意思。 从本地删除标签 $ git tag -d v0.8.0.0 Deleted tag &apos;v0.8.0.0&apos; (was e11559e) 删除远程标签 $ git push git_github :refs/tags/v0.8.0.0 To git@github.com:fusijie/JackyGit.git - [deleted] v0.8.0.0 DIY GitGit的配置是很有学问的，如果弄懂它，将对你帮助很大 用户配置 设置用户名 $ git config –global user.name “Jacky” 设置邮箱 $ git config –global user.email fusijie@vip.qq.com 设置默认编辑器 在需要输入文本信息时调用，比如之前的rebase commit，系统自动调用了Vim $ git config –global core.editor xxx 设置提交模版 你可以设置一个提交的模版，然后再每次提交时填充此模版即可。 git config –global commit.template xxx 设置分页器 你可以设置一个诸如log，diff等使用的分页器。 $ git config –global core.pager xxx 设置自动纠错 设置为1的时候，如果只有1个命令被模糊匹配到，将自动纠错。 $ git config –global help.autocorrect 1 设置高亮 设置bash输出高亮。 $ git config –global color.ui auto 设置换行转换 windows下换行占2个字符，而mac和linux下换行只有一个字符，如果要进行自动的换行转化的话，设置autocrlf吧。如果只在windows开发，那设置为false吧。 git config –global core.autocrlf true 设置差异分析工具 在解决冲突的时候如果用到差异分析工具，可用在这里设置。 $ git config –global merge.tool xxx 设置别名 如果一条命令很长或者很难记，那么我们可以为他设置一个别名。 $ git config –global alias.st status 好了，现在就可以用git st代替git status了。 设置忽略文件 一个项目中并不是所有的文件都要加入版本控制的，比如中间文件，生成的最终文件。那么处女座的肯定受不了那一堆的untrack。。。通过设置一个.ignore文件，git将忽略里面的文件而不进行提醒。 查看所有配置 $ git config –list 查看单个配置 $ git config user.name 查看配置使用帮助 git的配置属性太多了，这里不可能一一列举，用help吧！$ git config –help Ubuntu和git Ubuntu下使用git 打开终端（Ctrl+Alt+T）。Ubuntu下就没有git bash了，都是使用terminal。 1.1.安装SSH sudo apt-get install SSH 1.2.安装git sudo apt-get install git 1.3.设置用户名和邮箱 $ git config --global user.name &quot;Jacky&quot; $ git config --global user.email fusijie@vip.qq.com 利用Ubuntu搭建服务器 2.1.搭建服务器远程仓库 2.2.推送本地修改到服务器仓库 Git GUI Git GUI有什么？ 初始化仓库 修改内容 进入提交界面 提交修改 Git History和Git Blame 推送到远程服务器上 其他操作 Github操作指南 如何创建一个仓库？ 如何Fork一个仓库 社交化功能]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript的学习及总结]]></title>
    <url>%2F2014%2F01%2F31%2FJavaScript%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8F%8A%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[JavaScript的介绍JavaScript是什么？ javaScript是一种广泛用于客户端Web开发的脚本语言，常用来给HTML网页添加动态功能，比如响应用户的各种操作 javascript最主要的设计目的就是让网页中的元素可以被编程,也就是让网页动起来，甚至你可以编写js版本的坦克大战游戏。 javascript不能独立运行，它要嵌入到其它编程语言中才能运行(html,asp,asp.net,jsp,php…) javascript一般用于b(brower浏览器)/s(server服务器)开发,即我们常说的web开发(比如网站开发，web应用等.)，很少用于后台 脚本语言是什么？ 脚本语言介于HTML和C,C++,Java,C#等编程语言之间 脚本语言与编程语言有相似地方，其函数与编程语言类似,也有变量。与编程语言之间最大的区别是编程语言的语法和规则更为严格和复杂一些 脚本语言是一种解释性语言,例如Python、vbscript,javascript等等,它不象c\c++等可以编译成二进制代码,以可执行文件的形式存在 脚本语言一般都有相应的脚本引擎来解释执行,javascript的脚本引擎就是浏览器（因为js是由浏览器来执行的，因此这里有个问题，不同类型的浏览器可能对js的支持不一样。） js语言的特点 Javascript语言是简单的 Javascript是基于对象和事件驱的(动态的)。 它可以直接对用户或客户输入做出响应，无须经过Web服务程序。它对用户的反映响应，是采用以事件驱动的方式进行的。所谓事件驱动，就是指在主页中执行了某种操作所产生的动作，就称为“事件”。比如按下鼠标、移动窗口、选择菜单等都可以视为事件。当事件发生后，可能会引起相应的事件响应。 javascript是跨平台的。 JavaScript是依赖于浏览器本身，与操作环境无关，只要能运行浏览器的计算机，并支持JavaScript的浏览器就可以正确执行。 js的位置可以随意放 js必须使用 代码 在一个html文件中（JSP/PHP/ASP.NET）可以出现多对（script）片段，浏览器会按照先后顺序依次执行 Js的变量类型是怎样决定的? Js是弱数据类型语言，即：在定义变量时候，统一使用var表示，甚至可以去掉var这个关键字 Js中的变量的数据类型是由js引擎决定的 JavaScript中简单语法 标识符是指JavaScript中定义的符号，例如，变量名，函数名，数组名等。标识符可以由任意顺序的大小写字母、数字、下划线(_)和美元符号($)组成，但标识符不能以数字开头，不能是JavaScript中的保留关键字 JavaScript严格区分大小写computer和Computer是两个完全不同的符号 每条功能执行语句的最后必须用分号(;)结束，每个词之间用空格、制表符、换行符或大括号、小括号这样的分隔符隔开 语句块使用{}来表示 JavaScript程序的注释 /*…*/中可以嵌套“//”注释，但不能嵌套/*…*/ JavaScript基础基本数据类型 基本数据类型3种 数值类型（整型常量、实型常量、特殊数值） 字符串类型（双引号或单引号都行） 布尔类型（true、false） 复合数据类型 数组 对象 特殊数据类型 Null 即：var a=null Undefine 即：如下代码 &lt;script language=&quot;javascript&quot;&gt; window.alert(tt);//直接报错：未定义 var tt;//不报错 未给值 输出Undefine &lt;/script&gt; 其中，Number(数值类型)包括 整型常量(10进制\8进制\16进制) 十六进制以0x或0X开头，例如：0x8a。 八进制必须以0开头，例如：0123。 十进制的第一位不能是0（数字0除外），例如：123。 实型常量 12.32、193.98、 5E7、4e5等。 特殊数值：NaN(不是一个数)、Infinity(无穷大)、isNaN()、isFinite() JavaScript类型转换 自动转换 强制转换（parseInt(“”)系统函数，可直接使用） JavaScript运算符 算术运算符（+、-、*、/、%、++、–） 关系运算符(==、&gt;、&lt;、!=…) 逻辑运算符(&amp;&amp;与/||或/!非)在逻辑运算中，0、””、false、null、undefined、NaN均表示false 位运算和移位运算 JavaScript三大流程控制 顺序控制：对变成而言，不控制其流程就是顺序执行 分支控制:if…else/switch…case 循环控制:for循环/while循环/do while循环 利用工具进行JS调试 在ie8中，我们可以通过工具来对JS代码进行调试，尤其页面比较复杂的情况下非常有用。 在ie8中，通过开发人员工具，就可以进行JS的调试工作。 JavaScript函数什么是函数？为完成某一功能的程序指令(语句)的集合,称为函数。在js中,函数分为: 自定义函数、系统函数(经常查看js帮助手册) 函数的定义function 函数名(参数列表) { 语句;//函数主体 return 返回值;} 函数的几种调用方式 函数名（传递给函数的参数1，传递给函数的参数2，….） 变量 = 函数名;此时变量就相当于函数的引用(指针)，可以这样调用函数: 变量(实际参数..) 如果函数没有返回值则返回undefined，如果有返回值，则返回什么就是什么 函数的参数列表可以是多个 参数列表可以是多个,并且数据类型可以是任意的类型 js支持参数个数可变的函数 js支持创建动态函数 //由于js不支持重载，所以function abc2(n1)和function abc2()是同一个函数 function abc2() { //在JS中有一个 arguments可以访问所有传入的值 //得到参数的个数 window.alert(arguments.length); //遍历所有的参数 var sum=0; for(var i=0;i&lt;arguments.length;i++){ sum=arguments[i]+sum; } window.alert(sum); } 数组数组，这种数据类型，也可以称作引用类型/复杂类型/复合类型，数组的基本概念：用于存放一组数据。特别强调：JS中的数组，可以存放各种数据类型（数值/字符串…） 一维数组js中的数组是用于表示一组数据的集合，它由一对方括号[]包围，数组的每个元素用逗号分隔，数组元素可以是任意类型的数据 var a=[”shunping”,123,”1.1”,4.5,true] b = a[6] a[2]=56; for(var key in a) { window.alert(key+“= &quot;+arr[key]); } 数组可存放任意类型的数据 数组大小不必事先指定,可以动态增长 数组名可以理解为指向数组首地址的引用 数组元素默认从0开始编号的 多维数组多维数组我们只介绍二维数组,一维数组的元素还可以是一个数组，就构成二维数组。 var arr=[[“shunping”,123,4.5],[“a”,”b”,”c”]] for (var i=0; i&lt;arr.length; i++) { for (var j=0; j&lt;arr[i].length; j++) { arr[i][j] = 100; } } 排序和查找 冒泡排序 冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从后向前（从下标较大的元素开始）,依次比较相邻元素的排序码，若发现逆序则交换,使排序码较小的元素逐渐从后部移向前部（从下标较大的单元移向下标较小的单元），就象水底下的气泡一样逐渐向上冒 快速排序 顺序查找 二分查找 JavaScript面向对象编程1Javascript是一种面向(基于)对象的动态脚本语言，是一种基于对象(Object)和事件驱动(EventDriven)并具有安全性能的脚本语言。他具有面向对象语言所特有的各种特性，比如封装、继承及多态等。但对于大多数人说，我们只把javascript做为一个函数式语言，只把他用于一些简单的前端数据输入验证以及实现一些简单的页面动态效果等，我们没能完全把握动态语言的各种特性。在很多优秀的Ajax框架中，比如ExtJS、JQuery等，大量使用了javascript的面向对象特性，要使用好JQuery技术，javascript的高级特性，面向对象语言特性是我们必须完全把握的 JavaScript的对象 Javascript是一种基于对象（object-based）的语言，你遇到的所有东西几乎都是对象 因为javascript中没有class(类), 所以有人把类也称为原型对象，因为这两个概念从在编程中发挥的作用看都是一个意思,为了统一叫法，我这里就统一叫类 特别说明：基于对象也好，面向对象也好实际上都是以对象的概念来编写程序，从本质上并无区别，所以这两个概念在我的课程中是一样的 //这里就是一个Cat类 function Cat() { } var cat1=new Cat();//这时cat1就是一个对象 cat1.name=&quot;小白&quot;; cat1.age=3; cat1.color=&quot;白色&quot;; window.alert(cat1.name);输出小白 从上面的代码我们可以看出 JS中的对象的属性可以动态的添加 属性没有限制 类(原型对象)和对象(实例)的区别和联系 类(原型对象)是抽象的，概念的，代表一类事物,比如人,猫.. 对象是具体的，实际的，代表一个具体事物 类(原型对象)是对象实例的模板，对象实例是类的一个个体 创建对象的方式有5种 工厂方法—使用new Object创建对象并添加相关属性 使用构造函数来定义类（原型对象） 使用prototype 构造函数及原型混合方式 动态原型方式 使用构造函数来定义类（原型对象），然后再创建实例 基本语法： function 类名/原型对象名() { } 创建对象： var 对象名=new 类名(); 如何判断一个对象实例是不是某个类型 方法1： if(a instanceof Person){ window.alert(&quot;a是Person&quot;); } 方法2： if(a.constructor==Person){ window.alert(&quot;a是Person&quot;); } 在js 中一切都是对象 类function(原型对象)其实也是对象，它实际上是Function类的一个实例， 通过类我们可以创建自己的对象实例 补充说明：带var和不带var的区别 var abc=89;//全局变量 function test(){ //在函数里，如果不带var，则表示使用全局的变量 //如果带上var表示在函数中定义的一个新的变量 abc=900; } test(); window.alert(abc);//输出900，var abc=900;则输出89 访问对象的成员变量对象实例-如何访问(使用)对象实例的成员变量 对象实例名.属性名; 对象实例名[“属性名”]; function Person(){} var p1=new Person(); p1.name=&quot;姜爽&quot;; window.alert(p1.name); var val=&quot;na&quot;+&quot;me&quot;; window.alert(p1[&quot;name&quot;]); window.alert(p1[val]); function Person(){} var a=new Person(); a.age=10; a.name=&quot;小明&quot;; var b=a; b.name=&quot;小白&quot;; window.alert(b.age+&quot;名字&quot;+b.name+&quot;名字&quot;+a.name); JS提供一种方式主动释放内存 delete a.age;//用于删除属性 指向同一个地方，一个删了b就访问不到了 这样就会立即释放对象的属性空间 this关键字this声明公开的属性 function Person() { var name=&quot;abc&quot;;//私有的,只能在内部使用 var age=30;//私有的,只能在内部使用 this.name2=&quot;abc2&quot;;//this.name2 表示name2这个属性是公开的 this.show=function() {//函数 这就是Person类里面的一个公开的方法 window.alert(&quot;name&quot;+name+&quot;age&quot;+age); } function show2() {//这就是Person类里面的一个私有的方法,只能在类内部使用, //如要一定要使用,只能通过公开方法(特权方法)来调用私有方法来实现 window.alert(&quot;show2()&quot;+name+&quot;age&quot;+age); } } var p1=new Person(); //这样使用会报 undefined，私有的外部访问不到 window.alert(p1.name+&quot; &quot;+p1.age);//错误 p1.show(); //p1.show2();//这里会报错 记住一句话: 哪个对象实例调用this所有的函数,那么this就代表哪个对象实例 function test1() { alert(this.v); } var v=90; window.test1();//等价于test1() window调用test1()，所以this就代表window，输出90 this注意事项: this不能放在类的外部使用,否则调用就变成window调用了 JavaScript对象的成员函数几种成员函数的方法 方式0 function Person(){ //使用传递的实际参数去初始化属性 this.name=name; this.age=age; //输出自己的名字,这里this.show就是一个公开的函数，函数名字是show this.show=function() { document.write(&quot;名字&quot;+this.name); } } var p1=new Person(); p1.show(); 方式1 function Person() { this.name=&quot;abc&quot;; this.age=900; } function show1() { window.alert(&quot;hello&quot;+this.name); } var p1=new Person(); p1.abc=show1; p1.abc(); 方式2 function Person() { this.name=&quot;abc&quot;; this.age=900; } var p1=new Person(); p1.abc= function show1(){ window.alert(&quot;hello&quot;+this.name); }; p1.abc(); 前几种方法有一个问题，那就是以上对象独占函数代码，这样如果对象过多，则会影响效率，js设计者，给我们提供了别一个方法，原型法：这样多个对象可以共享函数代码，代码如下 function Dog() { } //使用prototype去绑定一个函数给shout Dog.prototype.shout=function() { window.alert(&apos;小狗&apos;); } var dog1=new Dog(); dog1.shout(); 补讲 == 号的作用 当 == 的两边 都是字符串的时候，则比较内容 相等否。 如 == 的两边 都是数字的时候，则数的大小是否相等。 如 == 的两边 是对象或对象中的函数属性，则比较地址是否相等。 成员函数的细节 1. 成员函数的参数可以是多个 function 函数名（参数......）{ } 2. 成员函数可以返回值,也可以没有,但是有的话,最多只有一个 function 函数名(参数列表){ 语句;//函数主体 return 返回值; } 3. js支持参数个数可变的函数 4. js中不支持函数的重载,始终只找最后一个函数，具体案例 function test(a,b){ window.alert(&quot;hello&quot;); } function test(a){ window.alert(a); } function test(a,b){ window.alert(a+&quot;&quot;+b); } test(23); //输出23 undefined window.test(3,&quot;hello&quot;);//输出3 hello 结论: js在调用一个函数的时候,是根据函数名来调用的,如果有多个函数名相同,则认最后那一个函数. 直接定义一个函数或者变量,实际上这些函数和变量就是全局函数和全局变量(本质上他们是属于window对象的) 对象-Object类Object类是所有javascript类的基类，提供了一种创建自定义对象的简单方式，不需要程序员再定义构造函数。 主要属性： constructor-对象的构造函数 prototype-获得类的prototype对象,static性质 主要方法： hasOwnProperty(property)－是否属于本类定义的属性 isPrototypeOf(object)－是否是指定类的prototype propertyIsEnumerable(property)－是否可例举的属性 toString()－返回对象对应的字符串 valueOf()－返回对象对应的原始类型值 加深对类和对象的认识：如何给类添加方法（如何给某类型的所有对象添加方法） 案例1： //初步体验Object类,通过Object直接创建对象 var p1 = new Object(); p1.name = &quot;abc&quot;; window.alert(p1.name); window.alert(p1.constructor); 案例2： var i = new Number(10); //我们可以给类添加方法. Number.prototype.add=function(a){ return this+a; } window.alert(i.add(10).add(30)); var b= 90; window.alert(b.add(40)); //输出50 130 构造函数构造函数(方法)介绍 什么是构造函数呢?在回答这个问题之前，我们来看一个需求：前面我们在创建人类的对象时，是先把一个对象创建好后，再给他的年龄和姓名属性赋值，如果现在我要求，在创建人类的对象时，就直接指定这个对象的年龄和姓名，该怎么做? 基本用法 function 类名（参数列表）{ 属性=参数值； } 案例： function Person(name,age){ this.name=name; this.age=age; } //创建Person对象的时候，就可以直接给名字,年龄 var p1=new Person(&quot;顺平&quot;,12); 构造函数(方法)是的一种特殊的方法，它的主要作用是完成对对象实例的初始化。它有几个特点： 构造函数(方法)名和类名相同 在创建一个对象实例时，系统会自动的调用该类的构造方法完成对新对象的初始化 主要作用是完成对新对象实例的初始化 另外一种创建对象的方式如果一个对象比较简单，我们可以直接创建。可以指定普通属性和函数属性。 var dog={name:&quot;小狗&quot;,age:8, fun1:function(){window.alert(&quot;hello&quot;);}, fun2:function(){window.alert(&quot;world&quot;);} }; window.alert(dog.name+dog.age); window.alert(dog.constructor); dog.fun1(); dog.fun2(); 有时我们会看到这样一种调用方法：函数名.call（对象实例） 这样调用,该函数的this就是这个对象实例。 小案例： var dog={name:&quot;hello&quot;}; function test(){ window.alert(this.name); } test.call(dog);//==dog.test; 输出：hello for ..in的用法 var dog={name:&quot;小明&quot;,fun1:function(){window.alert(&quot;hello&quot;);}}; //循环列出 dog对象的所有属性和方法 对象名[&quot;属性名&quot;] for(var key in dog){ window.alert(key+&quot;:&quot;+dog[key]); // key属性 dog[key]属性值 } //遍历window对象的所有属性 for(var key in window){ document.write(key+&quot;:&quot;+window[key]+&quot;&lt;/br&gt;&quot;); } 闭包闭包和垃圾回收gc是相关联的，闭包实际上是在涉及到一个对象的成员属性何时被gc处理的问题 怎样才能对对象的属性形成一个闭包，案例： //闭包closure function A(){ var i=0; function b(){ window.alert(i++); } return b; } //A();//此时内存中有i的空间就被回收了 var c=A();//这种用法gc不会把i当成垃圾处理 c();//0 c();//0从而证明i被闭包了 JavaScript面向对象编程2封装封装就是把抽象出的属性和对属性的操作封装在一起,属性被保护在内部,程序的其它部分只有通过被授权的操作(函数),才能对属性进行操作 js提供有以下几种控制方法和属性的访问权限: 公开级别:对外公开 私有级别:类本身可以访问,不对外公开 案例： function Person(name,age,sal){ this.name=name;//公开的属性 var age=age;//私有的属性 var sal=sal;//私有的属性 //在类中如何定义公开方法（特权方法），私有方法（内部方法） //如果我们希望操作私有的属性则可用公开方法去实现 this.show=function(){ window.alert(age+&quot; &quot;+sal ); } //私有方法,可以访问对象的属性 function show2(){ window.alert(age+sal); } } var p1=new Person(“sp”,30,4000); p1.show();//这个可以成功//不能在类的外部去访问私有的方法 p1.show2();//不能在类的外部去访问私有的方法 特别强调：我们前面学习的通过prototype给所有的对象添加方法，但是这种方式不能去访问类的私有变量和方法。 function Person(){ this.name=&quot;sp&quot;; var age=90; this.abc=function(){ window.alert(&quot;abc&quot;); } function abc2(){ window.alert(&quot;abc&quot;); } } Person.prototype.fun1=function(){ window.alert(this.name);//ok //window.alert(age);//no ok //abc2();//no ok this.abc();//ok } var p1=new Person(); p1.fun1(); 继承继承可以解决代码复用,让我们的编程更加靠近人类思维.当多个类存在相同的属性(变量)和方法时,可以从这些类中抽象出父类(比如刚才的Student),在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法.js 中没有extends 关键字，它可以通过如下方式实现继承. 对象冒充 //抽象出一个学生类，即把中学生和小学生的共性拿出来 function Stu(name,age){ this.name=name; this.age=age; this.show=function(){ window.alert(this.name+&quot; &quot;+this.age); } } function MidStu(name,age){ this.stu=Stu; this.stu(name,age); //JS中实际上是通过对象冒充来实现继承，这句话不可少，因为JS是动态语言，如果不执行，则不能实现继承效果 } function Pupil(name,age){ this.stu=Stu; this.stu(name,age); } var midStu=new MidStu(&quot;顺平&quot;,32); midStu.show(); 特别说明：通过对象冒充，JS可以实现多重继承的效果，用的少 call及apply function Stu(name,age){ this.name=name; this.age=age; this.show=function(){ window.alert(this.name+&quot; &quot;+this.age); } } function MidStu(name,age){ //Stu.call(this,name,age); //或者 Stu.apply(this,[name,age]); this.payFee=function(sal){ //这个是MidStu对象自己的函数 window.alert(&quot;应付学费=&quot;+sal*0.8); } } function Pupil(name,age){ //Stu.call(this,name,age); Stu.apply(this,[name,age]); this.payFee=function(sal){ window.alert(&quot;应付学费1=&quot;+sal*0.5); } } var pupil1=new Pupil(&quot;xm1&quot;,12); pupil1.show(); pupil1.payFee(1000); var midStu1=new MidStu(&quot;xh4&quot;,22); midStu1.show(); midStu1.payFee(1000); window.alert(&quot;********&quot;); pupil1.show(); 方法重载及覆盖简单的说:方法重载就是类的同一种功能的多种实现方式,到底采用哪种方式,取决于调用者给出的参数。js不支持重载操作。因为Javascript 中的方法本身就是一个带可变参数的，通过在方法体内检测方法的参数情况，来实现重载的效果。【调用最后那个方法】 覆盖，也称为改写，就是指子类中定义的方法替换掉父类的方法。（案例说明） 父类： function Stu(name,age){ this.name=name; this.age=age; this.show=function(){ window.alert(this.name+&quot; &quot;+this.age); } } 子类： function MidStu(name,age){ this.stu=Stu; this.stu(name,age);//JS中实际上是通过对象冒充来实现继承，这句话不可少 //MidStu可以覆盖Stu父类的show方法 this.show=function(){ window.alert(&quot;hello&quot;); } } var midStu=new MidStu(&quot;顺平&quot;,32); midStu.show(); //这里调用的是子方法 多态所谓多态,就是指一个 变量在不同情况下的多种状态.js 实际上是无态的，是一种动态语言，一个变量的类型是在运行的过程中由js 引擎来决定的，所以说,js天生就支持多态 function Master(){ this.feed=function(animal,food){ window.alert(&quot;主人给&quot;+animal.name+&quot;喂&quot;+food.name); } } function Food(name){ this.name=name; } function Fish(name){ this.fish=Food; this.fish(name); } function Bone(name){ this.bone=Food; this.bone(name); } function Animal(name){ this.name=name; } function Cat(name){ this.cat=Animal; this.cat(name); } function Dog(name){ this.dog=Animal; this.dog(name); } var master = new Master(); var cat=new Cat(&quot;小猫&quot;); var fish=new Fish(&quot;鱼&quot;); master.feed(cat,fish); 输出：主人给小猫喂鱼 内部类和系统函数前面我们讲的对象都是自定义类(就是自个写的)，js的设计者为了编程方便，也提供了事先定义好的类(有属性和方法了)，这些类在我们做web开发的时候,经常用到。我们称为js内部类(原型对象)。主要有：Object Array Border String Date Number Math RegExp Boolean 按照使用方式，我们把js内部类分为两类(动态类,静态类) 动态类 在引用其属性和方法的时候: var 对象实例名=new 类() 对象实例名.方法(或属性) 如： Object类是所有javascript类的基类，提供了一种创建自定义对象的简单方式，不需要程序员再定义构造函数 Date类提供了日期和时间的操作 String是动态类,提供了对字符串的各种操作 Array类提供了对数组的操作，使用Array类可以轻松的创建数组，并对数组进行删除、排序和合并等操作 Boolean是动态类，是一个把布尔值打包的布尔对象,这个对象在实际编程中 Number类是该对象是原始数值的包装类 静态类 在引用其属性和方法的时候: 静态类.方法(或属性)Math 如： Math：Math.ceil(4.5)、Math.floor(4.5)、Math.round(4.77)、Math.random() 系统函数也叫全局函数，可以直接使用。是js设计者们为了编程方便提供的,如 eval() //可以把一个字符串当做脚本来运行,用处很大 parseInt() //把字符串转成整数 parseFloat() //把字符串转成小数 isNaN() //判断某个值是不是数(该函数不是特别完美) JavaScript事件驱动机制js是采用事件驱动(event-driven)响应用户操作的。比如通过鼠标或者按键在浏览器窗口或者网页元素(按钮,文本框…)上执行的操作,我们称之为事件(Event)。 由鼠标或热键引发的一连串程序的动作,称之为事件驱动(Event-Driver)。 对事件进行处理程序或函数，我们称之为事件处理程序(Event Handler)。 JS中的事件主要分为4种： 鼠标事件 click dblclick mousedown mouseout mouseover mouseup mousemove 键盘事件 keydown keypress keyup HTML事件 window的onload unload error abort 文本框的select change 其他事件 页面中有些特殊对象运行过程中产生的事件 快速入门案例 案例1： 监听鼠标点击事件，并能够显示鼠标点击的位置x,y &lt;head&gt; &lt;script&gt; function test1(e){ window.alert(&quot;x=&quot;+e.clientX+&quot;y=&quot;+e.clientY); } &lt;/script&gt; &lt;/head&gt; &lt;body onmousedown=&quot;test1(event)&quot;&gt; &lt;/body&gt; 点击浏览器之后，显示坐标 案例2：点击按钮，图片变成红色，黑色 方法：JS访问内部css &lt;head&gt; &lt;script&gt; //js如何访问css属性，来改变外观 function test3(e){ var pic=document.getElementById(&quot;pic&quot;); if(e.value==&quot;红色&quot;){ pic.style.backgroundColor=&quot;red&quot;; } else if(e.value==&quot;黑色&quot;) { pic.style.backgroundColor=&quot;black&quot;; } } &lt;/script&gt; &lt;/head&gt; &lt;body &gt; &lt;div id=&quot;pic&quot; style=&quot;border:1;background-color:red;width:300px;height:300px&quot;&gt;&lt;/div&gt; &lt;input type=&quot;button&quot; onclick=&quot;test3(this)&quot; value=&quot;红色&quot;&gt; &lt;input type=&quot;button&quot; onclick=&quot;test3(this)&quot; value=&quot;黑色&quot;&gt; &lt;/body&gt; 方法：JS访问外部css event2.css文件： .style { border:1; background-color:red; width:300px; height:300px; } event2.html文件： &lt;head&gt; &lt;script&gt; function test3(e){ //取连接的第一个css文件的内容，0表示引入css文件列表的index var ocssRules=document.styleSheets[0].rules; //从ocssRules取出你希望的样式 var style=ocssRules[0];//这里面的0表示event2.css文件中第一个规则 if(e.value==&quot;黑色&quot;){ style.style.backgroundColor=&quot;black&quot;; } else if(e.value==&quot;红色&quot;) { style.style.backgroundColor=&quot;red&quot;; } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;style&quot;&gt;&lt;/div&gt; &lt;input type=&quot;button&quot; onclick=&quot;test3(this)&quot; value=&quot;红色&quot;&gt; &lt;input type=&quot;button&quot; onclick=&quot;test3(this)&quot; value=&quot;黑色&quot;&gt; &lt;/body&gt; &lt;/html&gt; 一个事件可以被多个函数监听 &lt;head&gt; &lt;script&gt; function test(e){ window.alert(&quot;fss&quot;); } function test1(e){ window.alert(&quot;sfdsdf&quot;); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;style&quot;&gt;&lt;/div&gt; &lt;input type=&quot;button&quot; onclick=&quot;test(this),test1(this)&quot; value=&quot;红色&quot;&gt; &lt;/body&gt; &lt;/html&gt; 如何区分浏览器:根据是否支持某种方法判断 if (window.XMLHttpRequest) { if (window.ActiveXObject) { alert(&quot;Mozilla&quot;, &quot;Safari&quot;) } else { alert(&quot;IE&quot;) } } else { alert(&quot;IE6&quot;) } 特别说明：我这要特别强调一点,并不是所有的html 元素都有相同的event事件(对象),这个请大家在做项目的时候特别注意，比如提交按钮有onsubmit事件,但是输入框就没有的，具体请大家参考js帮助文档 DOM编程什么是DOM编程 dom(document object model) 文档对象模型,根据w3c dom规范,dom 是html 和xml 的应用程序编程接口(api),dom 将html 或 xml映射成由层次节点组成的模型, 根据规范的严格层度,分为 1,2,3级。 dom 的核心是提供了一套访问结构化文档的api ,核心是对节点各种操作。 为什么要学习dom编程： Dom编程 重要的作用是可以让用户对网页元素进行交互操作。 Dom编程 用来做一些网页游戏 Dom编程也是ajax的重要基础 前面说过,js把浏览器,网页文档和网页文档中的html 元素都用相应的内置对象(看文档)来表示，这些对象与对象间的层次关系构成dom,针对网页(html,jsp,php,aspx.net)的dom就是html dom。我们这讲的就是html dom 这里有几个特别重要的概念要给大家说清楚: 上面说的内置对象就是dom 对象,准确的说是html dom对象。 因为我目前讲的是 html dom 编程，所以我提到的dom 编程,dom 对象都是说的 html dom 编程 和 html dom对象，请大家不要犯迷糊。 dom 编程时，会把html文档看做是一颗dom 树(对照乌龟抓鸡来的代码来说明dom编程.(首先要画出html dom图[参看资料文件夹，已经画好]) dom 编程的核心就是各个dom 对象,下一章节会详细讲解 BOM 介绍bom(browser object model)浏览器对象模型,因为做浏览器的厂家很多W3C就定义一个做浏览器的规范，规定 通过使用BOM，可移动窗口、更改状态栏文本。bom 是w3c 组织提出的，他建议所有的浏览器都应当遵循这样的设计规范，可以说 bom和dom关系密切，bom 为纲，dom为目,我们可以简单的理解dom 就是 bom 的具体实现 dom 对象2.1 dom对象简介 2.2 常用的dom对象层次图 dom 对象详解window对象Window 对象表示一个浏览器窗口或一个框架。在客户端 JavaScript中,Window 对象是全局对象,要引用当前窗口根本不需要特殊的语法,可以把那个窗口的属性作为全局变量来用。 alert() 显示消息和一个确认按钮的警告框 confirm() 显示消息以及确认按钮和取消按钮的对话框 var res=window.confirm(&quot;你要删除&quot;); if(res) { window.alert(&quot;删除成功&quot;); } else { window.alert(&quot;删除失败&quot;); } setInterval() 按照指定的周期(毫秒计)来循环调用函数或计算表达式 function sayHello(){ window.alert(&quot;hello,world&quot;); } setInterval(&quot;sayHello()&quot;,1000); clearInterval() 取消由setInterval()设置的定时器 var count=0; function showTime(){ count++; if(count==10){ clearInterval(time); } setTimeout() 指定的毫秒数后调用函数或计算表达式 function sayHello(){ window.alert(&quot;hello,world&quot;); } var time=setTimeout(&quot;sayHello()&quot;,5000); clearTimeout(time);//取消Timeout 不再显示hello,world clearTimeout() 取消由setTimeout()设置的定时器 function sayHello(){ window.alert(&quot;hello,world&quot;); } var time=setTimeout(&quot;sayHello()&quot;,5000); clearTimeout(time);//取消Timeout 不再显示hello,world moveTo() moveBy() window.moveTo(100,100); //这个是相对于屏幕左上角0，0坐标 window.moveBy(100,100);//这个是相对当前窗口的左上角0，0坐标 resizeBy() 和resizeTo() window.resizeTo(100,100); //把窗口的大小调整到指定的宽度100和高度100。 window.resizeBy(100,100);//把窗口再增加100，100 open()开一个新窗口 window.open(&quot;event1.html&quot;,&quot;_blank&quot;); opener 返回对创建此窗口的窗口的引用,用于父窗口和子窗口通信 &lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt; var newWindow; function test2(){ //newWindow其实就是指向新窗口的引用 newWindow=open(&quot;newWindow.html&quot;,&quot;_blank&quot;); } function test3(){ newWindow.$(&quot;myspan2&quot;).innerText=$(&quot;info2&quot;).value; } function $(id){ return document.getElementById(id); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt;我是父窗口 &lt;input type=&quot;button&quot; value=&quot;打开新窗口&quot; onclick=&quot;test2()&quot;/&gt; &lt;input type=&quot;text&quot; value=&quot;&quot; id=&quot;info2&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;发送给子窗口&quot; onclick=&quot;test3()&quot;/&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;接收的信息是：&lt;/span&gt; &lt;span id=&quot;myspan&quot;&gt;信息&lt;/span&gt; &lt;/body&gt; &lt;/html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt; function test2(){ opener.$(&quot;myspan&quot;).innerText=$(&quot;info&quot;).value; } function $(id){ return document.getElementById(id); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt;我是新窗口 &lt;input type=&quot;text&quot; value=&quot;&quot; id=&quot;info&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;发送给父窗口&quot; onclick=&quot;test2()&quot;/&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;接收的信息是：&lt;/span&gt; &lt;span id=&quot;myspan2&quot;&gt;信息&lt;/span&gt; &lt;/body&gt; &lt;/html&gt; History对象history对象:Contains information about the URLs visited by the client ,即:该对象包含客户端访问过的URL信息 从dom层次图看,history是window对象的成员属性,但实际history是由js runtime engine 自动创建的，所以你也可以认为history就是一个js对象 我们一起看看history对象常用的函数和属性 back() Loads a previous URL from the History list. forward() Loads the next URL from the History list. go() Loads a URL from the History list. length Retrieves the number of elements in the History list html文件 &lt;a href=&quot;b.html&quot;&gt;点击&lt;/a&gt; html文件 &lt;script language=&quot;javascript&quot;&gt; function goback(){ //history.go(-1); history.back(); } &lt;/script&gt; &lt;a href=&quot;#&quot; onclick=&quot;goback()&quot;&gt;返回上一级&lt;/a&gt; location对象location对象:Contains information about the current URL ,即:该对象包含客户端当前的URL信息。 从dom层次图看,location是window对象的成员属性,但实际location也是由js runtime engine 自动创建的，所以你也可以认为location就是一个js对象。 我们一起看看location对象常用的函数和属性。 reload() Reloads the current page 重新加载当前页. replace() Replaces the current document by loading another document at the specified URL 用新的文档替换当前文档 hostname Sets or retrieves the host name part of the location or URL. 设置或得到主机名 port Sets or retrieves the port number associated with a URL. 设置或得到端口号 href Sets or retrieves the entire URL as a string. 设置或得到完整的url,也可以载入一个新的url &lt;script language=&quot;javascript&quot;&gt; function test(){ //location.reload(); window.alert(location.href);//返回完整的 URL } &lt;/script&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;刷新&quot; onclick=&quot;test()&quot;&gt; aderwrqwrq &lt;/body&gt; navigator对象navigator对象:Contains information about the browser. ,即:该对象包含当前浏览器的各信息。 我们一起看看navigator对象常用的函数和属性。 javaEnabled() 返回该浏览器是否支持java appName 浏览器的名称 appVersion 浏览器的版本 browserLanguage 浏览器当前使用的语言 cookieEnabled 返回浏览器是否启用cookie platform 返回浏览器所在操作系统名称 systemLanguage 系统默认语言 screen对象screen对象:Contains information about the client’s screen and rendering capabilities ,即:该对象包含有关客户机显示屏幕的信息 我们一起看看screen对象常用的属性,该对象没有方法。 height 返回显示屏幕的高度(按像素) width 返回显示屏幕的宽度(按像素) availHeight 返回显示屏幕可用高度(去掉windows任务栏) availWidth 返回显示屏幕可用宽度 window.alert(screen.width+&quot; &quot;+screen.height); if(screen.width!=1024||screen.height!=768){ window.alert(&quot;不是这像素&quot;); } event对象event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态,事件通常与函数结合使用。 从dom对象层次图看,event对象是window对象的属性. 如何绑定事件监听 直接在 某个html 控件上指定 &lt;input type=&quot;button&quot; value=&quot;刷新页面&quot; onclick=&quot;test()&quot;/&gt; getElementById(‘’) 获取控件后，再绑定 &lt;html&gt; &lt;head&gt; &lt;script language=&quot;javascript&quot;&gt; function test(){ document.write(&quot;hello,world&quot;); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;点击&quot; id=&quot;but1&quot;&gt; &lt;script language=&quot;javascript&quot;&gt; document.getElementById(&quot;but1&quot;).onclick=test;//这里绑定监听 &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 通过 addEventListener() 或者是 attachEvent() 来绑定 &lt;html&gt; &lt;head&gt; &lt;script language=&quot;javascript&quot;&gt; function test(){ window.alert(&quot;你投票一次&quot;); //解除事件绑定 document.getElementById(&quot;but1&quot;).detachEvent(&quot;onclick&quot;,test); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;投票&quot; id=&quot;but1&quot;&gt; &lt;script language=&quot;javascript&quot;&gt; document.getElementById(&quot;but1&quot;).attachEvent(&quot;onclick&quot;,test); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 一个事件可以有多个事件监听者(函数) document对象Document对象代表整个html文档,可用来访问页面中的所有元素,是最复杂的一个dom对象，可以说是学习好dom编程的关键所在。 Document对象是Window对象的一个成员属性,通过window.document来访问,当然也可以直接使用 document 我给大家讲document对象常用的函数和属性，其它的参考帮助文档。 write() 向文档写文本或HTML表达式或JavaScript 代码 writeln() 等同于write()方法,不同的是在每个表达式之后写一个换行符 open() 打开一个新文档,并删除当前文档内容 close() 关闭open()文档流 getElementById() 通过html控件的id 得到 该控件.如果有相同的id则只取第一个 getElementsByName() 通过html控件的名字返回对象集合 getElementsByTagName() 通过html的标签名返回对象集合 createElement() 创建一个指定标签名的元素[比如:动态创建超链接] alinkColor 当前文档超链接的颜色 linkColor 当前文档超链接的颜色 alinkColor 当前文档访问过的超链接颜色 bgColor 当前文档背景色 fgColor 文档前景色 titel 当前文档的标题. URL 当前文档URL domain 当前文件访问的域名 动态的创建元素(节点)/添加元素(节点)/删除元素(节点)？基本步骤： 创建元素 给新的元素添加必要的信息 将元素添加到指定的位置，比如div body 动态增加一个元素 &lt;html&gt; &lt;head&gt; &lt;script language=&quot;javascript&quot;&gt; function test(){ //创建元素 //写希望创建的元素的标签名字 var myElement=document.createElement(&quot;a&quot;); var myElement2=document.createElement(&quot;input&quot;); //给新的元素添加必要的信息 myElement.href=&quot;http://www.baidu.com&quot;; myElement.innerText=&quot;连接到百度&quot;; myElement.id=&quot;id1&quot;; myElement2.type=&quot;button&quot;; myElement2.value=&quot;我是按钮&quot;; //可以指定位置 /*myElement.style.left=&quot;200px&quot;; myElement.style.top=&quot;300px&quot;; myElement.style.position=&quot;absolute&quot;; //将元素添加到document.body上去 document.body.appendChild(myElement);*/ //将元素添加到div上去 document.getElementById(&quot;div&quot;).appendChild(myElement); document.getElementById(&quot;div&quot;).appendChild(myElement2); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; onclick=&quot;test()&quot; value=&quot;动态的创建一个超链接&quot;&gt; &lt;div id=&quot;div&quot; style=&quot;width:100px;height:300px;border=1px solid red&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 动态删除一个元素 function test2(){ //删除一个元素(删除一个元素的是有前提的：必须获得父元素) //这是第一种方法(不灵活) document.getElementById(&quot;div&quot;).removeChild(document.getElementById(&quot;id1&quot;)); //第二种方法比较灵活（推荐）这种方法不知道父元素id也能获得父元素 //window.alert(document.getElementById(&quot;id1&quot;).parentNode.id);//测试可以返回父元素id document.getElementById(&quot;id1&quot;).parentNode.removeChild(document.getElementById(&quot;id1&quot;)); } &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;动态的创建一个超链接&quot; onclick=&quot;test()&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;删除一个元素id为id1的&quot; onclick=&quot;test2()&quot;/&gt; &lt;div id=&quot;div&quot; style=&quot;width:200px;height:400px; border:1px solid red;&quot;&gt;div&lt;/div&gt; &lt;/body&gt; 对dom的加强： 在dom编程中，一个html文档会被当做 dom 树对待，dom会把所有的html元素（包括注释），映射成Node节点。于是你就可以使用Node节点的属性和方法。 温馨提示：html dom 和 xml dom 都遵循相同dom规范的，所以他们有很多相同的方法和属性 ，因此我们也可以去查看 xml dom 的 node 节点提供的方法和属性 body对象body 对象代表文档的主体 (HTML body)。 body对象是document对象的一个成员属性,通过document.body来访问. 使用body对象，要求文档的主体创建后才能使用,也就是说不能再文档的body体还没有创建就去访问body,这个后面我会举例说明. 我给大家讲body对象常用的函数和属性，其它的参考帮助文档。 appendChild() 添加元素 removeChild() 删除元素 getElementsByTagName() 通过html元素名称,得到对象数组. bgColor 文档背景色 backgorund 文档背景图 innerText 某个元素间的文本 innerHtml 某个元素间的html代码 onload事件 文档加载时触发 onunload事件 文档关闭时触发 onbeforeunload事件 文档关闭前触发 onselectstart事件 用户选中文档body体的内容时触发 onscroll事件 用户拉动滚动条时触发（） offsetWidth可以返回当前对象的实际宽度 offsetHeight可以返回当前对象的实际高度 body.clientWidth当前页面的宽度 body.clientHeight当前页面的高度 innerText属性和innerHtml属性的区别 &lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt; function test(){ //innerText 浏览器会作为纯文本来解析 document.getElementById(&quot;myspan&quot;).innerText=&quot;&lt;a href=&apos;http://www.sina.com&apos;&gt;到新浪&lt;/a&gt; &quot;; //innerHTML 浏览器会作为html来解析 document.getElementById(&quot;myspan&quot;).innerHTML=&quot;&lt;a href=&apos;http://www.sina.com&apos;&gt;到新浪&lt;/a&gt; &quot;; } &lt;/script&gt; &lt;body&gt; &lt;span id=&quot;myspan&quot;&gt;&lt;/span&gt; &lt;input type=&quot;button&quot; value=&quot;测试&quot; onclick=&quot;test()&quot;/&gt; &lt;/body&gt; style对象style对象和document对象下的集合对象styleSheets有关系,styleSheets是文档中所有style对象的集合,这里讲解的重点是 style对象,styleSheets不是重点。 style对象定义:Represents the current settings of all possible inline styles for a given element ,即表示当前元素的样式设置 style对象不是针对某一个html元素,而是对所有的html元素而言的,也就是说,我们可以通过document.getElementById(“id”).style.property=“值” ,来控制网页文档的任何一个元素(对象)的样式,当然这个很重要的. js 通过style对象把css 结合起来的，所以各位需要学习过css,如果大家忘了css ，请各位看我前面讲的 css部分内容 使用style对象属性的语法:document.getElementById(“id号”).style.property=“值”,这里我们需要参考帮助文档，看看究竟有哪些Property 我给大家讲style对象常用的函数和属性，其它的参考帮助文档。 backgroundRepeat 设置是否及如何重复背景图像 border 在一行设置四个边框的所有属性 display 设置元素显示方式 width 设置元素的宽度 height 设置元素的高度 visibility 属性设置元素是否可见 forms对象/form对象forms对象(集合)定义:Retrieves a collection, in source order, of all form objects in the document,即按照表单在文档中的顺序得到form对象,forms对象集合中包括了当前文档的所有form对象。 讲forms对象(集合)的目的其实是为了讲解form对象,form对象我会单拉出来讲解。 我给大家讲forms常用的函数和属性，其它的参考帮助文档。 lenght 设置或得到集合大小。 item() namedItem() //这两个方法我们不做介绍，在实际开发中用的很少，我们重点介绍form对象 form对象代表一个HTML表单在 HTML文档中每出现一次,Form 对象就会被创建。 从dom对象层次图看,document.forms对象是当前文档所有form对象的集合。 说明：当访问某个表单的某个元素的时候，可以 document.forms[第几个表单].元素的名字 document.forms.item(第几个表单).元素的名字 //如何取得所有表单 var forms = document.forms; //window.alert(forms.length); //可以通过forms访问指定表单 //window.alert(forms[0].username.value); 两者等价 window.alert(forms.item(0).username.value); images对象/img对象images对象(集合)定义:Retrieves a collection, in source order, of img objects in the document ,即按照img在文档中的顺序得到img 对象, images对象集合中包括了当前文档的所有img对象 讲images对象(集合)的目的其实是为了讲解img对象 img对象代表一个图片在HTML文档中每出现 一次,就会创建一个img对象。 讲从dom对象层次图看,document.images对象是当前文档所有img对象的集合。 我们看看img常用的属性。 id 设置或得到该图片id name 设置或得到该图片name src 设置或得到该图片src width 设置或得到该图片width height 设置或得到该图片的height style 设置或得到该图片的style,通过style对象的各个属性，可以控制该图片更多的样式. image 对象的事件句柄 onerror图片加载失败触发此事件 onload图片加载成功触发此事件 onabort用户放弃图像的装载时调用 links对象/link对象links对象(集合)定义:Retrieves a collection of all a objects that specify the HREF property and all area objects in the document 。 讲links对象(集合),就自然的引出了link对象。 link对象代表一个超链接在HTML文档中&lt;a&gt;每出现一次,就会创建一个link对象。 讲从dom对象层次图看,document.links对象是当前文档所有link对象的集合。 我们看看link常用的属性 id 设置或得到该超链接id name 设置或得到该超链接name href 设置或得到该超链接href all对象all对象(集合)定义:Returns a reference to the collection of elements contained by the object 。 all对象(集合),能得到当前文档的所有元素,一般在遍历文档的时候使用，在实际开发中用的不是很多,故而简单讲解 我们看看all对象常用的函数和属性。 lenght 设置或得到集合大小。 item() 通过序列号得到对象 namedItem() 通过名字得到对象 table对象table 对象代表一个 html 表格。 在HTML文档中标签每出现一次，一个table对象就会被创建 我们看看table常用的属性。 id 设置或得到该表格的id name 设置或得到该表格name border 设置或得到该表格的边框 width 设置或得到该表格的宽度 height 设置或得到该表格的高度 cellpadding 设置或返回单元格内容和单元格边框之间的空白量 cellspacing 设置或返回在表格中的单元格之间的空白量 style 设置或得到该表格的style对象 我们看看table常用的属性(对象集合)。 rows[] 表格中所有行的一个数组(针对表格) cells[] 表格中所有单元格的一个数组(针对一行) 我们看看table常用的方法 deleteRow() 删除一行 insertRow() 插入一行 TableRow 对象代表一个 HTML 表格行。在 HTML 文档中 &lt;tr&gt; 标签每出现一次，一个 TableRow 对象就会被创建。 TableCell 对象代表一个 HTML 表格单元格。在HTML 文档中 &lt;td&gt; 标签每出现一次，一个TableCell 对象就会被创建。 其它html dom对象img对象对于images对象集合,link对象对应links对象集合,form对象对应forms对象集合,frame对象对应frames对象集合…实际上html元素还有很多,比如button select radio text option table …这些也是html dom对象，它们的使用和image对象、link对象非常相似，相信大家可以举一反三。 正则表达式所谓正则表达式，就是某种模式去匹配一类字符串的一个公式，反应到我们的JS中就是一个RegExp对象。RegExp 对象表示正则表达式，它是对字符串执行模式匹配的强大工具。 创建RegExp对象有以下几种方法: 隐式创建RegExp对象它的创建形式是 /pattern/[flag] 这种形式; 说明：pattern 是必须的，flag是可以选择的。 pattern就是按照正则表达式的模式进行编写，flag是可以选择的，它主要有以下几种标识符: 显式的创建RegExp对象,它的创建形式是 new RegExp(“pattern”[,”flag”]); 说明：pattern 是必须的，flag是可以选择的。 pattern就是按照正则表达式的模式进行编写，flag是可以选择的，它主要有以下几种标识符: g 全局标志 i 忽略大小写 m 用作多行标志比如: var myReg = new RegExp(“\d{3}”,”gi”); 举例说明正则表达式的使用方法 查找以空字符结尾的行 [\x20\t]+$ 查找空行 ^$ 查找12.34 \$12.34 查找合法的C语言变量名 \&lt;[a-zA-Z][a-zA-Z0-9]* 查找最里层的表达式 ([^()]*) RegExp对象的常用方法 regexp.exec(con) 检索字符串中指定的值,并返回值(找不到返null)。 regexp.test(con) 检索字符串中指定的值,返回 true 或 false String对象的方法 match() 语法格式为：match(reExp)。与RegExp对象的exec方法类似，它使用正则表达式模式对字符串执行搜索，并返回一个包含搜索结果的数组。 search() 语法格式为：search(reExp)，它返回使用正则表达式搜索时，第一个匹配的字符串在整个被搜索的字符串中的位置。 replace() 语法格式为：replace(rgExp,replaceText)，使用正则表达式模式对字符串执行搜索，并对搜索到的内容用指定的字符替换，返回值为包含替换后的内容的字符串对象。 split() 把字符串分割为字符串数组。用法 split(“按什么字符分割”)，也可以用split(regExp). RegExp对象的属性 RegExp对象属性分为静态属性和实例属性,所谓静态属性是指:可以通过RegExp就可以访问。所谓实例属性是指: 通过RegExp对象实例才能访问使用。 我们一起来看看RegExp有哪些静态属性 index 是当前表达式模式首次匹配内容的开始位置，从0开始计数。其初始值为-1，每次成功匹配时，index属性都会随之改变 lastindex 是当前表达式模式首次匹配内容中最后一个字符的下一个位置，从0开始计数 input 返回当前所作用的字符串, leftContext 是当前表达式模式最后一个匹配字符串左边的所有内容 rightContext 是当前表达式模式最后一个匹配字符串右边的所有内容 RegExp对象的属性 global 返回创建RegExp对象实例时指定的global标志（g）的状态,(true,false) ignoreCase 是返回创建RegExp对象实例时指定的ignoreCase标志（i）的状(true,false) multiLine 返回创建RegExp对象实例时指定的multiLine标志（m）的状态,true或者false source 返回创建RegExp对象实例时指定的表达式文本字符串 要解决前面的问题，我们需要了解正则表达式的几个概念: 子表达式:我们可以用圆括号组成一个比较复杂的匹配模式，那么一个圆括号的部分我们可以看作是一个子表达式。 捕获:多个子表达式所匹配到的内容按顺序出现在内存的缓冲区中，这个我们称为捕获 反向引用:圆括号的内容被捕获后，可以在这个括号后被使用，从而写出一个比较实用的匹配模式，这个我们称为反向引用 看几个小案例 要匹配两个连续的数字 : (\d)\1要匹配五个连续的数字：(\d)\1{4}要匹配个位与千位相同，十位与百位相同的数 5225 , 1551 , 可以这样写： (\d)(\d)\2\1 元字符 如果要想灵活的运用正则表达式，必须了解其中各种元字符的功能，元字符从功能上大致分为： 限定符:用于指定其前面的字符和组合项连续出现多少次 {n}说明：n表示出现的次数，比如 a{3},1{4},(\d){2} 但是这里要注意一点, 1{3} 去匹配 1111111的话，会得到什么结果呢? 111 111 最后的一个1被舍弃 {n,m}说明：n表示至少出现的n次最多m次 ，比如 a{3,4},1{4,5},(\d){2,5} 我们看看 1{3,4} 去匹配 1111111的话，会得到什么结果呢? 1111 111 表示出现1次到任意多次 ，比如 /a+/gi,/1+/gi,/(\d)+/gi 表示出现0次到任意多次 ，比如 /a*/gi,/1*/gi,/(\d)*/gi ? 表示出现0次到1次 ，比如 /a?/gi,/1?/gi,/(\d)?/gi 字符匹配符 [a-z] 说明：[a-z] 表示可以匹配a-z中任意一个字符 ，比如 /[a-z]/gi,/[a-z]{2}/gi [^a-z] 表示可以匹配不是a-z中的任意一个字符 ，比如 /[a-z]/gi,/[a-z]{2}/gi [abcd] 表示可以匹配abcd中的任意一个字符 \d 表示可以匹配0-9的任意一个数字,相当于 [0-9]。 \D 表示可以匹配不是0-9中的任意一个数字,相当于[^0-9] \w 匹配任意英文字符、数字和下划线,相当于[a-zA-Z0-9_] \W 相当于 [^a-zA-Z0-9_] 是\w 刚好相反. \s 匹配任何空白字符(空格,制表符等) \S 匹配任何非空白字符 ,和\s刚好相反 . 匹配出 \n 之外的所有字符,如果要匹配.本身则需要使用 . 需要用到转义符号的字符有以下:* + ( ) $ / \ ? [ ] ^ { } 定位符 定位符用于 规定要匹配的字符串出现的位置，比如在字符串的开始还是在结束的位置，这个也是相当有用的，必须掌握。 ^ 符号 说明: 匹配目标字符串的开始位置。 比如 /^han/gi 去匹配 “hanshunping han han” ,我们看看会得到什么结果? $ 符号 说明: 匹配目标字符串的结束位置。 比如 /han$/gi 去匹配 “hanshunping han hanuu” ,我们看看会得到什么结果?\b 符号 说明: 匹配目标字符串的边界。这个字符串的边界，有点不好理解，我给大家举一个实例说明,比如 /han\b/gi 去匹配 “hanshunping sphan nnhan” ,我们会匹配到 “hanshunping sphan nnhan” ,所以这里说的字符串的边界指的是子串间有空格，或者是目标字符串的结束位置，特别注意没有目标字符串的开始位置 \B 符号 说明:匹配目标字符串的非边界。这个和\b的含义刚刚相反，不再赘述，请看一个案例比如 /han\B/gi 去匹配 “hanshunping sphan nnhan” ,我们会匹配到 “hanshunping sphan nnhan” 选择匹配符: 有时候，我们在匹配某个字符串的时候是选择性的，即：既可以匹配这个，又可以匹配那个，这时你需要用到 选择匹配符号 | 选择匹配符号还是比较好理解的,我们通过一个案例说明:用 (han|韩|含)\gi 去匹配“hanshunping 韩顺平 ”，会得到什么结果? 特殊字符: \xn 的 x是固定的 , n是一个十六进制的数，比如\x21 就是去匹配 ascii码表中 十六进制是 21的字符，查表可知就是 ! 实际上，我们也可以直接通过\ \gi 的方式来匹配某些不可见特殊字符 js在默认匹配中使用的是贪婪匹配的原则，即尽可能匹配多的字符串，这点在上面的案例中体现的很清楚]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS的学习及总结]]></title>
    <url>%2F2013%2F12%2F27%2FCSS%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8F%8A%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[基本介绍div是用于存放html元素，文字，图片，视频的元素 css 是层叠样式表，用于指定div中的内容的样式 test.html： &lt;!DOCTYPE HTML PUBLIC &quot;-//w3c//DTD HTML 4.0 Transitional//EN&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;快速入门&lt;/title&gt; &lt;link href=&quot;my.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot;/&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;style1&quot;&gt; &lt;table&gt; &lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; my.css中指定： .style1{ width:300px; height:200px; border:1px solid red; margin:100px 0px 0px 200px; } .style1 table{ border:1px solid black; width:298px; height:190px; } .style1 table td{ border: 1px solid black; text-align:center; } div+css优势 大大缩减页面代码，提高页面浏览速度,缩减带宽成本; 结构清晰，容易被搜索引擎搜索到，天生优化了seo 缩短改版时间。只要简单的修改几个CSS文件就可以重新设计一个有成百上千页面的站点。 强大的字体控制和排版能力。CSS控制字体的能力比糟糕的FONT标签好多了，有了CSS，我们不再需要用FONT标签或者透明的1 px GIF图片来控制标题，改变字体颜色，字体样式等等。服合WEB2.0标准 使用元素来编写，使用myeclipse来开发，因为myeclipse有提示功能 &lt;span style=&quot;font-size:30px;color: blue;&quot;&gt;栏目一&lt;/span&gt;&lt;br/&gt; &lt;元素名 style=”属性名：属性值；属性名：属性值2；”/&gt; css的三种选择器 类选择器 .类选择器名{ 属性名:属性值; … } my.css文件 .style1{ font-size: 20px; font-weight: bold; background-color: purple; } &lt;span class=&quot;style1&quot;&gt;栏目一&lt;/span&gt; id选择器 #id选择器名{ 属性名：属性值； } 案例： #style2{ font-size: 30px; background-color: skyblue; } &lt;span id=&quot;style2&quot;&gt;这是一则重要的新闻&lt;/span&gt; Html选择器 /*html选择器body(button,input,form...)*/ body { color:silver; } 通配符选择器 如果希望所有的元素都符合某一种样式，可以使用通配符选择器。 基本语法： /*使用通配符选择器对外边距和内边距清零*/ * { margin: 0; padding: 0; } * { /*margin: 0; 将外边距清零*/ /*margin-top:10px;分别设置四个方向的外边距 margin-left:10px; margin-right:0px; margin-bottom:opx;*/ /*margin:10px 0px 0px 10px;顺时针方向：上，右，下，左 */ margin:10px 0px 0px;/*10表示上，左右，下*/ padding: 0;/*将内边距清零，padding的规范跟margin一样/ } 父子选择器 &lt;span id=&quot;style2&quot;&gt;这是一则&lt;span&gt;非常重要&lt;/span&gt;的新闻&lt;/span&gt;&lt;br/&gt; my.css添加一个父子选择器 /*父子选择器*/ #style2 span { font-style:italic; color:red; } 注意: 子选择器标签必须是html可以识别的标记 父子选择器可以有多级 父子选择器可以适用于id选择器和class选择器 结论：当一个元素同时被id选择器 类选择器 html选择器修饰时，优先级为：id选择器&gt;类选择器&gt;html选择器&gt;通配符选择器, 一个元素最多有一个id选择器，但是可以有多个类选择器 在有些css中，我们可以把多个class选择器，id选择器，html选择器，共同的部分提取出来，写在一起，这样的好处是可以简化css文件 /*广告2*/ .ad_2{ width :457px; background-color:#7CF574; margin:5px 0 0 6px; } /*房地产广告*/ .ad_house{ height:196px; background-color:#7CF574; margin:5px 0 0 5px; } .ad_2,.ad_house{ width :152px; float:left } 块元素和行内元素 行内元素(inline element),又叫内联元素:内联元素只能容纳文本或者其他内联元素,常见内联元素&lt;span&gt; &lt;a&gt; 块元素(block element):块元素一般都从新行开,可以容纳文本,其它内联元素和其它块元素，即使内容不能占满一行，块元素也要把整行占满。常见块元素&lt;div&gt; &lt;p&gt; 块元素和行内元素-区别 行内元素只占内容的宽度,块元素内容不管内容多少要占全行。 行内元素只能容纳文本和其它行内元素，块元素可以容纳文本，行内元素和块元素.(与浏览器类版本和类型有关) 一些css属性对行内元素不生效，比如margin,left,right,width,height.建议尽可能使用块元素定位。(与浏览器类版本和类型有关) 请注意:行内元素和块元素可以相互转换 display:inline -&gt; 转为行内元素 (比如div) display:block -&gt; 转为块元素 (比如a) 流流: 在现实生活中就是流水,在网页设计中就是指元素(标签)的排列方式。 标准流: 元素在网页中就象流水，排在前面的元素(标签)内容前面出现，排后面的元素(标签)内容后面出现 非标准流: 当某个元素(标签)脱离了标准流[比如因为相对定位]排列，我们统称为非标准流排列 css盒子模型我们可以把盒子模型转移到我们日常生活中的盒子(箱子)上来理解，日常生活中所见的盒子也具有这些属性，所以叫它盒子模式。那么内容就是盒子里装的东西；而填充就是怕盒子里装的东西（贵重的）损坏而添加的泡沫或者其它抗震的辅料；边框就是盒子本身了；至于边界则说明盒子摆放的时候的不能全部堆在一起，要留一定空隙保持通风，同时也为了方便取出嘛。 与现实生活中盒子不同的是，现实生活中的东西一般不能大于盒子,否则盒子会被撑坏的，而CSS盒子具有弹性，里面的东西大过盒子本身最多把它撑大,但它不会损坏的。 细节说明： html元素都可以看成一个盒子 盒子模型的参照物不一样，则使用的css属性不一样，比如从div1的角度看，是margin-right，从div2的角度看，则是margin-left 如果不希望破坏整个外观，则尽量使用margin布局，因为padding可能会改变盒子的大小（相当于这个盒子有弹性），margin如果过大，盒子内容被挤到盒子外边去，但是盒子本身没有变化 浮动浮动是一个重要的概念：分为左浮动，右浮动，清除浮动 特别强调：浮动对块元素和行内元素都是生效的。 你可以这么理解浮动:如果一个元素右/左浮动则: 它本身会尽可能向右/左移动，直到碰到边框或者别的浮动元素 元素向右/左浮动，就相当于让出自己的左/右边,别的元素就会在它的左/右边排列。 浮动-清除浮动 如果不希望别的元素在某个元素的左边或者右边，可以使用清除浮动的方法 clear:right ; clear: left; clear:both 定位CSS定位(Positioning)属性允许你对元素进行定位.position 属性值： static (默认值)：元素框正常生成。块级元素生成一个矩形框，作为文档流/标准流的一部分，行内元素则会创建一个或多个行框，置于其父元素中。 relative：元素框偏移某个距离。元素仍保持其未定位前的形状，它原本所占的空间仍保留,从这一角度看，好像该元素仍然在文档流/标准流中一样。 absolute：元素框从文档流完全删除，并相对于其包含块定位。包含块可能是文档中的另一个元素或者是初始包含块。元素原先在正常文档流中所占的空间会关闭，就好像元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。 fixed：元素框的表现类似于将 position 设置为 absolute，不过其包含块是视窗本身。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Html的学习及总结]]></title>
    <url>%2F2013%2F11%2F29%2FHtml%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8F%8A%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Html基础什么是HtmlHTML（HyperText Mark-up Language）即超文本标记语言或超文本链接标示语言，是目前网络上应用最为广泛的语言，也是构成网页文档的主要语言。HTML文本是由HTML命令组成的描述性文本，HTML命令可以说明文字、图形、动画、声音、表格、链接等。 HTML的结构包括头部（Head）、主体（Body）两大部分，其中头部描述浏览器所需的信息，而主体则包含所要说明的具体内容。 HTML可以编写静态网页. 该静态网页可以包括文字、图形、动画、声音、表格、链接。从而构成一个个漂亮的网页。 W3C的介绍W3C是英文 World Wide Web Consortium 的缩写，中文意思是W3C理事会或万维网联盟。W3C于1994年10月在麻省理工学院计算机科学实验室成立。创建者是万维网的发明者Tim Berners-Lee。W3C组织是对网络标准制定的一个非赢利组织，像HTML、XHTML、CSS、XML的标准就是由W3C来定制。W3C会员（大约500名会员）包括生产技术产品及服务的厂商、内容供应商、团体用户、研究实验室、标准制定机构和政府部门，一起协同工作，致力在万维网发展方向上达成共识。 html-&gt;xhtml-&gt;xmlhtml语言本身有一些缺陷(比如内容和形式不能分离,标记单一,数据不能复用等),随着xml的兴起，xml越来越受到国际认可，所以人们希望xml来弥补html的不足,但是目前有成千上万的网页都是html编写的，所以完全使用xml来替代html还为时过早,于是w3c在2000推出xhtml1.0，建立XHTML的目的就是实现HTML向XML的过渡。 Html的运行原理 本地运行html文件 使用 浏览器（软件）打开 远程访问运行你的电脑（浏览器），另一台电脑访问远程服务器 html的开发工具 记事本 editplus vim frontpage dw zend studio 其它的ide myeclipse/vs/idea ###html的基本结构&lt;元素名 [属性]&gt;元素内容&lt;/元素名&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;第一个网页&lt;/title&gt; &lt;/head&gt; &lt;body&gt;hello&lt;/body&gt; &lt;/html&gt; 不管这html文件有多复杂，它的基本结构是 &lt;元素名 [属性]&gt;元素内容&lt;/元素名&gt; 元素也叫标记 &lt;font size=2 color=red&gt;举头望明月&lt;/font&gt;&lt;/br&gt; 案例 &lt;p&gt;段落标记&lt;/p&gt; 跳转到下一行的下一行 &lt;font size=””&gt;字体标记&lt;/font&gt;size取值1到7 &lt;h#&gt;标题字体&lt;/h#&gt; #=1，2，3，4，5，6 &lt;b&gt;&lt;/b&gt;：字体加粗 &lt;/br&gt;换到下一行 将html的内容放在体内 &lt;html&gt; &lt;head&gt; &lt;title&gt;第一个网页&lt;/title&gt;//文件的头部，此处可以略去不写 &lt;/head&gt; &lt;body&gt; &lt;!==我们的内容放在这部分中==&gt;//注释这样写 &lt;h3&gt;静夜思&lt;/h3&gt; &lt;p&gt;&lt;b&gt;床前明月光&lt;/b&gt;&lt;/p&gt;疑是地上霜&lt;/br&gt; &lt;font size=2 color=red&gt;举头望明月&lt;/font&gt;&lt;/br&gt; 低头思故乡&lt;/br&gt; &lt;/body&gt; &lt;/html&gt; html的标记/元素html的标记/元素的认识 HTML标记是用来组成HTML元素的 HTML标记用两个尖括号”&lt;&gt;”括起来 HTML标记一般是双标记，如和 前一个标记是起始标记, 后一个标记为结束标记 两个标记之间的文本是html元素的内容 某些标记称为“单标记”,因为它只需单独使用就能完整地表达意思,如 html标记和html元素可以看做是同一个概念，在我的课程中为统一说法，就叫html元素 html的标记/元素 html超链接 &lt;a href=“url地址” target=&quot;_self/_blank&quot;&gt;&lt;/a&gt;`` html图像元素 &lt;img src=&quot;http://www.baidu.com/img/baidu_jgylogo3.gif&quot; &gt;&lt;/img&gt; &lt;img src=&quot;d://1.jpg&quot; width=300 border=1 &gt;&lt;/img&gt; 加边框 html表格 &lt;table border=“边框宽度” cellspacing=“空隙大小” cellpadding=“填充大小”&gt; &lt;tr align=center&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;/tr&gt; &lt;tr align=center&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; 无序列表ul/li &lt;ul type=“属性值”&gt; &lt;li&gt;列表内容&lt;/li&gt; &lt;/ul&gt; type=”square”设定符号款式，其值有三种，如下，默认为 type=”disc”： type=”disc” 时的列项符号为实心圆点。 type=”circle” 时的列项符号为空心圆。 type=”square” 时的列项符号为空心正方形。 html列表-有序列表 &lt;ol type=“属性值” start=“起始值”&gt; &lt;li&gt;列表内容&lt;/li&gt; &lt;/ol&gt; type设定数目款式，其值有五种 1 阿拉伯数字 1, 2, 3, … a 小写字母 a, b, c, … A 大写字母 A, B, C, … i 小写罗马数字 i, ii, iii, … I 大写罗马数字 I, II, III, … html列表-框架 &lt;frameset frameborder=“边框大小” cols=‘”各窗口百分比，隔开” rows=“各窗口百分比”&gt; &lt;frame name=“给frame取名” src=“html路径” noresize&gt; &lt;/frameset&gt; form(表单)元素介绍 html表单元素主要是让用户输入数据，提交给服务器 &lt;form action=&quot;url&quot; method=*&gt; ... ... &lt;input type=submit&gt; &lt;input type=reset&gt; &lt;/form&gt; //星号*部分可以为GET,也可以是 POST type表示输入框的类型，有以下几种：type = text（文本框）、password（密码框）、hidden（隐藏框）、checkbox（复选框）、radio（单选框）、submit（提交按钮）、reset（重置按钮）、image（图片按钮）&lt;input type=”image” src=””&gt; name 是给该表单元素取名,action指定把请求提交给哪个页面,post不会在地址栏上显示，但是get会在地址栏上显示，这样很危险 html的加强 语言字符集 您在浏览主页时，最好自己在浏览器的选项菜单内选择相应的语言。但是如果 HTML 文件里写明了设置，浏览器就会自动设置语言选项。 &lt;head&gt; &lt;title&gt;hello&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=gbk&quot;&gt; &lt;/head&gt; 背景色彩和文字色彩 &lt;body link=red text=blue&gt;你好,文本是蓝色，链接是红色 &lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt; &lt;/body&gt; 页面空白 让文本靠近左上角 &lt;body leftmargin=0 topmargin=0&gt;你好 &lt;/body&gt; target &lt;a href=url target=_blank&gt; 新窗口 &lt;a href=url target=_self&gt; 本窗口 &lt;a href=url target=_parent&gt; 父窗口 &lt;a href=url target=_top&gt; 整个浏览器窗口 &lt;a href=url target=指向frame的名字&gt; 标识线 &lt;hr color=”red”/&gt; 字体大小 &lt;font style=”font-size:150px”&gt;标题&lt;/font&gt; 次句可以将字体无限放大，因为用&lt;h1&gt;最大此时满足不了需要face=”华文新魏” 可以给字设置不同的字体 图像 &lt;img src=”d://1.jpg” alt=”这是小狗”&gt; &lt;/img&gt; 鼠标点到图片时，显示文字 会移动的文字 &lt;marquee&gt;啦啦啦，我会移动耶！&lt;/marquee&gt;]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springMvc的学习和总结]]></title>
    <url>%2F2013%2F10%2F25%2FspringMvc%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93(%E6%9C%AA%E5%AE%8C%E6%88%90)%2F</url>
    <content type="text"></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Server</tag>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>Framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring的学习和总结]]></title>
    <url>%2F2013%2F09%2F27%2Fspring%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[spring是什么 struts 是 web 框架 (jsp/action/actionfrom) hibernate 是 orm框架,处于持久层. spring 是容器框架,用于配置bean,并维护bean之间关系的框架 spring中有一个非常概念: bean (是java中的任何一种对象 javabean/service/action/数据源./ dao, ioc(控制反转 inverse of control) di( dependency injection 依赖注入) 快速入门开发一个spring项目 引入spring的开发包(最小配置spring.jar 该包把常用的jar都包括, 还要 写日志包 common-logging.jar 创建spring的一个核心文件 applicationContext.xml, [hibernate有核心 hibernate.cfg.xml struts核心文件 struts-config.xml], 该文件一般放在src目录下,该文件中引入 xsd文件 ： 配置bean &lt;!-- 在容器文件中配置bean(service/dao/domain/action/数据源) --&gt; &lt;!-- bean元素的作用是，当我们的spring框架加载时候，spring就会自动的创建一个bean对象，并放入内存 UserService userSerivce=new UserService(); userSerivce.setName(&quot;韩顺平&quot;); --&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.service.UserService&quot;&gt; &lt;!-- 这里就体现出注入的概念. --&gt; &lt;property name=&quot;name&quot;&gt; &lt;value&gt;韩顺平&lt;/value&gt; &lt;/property&gt; &lt;!-- 有可以用这种方式来注入 --&gt; &lt;property name=&quot;name&quot; value=“韩顺平” /&gt; &lt;/bean&gt; 传统的方法和使用spring的方法 使用spring ，没有new 对象,我们把创建对象的任务交给spring框架，spring实际上是一个容器框架，可以配置各种bean(action/service/domain/dao),并且可以维护bean与bean的关系,当我们需要使用某个bean的时候，我们可以getBean(id),使用即可 ioc是什么?ioc(inverse of controll ) 控制反转: 所谓控制反转就是把创建对象(bean),和维护对象(bean)的关系的权利从程序中转移到spring的容器(applicationContext.xml),而程序本身不再维护 DI是什么? di(dependency injection) 依赖注入: 实际上di和ioc是同一个概念，spring设计者认为di更准确表示spring核心技术 学习框架，最重要的就是学习各个配置. 装配bean（两种方式）包括bean工厂模式和应用上下文模式两种 什么是bean工厂？ 最简单的容器，提供了基础的依赖注入支持。创建各种类型的Bean. 工厂设计模式，创建分发各种bean。配置好它们之间的写作关系，参与bean的生命周期。 //如果我们使用beanfactory去获取bean，当你只是实例化该容器， 那么容器的bean不被实例化,只有当你去使用getBean某个bean时，才会实时的创建. BeanFactory factory = new XmlBeanFactory( new ClassPathResource(&quot;com/hsp/ioc/beans.xml&quot;)); factory.getBean(&quot;student&quot;); bean工厂只把bean的定义信息载进来，用到的时候才实例化。 什么是应用上下文(ApplicationContext)？ 建立在bean工厂基础之上，提供系统架构服务。 //从ApplicationContext中取bean //当我们去实例化beans.xml,该文件中配置的bean被实例(该bean scope是 singleton)从bean中取出student ApplicationContext ac=new ClassPathXmlApplicationContext(&quot;com/hsp/ioc/beans.xml&quot;); 三种经常用到的实现： ClassPathXmlApplicationContext:从类路径中加载。 FileSystemXmlApplicationContext:从文件系统加载。 ApplicationContext ac=new FileSystemXmlApplicationContext(&quot;文件路径beans.xml / applicationContext.xml&quot;); XmlWebApplicationContext:从web系统中加载 结论: 如果使用ApplicationContext ，则配置的bean如果是 singlton不管你用不用，都被实例化.(好处就是可以预先加载,缺点就是耗内存) 如果是 BeanFactory ,则当你获取beanfacotry时候，配置的bean不会被马上实例化，当你使用的时候，才被实例(好处节约内存,缺点就是速度) 规定: 一般没有特殊要求，应当使用ApplicatioContext完成(90%) bean 的 scope的细节 singleton: 单例 默认值 prototype: 原型 request: 一次请求有效( java web开发中) session: session级有效(java web开发中) bean的生命周期 实例化(当我们的程序加载beans.xml文件)，把我们的bean(前提是scope=singleton)实例化到内存 调用set方法设置bean的属性 如果你实现了bean名字关注接口(BeanNameAware) 则，可以通过setBeanName获取bean的id号 如果你实现了 bean工厂关注接口，(BeanFactoryAware),则可以获取BeanFactory 如果你实现了 ApplicationContextAware接口，则调用方法setApplicationContext，该方法传递ApplicationContext public void setApplicationContext(ApplicationContext arg0) throws BeansException { System.out.println(&quot;setApplicationContext&quot;+arg0); } 如果bean 和 一个后置处理器关联,则会自动去调用 Object postProcessBeforeInitialization方法 如果你实现InitializingBean接口，则会调用 afterPropertiesSet 如果自己在 则可以在bean定义自己的初始化方法 init. 如果bean 和 一个后置处理器关联,则会自动去调用 Object postProcessAfterInitialization方法 使用我们的bean 容器关闭 可以通过实现DisposableBean 接口来调用方法 destory 可以在 调用定制的销毁方法 小结: 我们实际开发中往往，没有用的这么的过程,常见的是:1-&gt;2-&gt;6-&gt;10-&gt;9-&gt;11 问题:通过BeanFactory来获取bean对象，bean的生命周期是否和Applicationcontext 是一样吗? 具体只有1、2、3、4、7、8、10、11、12、13 装配bean尽量使用 scope=”singleton” ,不要使用prototype,因为这样对我们的性能影响较大 如何给类型注入值&lt;!-- 通过set方法注入依赖 --&gt; &lt;bean id=&quot;foo&quot; class=&quot;...Foo&quot;&gt; &lt;property name=&quot;name&quot;&gt; &lt;value&gt;tom&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;name&quot;&gt; &lt;ref bean=&quot;bar&quot;&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;bar&quot; class=&quot;...Bar&quot;&gt; &lt;/bean&gt; &lt;!-- 内部bean --&gt; &lt;bean id=&quot;foo&quot; class=&quot;...Foo&quot;&gt; &lt;property name=&quot;bar&quot;&gt; &lt;bean class=&quot;...Bar&quot;&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 继承配置 --&gt; &lt;!-- 配置一个学生对象 --&gt; &lt;bean id=&quot;student&quot; class=&quot;com.hsp.inherit.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;顺平&quot; /&gt; &lt;property name=&quot;age&quot; value=&quot;30&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置Grdate对象 --&gt; &lt;bean id=&quot;grdate&quot; parent=&quot;student&quot; class=&quot;com.hsp.inherit.Gradate&quot;&gt; &lt;!-- 如果自己配置属性name,age,则会替换从父对象继承的数据 --&gt; &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt; &lt;property name=&quot;degree&quot; value=&quot;学士&quot;/&gt; &lt;/bean&gt; &lt;!-- 给数组注入值 --&gt; &lt;property name=&quot;empName&quot;&gt; &lt;list&gt; &lt;value&gt;小明&lt;/value&gt; &lt;ref bean=&quot;emp1&quot;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 给set注入值 set不能有相同的对象 --&gt; &lt;property name=&quot;empsets&quot;&gt; &lt;set&gt; &lt;value&gt;小明&lt;/value&gt; &lt;ref bean=&quot;emp1&quot; /&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- 给map注入值 map只有key不一样，就可以装配value --&gt; &lt;property name=&quot;empMaps&quot;&gt; &lt;map&gt; &lt;entry key=&quot;11&quot; value=&quot;小明&quot; /&gt; &lt;entry key=&quot;11&quot; value-ref=&quot;emp1&quot; /&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- 装配Properties： --&gt; &lt;property name=&quot;barlist&quot;&gt; &lt;props&gt; &lt;prop key=&quot;key1&quot;&gt;bar1&lt;/prop&gt; &lt;prop key=&quot;key2&quot;&gt;bar2&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- 设置null：--&gt; &lt;property name=&quot;barlist&quot;&gt; &lt;null/&gt; &lt;/property&gt; 目前我们都是通过set方式给bean注入值，spring还提供其它的方式注入值，比如通过构造函数注入值! 如果属性是类类型，则使用ref=&quot;&quot; &lt;bean id=&quot;employee&quot; class=&quot;com.hsp.contructor.Employee&quot;&gt; &lt;constructor-arg index=&quot;0&quot; type=&quot;java.lang.String&quot; value=&quot;顺平&quot; /&gt; &lt;constructor-arg index=&quot;1&quot; type=&quot;int&quot; value=&quot;20&quot;/&gt; &lt;constructor-arg index=&quot;2&quot; type=&quot;double&quot; value=&quot;34.5&quot; /&gt; &lt;/bean&gt; set注入的缺点是无法清晰表达哪些属性是必须的，哪些是可选的，构造注入的优势是通过构造强制依赖关系，不可能实例化不完全的或无法使用的bean。 自动装配bean的属性值&lt;bean id=&quot;foo&quot; class=&quot;...Foo&quot; autowire=&quot;autowire type&quot;&gt; 有四种自动装配类型： 1. byName寻找和属性名相同的bean,若找不到，则装不上。 2. byType:寻找和属性类型相同的bean,找不到,装不上,找到多个抛异常。 3. constructor:查找和bean的构造参数一致的一个或多个bean，若找不到或找到多个，抛异常。按照参数的类型装配 4. autodetect: (3)和(2)之间选一个方式。不确定性的处理与(3)和(2)一致。 5. defualt : 这个需要在&lt;beans default-autorwire=“指定” /&gt; 6. no : 不自动装配，这是autowrite的默认值 混合使用手动和自动组装&lt;bean id=&quot;bar&quot; class=&quot;...Bar&quot; autowire=&quot;byName&quot;&gt; &lt;property name=&quot;cousedao&quot;&gt; &lt;ref bean=&quot;somebean&quot; /&gt; &lt;/property&gt; &lt;/bean&gt; spring2.5提供了&lt;context:annotation-config /&gt;配置.该配置可激活在类中探测到的各种注解,@Required @Autowire @PostConstrct @PreDestroy @Resource @EJB @PersistenceContext @WebServiceRef等等 使用spring的特殊bean让spring特殊对待这些bean。使它们可以： 通过配置后加工bean，涉及到Bean和Bean工厂生命周期。 改变依赖注入，将字符串转换成其它类型。 从属性文本装载信息，包括信息国际化。 监听并处理其它bean及spring发布的系统消息。 知道自己在spring中的唯一表识。 例如：使用spring的特殊bean,完成分散配置: beans.xml 说明: 当通过 context:property-placeholder 引入 属性文件的时候，有多个需要使用 , 号间隔. &lt;!-- 引入我们的db.properties文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:com/hsp/dispatch/db.properties,classpath:com/hsp/dispatch/db2.properties&quot;/&gt; &lt;!-- 配置一DBUtil对象 $占位符号 --&gt; &lt;bean id=&quot;dbutil&quot; class=&quot;com.hsp.dispatch.DBUtil&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;${name}&quot; /&gt; &lt;property name=&quot;drivername&quot; value=&quot;${drivername}&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;${url}&quot; /&gt; &lt;property name=&quot;pwd&quot; value=&quot;${pwd}&quot; /&gt; &lt;/bean&gt; &lt;!-- 配置一DBUtil对象 --&gt; &lt;bean id=&quot;dbutil2&quot; class=&quot;com.hsp.dispatch.DBUtil&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;${db2.name}&quot; /&gt; &lt;property name=&quot;drivername&quot; value=&quot;${db2.drivername}&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;${db2.url}&quot; /&gt; &lt;property name=&quot;pwd&quot; value=&quot;${db2.pwd}&quot; /&gt; &lt;/bean&gt; db.properties: name=scott drivername=oracle:jdbc:driver:OracleDirver url=jdbc:oracle:thin:@127.0.0.1:1521:hsp pwd=tiger AOP编程aop( aspect oriented programming ) 面向切面(方面)编程,是对所有对象或者是一类对象编程,核心是“在不增加代码的基础上，还增加新功能” 汇编(伪机器指令 mov jump) 面向机器c语言(面向过程)-&gt;系统软件(操作系统，数据库, 杀毒软件，防火墙,驱动..) aop特别提醒: aop编程，实际上在开发框架本身用的多,在实际项目中，用的不是很多,但是将来会越来越多，这个一个趋势. 定义接口 编写对象(被代理对象=目标对象) 编写通知（前置通知目标方法调用前调用） 在beans.xml文件配置 配置 被代理对象=目标对象 配置通知 配置代理对象 是 ProxyFactoryBean的对象实例 织入通知 配置被代理对象 提问? 说spring的aop中，当你通过代理对象去实现aop的时候，获取的ProxyFactoryBean是什么类型？ 答: 返回的是一个代理对象,如果目标对象实现了接口，则spring使用jdk 动态代理技术,如果目标对象没有实现接口，则spring使用CGLIB技术.]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Server</tag>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>Framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struts的学习和总结]]></title>
    <url>%2F2013%2F08%2F30%2Fstruts%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[为什么有struts struts是一个框架 struts是一个web框架 struts提高了程序规范的同时，也约束了程序的自由 struts的优势 程序更加规范化 成都开发的效率提高了 程序的可读性增加了 程序的可维护性增加了 struts的不足之处 form表单有点鸡肋 action是单态(对网站并发性有影响)（在整个程序运行过程中，始终是一个对象） 因为我们队mvc理解的不同,可能造成不同公司写程序的时候,规范不统一,这样不利于程序的维护和扩展,所以我们有必要用一个统一的规范来开发项目(struts) struts的原理 一个请求从浏览器发送给ｗｅｂ服务器,http://localhost:8080/web应用/action web服务器首先解析主机、然后解析web应用的名称、再解析出资源名、转发给总司令ActionServlet(该类由struts框架提供给我们的无需编写,只需配置) ActionServlet有一个文件struts-config.xml,该文件配置了表单actionForm(军火库),还配置了action,以及他们之间的对应关系 当ActionServlet拿到命令后它会查询struts-config.xml文件去填充数据,把用户的数据填充到表单里边 下个动作就是去调用指定的action(小队长),action去从表单中读取数据,调用某个model(士兵,如service)完成任务,完成任务把结果返回给ActionServlet总司令(返回一个执行的结果) 总司令又去查询struts-config.xml文件,决定跳转到哪个jsp页面,返回一个执行结果(形成静态html文件)，直接返回给web服务器，服务器再把静态页面以http响应给浏览器 手写版struts登录系统 先创建一个web工程 把struts开发包引入到工程 编写login.jsp 编写ActionForm(用户表单)和Action(小队长-登录小队长) 编写struts-config.xml文件，该文件用于配置action和actionForm，对应关系，跳转位置，一般放在web-inf目录下 写出welcome.jsp和error.jsp 在web.xml中配置ActionServlet 开始使用struts public class ActionForm extends ActionForm { private String userName; private String password; } public class LoginAction extends Action { @override public ActionForward execute(ActionMapping mapping, UserForm form, HttpServletRequest request, HttpServletResponse response) throws Exception { UserForm userForm = (UserForm)form; if (&quot;123&quot;.equals(userForm.getPassword())) { request.setAttribute(&quot;username&quot;, userForm.getUserName()) return mapping.findForward(&quot;ok&quot;) } else { return mapping.findForward(&quot;err&quot;) } } } &lt;struts-config&gt; &lt;form-beans&gt; &lt;!-- name是表单名，可以随意写，但是我们建议取名规范 表单类名小写 --&gt; &lt;!-- type用于指定表单类全路径 --&gt; &lt;form-bean name=&quot;userForm&quot; type=&quot;com.hsp.forms.UserForm&quot; /&gt; &lt;/form-beans&gt; &lt;!-- 配置action --&gt; &lt;action-mappings&gt; &lt;!-- 配置具体的一个action path表示将来访问该action资源名 name用于关联某个表单 type用于指定action类全路径 --&gt; &lt;!-- scope表示表单的生命周期是request级别的还是session级别 --&gt; &lt;action path=&quot;/login&quot; name=&quot;userForm&quot; scope=&quot;request/session&quot; type=&quot;com.hsp.actions.LoginAction&quot;&gt; &lt;!-- 配置跳转关系 --&gt; &lt;!-- name表示结果名称， path转发到哪个页面 --&gt; &lt;forward name=&quot;ok&quot; path=&quot;/WEB-INF/wel.jsp&quot; /&gt; &lt;forward name=&quot;err&quot; path=&quot;/WEB-INF/err.jsp&quot; /&gt; &lt;/action&gt; &lt;/action-mappings&gt; &lt;/struts-config&gt; &lt;servlet&gt; &lt;servlet-name&gt;action&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.struts.action.ActionServlet&lt;/servlet-name&gt; &lt;init-param&gt; &lt;param-name&gt;config&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/struts-config.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;action&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 在登录成功后的页面上加上”wel 用户名 返回首页” &lt;body&gt; wel &lt;%= request.getAttribute(&quot;username&quot;).toString() %&gt;&lt;br&gt; &lt;a href=&quot;struts/index.jsp&quot;&gt;返回重新登录&lt;/a&gt; &lt;/body&gt; 使用filter配合struts解决中文乱码 public class MyFilter extends HttpServlet implements Filter { @Override public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2) throws IOException, ServletException { arg0.setCharacterEncoding(&quot;utf-8&quot;); arg1.setCharacterEncoding(&quot;utf-8&quot;); arg2.doFilter(arg0, arg1); arg1.setContentType(&quot;text/html;charset=utf-8&quot;) } } &lt;filter&gt; &lt;filter-name&gt;MyFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.chao98.services.MyFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;MyFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 注：struts-conig.xml文件的路径不一定在WEB-INF目录下,并且可以有多个struts-config.xml文件，只需要在web.xml文件中配置路径，并且用逗号隔开即可 工具版structs登录系统 用工具引入struts包和配置文件，然后自己配置struts-config.xml，完成开发 完全依赖MyEclipse提供的工具完成struts开发]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Server</tag>
        <tag>Java</tag>
        <tag>Struts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hibernate的学习和总结]]></title>
    <url>%2F2013%2F07%2F26%2Fhibernate%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[hibernate是什么 hibernate 是一个框架(framework) hibernate 是一个orm框架,(object relation mapping) 对象关系映射 框架 hibernate 处于我们项目的持久层位置(正因为如此，所以有人又把hibernate称为 持久层框架) hibernate 实际上就是对jdbc进行了轻量级的封装 hibernate 的基础还是我们java 反射机制 总结: hibernate 是对jdbc进行轻量级封装的 orm 框架，充当项目的持久层 为什么有hibernate 引入hibernate可以使工作人员角色细化，让程序员更关心业务流程。让数据库人员关注数据库相关的各种操作。 分层更清晰，耦合性更小。 通用性强：可以更轻松的从一个数据库平台转移到别的平台。 对象化：把关系数据库变成了Java的对象，更加方便操作。 性能保证：hibernate可能按不同的数据库，处理不同的操作是用最优化的SQL语句，不用我们去想，对于分等算法，在hibernate中会显得更简单，可靠。 增加了程序的鲁棒性（健壮性）! hibernate的原理hibernate是 轻量级的 ORM 框架，ORM全称object/relation mapping [对象/关系 映射]。 对象关系映射（Object Relation Mapping，简称ORM）是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术。 简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将java程序中的对象自动持久化到关系数据库中。本质上就是将数据从一种形式转换到另外一种形式。 结论:使用orm技术(hibernate是其中最为流行的)可以在java程序以类和对象的方式去操控数据库表和记录. 第一个hibernate项目hibernate开发方式的三种方式: 由Domain object -&gt; mapping-&gt;db。(官方推荐) 由DB开始，用工具生成mapping和Domain object。(使用较多) 由映射文件开始。 这里我们说明如果要自动的创建出对应的数据库，需要做配置(hibernate.cfg.xml) &lt;property name=&quot;hbm2ddl.auto&quot;&gt;create&lt;/property&gt; 这里有四个配置值: create , update , create-drop, validate create : 当我们的应用程序加载hibernate.cfg.xml [ new Configuration().config(); ]就会根据映射文件，创建出数据库, 每次都会重新创建， 原来表中的数据就没有!!! update: 如果数据库中没有该表，则创建，如果有表，则看有没有变化，如果有变化，则结构更新，而数据会保留 create-drop: 在显式关闭sessionFactory时，将drop掉数据库的schema validate: 相当于每次插入数据之前都会验证数据库中的表结构和hbm文件的结构是否一致 在开发测试中，我们配置哪个都可以测试，最好自己配置一次，让对应的数据库生成，完后取消配置，但是如果项目发布后，就取消配置，如果要配置，就配置成update 配置成update到底会不会影响数据？？？ 开发hibernate流程 引入hiberate的包 编写POJO类(Users类) 编写对象映射文件User.hbm.xml 配置hibernate.cfg.xml 编写测试类，并测试. 请解释什么是pojo类，它有什么要求: pojo类是和一张表对应 一般我们放在 com.xxx.domain下 pojo 需要一个主键属性(用于标示一个pojo对象) 除了主键属性外，它应当还有其属性，属性的访问权限是private 提供 set /get 方法 它应当有一个无参的构造方法(hibernate 反射) pojo类其实就是javabean/ 有些老程序员 叫他 date对象 domain对象的细节: 需要一个无参的构造函数(用于hibernate反射该对象) 应当有一个无业务逻辑的主键属性. 给每个属性提供 get set方法. 在domian对象中的属性，只有配置到了对象映射文件后，才会被hiberante管理. 属性一般是private范围 hibernate核心类和接口的使用Configuraion类 负责管理hibernate的配置信息 读取hibernate.cfg.xml 加载hibernate.cfg.xml配置文件中配置的驱动,url,用户名,密码,连接池. 管理 *.hbm.xml对象关系文件. hibernate.cfg.xml文件 该文件主要用于指定各个参数,是hibernate核心文件 默认放在src目录下，也可以放在别的目录下。 指定连接数据库的驱动、用户名、密码、url、连接池.. 指定对象关系映射文件的位置. 也可使用hibernate.properties文件来替代该文件.(推荐使用hibernate.cfg.xml)。 对象关系映射文件(*.hbm.xml) 该文件主要作用是建立表和类的映射关系，是不可或缺的重要文件. 一般放在其映射的类同一个目录下,但不是必须的。 命名方式一般是 类名.hbm.xml,但不是必须的。 对对象关系映射文件的说明 对象关系文件中，有些属性是可以不配，hibernate会采用默认机制，比如 table 值不配，则以类的小写做表名 type不配置，则hibernate会根据类的属性类型，选择一个适当的类型### SessionFactory(会话工厂)，他是一个接口1. 缓存sql语句和某些数据2. 在应用程序初始化的时候创建,是一个重量级的类(吃内存),一般用单例模式保证一个应用中只需要一个SessionFactory实例.3. 如果某个应用访问多个数据库，则要创建多个会话工厂实例,一般是一个数据库一个会话工厂实例.4. 通过SessionFactory接口可以获得Session(会话)实例.openSession/getCurrentSession，如果需要能获取getCurrentSession则要在hibernate.cfg.xml中配置&lt;property name=&quot;current_session_context_class&quot;&gt;thread&lt;/property&gt;来线程绑定### Session(会话)接口1. Session一个实例代表与数据库的一次操作(当然一次操作可以是crud组合)2. Session实例通过SessionFactory获取，用完需要关闭。3. Session是线程不同步的(不安全),因此要保证在同一线程中使用,可以用getCurrentSessiong()。4. Session可以看做是持久化管理器,它是与持久化操作相关的接口### openSession()和 getCurrentSession()区别1. 采用getCurrentSession()创建的session会绑定到当前线程中，而采用openSession()创建的session则不会2. 采用getCurrentSession()创建的session在commit或rollback时会自动关闭，而采用openSession()创建的session必须手动关闭.3. 使用getCurrentSession()需要在hibernate.cfg.xml文件中加入4. 每次openSession() 是获取一个新的session5. 如果是通过getCurrentSession() 获取 sesssion ,进行查询需要事务提交.（视频中举例，如果没有事务，就不能查出结果）&gt; ①如果需要在同一线程中，保证使用同一个Session则，使用getCurrentSession()&gt;&gt; ②如果在一个线程中，需要使用不同的Session,则使用opentSession()如下配置: 如果使用的是本地事务（jdbc事务）&lt;property name=&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;/property&gt; 如果使用的是全局事务（jta事务）&lt;property name=&quot;hibernate.current_session_context_class&quot;&gt;jta&lt;/property&gt;&gt; 简单解释一下jdbc事务和jta事务的区别吧!&gt;&gt; 1. 全局事务是指跨数据库的事务，如建行给工行转账时的事务控制&gt; 2. 本地事务是指针对一个数据库的事务### Session会话接口的几个重要方法1. 保存一个对象(记录)—save方法2. 删除一个对象(记录)—delete方法3. 查询一个对象(记录)—get/load方法4. 修改一个对象(记录)—update方法### session get()和load()区别1. get()方法直接返回实体类,如果查不到数据则返回null。load()会 返回一个实体代理对象（当前这个对象可以自动转化为实体对象）， 但当代理对象被调用时，如果没有数据不存在，就会抛出个 org.hibernate.ObjectNotFoundException异常2. load先到缓存(session缓存/二级缓存)中去查，如果没有则返回一个 代理对象（不马上到DB中去找），等后面使用这个代理对象操作的时 候，才到DB中查询,这就是我们常说的 load在默认情况下支持延迟加 载（lazy）3. get先到缓存(session缓存/二级缓存)中去查，如果没有就到DB中去 查（即马上发出sql）。&gt; 总之，如果你确定DB中有这个对象就用load(),不确定就用get()（这样效率高）&gt; load/get -&gt; 一级缓存(session缓存) -&gt; 二级缓存(内存和文件缓存) -&gt; 数据库，get方法会一步一步往下查找，load方法只会进行一级和二级缓存，不会查询数据库，只有当用到结果时，才会去数据库中查找### openSession()和 getCurrentSession()联系在 SessionFactory启动的时候，Hibernate 会根据配置创建相应的 CurrentSessionContext,在getCurrentSession()被调用的时候，实际被执行的方法是 CurrentSessionContext.currentSession()。在currentSession()执行时，如果当前Session为空，currentSession会调用SessionFactory的openSession package com.hsp.util; import org.hibernate.Session; import org.hibernate.SessionFactory; import org.hibernate.cfg.Configuration; final public class HibernateUtil { //SqlHelper private static SessionFactory sessionFactory=null; //使用线程局部模式 private static ThreadLocal threadLocal=new ThreadLocal(); private HibernateUtil(){}; static { sessionFactory=new Configuration().configure(“com/hsp/config/hsp.cfg.xml”).buildSessionFactory(); } //获取全新的全新的sesession public static Session openSession(){ return sessionFactory.openSession(); } //获取和线程关联的session public static Session getCurrentSession(){ Session session=threadLocal.get(); //判断是否得到 if(session==null){ session=sessionFactory.openSession(); //把session对象设置到 threadLocal,相当于该session已经和线程绑定 threadLocal.set(session); } return session; } }### Transaction(事务)接口事务简单的说,就是一组对数据库的操作集合,它们要么全部成功,要么全部失败.这个可以保证数据的一致性,事务具有原子性。1. Transaction是底层的事物实现中抽象出来的接口2. 可能是一个jdbc或者jta的事务,这样有利于hibernate在不同执行环境的移植。3. hibernate要求显示的调用事务(如果仅仅是查询可以不调用.)### Query接口Query接口类型的对象可以对数据库操作,它可以使用Hql,Qbc,Qbe和原生SQL(native Sql)对数据库操作.官方推荐使用Hql语句。这里我们给大家举例简单说明，后面有一个章节专门讲解Hql的使用，Query接口查询出来的结果是一个List接口类型的对象。### Criteria接口Criteria接口也可用于面向对象方式的查询，关于它的具体用法我们这里先不做介绍,简单看几个案例. //最简单案例:返回50条记录 Criteria crit = sess.createCriteria(Cat.class); crit.setMaxResults(50); List cats = crit.list(); 限制结果集内容 List cats = sess.createCriteria(Cat.class) .add( Restrictions.like(“name”, “Fritz%”) ) .add( Restrictions.between(“weight”, minWeight, maxWeight) ) .list();Criteria是一种比HQL更面向对象的查询方式；Criteria的创建方式： Criteria crit = session.createCriteria(DomainClass.class); //简单属性条件如： criteria.add(Restrictions.eq(propertyName, value)), criteria.add(Restrictions.eqProperty(propertyName,otherPropertyName))Criteric 优点是更加面向对象，如果你的hql语句不太了解，可以使用。缺点是: 功能不如hql强大.而且hql是hibernate官方推荐使用的语句### HQL面向对象的查询语言，与SQL不同，HQL中的对象名是区分大小写的（除了JAVA类和属性其他部分不区分大小写）；HQL中查的是对象而不是表，并且支持多态；HQL主要通过Query来操作，Query的创建方式： Query q = session.createQuery(hql); from Person from User user where user.name=:name from User user where user.name=:name and user.birthday &lt; :birthday1. 检索类的全部属性（from Student）2. 检索类的部分属性（select 属性1,属性2 from Student）3. 使用函数 1. UniqueResult:当session.createQuery(“from xxx where cardid=‘xxx’”).uniqueResult();返回的结果只有一个对象时，可以使用uniqueResult()得到该对象。但是，如果结果是多条，使用该方法就会抛出异常 2. 当要过滤重复的数据时，可以使用distinct关键字:(select distinct sage,ssex from Student) 3. between…and(select distinct sage,ssex from Student where sage between 20 and 22) 4. in/not in(from Student where sdept in (‘计算机系’,’英语系’)) 5. group by 分组查询(select avg(sage),sdept from Student group by sdept) 6. having 对分组查询后的结果，进行筛选(select count(*),sdept from Student group by sdept having count(*)&gt;3) 7. 聚集函数的使用 count(),avg(),max(),min(),sum(); 8. 分页显示对象(setFirstResult,setMaxResult)4. 模糊查询 like 属性 ‘%_’5. 参数绑定 &gt; 使用绑定参数的好处: &gt; &gt; 1. 可读性好. &gt; 2. 性能提高. &gt; 3. 防止sql注入 &gt; //如果按冒号的方式 Query q=session.createQuery(from Student where sdept=:dept and sage&gt;:age) //也可使用setInteger()，setString() …来指定值 q.setParameter(参数名,值) 参数绑定有两种形式 如果我们的参数是 :冒号形式给出的，则我们的参数绑定应当这样: List list=session.createQuery(“from Student where sdept=:a1 and sage&gt;:sage”) .setString(“a1”, “计算机系”).setString(“sage”, “2”).list(); 还有一种形式: Query q=session.createQuery(from Student where sdept=? and sage&gt;?) 如果我们的参数是以 ? 形式给出的则，参数绑定应当: List list=session.createQuery(“from Student where sdept=? and sage&gt;?”) .setString(0, “计算机系”).setString(1, “2”).list(); &gt; 总结：如果是冒号形式，只能按属性名称方式填值，如果是按问号形式给出的，只能按照位置方式填值6. 在映射文件中得到hql语句 hibernate提供了一种更加灵活的查询方法: 把hql语句配置到 对象关系映射文件， &lt;![CDATA[select sname,ssex from Student where sage&gt;22]]&gt; 在程序中，我们这样获取并执行: List list=session.getNamedQuery(“myquerytest”).list(); System.out.println(list.size()); Iterator it=list.iterator(); while(it.hasNext()){ Object obj[]=(Object[])it.next(); System.out.println(“n=”+obj[0]); }7. 子查询 可以在sql中，我们经常使用子查询处理复杂的查询要求 对于简单的表(没有外键或是被别的表关联的表)，比如第二讲的admin【管理员表】和 employee【雇员表】就是简单的POJO 。但是我们项目中很多表和别的表都会有关联,在hibernte中的对象存在三种关系 1. one-to-one 2. one-to-many 【many-to-one】 3. many-to-many [课程 — 学生 中间表] 并且还有所谓的单向和双向之分: 我们的Student【学生表】和 Course【课程表】就是多对多,多对多一般都会通过一个中间表转成one-to-many 和 many-to-one比如.我们这里用了一个 中间表 StudCourse【学生-课程表】把关系简化成 one-to-many 和 many-to-one ，我们看看对象配置文件可以看出8. 多表查询 studCourse 作为中间表，将多对多的关系简化成 one-to-many和 many-to-one 的关系，这个也是在表的设计中惯用的一种数据库设计模式，下面我们就看看hql 如何处理多表查询的问题 在项目开发过程中，我们不可能只对一张表进行操作，一定有多张表联合查询，下面看看在hql中如何对多表查询: //比如: 请显示林青霞 选择的所有课程名，和成绩。 “select s1.sname,s2.course.cid,c1.cname,s2.grade from Student as s1,StudCourse as s2,Course as c1 where s1.sname=’林青霞’ and s1.sname=s2.student.sname and c1.cid=s2.course.cid“ 简单的:select s1.course.cname,s1.grade from Studcourse s1 where s1.student.sname=’林可欣’### hibernate对象的三种状态瞬时(transient)：数据库中没有数据与之对应，超过作用域会被JVM垃圾回收器回收，一般是new出来且与session没有关联的对象。（不处于session的管理，在数据库中没有对应的记录）持久(persistent)：数据库中有数据与之对应，当前与session有关联，并且相关联的session没有关闭，事务没有提交；持久对象状态发生改变，在事务提交时会影响到数据库，hibernate能检测到。（处于session的管理下，并在数据库中有对应的记录）脱管/游离(detached)：数据库中有数据与之对应，但当前没有session与之关联；脱管对象状态发生改变，hibernate不能检测到(没有处于session的管理，在数据库中有对应的记录)&gt; 如何判断一个对象处于怎样的状态?&gt;&gt; 主要的依据是: 1. 看该对象是否处于session, 2, 看在数据库中有没有对应的记录&gt;&gt; 瞬时态: 没有session管理,同时数据库没有对应记录&gt; 持久态: 有session管理，同时在数据库中有记录&gt; 脱管态/游离态： 没有session管理，但是在数据库中有记录.### 懒加载简述: 当我们查询一个对象的时候，在默认情况下,返回的只是该对象的普通属性,当用户去使用对象属性时，才会向数据库发出再一次的查询.这种现象我们称为 lazy现象.懒加载(Load On Demand)是一种独特而又强大的数据获取方法 ，是指程序推迟访问数据库，这样做可以保证有时候不必要的访问数据库，因为访问一次数据库是比较耗时的。解决方法可以这样: Domain Object 写成final的, final的对象不会懒加载 显式初始化 Hibernate.initized(代理对象)或直接调用一次xxx.getXxx() 修改对象关系文件 lazy 改写 lazy=false 通过过滤器(web项目) openSessionInView 在ssh中，可以实现在service层，标注方式解决懒加载### 对象对应关系* many-to-one 的many这方，如果你配置了cfg文件,那么hibernate就会在 查询学生 many 方时，把它相互关联的对象也查询,这里我们可以看出，对select语句查询影响不大 //column设置的值为外键名 one-to-many 的 one 的这方，如果你配置 &lt;set name=”集合对象属性名”&gt; &lt;key column=”外键名”/&gt; &lt;one-to-many class=”集合放入的类名”/&gt; &lt;/set&gt; //如 &lt;class name=&quot;Department&quot; lazy=&quot;false&quot; &lt;set name=&quot;stus&quot; cascade=&quot;save-update&quot; lazy=&quot;false&quot;&gt; &lt;key column=&quot;dept_id&quot; /&gt; &lt;one-to-many class=&quot;Student&quot; /&gt; &lt;/set&gt; &lt;/class&gt; one-to-one 基于主键的one-to-one(idCard又是主键，又是外键) //Person映射文件： &lt;one-to-one name=“idCard” /&gt; //IdCard映射文件： &lt;id name=”id”&gt; &lt;generator class=”foreign”&gt; &lt;param name=”property”&gt;person&lt;/param&gt; &lt;/generator&gt; &lt;/id&gt; //[没有constraned true将不会生成外键约束] &lt;one-to-one name=”person” constrained=”true”/&gt; 基于外健的one-to-one，可以描述为多对一，加unique=“true”约束 //Person映射文件： &lt;one-to-one name=“idCard” /&gt; //IdCard映射文件： &lt;many-to-one name=”person” column=”person_id” unique=”true” not-null=”true”/&gt; many-to-many 在操作和性能方面都不太理想，所以多对多的映射使用较少，实际使用中最好转换成一对多的对象模型；Hibernate会为我们创建中间关联表，转换成两个一对多。 &lt;set name=“xxx&quot; table=“xxx&quot;&gt; &lt;key column=“xxx&quot;/&gt; &lt;many-to-many class=“xxx&quot; column=“xxx&quot;/&gt; &lt;/set&gt; 级联操作Casade用来说明当对主对象进行某种操作时是否对其关联的从对象也作类似的操作，常用的cascade:none,all,save-update ,delete,lock,refresh,evict,replicate,persist,merge,delete-orphan(one-to-many) 。一般对many-to-one,many-to-many不设置级联，在和中设置级联 在集合属性和普通属性中都能使用cascade 一般讲cascade配置在one-to-many(one的一方,比如Employee-Department),和one-to-one(主对象一方) 缓存和加强缓存的作用主要用来提高性能，可以简单的理解成一个Map；使用缓存涉及到三个操作：把数据放入缓存、从缓存中获取数据、删除缓存中的无效数据。 一级缓存，Session级共享。save,update,saveOrUpdate,load,get,list,iterate,lock这些方法都会将对象放在一级缓存中，一级缓存不能控制缓存的数量，所以要注意大批量操作数据时可能造成内存溢出；可以用evict,clear方法清除缓存中的内容。 二级缓存, SessionFacotry级共享 什么操作会向一级缓存放入数据？ save,update,saveOrUpdate,load,get,list,iterate,lock 什么操作会从一级缓存取数据？ get / load / list 一级缓存不需要配置，就可以使用,它本身没有保护机制，所以我们程序员要考虑这个问题,我们可以同 evict 或者 clear来清除session缓存中对象. evict 是清除一个对象，clear是清除所有的sesion缓存对象 session级缓存中对象的生命周期, 当session关闭后，就自动销毁 我们可以自己用HashMap来模拟一个Session缓存，加深对缓存的深入 为什么需要二级缓存? 因为一级缓存有限(生命周期短),所以我们需要二级缓存(SessionFactory缓存)来弥补这个问题 需要配置 二级缓存是交给第三方去处理,常见的Hashtable , OSCache , EHCache 二级缓存的原理 二级缓存的对象可能放在内存，也可能放在磁盘 使用OsCache来演示二级缓存的使用 //可以在.cfg.xml文件中配置 &lt;property name=&quot;hbm2ddl.auto&quot;&gt;update&lt;/property&gt; &lt;!-- 启动二级缓存 --&gt; &lt;property name=&quot;cache.use_second_level_cache&quot;&gt;true&lt;/property&gt; &lt;!-- 指定使用哪种二级缓存 --&gt; &lt;property name=&quot;cache.provider_class&quot;&gt;org.hibernate.cache.OSCacheProvider&lt;/property&gt; &lt;mapping resource=&quot;com/hsp/domain/Department.hbm.xml&quot; /&gt; &lt;mapping resource=&quot;com/hsp/domain/Student.hbm.xml&quot; /&gt; &lt;!-- 指定哪个domain启用二级缓存 特别说明二级缓存策略: 1. read-only 2. read-write 3. nonstrict-read-write 4. transcational --&gt; &lt;class-cache class=&quot;com.hsp.domain.Student&quot; usage=&quot;read-write&quot;/&gt; //也可以直接在.hbm.xml文件中配置 &lt;cache usage=&quot;read-write&quot; /&gt; 可以把文件oscache.properties放在 src目录下，这样你可以指定放入二级缓存的对象capacity 大小. 默认1000 hibernate二级缓存策略 只读缓存(read-only) 读写缓存(read-write) [ 银行，财务软件] 不严格读写缓存(nonstrict-read-write) [bbs 被浏览多少次] 事务缓存(transactional) 在配置了二级缓存后，请大家要注意可以通过 Statistics,查看你的配置命中率高不高 &lt;property name=&quot;hibernate.generate_statistics&quot;&gt;true&lt;/property&gt; //SessionFactory对象. Statistics statistics= getSessionFactory().getStatistics(); System.out.println(statistics); System.out.println(&quot;放入&quot;+statistics.getSecondLevelCachePutCount()); System.out.println(&quot;命中&quot;+statistics.getSecondLevelCacheHitCount()); System.out.println(&quot;错过&quot;+statistics.getSecondLevelCacheMissCount()); 主键增长策略hibernate标示符生成器(策略) increment 由Hibernate自动以递增方式生成标识符，每次增量为1。 优点：不依赖于底层数据库系统，适用于所有的数据库系统。 缺点：适用于单进程环境下，在多线程环境下很可能生成相同主键值，而且OID必须为数值类型,比如long,int,short类型 配置方式: &lt;id name=“id” type=”long” column=”ID”&gt; &lt;generator class=”increment”/&gt; &lt;/id&gt; indentity 由底层数据库生成标识符。 前提条件：数据库支持自动增长字段类型,比如(sql server,mysql),而且OID必须为数值类型,比如long,int,short类型 配置文件: &lt;id name=”id” type=”long” column=”ID”&gt; &lt;generator class=”identity”/&gt; &lt;/id&gt; sequence 依赖于底层数据库系统的序列 前提条件:需要数据库支持序列机制（如:oracle等）,而且OID必须为数值类型,比如long,int,short类型。 配置文件: &lt;id name=”id” type=”java.lang.Long” column=”ID”&gt; &lt;generator class=”sequence”&gt; &lt;param name=”sequence”&gt;my_seq&lt;/param&gt; &lt;/generator&gt; &lt;/id&gt; hilo hilo标识符生成器由Hibernate按照一种high/low算法生成标识符，他从数据库中的特定表的字段中获取high值，因此需要额外的数据库表保存主键生成的历史状态，hilo生成方法不依赖于底层数据库，因此适用于每一种数据库,但是OID必须为数值类型(long,int,shor类型)。 配置文件: &lt;id name=”id” type=”java.lang.Integer” column=”ID”&gt; &lt;generator class=”hilo”&gt; &lt;param name=”table”&gt;my_hi_value&lt;/param&gt; &lt;param name=”column”&gt;next_value&lt;/param&gt; &lt;/generator&gt; &lt;/id&gt; native native生成器能根据底层数据库系统的类型，自动选择合适的标识符生成器，因此非常适用于跨数据库平台开发，他会由Hibernate根据数据库适配器中的定义,自动采用identity,hilo,sequence的其中一种作为主键生成方式，但是OID必须为数值类型(比如long,short,int等) 配置文件: &lt;id name=”id” type=”java.lang.Integer” column=”ID”&gt; &lt;generator class=”native”/&gt; &lt;/id&gt; assigned 采用assign生成策略表示由应用程序逻辑来负责生成主键标识符,OID类型没有限制。 配置文件: &lt;id name=”id” type=”java.lang.Integer” column=”ID”&gt; &lt;generator class=”assigned”/&gt; &lt;/id&gt; uuid 由Hibernate基于128位唯一值产生算法，根据当前设备IP，时间，JVM启动时间，内部自增量等4个参数生成16进制数值作为主键，一般而言,利用uuid方式生成的主键提供最好的数据插入性能和数据库平台适应性. OID一般使用是String类型,大家去试试数值可否? 配置文件: &lt;id name=”id” type=”java.lang.String” column=”ID”&gt; &lt;generator class=”uuid”/&gt; &lt;/id&gt; foreign 第一种方式:以独立主键类映射复合主键，这样可以达到将逻辑加以隔离的目的 配置文件如下： &lt;composite-id name=&quot;id&quot; class=&quot;com.test.model.pojo.CustomersId&quot;&gt; &lt;key-property name=&quot;cusname&quot; type=&quot;java.lang.String&quot;&gt; &lt;column name=&quot;CUSNAME&quot; length=&quot;40&quot; /&gt; &lt;/key-property&gt; &lt;key-property name=&quot;homeaddress&quot; type=&quot;java.lang.String&quot;&gt; &lt;column name=&quot;HOMEADDRESS&quot; length=&quot;50&quot; /&gt; &lt;/key-property&gt; &lt;key-property name=&quot;birthday&quot; type=&quot;java.util.Date&quot;&gt; &lt;column name=&quot;BIRTHDAY&quot; length=&quot;7&quot; /&gt; &lt;/key-property&gt; &lt;/composite-id&gt; 给出一个简单原则: 针对oracle [主键是int/long/short 建议使用 sequence] 主键是String 使用uuid或者assinged 针对 mysql [主键是 int/long/short 建议使用increment/assigend ,如果是字串 UUId/assigned] 针对 sql server [主键是 int/long/short 建议使用 identity/native/assinged ,如果主键是字串，使用uuid/assigned ] one-to-one 又是基于主键的则使用foreign Hibernate不适合的场景 不适合OLAP(On-Line Analytical Processing联机分析处理)，以查询分析数据为主的系统；适合OLTP（on-line transaction processing联机事务处理） 对于些关系模型设计不合理的老系统，也不能发挥hibernate优势。 数据量巨大，性能要求苛刻的系统，hibernate也很难达到要求, 批量操作数据的效率也不高。]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Server</tag>
        <tag>Java</tag>
        <tag>Hibernate</tag>
        <tag>DataBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习]]></title>
    <url>%2F2013%2F06%2F28%2FAndriod%E5%AD%A6%E4%B9%A05(%E6%9C%AA%E5%AE%8C%E6%88%90)%2F</url>
    <content type="text"><![CDATA[树和二叉树]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习]]></title>
    <url>%2F2013%2F05%2F31%2FAndriod%E5%AD%A6%E4%B9%A04(%E6%9C%AA%E5%AE%8C%E6%88%90)%2F</url>
    <content type="text"><![CDATA[树和二叉树]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习]]></title>
    <url>%2F2013%2F04%2F26%2FAndriod%E5%AD%A6%E4%B9%A03(%E6%9C%AA%E5%AE%8C%E6%88%90)%20%2F</url>
    <content type="text"><![CDATA[树和二叉树]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习]]></title>
    <url>%2F2013%2F03%2F29%2FAndriod%E5%AD%A6%E4%B9%A03(%E6%9C%AA%E5%AE%8C%E6%88%90)%2F</url>
    <content type="text"><![CDATA[树和二叉树]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习]]></title>
    <url>%2F2013%2F02%2F22%2FAndriod%E5%AD%A6%E4%B9%A02(%E6%9C%AA%E5%AE%8C%E6%88%90)%2F</url>
    <content type="text"><![CDATA[树和二叉树]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习]]></title>
    <url>%2F2013%2F01%2F25%2FAndriod%E5%AD%A6%E4%B9%A0(%E6%9C%AA%E5%AE%8C%E6%88%90)%2F</url>
    <content type="text"><![CDATA[树和二叉树]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AS从入门到精通]]></title>
    <url>%2F2012%2F12%2F28%2FAS%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A(%E6%9C%AA%E5%AE%8C%E6%88%90)%2F</url>
    <content type="text"><![CDATA[在今年5月16日的I/O大会上，谷歌推出新的Android开发环境——Android Studio，经过我这一段时间的实际应用，切身体会到android Studio和eclipse之间的优劣之处，现在将其总结如下： 工程管理： 新建工程时，Android Studio和eclipse新建工程的文件夹组织方式不同，开发环境之间的共容性较差，比如要将eclipse中的project导入到Android Studio中需费一定的周折，而要将Android Studio中的工程导入到eclipse中，却没有比较简单的方法，只能一个文件一个文件的拷贝。 新建工程后，设置工程的属性比较难，在eclipse中直接去properties设置就可以，但是在Android Studio中，0.1版提供了一个界面设置project structure，我设置过很多次，遇到各种问题，在Android Studio中新建的工程问题较少，但是从eclipse中导入的工程就比较容易出BUG，比如找不到Lib，找不到sdk，当升级到0.1.1版的时候直接没有界面了，当点击project structure的时候，提示：我们以后会提供一个界面来配置工程的设置，但是在这之前需要自己在gradle里去手动设置。 新建或导入工程后，要删除工程，Android Studio只能去workspace文件夹去删除，而不能在开发环境中删除。 在eclipse中引用库项目非常简单，库项目properties里android lib打钩，然后就可以直接在项目中引用了，但是在Android Studio中，由于时间的关系，我到现在没找到解决方法。 综上所述，在管理工程这块，可能是对Android Studio比较陌生，不习惯，总觉得android Studio远不如eclipse. IDE界面： Android Studio提供的dock留边停靠完胜eclipse,在eclipse中要是想用更大的视野来显示一个view，而隐藏其他的view的一个方法就是点X，关闭后要打开就比较麻烦了，而Android Studio是将常用的view最小化dock到其边界，更加人性化，已操作和灵活。 第二点，eclipse的启动速度令人蛋碎呢，每次开机先启eclipse，后启动其他程序，其他程序都百米5s的速度，eclipse都还没上起跑线。 还有eclipse的死机问题非常严重，我的ubuntu每天都要因为eclipse死机的问题来重启，有的时候甚至一天五六次。 项目编码： Android studio中的图标在每行最开始表示，使开发者更加可视化了自己的界面，程序等，这是Android Studio的最大亮点。 错误提示不比eclipse提示，eclipse放在错误上边即可提示，android studio需要按快捷键command+1才能显示。 拷贝一个方法或字段到另一个地方时，eclipse中是连它的引入类一起拷贝，比如拷贝List时会连import java.util.List和import android.Bluetooth.BluetoothDevice一起拷贝过去，而android Studio会给用户提供一个选择，要拷什么不要拷什么会给用户一个界面来勾选。 Android Studio 中 command+W可以直接快速定位到最近编辑的文件，不知道eclipse中有没有，暂时没有发现。 inspect code,利用android lit可以帮助开发者自动检查代码中的错误和有可能出现bug的地方。 在Android Studio中code assistance要远远强大于eclipse，比如你可以先调用方法，再写方法时会有提示，而在eclipse中只能傻傻地自己写，没有提示。还有一个，拷贝string或color中的value前选择value的时候，eclipse的反应速度慢到无法忍受。 res资源： Android studio中的颜色等都在每行最开始表示，使开发者更加可视化了自己的界面，程序等，这是Android Studio的最大亮点。 在代码中可以看到资源中不痛分辨率下的drawable图像，将光标放置图像名字中间，点View-quick documation即可看到,由于是在本环境中打开，而不是像eclipse中重启程序打开，所以打开图像的速度远远小于eclipse。 生成res的values文件更简单，感觉创建时更倾向于android开发，android专用，不像eclipse那么复杂。 提示更加完善，比如如果将Button拼成Bitton，Android Studio会自动检查出来，如果没有layout_width或layout_height，会自动检查出来并提供选项让开发者选择。 在android Studio中提供了一个Preview视图，可以和layout.xml文件进行关联，在xml文件中改属性，或添加组件，会动态在Preview视图中表现出来，而且可以添加不同语系，不痛屏幕尺寸的android设备。 编译代码： 在eclipse中编译速度感觉要慢于Android Studio，但是在eclipse中有一个build automatically的功能，觉得挺好用，在android Studio中未找到，只能在每次安装前手动编译。 编译后选择运行的平台，eclipse中会自动打开软件，而android Studio会安装软件，需要手动打开。 LOG查看： log查看相比较而言，还是android Studio稍微先进于eclipse，在eclipse很多次，我删掉的tag，第二次打开eclipse，它又存在于左边的list当中，Adnroid studio看起来界面比较友好，使人更容易找出log。 以上几点是我在这段时间来试用android studio和eclipse的真实体验，优缺点介绍的不那么完善，可能其中也存在一些问题，毕竟仁者见仁，智者见智，我觉得相对而言，总体还是Android studio 略胜eclipse一筹，由于android studio是新版本，还是不断的完善当中，所以建议初学者可以直接学习用android studio来开发，因为在我看来，android Studio代替eclipse来写android程序已经是大趋势，不可避免的了，谁先掌握了此工具的用法，谁就会比其他开发者更有优势，编程优势，面试优势等，但是毕竟android studio才刚出现，还年轻，难免会出现一些比较难解的bug，所以建议有经验的开发者暂时先用eclipse来开发，毕竟熟悉了那么长时间了，不会像android Studio那样，如果中奖碰上大的bug，那真是叫天不应，入地无门啊，整个项目的进度就得耽搁很久了 。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[疯狂Android第四部分]]></title>
    <url>%2F2012%2F11%2F30%2F%E7%96%AF%E7%8B%82Android%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[Android的网络应用Android完全支持JDK本身的TCP、UDP网络通信API。可以使用ServerSocket、Socket来建立基于TCP/IP协议的网络通信；也可以使用DatagramSocket、DatagramPacket、MulticastSocket来建立基于UDP协议的网络通信。 13.1 基于TCP协议的网络通信TCP/IP通信协议是一种可靠的网络协议，它在通信的两端各建立一个Socket，从而在通信的两端之间形成网络虚拟链路。一旦建立了虚拟的网络链路，两端的程序就可以通过虚拟链路进行通信。 IP协议是Internet上使用的一个关键协议，它的全称是Internet Protocol，即Internet协议，通常简称IP协议。通过使用IP协议，使Internet成为一个允许连接不同类型的计算机和不同操作系统的网络。要使两台计算机彼此之间进行通信，必须使两台计算机使用同一种“语言”，IP协议只保证计算机能发送和接收分组数据。IP协议负责将消息从一个主机传送到另一个主机，消息在传送过程中被分割成一个个小包。 尽管计算机通过安装IP软件，保证了计算机之间可以发送和接收数据，但IP协议还不能解决数据分组在传输过程中可能出现的问题。因此，若要解决可能出现的问题，连接上Internet的计算机还需要安装TCP协议来提供可靠并且无差别的通信服务。TCP协议被称作一种端对端协议，这是因为它为两台计算机之间的连接起了重要作用。当一台计算机需要与另一台远程计算机连接时，TCP协议会让他们建立一个连接：用于发送和接收数据的虚拟链路。TCP协议负责收集这些信息包，并将其按适当的次序放好传送，在接收端收到后再将其正确的还原。TCP协议保证了数据包在传送过程中准确无误。TCP协议使用重发机制：当一个通信实体发送一个消息给另一个通信实体后，需要收到另一个通信实体的确认信息，如果没有收到另一个通信实体的确认信息，则会再次重发刚才发送的信息。 使用ServerSocket创建TCP服务器端 //创建一个ServerSocket，用于监听客户端Socket的连接请求 ServerSocket ss = new ServerSocket(30000); //采用循环不断接受来自客户端的请求 while(true) { //每当接收到客户端Socket的请求，服务器也对应产生一个Socket Socket s = ss.accept(); //下面就可以使用Socket进行通信了 OutputStream os = ss.getOutputStream(); os.write(&quot;你好，你收到的服务器的新年祝福！&quot;.getBytes(&quot;utf-8&quot;)); os.close(); s.close(); } 客户端使用Socket进行通信 try { //建立到连接远程服务器的Socket Socket socket = new Socket(&quot;192.168.1.88&quot;, 30000); //将Socket对应的输入流包装成BufferedReader BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); String line = br.readLine(); system.out.printLine(&quot;来自服务器的数据：&quot;+line); br.close(); socket.close(); } catch (IOException e) { e.printStackTrace(); } 实际应用中的客户端则可能需要和服务器端保持长时间通信，即服务器需要不断地读取客户端数据，并向客户端写入数据，客户端也需要不断地读取服务器数据，并向服务器写入数据。为了解决这个问题，应该分别为服务器和客户端单独启动一条线程来负责读取对方数据。 服务端多线程Socket public class MyServer { public static ArrayList&lt;Socket&gt; socketList = new ArrayList&lt;Socket&gt;(); public static void main(String[] args) { ServerSocket ss = new ServerSocket(30000); while(true) { //此行代码会阻塞，将一直等待别人的连接 Socket s = ss.accept(); socketList.add(s); //每当客户端连接后启动一条ServerThread线程为该客户端服务 new Thread(new ServerThread(s)).start(); } } } public class ServerThread implements Runnable { Socket s = null; BufferedReader br = null; public ServerThread(Socket s) { this.s = s; br = new BufferedReader(new InputStreamReader(s.getInputStream(), &quot;utf-8&quot;)); } public void run() { String content = null; while((content=readFromClient())!=null) { for (Socket s : MyServer.socketList) { //遍历socketList的每个socket并向每个socket发送刚才读到的内容 OutputStream os = s.getOutputStream(); os.write((content+&quot;\n&quot;).getBytes(&quot;utf-8&quot;)); } } } public void readFromClient() { return br.readLine(); } } 客户端多线程Socket public class MultiThreadClient extends Activity { public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); Handler handler = new Handler() { public void handle(Message message) { if (msg.what == OX123) { show.append(&quot;\n&quot;+msg.obj.toString()); } } }; try { s = new Socket(&quot;192.168.1.88&quot;, 30000); new Thread(new ClientThread(s, handler)).start(); } send.setOnClickListener(new OnClickListener(){ public void onClick(View v) { os.write(input.getText().toString()+&quot;\r\n&quot;); input.setText(&quot;&quot;); } }); } } public class ClientThread implements Runnable { private Socket s; private Handler handler; private BufferedReader br; public ClientThread(Socket s, Handler handler) { this.s = s; this.handler = handler; this.br = new BufferedReader(new InputStreamReader(s.getInputStream())); } public void run() { String content = null; while((content = br.readLine()) != null) { Message msg = new Message(); msg.what = 0X123; msg.obj = content; handler.sendMessage(msg); } } } 13.2 使用URL访问网络资源URL(Uniform Resource Locator)对象代表统一资源定位器，它是指向互联网资源的指针。URL可以由协议名、主机、端口和资源组成，即 protocol://host:port/resourceName URL类提供了多个构造器用于创建对象，一旦获得了URL对象之后，可以调用如下常用方法来访问该URL对应的资源。getFile()/getHost()/getPath()/getPort()/getProtocol()/getQuery()/openConnection()/openStream()等 //打开URL的流并解析图片，将其显示在ImageView上 URL url = new URL(&quot;http://www.crazyit.org/attachments/.../1.png&quot;); InputStream is = url.openStream(); Bitmap bitmap = BitmapFactory.decodeStream(is); show.setImageBitmap(bitmap); is.close(); //保存URL对应的资源到本地 is = url.openStream(); OutputStream os = openFileOutput(&quot;crazyit.png&quot;, MODE_WORLD_READABLE); byte[] buff = new byte[1024]; int hasRead = 0; while((hasRead == is.read(buff)) &gt; 0) { os.write(buff, 0, hasRead); } is.close(); os.close(); URL的openConnection()方法将返回一个URLConnection对象，该对象表示应用程序和URL之间的通信连接。程序可以通过URLConnection实例向该URL发送请求，读取URL引用的资源。通常创建一个和URL的连接，并发送请求、读取此URL引用的资源需要如下几个步骤： 通过调用URL对象openConnection()方法来创建URLConnection对象 设置URLConnection的参数和普通请求属性 如果只是发送Get方式请求，使用connect方法建立和远程资源之间的实际连接即可；如果用post方式的请求，需要获取URLConnection实例对应的输出流来发送请求参数 远程资源变为可用，程序可以访问远程资源的头字段，或通过输入流读取远程资源的数据 public class GetPostUtil { public static String sendGet(String url, String params) { String urlName = url + &quot;?&quot; + params; URL realUrl = new URL(urlName); URLConnection conn = realUrl.openConnection(); //设置通用的请求属性,如connection, user-agent conn.setRequestProperty(&quot;accept&quot;, &quot;/*&quot;); conn.connect(); BufferedReader in = new BufferedReader(conn.getInputStream()); while ((String line = in.readLine) != null) { result += &quot;\n&quot; + line; } in.close(); } public static String sendPost(String url, String params) { URL realUrl = new URL(url); URLConnection conn = realUrl.openConnection(); //设置通用的请求属性,如connection, user-agent conn.setRequestProperty(&quot;accept&quot;, &quot;/*&quot;); conn.setDoOutput(true); conn.setDoInput(true); //获取URLConnection对象对应的输出流 PrintWriter out = new PrintWriter(conn.getOutputStream()); //发送请求参数 out.print(params); out.flush(); BufferedReader in = new BufferedReader(conn.getInputStream()); while ((String line = in.readLine) != null) { result += &quot;\n&quot; + line; } out.close(); in.close(); } } 13.3 使用HTTP访问网络前面介绍了URLConnection已经可以非常方便地与指定站点交换信息，URLConnection还有一个子类，HttpURLConnection，HttpURLConnection在URLConnection的基础上做了进一步改进，增加了一些用于操作HTTP资源的便捷方法： int getResponseCode() String getResponseMessage() String getRequestMethod(&quot;GET/POST&quot;) String setRequestMethod(String method) HttpURLConnection已经可以完成HTTP的请求了，但是在很多情况下，要涉及一些复杂的如Session，cookie的处理，用HttpURLConnection处理起来就比较负责了，所以Apache开源组织提供了一个HttpClient项目，它是一个增强版的HttpURLConnection；其使用方法如下 HttpGet get = new HttpGet(&quot;http://192.168.1.88:8888/foo/secret.jsp&quot;); HttpResponse httpResponse = httpClient.execute(get); HttpEntity entity = httpResponse.getEntity(); if (entity != null) { BufferedReader br = new BufferedReader(new InputStreamReader(entity.getContent())); while((String line = br.readLine()) != null) { response.append(line+&quot;\n&quot;); } } HttpPost post = new HttpPost(&quot;http://192.168.1.88:8888/foo/login.jsp&quot;); List&lt;NameValuePair&gt; params = new ArrayList&lt;NameValuePair&gt;(); params.add(new NameValuePair(&quot;name&quot;, name)); params.add(new NameValuePair(&quot;pass&quot;, pass)); post.setEntity(new UrlEncodedFormEntity(params, HTTP.UTF_8)); HttpResponse httpResponse = httpClient.execute(post); if (httpResponse.getStatusLine().getStatusCode()==200) { HttpEntity entity = httpResponse.getEntity(); String msg = EntityUtils.toString(entity); Toast.makeText(HttpClient.this, msg, 5000).show(); } 13.4 使用WebView视图显示网页WebView组件本身就是一个浏览器实现，它的内核基于开源WebKit引擎。它有如下一些方法：goback()/goForward()/loadUrl(String url)/zoomIn()/zoomOut() WebView提供了一个loadData(String data, String mineType, String encoding)方法，该方法可用于加载并显示HTML代码。但在使用过程中，当它加载包含中文的HTML内容时，WebView将显示乱码。好在WebView还提供了一个loadDataWithBaseURL(String baseUrl, String data, String mineType, String endcoding, String historyUrl)方法，该方法中文不会显示乱码 13.5 使用WebService进行网络编程Web Service主要的设计思想是：充分利用Web分布式编程模型的松散耦合性，允许各种平台、各种编程语言的应用可以交换数据，可以无缝的整合在一起。也就是说，Web Service提供了一种建立分布式应用的平台，使得不同操作平台上、不同语言实现的软件、所有已开发部署的软件都可以充分利用这个平台实现分布式计算。 与其他网络集成技术相比，Web Service具有如下两大优势： Web Service使用SOAP作为基本通信协议，更加简单易用 Web Service采用已经广泛使用的技术和协议，如XML、HTTP等，因此Web Service更容易掌握 Web Service平台主要涉及的技术有SOAP(Simple Object Access Protocol, 简单对象访问协议)，WSDL(Web Service Description Language, Web Service描述语言)，UDDI(Universal Description，Description and Integration, 统一描述、发现和整合协议) SOAP(Simple Object Access Protocol, 简单对象访问协议) 是一种具有扩展性的XML消息协议。SOAP允许一个应用程序向另一个应用程序发送XML消息，SOAP消息是从SOAP发送者传至SOAP接收者的单路消息，任何应用程序均可作为发送者和接收者。SOAP协议仅定义消息结构和消息处理的协议，与底层的传输协议独立。因此，SOAP协议能通过HTTP，JMS或SMTP协议传输。SOAP依赖于XML文档来构建，一条SOAP消息就是一份特定的XML文档，SOAP消息包含如下几个主要元素Envelope根元素/Header元素/Body元素 WSDL(Web Service Description Language, Web Service描述语言)使用XML描述Web Service，包括访问和使用Web Service所必须的信息，定义该Web Service的位置、功能及如何通信等描述信息。一般来说，只要调用者能够获取Web Service对应的WSDL，就可以从中了解它所提供的服务及如何调用Web Service，因为一份WSDL文件清晰地定义了三个方面的内容WHAT/HOW/WHERE UDDI(Universal Description，Description and Integration, 统一描述、发现和整合协议)是一套信息注册规范，它具有基于Web/分布式的特点。它包括一组允许企业向外注册Web Service，以使其他企业发现访问的实现标准。UDDI的核心组件是UDDI注册中心，它使用XML文件来描述企业及其提供的Web Service。 Java本身提供了丰富的Web Service支持，比如sun公司制定的JAX-WS2规范，还有Apache开源组织所提供的Axis1、Axis2、CXF等，这些技术不仅可以用于非常方便的对外提供Web Service，也可以用于简化Web Service的客户端编程。 Google为Android平台开发Web Service客户端提供了ksoap2-android项目，但这个项目并未直接集成在Android平台中，还需要开发人员自行下载jar包 //创建HttpTransportSE传输对象 HttpTransportSE ht = new HttpTransportSE(SERVICE_URL); //使用SOAP1.1协议创建Envelop对象 SoapSerializationEnvelope envelope = new SoapSerializationEnvelope(SoapEnvelope.VER11); //实例化SoapObject对象 SoapObject soapObject = new SoapObject(SERVICE_NS, &quot;getUserList&quot;); soapObject.addProperty(&quot;arg0&quot;, &quot;客户端参数：&quot;); //将soapObject对象设置为SoapSerializationEnvelope对象的传出SOAP消息 envelope.body = soapObject; ht.call(null, envelope); if (evenlope.getResponse() != null) { SoapObject result = (SoapObject)envelope.bodyIn; SoapObject detail1 = (SoapObject)result.getProperty(0); system.out.printLine(&quot;用户名：&quot;+detail1.getProperty(0)); } 管理Android手机桌面Android系统提供了一个桌面–也就是用户启动后第一次看到的界面，桌面上通常放置一些常用的程序和功能。Android桌面上首先看到壁纸，也就是手机桌面上的那张图片，接着可以看到手机桌面规则排列的多个图标，这些图标就是Android桌面组件，分别代表快捷方式、实时文件夹与桌面控件三类。每个快捷方式与实时文件夹只占用桌面的一个摆放位置，桌面控件则可以很大，一个桌面控件就可以占据多个摆放位置。 14.1 管理手机桌面关于如何添加、删除手机桌面上三类控件和壁纸的问题，都是一些操作步骤，此处不再赘述。 14.2 改变手机壁纸Android允许使用WallpaperManager来改变手机壁纸，该对象中改变手机壁纸的方法如下： setBitmap(Bitmap bitmap):将壁纸设置为bitmap所代表的位图 setResource(Int resId):将壁纸设置为resid资源所代表的图片 setStream(InputStream data):将壁纸设置为data数据所代表的图片 除此之外，Android系统还提供了一种实时壁纸的功能，所谓实时壁纸，就是指手机桌面不再是简单的图片，而是运行中的动画，这个动画是由程序实时绘制的，因此被称为实时壁纸。 为了开发实时壁纸，Android提供了WallpaperService基类，实时壁纸的实现类需要继承该类。在Android中开发实时壁纸的步骤如下： 开发一个类继承WallpaperService基类 继承WallpaperService基类时必须重写onCreateEngine()方法，该方法返回WallpaperService.Engine子类对象 开发者需要实现WallpaperService.Engine子类，并重写其中的onVisibilityChanged(boolean visible)和onOffsetChanged()方法。不仅如此，由于WallpaperService.Engine子类采用了与SurfaceView相同的绘图机制，因此还可选择性地重写在SurfaceHolder.Callback中的三个方法。重写这些方法时刻通过SurfaceHolder动态地绘制图形。 定义了该Service类之后，接下来还需要在AndroidManifest.xml文件中配置该Service，配置实时壁纸Service和配置普通Service存在小小的区别，它需要指定如下项 &lt;service android:label=&quot;@string/app_name&quot; android:name=&quot;.LiveWallpaper&quot; android:permission=&quot;android.permission.BIND_WALLPAPER&quot; &gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.service.wallpaper.WallpaperService&quot; /&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;android.service.wallpaper&quot; android:resource=&quot;@xml/livewallpaper&quot; /&gt; &lt;/service&gt; 14.3 桌面快捷方式对于一个希望拥有更多用户的应用来说，用户桌面可以说是所有软件的必争之地，如果用户在手机桌面上建立了该软件的快捷方式，用户将会更频繁的使用该软件。 在程序中把一个软件的快捷方式添加到桌面上，只需要如下几步即可： 创建一个添加快捷方式的Intent，该Intent的Action属性值应该为com.android.launcher.INSTALL_SHORTCUT 通过为该Intent添加Extra属性来设置快捷方式的标题、图标及快捷方式对应启动的程序 调用sendBroadcast()方法发送广播即可添加快捷方式 在程序中添加快捷方式需要的相应权限即可 Intent addIntent = new Intent(&quot;com.android.launcher.INSTALL_SHORTCUT&quot;); Intent myIntent = new Intent(AddShortcut.this, AddShortcut.class); addIntent.putExtra(Intent.EXTRA_SHORTCUT_NAME, title); addIntent.putExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE, icon); addIntent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, myIntent); sendBroadcast(addIntent); &lt;uses-permission android:name=&quot;com.android.lancher.permission.INSTALL_SHORTCUT&quot; /&gt; 通过上面的程序已经可以在桌面上为该程序添加快捷方式，但是这种添加方式需要先运行程序，并通过程序中的某个按钮来添加快捷方式，这种方式未免显得有些繁琐。为了让指定应用程序出现在桌面设置中，只要配置该Activity时指定相应的元素即可 &lt;activity android:name=&quot;.AddShortcut&quot; android:label=&quot;@string/app_name&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.CREATE_SHORTCUT&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 14.4 管理桌面小控件桌面小控件是通过Broadcast的形式来控制的，因此每个桌面小控件都对应于一个BroadcastReceiver。为了简化桌面小控件的开发，Android系统提供了一个AppWidgetProvider类，它就是BroadcastReceiver的子类，也就是说开发者开发桌面小控件只要继承AppWidgetProvider类即可。 为了开发桌面小控件，开发者只要开发一个继承AppWidgetProvider的子类，并重写AppWidgetProvider不同状态的生命周期方法即可。AppWidgetProvider里提供如下四个不同的生命周期方法 onUpdate/onDeleted/onEnabled/onDisabled。 public class DesktopApp extends AppWidgetProvider { public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) { RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.main); remoteViews.setImageViewResource(R.id.show, R.drawable.logo); ComponentName componentName = new Component(context, DesktopApp.class); appWidgetManager.updateAppWidget(componentName, remoteViews); } } 由于AppWidgetProvider继承了BroadcastReceiver，因此AppWidgetProvider的本质还是一个BroadcastReceiver，为此需要在AndroidManifest.xml文件中使用元素来配置它，配置该元素时需要为它指定相应的&lt;intent-filter…/&gt;和&lt;meta-data…/&gt; &lt;receiver android:name=&quot;.DesktopApp&quot; android:label=&quot;@string/app_name&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.appwidget.action.APPWIDGET_UPDATE&quot; /&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;android.appwidget.provider&quot; android:resource=&quot;@xml/appwidget_provider&quot; /&gt; &lt;/receiver&gt; 上面配置文件的粗体字代码指定该桌面小控件使用@xml/appwidget_provider作为meta-data，因此还需要在应用的res/xml目录下添加appwidget_provider.xml文件 &lt;appwidget-provider xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:minWidth=&quot;140dp&quot; android:minHeight=&quot;50dp&quot; android:updatePeriodMillis=&quot;1000&quot; android:initialLayout=&quot;@layout/main&quot; /&gt; 14.5 实时文件夹(LiveFolder)所谓实时文件夹，是指用于显示ContentProvider提供的数据的桌面组件。当用户把实时文件夹添加到系统桌面上之后，如果用户单击该实时文件夹图标，系统将会显示从指定ContentProvider查出来的全部数据。开发实时文件夹很简单，实时文件夹也是一个普通的Activity，只是该Activity并不会加载任何显示界面。开发实时文件夹的Activity同样需要集成Activity，并重写Activity的onCreate(Bundle savedInstanceState)方法 public class ContactsLiveFolder extends Activity { public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); if (getIntent().getAction().equals(LiveFolders.ACTION_CREATE_LIVE_FOLDER)) { Intent intent = new Intent(); intent.setData(Uri.parse(&quot;content://contacts/live_folders/people&quot;)); intent.putExtra(LiveFolders.EXTRA_LIVE_FOLDER_BASE_INTENT, new Intent(Intent.ACTION_VIEW, ContactsContract.Contacts.CONTENT_URI)); intent.putExtra(LiveFolders.EXTRA_LIVE_FOLDER_NAME, &quot;电话本&quot;); intent.putExtra(LiveFOLDERS.EXTRA_LIVE_FOLDER_ICON, Intent.ShortcutIconResource.fromContext(this, R.drawable.icon)); intent.putExtra(LiveFolders.EXTRA_LIVE_FOLDER_DISPLAY_MODE, LiveFolders.DISPLAY_MODE_LIST); setResult(RESULT_OK, intent); } else { setResult(RESULT_CANCELED); } finish(); } } 提供了该Activity之后，还需要将该Activity配置成一个实时文件夹，这需要在配置该Activity时通过&lt;intent-filter…/&gt;元素的&lt;action…/&gt;子元素来指定。也就是在AndroidManifest.xml文件中增加如下配置片段 &lt;activity android:name=&quot;.ContactsLiveFolder&quot; android:label=&quot;@string/app_name&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.CREATE_LIVE_FOLDER&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 传感器应用开发在Android系统中开发传感器应用十分简单，因为Android系统为传感器支持强大的管理服务。开发传感器应用的步骤如下： public class AccelerometerTest extends Activity implements SensorEventListener { SensorManager sensorManager; public void onCreate(Bundle savedInstaceState) { super.onCreate(savedInstanceState); sensorManager = (SensorManager)getSystemService(Context.SENSOR_SERVICE); } protected void onResume() { Sensor sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER); //this:监听传感器事件的监听器 sensor:传感器对象 rate:获取的频率 //频率由快到慢的顺序为 SensorManager.SENSOR_DELAY_FASTEST, SENSOR_DELAY_GAME, SENSOR_DELAY_NORMAL, SENSOR_DELAY_UI sensorManager.registerSensor(this, sensor, SensorManager.SENSOR_DELAY_GAME); } protected void onStop() { sensorManager.unregisterListener(this); super.onStop(); } public void onSensorChanged(SensorEvent event) { ...;//当传感器的值发生改变时触发该方法 } public void onAccuracyChanged(Sensor sensor, int accuracy) { ...;//当传感器的精度发生改变时触发该方法 } } 有些手机不支持传感器，模拟器也不支持传感器，开发某些具有传感器功能的APP为了调试，可以借助于一款名叫SensorMimulator的传感器模拟工具，通过此工具，可以模拟出传感器的一些数据来实验，具体操作此处不再介绍 上面介绍了速度传感器，除此之外，安卓设备一般还支持方向传感器、磁场传感器、温度传感器、光传感器、压力传感器等 方向传感器用于感应手机设备的摆放状态。其可以返回三个角度，这三个角度即可确定手机的摆放状态 磁场传感器主要用于读取手机设备外部的磁场强度。其可以返回三个数据，三个数据分别代表周围磁场分解到X、Y、Z三个方向上的磁场分量，磁场数据的单位和微特斯拉(uT) 温度传感器用户获取手机设备所处环境的温度。其可以返回一个数据，代表手机设备周围的温度，单位是摄氏度 光传感器用于获取手机设备所处环境的光的强度。其可以返回一个数据，代表手机设备周围光的强度，该数据的单位是勒克斯(lx) 压力传感器用于获取手机设备所处环境的压力的大小。其可以返回一个数据，代表手机设备周围压力的大小，该数据的单位是百帕斯卡hectopascal（hPa） GPS应用开发GPS是英文Global Position System(全球定位系统)的简称，GPS是20世纪70年代由美国陆海空三军联合研制的新一代空间卫星导航定位系统。 Android为GPS功能支持专门提供了一个LocationManager类，它的作用与TelephonyManager、AudioManager等服务类的作用相似，所有GPS定位相关的服务，对象都将由该对象来产生。 LocationManager lm = (LocationManager)getSystemService(Context.LOCATION_SERVICE); LocationProvider对象就是定位组件的抽象表示，通过LocationProvider可以获取该定位组件的相关信息 Location对象就是一个代表位置信息的抽象类 public class AllProvidersTest extends Activity { public void onCreate(Bundle savedInstanceState) { ListView providers; LocationManager lm; public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); providers = (ListView)findViewById(R.id.providers); lm = (LocationManager)getSystemService(Context.LOCATION_SERVICE); //providerNames会有network（NETWORK_PROVIDER），passive(PASSIVE_PROVIDER)，gps(GPS_PROVIDER)三个值 List&lt;String&gt; providerNames = lm.getAllProviders(); ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1, providerNames); providers.setAdapter(adapter); } } } 此程序可以列出所有支持的位置服务提供者，如何获取某一个LocationProvider呢，有两种方式 直接获取：LocationProvider lp = lm.getProvider(LocationManager.GPS_PROVIDER); 根据条件获取：LocationProvider lp = lm.getBestProvider(new Criteria(), true); 其中 Criteria 类的对象可以设置条件，如高度，方向等过滤条件 获取到了位置管理者LocationManager，就可以获取定位数据了 public class LocationTest extends Activity { LocationManager lm; public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); lm = (LocationManager)getSystemService(Context.LOCATION_SERVICE); Location location = lm.getLastKnownLocation(LocationManager.GPS_PROVIDER); updateView(location); lm.requestLocationUpdates(LocationManager.GPS_PROVIDER, 3000, 8, new LocationListener() { public void onLocationChanged(Location location) { updateView(location); ...;//当GPS定位信息发生改变时，更新位置 } public void onProviderDisabled(String provider) { ...;//当位置提供者不能用时 } public void onProviderEnabled(String provider) { ...;//当位置提供者正常使用时 } public void onStatusChanged(String provider, int status, Bundle extras) { ...;//当位置提供者状态改变时 } }); } } &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt; 前面介绍LocationManager时已经提到，该API提供了一个addProximityAlert(double latitude, double longtitude, float radius, long expiration, PendingIntent intent)方法来添加一个临近警告，其中expiration参数表示经过多少毫秒后该临近警告就会过期失效，-1表示永不过期。 使用Google Map服务疯狂连连看电子拍卖系统]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[疯狂Android第三部分]]></title>
    <url>%2F2012%2F10%2F26%2F%E7%96%AF%E7%8B%82Android%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[使用ContentProvider实现数据共享为了在应用程序之间交换数据，Android提供了ContentProvider，ContentProvider是不同应用程序之间进行数据交换的标准API，当一个应用程序需要把自己的数据暴露给其他程序使用时，该应用程序就可通过提供ContentProvider来实现；其他应用程序就可通过ContentResolver来操作ContentProvider暴露的数据 ContentProvider也是Android应用的四大组件之一，与Activity、Service、BroadcastReceiver相似，都需要在AndroidManifest.xml中进行配置 ContentProvider是不同应用程序之间进行数据交换的标准API，ContentProvider以某种Uri的形式对外提供数据，允许其他应用访问或修改数据；其他应用程序使用ContentResolver根据Uri去访问操作指定数据。 完整地开发一个ContentProvider的步骤如下： 定义自己的ContentProvider类，该类需要集成Android提供的ContentProvider基类 向Android系统注册这个Provider，也就是在AndroidManifest.xml文件中注册这个ContentProvider，就像注册Activity一样。注册ContentProvider时需要为它绑定一个域名 &lt;!--下面配置中name属性指定ContentProvider类 authorities就相当于为该ContentProvider指定域名--&gt; &lt;provider android:name=&quot;.DictProvider&quot; android:authorities=&quot;org.crazyit.providers.dictprovider&quot; /&gt; 应用程序对数据的操作无非就是CRUD操作，因此DictProvider除了需要继承ContentProvider之外，还需要实现ContentProvider内的几个方法： public boolean onCreate();该方法在ContentProvider创建后会被调用，当其他应用程序的第一次访问ContentProvider时，该ContentProvider会被创建出来，并立即回调该onCreate()方法 public Uri insert(Uri uri, ContentValues values);根据Uri插入Values对应的数据 public int delete(Uri uri, String selection, String[] selectionArgs);根据Uri删除select条件所匹配的全部记录 public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs):根据Uri修改select条件所匹配的全部记录 public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder):根据Uri查询出select条件所匹配的全部记录，其中projection就是一个列名列表，表明只选择出指定的数据列 public String getType(Uri uri):返回当前Uri所代表的数据的MIME类型。如果该Uri对应数据可能包括多条记录，那么MIME类型字符串应该以vnd.android.cursor.dir开头，如果该Uri对应的数据只包含一条记录，那么返回MIME字符串应该以vnd.android.cursor.item开头 形如content://org.crazyit.providers.dictProvider/words的Uri可分为3个部分 content:// 这个部分是Android所规定的，是固定的 org.crazyit.providers.dictProvider:这个部分就是ContentProvider的authority，系统就是由这个部分来找到操作哪个ContentProvider。只要访问指定的ContentProvider，这个部分总是固定的 words:资源部分(或者是数据部分)，当访问者需要访问不同资源时，这个部分是动态改变的 Context提供了如下方法来获取ContentResolver对象getContentResolver()，ContentResolver和ContentProvider的方法对应，支持的方法有： insert(Uri uri, ContentValues values); delete(Uri uri, String selection, String[] selectionArgs); update(Uri uri, ContentValues values, String selection, String[] selectionArgs): query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder): 一般来说，ContentProvider是单例模式的，当多个应用程序通过ContentResolver来操作ContentProvider提供的数据时，ContentResolver调用操作将会委托同一个ContentProvider处理 public final class Words { //定义该ContentProvider的Authority public static final String AUTHORITY = @&quot;org.crazyit.providers.dictProvider&quot;; //定义一个静态内部类 public static final class Word implements BaseColumn { public final String _ID = &quot;_id&quot;; public final String WORD = &quot;word&quot;; public final String DETAIL = &quot;detail&quot;; //定义该Content提供服务的两个Uri public final Uri DICT_CONTENT_URI = Uri.parse(&quot;content://&quot;+AUTHORITY+&quot;/words&quot;); public final Uri WORD_CONTENT_URI = Uri.parse(&quot;content://&quot;+AUTHORITY+&quot;/word&quot;); } } public class DictProvider extends ContentProvider { private static UriMatcher matcher = new UriMatcher(UriMatcher.NO_MATCH); private static final int WORDS = 1; private static final int WORD = 2; private MyDatabaseHelper dbOpenHelper; static { matcher.addURI(Words.AUTHORITY, &quot;words&quot;, WORDS); matcher.addURI(Words.AUTHORITY, &quot;word/#&quot;, WORD); } public boolean onCreate() { dbOpenHelper = new MyDataBaseHelper(this.getContext(), &quot;myDict.db3&quot;, 1); return true; } public Uri insert(Uri uri, ContentValues values) { SQLiteDatabase db = dbOpenHelper.getReadableDatabase(); long rowId = db.insert(&quot;dict&quot;, Words.Word._ID, values); if (rowId &gt; 0) { Uri wordUri = ContentUris.withAppendedId(uri, rowId); getContext().getContentResolver().notifyChange(wordUri, null); return wordUri; } return null; } public int delete(Uri uri, String selection, String[] selectionArgs) { SQLiteDatabase db = dbOpenHelper.getReadableDatabase(); int num = 0; switch (matcher.match(uri)) { case WORDS: num = db.delete(&quot;dict&quot;, selection, selectionArgs); break; case WORD: long id = ContentUris.parseId(uri); String where = Words.Word._ID+&quot;=&quot;+id; if (selection != null &amp;&amp; !selection.equals(&quot;&quot;)) { where = where + &quot; and &quot; + selection; } num = db.delete(&quot;dict&quot;, where, selectionArgs); break; default: throw new IllegalArgumentException(&quot;未知Uri:&quot;+uri); } getContext().getContentResolver().nofityChange(uri, null); return num; } ... } public class DictResolver extends Activity { ContentResolver contentResolver; public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); contentResolver = getContentResolver(); insert.setOnClickListener(new OnClickListener() { public void onClick(View source) { ContentValues values = new ContentValues(); values.put(Words.Word.WORD, word); values.put(Words.Word.DETAIL, detail); contentResolver.insert(Words.Word.DICT_CONTENT_URI, values); } }); } } 在上边例子中，为了确定ContentProvider实际能匹配的Uri，以及确定每个方法中Uri参数所操作的数据，Android系统提供了UriMatcher工具类，该类提供了两个方法： void addURI(String authority, String path, int code):向UriMatcher对象注册Uri，其中authority和path组成一个Uri，Code则代表该Uri对应的标识码 int match(Uri):根据前面注册的Uri来判断指定Uri对应的标识码，如果没有匹配，则返回-1 Android还提供了一个ContentUris工具类，它是一个操作Uri字符串的工具类，它提供了两个方法： withAppendedId(uri, id):用于为路径加上ID部分 parseId(uri):用于从指定Uri中解析出包含的ID值 有些时候，只有第一个和第二个应用程序知道共享的数据发生变化，第三个应用如果想知道，就需要监听ContentProvider所共享数据的改变，这就需要利用ContentObserver了。监听ContentProvider数据改变的监听器需要继承ContentObserver类，并重写该基类所定义的onChange(boolean selfChange)方法，当它所监听的ContentProvider的数据发生改变时，该onChange方法将会被触发。 getContext().getContentResolver().notifyChange(uri, null);null可以为ContentObserver实例，表示当前应用监听器数据的变化；这行代码可以通知所有注册在该Uri上的监听者，该ContentProvider所共享的数据发生了改变 为了监听指定ContentProvider的数据变化，需要通过ContentResolver向指定Uri注册ContentObserver监听器。ContentObserver提供了如下方法来注册监听器： registerContentObserver(Uri uri, boolean notifyForDescendents, ContentObserver observer)：uri指该监听器所监听的ContentProvider的Uri；notifyForDescendents如果为true，则子uri也会被监听，如果为false，则不会监听子uri；observer则是监听器实例 getContentObserver().registerContentObserver(Uri.parse(&quot;content://&quot;+AUTHORITY+&quot;/words&quot;), true, new DictObserver(new Handler())); public class Monitor extends Activity { public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); getContentResolver().registerContentObserver(Uri.parse(&quot;content://&quot;+AUTHORITY+&quot;/words&quot;), true, new DictObserver(new Handler())); } public final class DictObserver extends ContentObserver { public DictObserver(Handler handler) { super(hander); } public void onChange(boolean selfChange) { ... } } } Service与BroadcastReceiverService是Android四大组件中与Activity最相似的组件，他们都代表可执行的程序，Service与Activity的区别在于，Service一直在后台运行，它没有用户界面，所以绝不会到前台来。一旦Service被启动起来之后，它就与Activity一样。它完全具有自己的生命周期。 本章还将向读者介绍BroadcastReceiver组件。BroadcastReceiver组件就像一个全局的事件监听器，只不过它用于监听系统发出的Broadcast。通过BroadcastReceiver，即可在不同应用程序之间进行通信。 10.1 Service简介就像开发Activity需要两个步骤一样，开发Service也需要两个步骤： 定义一个继承Service的子类 在AndroidManifest.xml文件中配置该Service Service与Activity还有一点相似之处，它们都是从Context派生出来的，因此它们都可以调用Context里定义的如getResource()，getContentResolver()等方法 与Activity相似的是，Service中也定义了生命周期方法，如下所示： abstract IBinder onBind(Intent intent):该方法是Service子类必须实现的方法，该方法返回一个IBinder对象，应用程序可通过该对象与Service组件通信 void onCreate():当该Service第一次被创建时将立即回调该方法 void onDestroy():当该Service被关闭之前将会回调该方法 void onStartCommand(Intent intent, int flags, int startId):该方法的早期版本时void onStart(Intent intent, int startId)，每次客户端调用startService(Intent)方法启动该Service时都会回调该方法 boolean onUnbind(Intent intent):当该Service上绑定的所有客户端都断开连接时将会回调该方法 定义了上边的Service之后，接下来需要在AndroidManifest.xml文件中配置该Service &lt;service android:name=&quot;.FirstService&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;org.crazyit.service.FIRST_SERVICE&quot;&gt; &lt;/intent-filter&gt; &lt;/service&gt; 当该Service开发完成之后，接下来就可在程序中运行该Service了，Android系统中运行Service有如下两种方式 通过Context的startService()方法，通过该方法启动Service，访问者与Service之间没有联系，即使访问者退出了，Service仍然运行 通过Context的bindService()方法，使用该方法启动Service，访问者与Service绑定在了一起，访问者一旦退出，Service也就终止 当程序通过startService()和stopService()启动，关闭Service时，Service与访问者之间基本上不存在太多的数据关联，因此Service和访问者之间也无法进行通信、数据交换。 如果Service和访问者之间需要进行方法调用或者数据交换，则应使用bindService()和unbindService()方法启动、关闭服务。 Context的bindService()方法的完整方法签名为：bindService(Intent service, ServiceConnection conn, int flags)，该方法的三个参数的解释如下： service：该参数通过Intent指定要启动的Service conn：该参数是一个ServiceConnection对象，该对象用于监听访问者与Service之间的连接情况。当访问者与Service之间连接成功时将回调该ServiceConnection对象的onServiceConnected(ComponentName name, IBinder service)方法，当访问者与Service断开连接时将回调该ServiceConnection对象的onServiceDisconnected(ComponentName, name)方法 flags：指定绑定时是否自动创建Service(如果Service还未创建)。该参数可指定为0（不自动创建）或BIND_AUTO_CREATE（自动创建） 注意到ServiceConnection对象的onServiceConnected方法中有一个IBinder对象，该对象即可实现与被绑定Service之间的通信 public class BindService extends Service { private MyBinder binder = new MyBinder(); public class MyBinder extends Binder { public int getXxx() { return ... } } public IBinder onBind(Intent intent) { return binder; } public void onCreate() { super.onCreate(); } public boolean onUnbind(Intent intent) { return truel } public void onDestory() { super.onDestory(); } } public class MainActivity extends Activity { BindService.MyBinder binder; private ServiceConnection conn = new ServiceConnection() { public void onServiceConnected(componentName name, IBinder service) { binder = (BindService.MyBinder)service; } public void onServiceDisconnected(ComponentName name) { ... } public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); final Intent intent = new Intent(); intent.setAction(&quot;org.crazyit.service.BIND_SERVICE&quot;); bindButton.setOnClickListener(new OnClickListener(){ public void onClick(View Source) { bindService(intent, conn, Service.BIND_AUTO_CREATE) } }); unbindButton.setOnClickListener(new OnClickListener(){ public void onClick(View source) { unbindService(conn); } }); getDataButton.setOnClickListener(new OnclickListener(){ public void onClick(View source) { print(binder.getXxx()); } }); } } } 通过前面两个示例，读者应该已经大致明白Service的生命周期了。随着应用程序启动Service方式不同，Service的生命周期也略有差异 如果应用程序通过startService方法来启动Service，Service的生命周期是：启动-onCreate-onStart-运行-onDestory 如果应用程序通过bindService方法来启动Service，Service的生命周期是：启动-onCreate-onBind-交互-onUnbind-onDestory 10.2 跨进程调用Service(AIDL服务)Android用AIDL(Android Interface Definition Language)来定义远程接口，AIDL的语法与Java接口很相似，但存在一些差异 AIDL定义接口的源代码必须以.aidl结尾 AIDL接口中用到的数据类型，除了基本类型、String、List、Map、CharSequence之外，其他类型全部都需要导包，及时它们在同一个包中也需要导包 // ICat.aidl package service.crazyit.org.aidlservice; interface ICat { void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString); String getColor(); double getWeight(); } //AidlService.java public class AidlService extends Service { private CatBinder catBinder; public class CatBinder extends ICat.Stub { @Override public double getWeight() throws RemoteException { return 100; } } @Override public IBinder onBind(Intent intent) { return catBinder; } @Override public void onCreate() { super.onCreate(); catBinder = new CatBinder(); } @Override public void onDestroy() { super.onDestroy(); } } //MainActivity.java public class MainActivity extends AppCompatActivity { private ICat catService; private ServiceConnection conn = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { catService = ICat.Stub.asInterface(service); } @Override public void onServiceDisconnected(ComponentName name) { catService = null; } }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); final Intent intent = new Intent(); intent.setAction(&quot;org.crazyit.aidl.action.AIDL_SERVICE&quot;); bindService(intent, conn, Service.BIND_AUTO_CREATE); new Thread(new Runnable() { @Override public void run() { try { Thread.sleep(5000); Log.d(&quot;frand&quot;, catService.getWeight()+&quot;&quot;); } catch (RemoteException e) { e.printStackTrace(); } catch (InterruptedException e) { e.printStackTrace(); } } }).start(); } } 10.3 电话管理器(TelephonyManager)TelephonyManager是一个管理手机通话状态、电话网络信息的服务类，该类提供了大量的getXxx()方法来获取电话网络的相关信息，在程序中获取TelephonyManager十分简单，只要调用如下代码即可TelephonyManager tManager = (TelephonyManager)getSystemService(Context.TELEPHONY_SERVICE);，接下来就可以通过TelephonyManager获取相关信息或者进行相关操作了 getDeviceId()/getDeviceSoftwareVersion()/getNetworkOperator()/getNetworkOperatorName()/getPhoneType()/getCellLocation()/getSimCountryIso()/getSimSerialNumber()/getSimState()等 //监听手机来电，如果是黑名单，则自动挂断 public class MonitorPhone extends Activity { public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); TelephonyManager tManager = (TelephonyManager)getSystemService(Context.TELEPHONY_SERVICE); PhoneStateListener listener = new PhoneStateListener() { public void onCallStateChanged(int state, String incomingNumber) { switch(state) { case TelephonyManager.CALL_STATE_IDLE: break; case TelephonyManager.CALL_STATE_OFFHOOK: break; case TelephonyManager.CALL_STATE_RINGING: if (isBlock(incomingNumber)) { Method method = Class.forName(&quot;android.os.ServiceManager&quot;).getMethod(&quot;getService&quot;, String.class); IBinder binder = (IBinder)method.invoke(null, new Object[]{TELEPHONY_SERVICE}); ITelephony telephony = ITelephony.Stub.asInterface(binder); telephony.endCall(); } break; default: break; } } }; tManager.listen(listener, PhoneStateListener.LISTEN_CALL_STATE); } } 10.4 短信管理器SmsManager是Android提供的另一个非常常见的服务，SmsManager提供了系列sendXxxMessage()方法用于发送短信，不过就现在实际应用来看，短信通常都是普通的文本内容，也就是调用sendTextMessage()方法进行发送即可 SmsManager sManager = SmsManager.getDefault(); PendingIntent pi = PendingIntent.getActivity(SendSms.this, 0, new Intent(), 0); sManager.sendTextMessage(number, null, content, pi, null); &lt;uses-permission android:name=&quot;android.permission.SEND_SMS&quot; /&gt; 10.5 音频管理器(AudioManager)在某些时候，程序需要管理系统音量，或者直接让系统静音，这就可以借助于Android提供的AudioManager来实现。程序一样是调用getSystemService()方法来获取系统的音频管理器。接下来就可调用AudioManager的方法来控制手机音频了。 adjustStreamVolume(int streamType, int direction, int flags):调整手机指定类型的声音。其中第一个参数streamType指定声音类型，该参数可接受如下几个值 STREAM_ALARM:手机闹铃的声音 STREAM_DTMF:DTMF音调的声音（键盘音） STREAM_MUSIC:手机音乐的声音 STREAM_NOTIFICATION:系统提示的声音 STREAM_RING:电话铃声的声音 STREAM_SYSTEM:手机系统的声音 STREAM_VOICE_CALL:语言电话的声音 第二个参数指定对声音进行增大、还是减少；第三个参数时调整声音时的标志，例如指定FLAG_SHOW_UI，则指定调整声音时显示音量进度条。 SetMicrophoneMute(boolean on):设置是否让麦克风静音 setMode(int mdoe):设置声音模式，可设置的值有NORMAL，RINGTONE和IN_CALL setRingerMode(int ringerMode):设置手机的电话铃声模式，支持如下几个属性 RINGER_MODE_NORMAL:正常的手机铃声 RINGER_MODE_SILENT:手机铃声静音 RINGER_MODE_VIBRATE:手机振动 setSpeakerPhoneOn(boolean on):设置是否打开扩音器 setStreamMute(int streamType, boolean state):将手机的指定类型的声音调整为静音，其中streamType和adjustStreamVolume方法中第一个参数的意义相同 setStreamVolume(int streamType, int index, int flags):直接设置手机的指定类型的音量 AudioManager aManager = (AudioManager)getSystemService(Service.AUDIO_SERVICE); 10.6 振动器系统获取Vibrator也是调用Context的getSystemService()方法即可，接下来就可调用vibrator的方法来控制手机振动了，其使用方法比较简单，只有三个简单的方法来控制手机振动： void vibrate(long milliseconds):控制手机振动多少毫秒 void vibrate(long[] pattern, int repeat):指定手机以pattern指定的模式振动 cancel():关闭手机振动 Vibrator vibrator = (Vibrator)getSystemService(Service.VIBRATOR_SERVICE); vibrator.vibrate(2000); &lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot; /&gt; 10.7 手机闹钟服务(AlarmManager)AlarmManager通常的用途就是用来开发手机闹钟，但实际上它的作用不止于此。它的本质是一个全局的定时器，AlarmManager可在指定时间或者指定周期启动其他组件(包括Activity、Service、BroadcastReceiver) AlarmManager不仅可用于开发闹钟应用，还可以作为一个全局定时器使用，Android应用中的程序也是通过Context的getSystemService()方法来获取AlarmManager对象，一旦程序获取了AlarmManager对象之后，就可调用它的如下方法来设置定时启动指定组件： void set(int type, long triggerAtTime, PedingIntent operation):设置在triggerAtTime时间启动由operation参数指定的组件。其中第一个参数指定定时服务的类型，该参数可接受如下值： ELAPSED_REALTIME:指定从现在开始时间过了一定时间后启动operation所对应的组件 ALAPSED_REALTIME_WAKEUP:即使系统关机也会执行operation所对应的组件 RTC:指定当系统调用System.currentTimeMillis()方法返回值与triggerAtTime相等时启动operation所对应的组件 RTC_WAKEUP:即使系统关机也会执行operation所对应的组件 void setInexactRepeating(int type, long triggerAtTime, long interval, PendingIntent operation):设置一个非精确的周期性任务。例如我们设置Alarm每个小时启动一次，但系统并不一定在每个小时的开始启动Alarm服务 void setRepeating(int type, long triggerAtTime, long interval, PendingIntent operation):设置一个周期性执行的定时任务 void cancel(PedingIntent operation):取消AlarmManager的定时任务 public class AlarmChangeWallpaper extends Activity { public void onCreate(Bundle savedInstance) { super.onCreate(savedInstance); setContentView(R.layout.main); AlarmManager aManager = (AlarmManager)getSystemService(Service.ALARM_SERVICE); Intent intent = new Intent(AlarmChangeWallpaper.this, ChangeService.class); final PendingIntent pi = PendingIntent.getService(AlarmChangeWallpaper.this, 0, intent, 0); aManager.setRepeating(AlarmManager.RTC_WAKEUP, 0, 5000, pi); } } public class ChangeService extends Service { WallpaperManager wManager; public void onCreate() { super.onCreate(); wManager = WallpaperManager.getInstance(this); } public void onStart(Intent intent, int startId) { wManager.setResource(wallpapers[count++]); super.onStart(intent, startId); } public void onBind(Intent intent) { return null; } } &lt;uses-permision android:name=&quot;android.permission.SET_WALLPAPER&quot; /&gt; 10.8 广播消息Android系统的四大组件还有一种BroadcastReceiver，这种组件本质上就是一种全局监听器，用于监听系统全局的广播消息。由于BroadcastReceiver是一种全局的监听器，因此它可以非常方便地实现系统中不同组件之间的通信。 BroadcastReceiver用于接收程序（包括用户开发的程序和系统内建的程序）所发出的Broadcast Intent，与应用程序启动Activity，Service相同的是，程序启动BroadcastReceiver也只需要两步： 创建需要启动的BroadcastReceiver的Intent 调用Context的sendBroadcast()或sendOrderedBroadcast()方法来启动指定的BroadcastReceiver 当程序发出一个Broadcast Intent之后，所有匹配该Intent的BroadcastReceiver都有可能被启动 与Activity、Service具有完整生命周期不同的是，BroadcastReceiver本质上只是一个系统级的监听器，它专门负责 监听各程序所发出的Broadcast。与前面介绍的各种OnXXXListener不同的是，它是一个系统级的监听器，它有自己的进程，当程序退出时，只要存在与之匹配的Intent被广播出来，BroadcastReceiver总会被激发。 一旦实现了BroadcastReceiver的onReceive方法，接下来就应该指定该BroadcastReceiver能匹配的Intent，此时有两种方式： 使用代码进行指定，调用BroadcastReceiver的Context的registerReceiver(BroadcastReceiver receiver, IntentFilter filter)方法指定: IntentFilter filter = new IntentFilter(&quot;android.provider.telephony.SMS_RECEIVERD&quot;); IncomingSMSReceiver receiver = new IncomingReceiver(); register(receiver, filter); 在AndroidManifest.xml文件中配置，代码如下: &lt;receiver android:name=&quot;.IncomingReceiver&quot; &gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.provider.telephoy.SMS_RECEIVED&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 每次系统broadcast事件发生之后，系统就会创建对应的BroadcastReceiver实例，并自动触发它的onReceive方法，onReceive方法执行完后，BroadcastReceiver的实例就会被销毁。如果BroadcastReceiver的onReceive方法不能在10秒内执行完成，Android会认为该程序无响应。所以不要在BroadcastReceiver的onReceive方法里执行一些耗时的操作，否则会弹出ANR（Application No Response）的对话框 在程序中发送广播十分简单，只要调用Context的sendBroadcast(Intent intent)方法即可，这条广播将会启动intent参数所对应的BroadcastReceiver。 Broadcast被分为如下两种： Normal Broadcast(普通广播):这种广播完全是异步的，可以在同一时刻被所有接收者接收到，消息传递的效率比较高。但缺点是接收者不能将处理结果传递给下一个接收者，并且无法终止Broadcast Intent的传播 Ordered Broadcast(有序广播):这种广播的接收者将按预先声明的优先级依次接收Broadcast。优先级别声明在&lt;intent-filter…/&gt;元素的android:priority属性中，数越大优先级别越高，取值范围为-1000~1000之间，优先级别也可以调用IntentFilter对象的setPriority()进行设置。Ordered Broadcast接收者可以调用BroadcastReceiver的abordBroadcast()方法终止Broadcast Intent的传播，Broadcast Intent一旦终止，后面的接收者就无法接收到Broadcast。另外，Ordered Broadcast的接收者可以将数据传递给下一个接收者 //发送广播 Intent intent = new Intent(); intent.setAction(&quot;org.crazyit.action.CRAZY_BROADCAST&quot;); sendOrderedBroadcast(intent, null); //第一个BroadcastReceiver Bundle bundle = new Bundle(); bundle.putString(&quot;first&quot;, &quot;第一个BroadcastReceiver存入的消息&quot;); setResultExtra(bundle); abortBroadcast(); &lt;receiver android:name=&quot;.MyReceiver&quot; &gt; &lt;intent-filter android:priority=&quot;20&quot;&gt; &lt;action android:name=&quot;org.crazyit.action.CRAZY_BROADCAST&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; //第二个BroadcastReceiver Bundle bundle = getResultExtra(true); String first = bundle.getString(&quot;first&quot;); 10.9 接收系统广播消息如果应用需要在系统特点时刻执行某些操作，就可以通过监听系统广播来实现。Android的大量系统事件都会对外发送标准广播。下面是Android常见的广播Action常量 ACTION_TIME_CHANGED:时间改变 ACTION_DATE_CHANGED:日期改变 ACTION_TIMEZONE_CHANGED:时区改变 ACTION_BOOT_COMPLETED:启动完成 ACTION_PACKAGE_ADDED:添加包 ACTION_PACKAGE_CHANGED:包被删除 ACTION_PACKAGE_REMOVED:包被删除 ACTION_PACKAGE_RESTARTED:包被重启 ACTION_PACKAGE_DATA_CLEARED:包数据被清空 ACTION_BATTERY_CHANGED:电池电量改变 ACTION_BATTERY_LOW:电池电量低 ACTION_POWER_CONNECTED:系统连接电源 ACTION_POWER_DISCONNECTED:系统断开电源 ACTION_SHUTDOWN:系统被关闭 多媒体应用开发11.1 音频和视频的播放Android提供了简单的API来播放音频、视频：MediaPlayer；使用MediaPlayer十分简单，当程序控制MediaPlayer对象装载音频完成以后，程序可以调用MediaPlayer的如下三个方法进行播放控制： start():开始或恢复播放 stop():停止播放 pause():暂停播放 为了让MediaPlayer来装载指定音频文件，MediaPlayer提供了如下简单的静态方法： static MediaPlayer create(Context context, Uri uri):从指定Uri来装载音频文件，并返回对象 static MediaPlayer create(Context context, int resid):从resid资源ID对应的资源装载音频文件并返回 如果程序需要使用MediaPlayer循环播放多个音频文件，使用MediaPlayer的静态create方法就不太合适了，此时可通过MediaPlayer的setDataSource()方法来装载指定的音频文件 void setDataSource(String path/FileDescriptor fd):指定装载path路径或fd所代表的文件 void setDataSource(FileDescriptor fd, long offset, long length):指定fd文件的offset开始length长度的文件内容 void setDataSource(Context context, Uri uri):指定装载uri所代表的文件 执行上面所示的setDataSource方法之后，MediaPlayer并未真正去装载那些文件，还需要调用MediaPlayer的prepare()方法去准备，所谓准备，就是让MediaPlayer真正去装载音频文件 除此之外，MediaPlayer还提供了一些绑定事件监听器的方法，用于监听MediaPlayer播放过程中所发生的特定事件，绑定事件监听器的方法如下： setOnCompletionListener(MediaPlayer.OnCompletionListener listener): setOnErrorListener(MediaPlayer.OnErrorListener listener): setOnPreparedListener(MediaPlayer.OnPreparedListener listener): setOnSeekCompleteListener(MediaPlayer.OnSeekCompleteListener listener): 如果应用程序经常需要播放密集、短促的音效，这是还用MediaPlayer就显得有些不合适了。MediaPlayer存在如下缺点： 占用资源较多，延时时间较长 不支持多个音效同时播放 为了解决这个问题，Android提供了SoundPool来播放音效，SoundPool使用音效池的概念来管理多个短促的音效，它与MediaPlayer相比，占用资源量低延时更小，而且还支持自行设置声音的品质、音量、缩放比率等参数。它的构造器如下： SoundPool(int maxStreams, int streamType, int srcQuality):第一个参数指定支持多少个声音，第二个参数指定声音类型，第三个参数指定声音品质 一旦得到了SoundPool对象之后，接下来就可调用SoundPool的多个重载的load方法来加载声音了，SoundPool提供了如下4个load方法 int load(Context context, int resId, int priority): int load(FileDescriptor fd, long offset, long length, int priority) int load(AssetFileDescriptor afd, int priority) int load(String path, int priority) 上面4个方法都有一个priority参数，该参数目前还没有任何作用，Android建议将该参数设为1，保持和未来的兼容性；上面的4个方法加载声音之后都会返回该声音的ID，以后程序就可以通过该声音的ID来播放指定声音，SoundPool提供的播放指定声音的方法如下： int play(int soundID, float leftVolume, float rightVolume, int priority, int loop, float rate):该方法的第一个参数指定播放哪个声音，leftVolume和rightVolume指定左、右的音量，priority指定播放声音的优先级，数值越大，优先级越高；loop指定是否循环，0为不循环，-1为循环；rate指定播放的比率，数值可从0.5到2，1为正常比率 为了更好的管理SoundPool所加载的每个声音的ID，程序一般会使用一个HashMap&lt;Integer, Integer&gt;对象来管理声音 SoundPool soundPool = new SoundPool(10, AudioManager.STREAM_SYSTEM, 5); HashMap soundMap = new HashMap&lt;Integer, Integer&gt;(); soundMap.put(1, soundPool.load(this, R.raw.bomb, 1)); btn.setOnClickListener(new OnClickListener(){ public void onClick(View v) { soundPool.play(soundMap.get(1), 1, 1, 0, 0, 1); } }); SoundPool虽然可以一次性加载多个声音，但由于内存限制，因此更应该避免使用SoundPool来播放歌曲或者做游戏背景音乐，只有那些短促、密集的声音才考虑使用SoundPool进行播放 使用VideoView播放视频的步骤如下： &lt;VideoView android:id=&quot;@+id/video&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; /&gt; VideoView videoView = (VideoView)findViewById(R.id.video); MediaController mediaController = new MediaController(this); File video = new File(&quot;/mnt/sdcard/movie.mp4&quot;); if (video.exist()) { videoView.setVideoPath(video.getAbsolutePath()); videoView.setMediaController(mediaController); mediaController.setMediaPlayer(videoPlayer); videoView.requestFocus(); } 11.2 使用MediaRecorder录制音频为了在Android应用中录制音频，Android提供了MediaRecorder类，使用MediaRecorder录制音频的过程很简单，按如下步骤进行即可： 创建MediaRecorder对象 调用MediaRecorder对象的setAudioSource()方法设置声音来源，一般传入MediaRecorder.AudioSource.MIC参数指定录制来自麦克风的声音 调用MediaRecorder对象的setOutputFormat设置所录制的音频文件格式 调用MediaRecorder对象的setAudioEncoder()、setAudioEncodingBitRate(int bitRate)、setAudioSamplingRate()设置所录制的声音的编码格式、编码位率、采样率等 调用MediaRecorder的setOutputFile(String path)方法设置录制音频文件的保存位置 调用MediaRecorder的prepare()方法准备开始录制 调用MediaRecorder的start()方法开始录制 调用MediaRecorder的stop()方法停止录制，并调用release()方法释放资源 File soundFile = new File(&quot;/file/sound.amr&quot;); MediaRecorder mediaRecorder = new MediaRecorder(); mediaRecorder.setAudioSource(MediaRecorder.AudioSource.MIC); mediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP); mediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.ARM_NB); mediaRecorder.setOutputFile(soundFile.getAbsolutePath); mediaRecorder.prepare(); mediaRecorder.start(); &lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt; 11.3 控制摄像头拍照和录视频短片使用MediaRecorder拍照代码： SurfaceView surfaceView = (SurfaceView)findViewById(R.id.sufaceView); SufaceHolder surfaceHolder = surfaceView.getHolder(); Camera camera = Camera.open(); Camera.Parameters parameters = camera.getParameters(); parameters.setPreviewSize(screenWidth, screenHeight); parameters.setPreviewFrameRate(4); parameters.setPictureFormat(PixelFormat.JPEG); parameters.set(&quot;jpeg-quality&quot;, 85); parameters.setPictureSize(screenWidth, screenHeight); camera.setParameters(parameters); camera.PreviewDisplay(surfaceHolder); camera.startPreview(); camera.autoFocus(null); camera.takePicture(null, null, myjpegCallback); PictureCallback myjpegCallback = new PictureCallback() { public void onPictureTaken(byte[] data, Camera camera) { Bitmap bm = BitmapFactory.decodeByteArray(data, 0, data.length); File file = new File(Environment.getExternalStorageDirectory(), &quot;logo.jpg&quot;); FileOutputStream outStream = new FileOutputStream(file); bm.compress(CompressFormat.JPEG, 100, outStream); outStream.close(); camera.stopPreview(); camera.startPreview(); } }; &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt; &lt;uses-permission android:name=&quot;android.hardware.camera&quot; /&gt; &lt;uses-permission android:name=&quot;android.hardware.camera.autofocus&quot; /&gt; MediaRecorder除了可用于录制音频外，还可用于录制视频。使用MediaRecorder录制视频与录制音频的步骤基本相同。只是录制视频时不仅需要采集声音，还需要采集图像，为了让MediaRecorder录制时采集图像，应该在调用setAudioSource(int audio_source)方法时再调用setVideoSource(int video_source)方法来设置图像来源。录视频代码如下： //设置从摄像头采集图像 mediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA); //设置视频文件的输出格式(必须在设置声音编码格式、图像编码格式之前设置) mediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4); mediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.DEFAULT); mediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.MPEG_4_SP); mediaRecorder.setVideoSize(320, 280); mediaRecorder.setVideoFrameRate(4); //使用指定的SurfaceView来预览视频 mediaRecorder.setPreviewDisplay(sView.getHolder().getSurface()); mediaRecorder.prepare(); mediaRecorder.start(); OpenGL与3D应用开发这个部分的知识比较少用，以后会总结]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[疯狂Android第二部分]]></title>
    <url>%2F2012%2F09%2F28%2F%E7%96%AF%E7%8B%82Android%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[使用Intent和IntentFilter进行通信 不管是启动一个Activity也好，Service或者BroadcastReceiver组件也好，Android使用统一的Intent对象来封装意图，用Intent可以提供一致的编程模型 在某些时候，应用程序只是想启动具有某种特征的组件，并不想和某个具体的组件耦合，用Intent明显利于高层次的解耦 5.1 Intent对象详解Intent对象大致包含Component、Action、Category、Data、Type、Extra这7个属性，其中Component用于明确指定需要启动的目标组件，而Extra用于携带需要交换的数据 5.2 Intent的属性及intent-filter配置Intent的Action、Category属性都是一个普通的字符串，其中Action代表Intent所要完成的一个抽象动作，而Category则用于为Action增加额外的附加类别信息，通常Action属性会和Category属性结合使用，在注册Activity时可以有一个或多个Action和Category，但是Action中，如果过滤规则中能够匹配到其中一个，是可以成功的；而过滤规则需要满足对应所有的category，才可以成功的 Data属性通常用于向Action属性提供操作的数据 Type属性用于明确指定Data属性所指定数据的类型或MIME类型，当Intent不指定Data属性时Type属性才会起作用，否则Android系统将会根据Data属性值来分析数据的类型，因此指定Data后无须指定Type属性 Intent的Extra属性通常用于在多个Action之间进行数据交换，Intent的Extra属性值应该是一个Bundle对象，Bundle对象就像一个Map对象，它可以存入多组key-value对，这样就可以通过Intent在不同的Activity之间进行数据交换了 Android应用的资源如果从物理存在形式来分，Android应用的源代码大致可分为如下三大类： 界面布局文件：XML文件，文件中每个标签都对应于相应的View标签 Java源文件：应用中的Activity、Service、BroadcastReceiver、ContentProvider四大组件都是采用Java代码来实现的 资源文件：主要以各种XML为主，还包括.png/.jpg/.gif图片资源 Android应用下除了res目录用于存放资源之外，assets目录也可用于存放资源。一般来说，assets目录下存放的资源代表应用无法直接访问的原生资源，应用程序需要通过AssetManager以二进制流的形式来读取资源，而res目录下的资源，Android SDK会在编译该应用时，自动在R.java文件中为这些资源创建索引，程序可直接通过R资源清单类进行访问 6.1 资源的类型及存储方式Android应用资源可分为两大类： 无法直接访问的原生资源，保存在assets目录下 可通过R资源清单类访问的资源，保存在res目录下 一旦将应用程序的各种资源分别保存在Android应用的/res目录下，接下来既可以在Java程序中使用这些资源，也可以在其他XML资源中使用这些资源 由于Android SDK会在编译应用时在R类中为/res目录下所有资源创建索引项，因此在Java代码中访问资源主要通过R类来完成[&lt;package_name&gt;.]R.&lt;resource_type&gt;.&lt;resource_name&gt; 当定义XML资源文件时，其中的XML元素可能需要指定不同的值，这些值就可以设置为已定义的资源项。在XML中使用资源的完整语法格式为：@[&lt;package_name&gt;:]&lt;resource_type&gt;/&lt;resource_name&gt; 6.2 使用字符串、颜色、尺寸资源字符串资源、颜色资源、尺寸资源，它们对应的XML文件都将位于/res/value目录下，它们的默认的文件名为strings.xml/colors.xml/dimens.xml 6.3 数组(Array)资源Android同样采用位于/res/value目录下的arrays.xml文件来定义数组，定义数组时XML资源文件的根元素也是&lt;resources…/&gt;元素，该元素内可包含如下三种子元素&lt;array.../&gt; &lt;string-array.../&gt; &lt;integer-array.../&gt; 6.4 使用Drawable资源Drawable资源通常保存在/res/drawable目录，实际上可能保存在/res/drawable-lmhdpi目录下，图片资源是最简单的Drawable资源，我们只要把.png .jpg .gif等格式的图片放入/res/drawable-xxx目录下，Android SDK就会在编译应用时自动加载该图片，并在R资源清单类中生成该资源的索引 StateListDrawable用于组织多个Drawable对象，当使用StateListDrawable作为目标组件的背景，前景图片时，StateListDrawable对象所显示的Drawable对象会随目标组件状态的改变而自动切换。 定义StateListDrawable对象的XML文件的根元素为&lt;selector.../&gt;，该元素可以包含多个&lt;item.../&gt;元素，该元素可以指定如下属性color/drawable/state_xxx 与StateListDrawable有点类似，LayerDrawable也可包含一个Drawable数组，因此系统将会按这些Drawable对象的数组顺序来绘制它们，索引最大的Drawable对象将会被绘制在最上面。 定义LayerDrawable对象的XML文件的根元素为&lt;layer-list.../&gt;，该元素可以包含多个&lt;item.../&gt;元素，该元素可指定如下属性drawable/id/bottom|top|left|right ShapeDrawable用于定义一个基本的几何图形(如矩形、圆形、线条等) 定义ShapeDrawable的XML文件的根元素是&lt;Shape.../&gt;元素，该元素可指定如下属性android:shape=[rectangle|oval|line|ring]，该元素下边可指定如下元素&lt;corners.../&gt; &lt;gradient.../&gt; &lt;padding.../&gt; &lt;size.../&gt; &lt;solid.../&gt; &lt;stroke.../&gt; ClipDrawable代表从其他位图上截取的一个“图片片段”，在XML文件中定义ClipDrawable对象使用&lt;clip.../&gt;元素，该元素可以指定三个属性drawable/clipOrientation/gravity AnimationDrawable代表一个动画资源，Android中既支持传统的逐帧动画（类似于电影方式、一张图片一张图片的切换），也支持通过平移、变化计算出来的补间动画 下面以逐帧动画原理来介绍定义AnimationDrawable资源, 定义逐帧动画的XML资源文件以元素作为根元素,该元素内可指定&lt;item…./&gt;子元素,将其设置为ImageView的background后,便可将item内的图片文件逐帧播放 下面以补间动画文理来介绍如何定义AnimationDrawable资源，定义补间动画的XML资源文件以&lt;set…/&gt;元素作为根元素，该元素内可以指定如下4个元素：alpha/scale/tanslate/rotate 6.5 使用原始XML资源在某些时候，Android应用有一些初始化的配置信息、应用相关的数据资源需要保存、一般推荐使用XML文件来保存它们，这种资源就被称为原始XML资源。 原始XML资源一般保存在/res/xml路径下，一般默认没有此目录，开发者应该自行手动创建xml目录，一旦成功的定义了原始XML资源，接下来在XML文件中可通过如下语法格式来访问它：@[&lt;package_name&gt;:]xml/file_name，在Java代码中通过[&lt;package_name&gt;.]R.xml.&lt;file_name&gt;来访问它 6.6 使用布局(Layout)资源Layout资源文件应放在/res/layout目录下，Layout资源文件的根元素通常是各种布局管理器，比如LinearLayout、RelativeLayout等 一旦在Android项目中定义了Layout资源，接下来在XML文件中可通过如下语法格式来访问它：@[&lt;package_name&gt;:]layout/file_name，在Java代码中通过[&lt;package_name&gt;.]R.layout.&lt;file_name&gt;来访问它 6.7 使用菜单(Menu)资源菜单资源文件通常应该放在/res/menu目录下，菜单资源的根元素通常是&lt;menu…/&gt;元素，&lt;menu…/&gt;元素无须指定任何属性。&lt;menu.../&gt;元素内可包含如下子元素&lt;item.../&gt; &lt;group.../&gt;，&lt;group.../&gt;子元素用于控制整组菜单的行为，该元素可指定如下常用属性 checkableBehavior：指定该组菜单的选择行为 menuCategory：对菜单进行分类，指定菜单的优先级 visible：该菜单是否可见 enable：该菜单是否可用 归纳起来，使用XML资源定义菜单有如下两个好处： XML资源文件不仅负责定义应用界面，也负责定义菜单，这样可把所有界面相关的内容交给XML文件管理，而Java代码的功能更集中 后期更新维护应用时，如果需要更新、维护菜单，打开、编辑XML文件即可，避免对Java文件的修改 6.8 样式(Style)和主题(theme)资源Android的样式资源文件也放在/res/values目录下，样式资源文件的根元素是&lt;resources.../&gt;元素，该元素内可包含多个&lt;style.../&gt;子元素，每个&lt;style.../&gt;子元素定义一个样式，&lt;style.../&gt;元素指定如下两个属性 name 和 parent，&lt;style.../&gt;元素内可包含多个&lt;item.../&gt;子元素，每个&lt;item.../&gt;子元素定义一个格式项，如android:textColor 与样式资源非常相似，主题资源的XML文件通常也放在/res/values目录下，主题资源的XML文档同样以&lt;resource.../&gt;元素作为根元素，同样使用&lt;style.../&gt;来定义主题。 主题与样式的区别主要体现在： 主题不能作用于单个的View组件，主题应该对整个应用中的所有Activity起作用，或对指定Activity起作用 主题定义的格式应该是改变窗口外观的格式，例如窗口标题、窗口边框等 6.9 属性（Attribute）资源属性资源文件也放在/res/values目录下，属性资源文件的跟元素也是&lt;resources.../&gt;，该元素里包含如下两个子元素 attr子元素：定义一个属性 declare-styleable子元素：定义一个styleable对象，每个styleable对象就是一组attr属性的集合 &lt;declare-styleable name=&quot;MyImageView&quot;&gt; &lt;attr name=&quot;imgSrc&quot; format=&quot;reference&quot;/&gt; &lt;/declare-styleable&gt; 6.10 使用原始资源类似声音文件及其他各种类型的文件，只要Android没有为之提供专门的支持，这种资源都被称为原始资源。Android的原始资源可以放在如下两个地方 位于/res/raw目录下，Android SDK会处理该目录下原始资源，Android SDK会在R清单类中为该目录下的资源生成一个索引 位于/assets/目录下，该目录下的资源是更彻底的原始资源。Android应用需要通过AssetManager来管理该目录下的原始资源 6.11 国际化和资源自适应Android应用使用res/values目录下的资源文件来保存程序中用到的字符串信息，为了给这些消息提供不同语言，国家的版本，开发者需要为values目录添加几个不同的语言国家版本，不同values文件夹的命名方式为： values-语言代码-r国家代码 图形与图像处理7.1 使用简单图片当我们为Android应用增加了Drawable资源后，Android SDK会为这份资源在R清单文件中创建一个索引项：R.drawable.file_name，接下来可以在XML资源文件中通过@drawable/file_name来访问该对象，也可在Java代码中通过R.drawable.file_name方位该Drawable对象 Bitmap代表一张位图，BitmapDrawable里封装的图片就是一个Bitmap对象。开发者为了把Bitmap对象包装成BitmapDrawable对象，可以调用BitmapDrawable的构造器BitmapDrawable drawable = new BitmapDrawable(bitmap)，如果需要获取BitmapDrawable所封装的Bitmap对象，则可调用BitmapDrawable的getBitmap()方法Bitmap bitmap = drawable.getBitmap(); 除此之外，Bitmap还提供了一些静态方法来创建新的Bitmap对象，例如： createBitmap(Bitmap src, int x, int y, int width, int height) createScaledBitmap(Bitmap src, int dstWidth, int dstHeight, boolean filter) createBitmap(int width, int height, Bitmap.Config config) createBitmap(Bitmap src, int x, int y, int width, int height, Matrix m, boolen filter) BitmapFactory是一个工具类，它用于提供大量的方法，这些方法可用于从不同的数据源来解析、创建Bitmap对象。BitmapFactory包含了如下方法： decodeByteArray(byte[] data, int offset, int length) decodeFile(String pathName) decodeFileDescriptor(FileDescriptor fd) decodeResource(Resources res, int id) decodeStream(InputStream is) 由于手机内存的限制，如果系统不停的去解析、创建Bitmap对象，可能由于前面创建Bitmap所占的内存还没有回收，而导致程序运行时引发OutOfMemory错误，Android为Bitmap提供了两个方法来判断它是否已回收 1. boolean isRecycled() 2. void recycle() 7.2 绘图Android的绘图应该继承View组件，并重写它的onDraw(Canvas canvas)方法即可；此时涉及一个绘图API：Canvas，Canvas代表了依附于指定View的画布，它提供了很多的方法来绘制各种图形，比如drawArc,drawBitmap,drawLine,drawRect,drawText等；这些方法的参数中都涉及一个绘图API：Paint，Paint代表了Canvas上的画笔，因此Paint类主要用于设置绘制风格，包括画笔颜色，粗细，填充风格，渐变Shader等 Android提供的Path是一个非常有用的类，它可以预先在View上将N个点连成一条路径，然后调用Canvas的drawPath(path, paint)即可沿着路径绘制图形，实际上Android还未路径绘制提供了PathEffect来定义绘制效果，如ComposePathEffect,CornerPathEffect,DashPathEffect,DiscretePathEffect,PathDashPathEffect,SumPathEffect等 为了让View组件上绘制的图形发生改变(无非是位置、大小、角度等发生改变)，这就需要程序采用变量来记住这些状态数据–如果需要游戏动画随用户操作而改变，就为用户动作编写事件监听器，在监听器中修改这些数据；如果需要游戏动画自行改变，那就是随时间的流失而改变，就需要使用定时器(Timer)，让Timer控制这些状态数据定期修改；不管使用哪种方式，每次View组件上的图形状态数据发生了改变，都应该通知View组件重写调用onDraw(Canvas canvas)方法重绘该组件。通知View重绘可调用invalidate(在UI线程中)或postInvalidate(在非UI线程中) 7.3 图形特效处理Matrix是Android提供的一个矩阵工具类，它本身并不能对图像或组件进行变换，但它可与其他API结合来控制图形、组件的变换，使用Matrix控制图像或组件的变换步骤如下 获取Matrix对象，该Matrix对象既可新创建，也可直接获取其他对象内封装的Matrix 调用Matrix的方法进行平移、旋转、缩放、倾斜等 将程序对Matrix所做的变换应用到指定图像或组件 Matrix提供了如下方法来控制平移、旋转和缩放setTranslate/setSkew/setRotate/setScale drawBitmapMesh(Bitmap bitmap, int meshWidth, int meshHeight, float[] vers, int vertOffset, int[] colors, int colorOffset, Paint paint)方法是Canvas提供，该方法可以对bitmap进行扭曲，其中的关键参数说明如下 bitmap:指定需要扭曲的源位图 meshWidth:该参数控制在横向上把该源位图划分成多少格 meshHeight:该参数控制在纵向上把该源位图划分成多少格 verts:该参数时一个长度为(meshWidth+1)*(meshHeight+1)*2的数组，它记录了扭曲后的位图各顶点位置。虽然它是一个数组，实际上它记录的数据是形如(x0, y0)、(x1, y1)、(x2, y2)、格式的数据，这些数组元素控制对bitmap位图的扭曲效果 verOffset:控制verts数组中从第几个数组元素开始才对bitmap进行扭曲 前面介绍Paint时提到其包含了一个setShader(Shader)方法，该方法控制画笔的渲染效果，Shader本身是一个抽象类，它提供了如下实现类：BitmapShader(位图平铺)/LinearGradient(线性渐变)/RadialGradient(圆形渐变)/SweepGradient(角度渐变)/ComposeGradient(组合渲染) 7.4 逐帧动画逐帧(Frame)动画是最容易理解的动画，它要求开发者能把动画过程的每张静态图片都收集起来，然后由Android来控制依次显示这些静态图片，然后利用人眼视觉暂留的原理，给用户造成动画的错觉 定义逐帧动画的XML资源文件以元素作为根元素,该元素内可指定&lt;item…./&gt;子元素,并指定各个item的持续时间，将其设置为ImageView的background后,便可将item内的图片文件逐帧播放 Android完全支持在Java代码中创建逐帧动画，如果开发者喜欢，开发者完全可以先创建AnimationDrawable对象，然后调用addFrame(Drawable frame, int duration)向该动画中添加帧，每调用一次addFrame方法，就向&lt;animation-list…/&gt;元素中添加一个&lt;item…/&gt;子元素 7.5 补间动画Android除了支持逐帧动画之外，也提供了对补间动画(Tween)动画的支持，补间动画就是指开发者只需指定开始、结束关键帧，而动画变化的中间帧由系统计算并补齐 Android使用Animation代表抽象的动画类，它包括如下几个子类alphaAnimation/ScaleAnimation/TranslateAnimation/RotateAnimation，一旦为补间动画指定了3个必要信息，Android就会根据动画的开始帧、结束帧、动画持续时间计算出需要在中间补入多少帧，并计算所有补入帧的图形 Interpolator根据特定算法计算出整个动画所需要动态插入帧的密度和位置，简单的说，Interpolator负责控制动画的变化速度，这就使得基本的动画效果能以匀速、加速、减速、抛物线速度等各种速度变化 Android为Interpolator提供了如下几个实现类，分别用于实现不同动画的变化速度： LinearInterpolator：匀速改变 AccelerateInterpolator：动画开始较慢，然后加速 AccelerateDecelerateInterpolator：动画在开始和结束时慢，在中间的时候加速 CycleInterpolator：变化速度按正弦曲线改变 DecelerateInterpolator：动画开始比较快，然后减速 自定义补间动画并不难，需要继承Animation类，继承Animation时关键是要重写该抽象基类的applyTransformation(float interpolatedTime, Transform t)方法，该方法中的两个参数的说明如下： interpolatedTime：代表了动画的时间进行比例，不管动画实际的持续时间如何，当动画播放时，该参数总是自动从0变到1 Transformation：该参数代表了补间动画在不同时刻对图形或组件的变形程度 从上面的介绍可以看出，实际自定义动画的关键就在于重写applyTransformation方法时根据interpolatedTime时间来动态地计算动画对图片或视图的变形程度 7.6 使用SurfaceView实现动画虽然前面大量介绍了使用自定义View来进行绘图，但是绘图机制存在如下两个缺陷： View缺乏双缓冲机制，界面会出现闪烁 当程序需要更新View上的图像时，程序必须重绘View上显示的整张图片 SurfaceView运行在非UI线程中画图，即可自己启动一个线程来画图，不会导致UI卡顿 由于View存在上面两个缺陷，所以通过自定义View来实现绘图、尤其是游戏中的绘图时性能并不好。Android提供了一个SurfaceView来代替View，在实现游戏绘图方面，SurfaceView比View更加出色，因此一般推荐使用SurfaceView SurfaceView一般会与SurfaceHolder结合使用，SurfaceHolder用于向与之关联的SurfaceView上绘图，调用SurfaceView的getHolder()方法即可获取SurfaceView关联的SurfaceHolder。SurfaceHolder提供了如下方法来获取Canvas对象： Canvas lockCanvas():锁定整个SurfaceView对象，获取该Surface上的Canvas Canvas lockCanvas(Rect dirty):锁定SurfaceView上的Rect划分的区域，获取该Surface上的Canvas 当对同一个SurfaceView调用上面两个方法时，两个方法所返回的是同一个Canvas对象，但当程序调用第二个方法获取指定区域的Canvas时，SurfaceView将只对Rect所圈出来的区域进行更新，通过这种方式可以提高画面的更新速度。 当通过lockCanvas获取指定了SurfaceView上的Canvas之后，接下来程序就可以调用Canvas进行绘图了，Canvas绘图完成后通过如下方法来释放绘图、提交所绘制的图形unlockCanvasAndPost(canvas) 需要指出的是，当调用SurfaceHolder的unlockCanvasAndPost方法之后，该方法之前所绘制的图形还处于缓冲之中，下一次lockCanvas方法锁定的区域可能会遮挡它 可以为SurfaceHolder添加一个Callback实例，该Callback中定义了如下三个方法 void surfaceChanged(SurfaceHolder holder, int format, int width, int height) void surfaceCreated(SurfaceHolder holder) void surfaceDestroyed(SurfaceHolder holder) Android 的数据存储和IO8.1 使用SharedPreferencesSharedPreferences 保存的数据主要是类似于配置信息格式的数据，因此它保存的数据主要是简单类型的key-value对。SharedPreferences接口主要负责读取应用程序的Preferences数据，它提供了如下常用方法来访问SharedPreferences中的key-value对 boolean contains(String key):判断是否包含特定key的数据 abstract Map&lt;String, ?&gt; getAll():获取SharedPreference数据里全部的key-value对 boolean getXxx(String key, xxx defValue):获取数据里指定key对应的value，如果该key不存在，则返回默认值defValue SharedPreferences 接口本身没有提供写入数据的能力，而是通过SharedPreferences的内部接口，SharedPreferences调用edit()方法即可获取它所对应的Editor对象。Editor提供了如下方法来向SharedPreferences写入数据 SharedPreferences.Editor clear();清空SharedPreferences里所有数据 SharedPreferences.Editor putXxx(String key, xxx value);向SharedPreferences存入指定key对应的数据 SharedPreferences.Editor remove(String key);删除SharedPreferences里指定key对应的数据项 boolean commit();当Editor编辑完成后，调用该方法提交修改 SharedPreferences本身是一个接口，程序无法直接创建SharedPreferences实例，只能通过Context提供的getSharedPreferences(String name, int mode)方法来获取SharedPreferences实例，该方法的第二个参数可以指定如下几个值 Context.MODE_PRIVATE:指定该SharedPreferences数据只能被本应用程序读写Context.MODE_WORLD_READABLE:指定该SharedPreferences能被其他应用程序读，但不能写Context.MODE_WORLD_WRITEABLE:指定该SharedPreferences能被其他应用程序读、写 SharedPreferences数据总是保存在/data/data/&lt;package_name&gt;/shared_prefs目录下，SharedPreferences数据总是以XML格式保存。通过File Explorer面板的导出文件按钮将该XML文件导出到XML文档，打开该XML文档可以看到如下内容 &lt;?xml version=1.0 encoding=&apos;utf-8&apos; standalone=&apos;yes&apos; ?&gt; &lt;map&gt; &lt;int name=&quot;random&quot; value=&quot;2&quot;/&gt; &lt;string name=&quot;time&quot; value=&quot;2018年&quot;/&gt; &lt;/map&gt; 要读、写其他应用的SharedPreferences，前提是创建该SharedPreferences的应用程序指定相应的访问权限，例如指定了MODE_WORLD_READABLE，然后按照如下步骤进行： 需要创建其他应用程序对应的Context context = createPackageContext(&quot;org.crazyit.io&quot;, Context.CONTEXT_IGNORE_SECURITY) 调用其他应用程序的Context的getSharedPreferences(String name, int mode)获取相应的SharedPreferences对象 如果需要获取数据，直接getXxx(String key, xxx defValue)，如果需要写入数据，则调用SharedPreferences的edit方法 事实上，如果开发者不通过先获取其他应用程序的Context，再获取SharedPreferences的方式也可以读取SharedPreferences的数据，开发者完全可以使用以IO流的方式先读取SharedPreferences对应的XML文件，再通过XML解析来获取数据也是可行的，只是这种方式过于繁琐，而使用SharedPreferences来读取数据则简单的多 8.2 File存储读者学习JavaSE的时候都知道Java提供了一套完整的IO流体系，包括FileInputStream、FileOutputStream等，通过这些IO流可以非常方便地访问磁盘上的内容文件。Android同样支持以这种方式来访问手机存储器上的文件 本应用程序的数据文件夹总是保存在/data/data/&lt;package_name&gt;/files目录下，Context提供了如下两个方法来打开本应用程序的数据文件夹里的文件IO流 FileInputStream openFileInput(String name):打开应用程序的数据文件夹下的name文件对应输入流 FileOutputStream openFileOutput(String name, int mode):打开应用程序的数据文件夹下name文件对应输出流 上面两个方法分别用于打开文件输入流、输出流，其中第二个方法的第二个参数指定打开文件的模式，该模式支持如下值： MODE_PRIVATE:该文件只能被当前程序读写 MODE_APPEND:以追加方式打开该文件，应用程序可以向该文件中追加内容 MODE_WORLD_READABLE:该文件的内容可以被其他程序读取 MODE_WORLD_WRITEABLE:该文件的内容可以被其他程序读、写 除此之外，Context还提供了如下几个方法来访问应用程序的数据文件夹 getDir(String name, int mode):在应用程序的数据文件夹下获取或创建name对应的子目录 File getFilesDir():获取该应用程序的数据文件夹的绝对路径 String[] fileList():获取该应用程序的数据文件夹下的全部文件 deleteFile(String name):删除该应用程序的数据文件夹下的指定文件 当程序通过Context的openFileInput或openFileOutput来打开文件输入流、输出流时，程序所打开的都是应用程序的数据文件夹里的文件，这样存储的文件大小可能比较有限一点，毕竟手机内置的存储空间都是有限的。为了更好地存、取应用程序的大文件数据，应用程序需要读、写SD卡上的文件。SD卡大大扩充手机的存储能力。读、写SD卡上的文件请按照如下步骤进行： 调用Environment的getExternalStorageState()方法判断手机上是否插入了SD卡，并且应用程序具有读写SD卡的权限Environment.getExternalStorageState().equals(Environment.MEDIA_MOUTED) 调用Environment的getExternalStorageDirectory()方法来获取外部的存储器，也就是SD卡的目录 使用FileInputStream、FileOutputStream、FileReader或FileWriter读写SD卡里的文件 应用程序读、写SD卡的文件有如下两个注意点： 手机上应该已插入SD卡，对应模拟器来说，可通过mksdcard命令来创建虚拟存储卡 为了读、写SD卡上的数据，必须在应用程序的清单文件(AndroidManifest.xml)中添加读、写SD卡的权限&lt;use-permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot;&gt; &lt;use-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;&gt; 8.3 SQLite数据库Android系统集成了一个轻量级的数据库：SQLite，SQLite并不想成为像Oracle、MySQL那样的专业数据库。SQLite只是一个嵌入式的数据库引擎，专门适用于资源有限的设备上适量数据存取。虽然SQLite支持绝大部分SQL 92语法，也允许开发者使用SQL语句操作数据库的数据，但SQLite并不像Oracle、MySQL数据库那样需要安装、启动服务器进程、SQLite数据库只是一个文件 Android提供了SQLiteDatabase代表一个数据库(底层就是一个数据库文件)，一旦应用程序获得了代表指定数据库的SQLiteDatabase对象，接下来就可通过SQLiteDatabase对象来管理操作数据库了，SQLiteDatabase提供了如下静态方法来打开一个文件对应的数据库 static SQLiteDatabase openDatabase(String path, SQLiteDatabase.CursorFactory factory, int flags) static SQLiteDatabase openOrCreateDatabase(File file, SQLiteDatabase.CursorFactory factory) static SQLiteDatabase openOrCreateDatabase(String path, SQLiteDatabase.CursorFactory factory) 在程序中获取SQLiteDatabase对象之后，接下来就可以调用SQLiteDatabase的如下方法来操作数据库了execSQL/insert/update/delete/query/rawQuery/beginTransaction/endTransaction 查询数据的方法都是返回一个Cursor对象，Android中的Cursor类似于JDBC的ResultSet，同样提供了一些方法来移动查询结果的记录指针move/moveToFirst/moveToLast/moveToNext/moveToPosition/moveToPrevious，一旦将记录指针移动到指定行之后，接下来就可以调用Cursor的getXxx()方法获得该行的指定列的数据 总结起来，使用SQLiteDatabase进行数据库操作的步骤如下 获取SQLiteDatabase对象，它代表了与数据库的连接 调用SQLiteDatabase的方法来执行SQL语句 操作SQL语句的执行结果，比如遍历查询结果 Cursor 关闭SQLiteDatabase，回收资源 在Android SDK的tools目录下提供了一个sqlite3.exe工具，它是一个简单的SQLite数据库管理工具，类似于MySQL提供的命令行窗口，有些时候，开发者利用该工具来查询、管理数据库 sqlite3 f:/my.db3 最先指定操作哪个数据库 .databases: 查看当前数据库的信息 .tables: 查看当前数据库中的数据表 .help:查看sqlite3支持的命令 需要指出的是，SQLite内部只支持NULL、Integer、REAL(浮点数)、TEXT(文本)、和BLOB(大二进制对象)这五种数据类型，但它允许把各种类型的数据保存到任何类型字段中，开发者可以不用关心声明该字段所使用的数据类型。 如果开发者对于SQL语法不熟悉，甚至以前从未使用过任何数据库，Android的SQLiteDatabase提供了insert、update、delete或者query语句来操作数据库，具体的介绍见书本 SQLiteDatabase中包含如下两个方法来控制事务 beginTransaction(): endTransaction(): 除此之外，SQLiteDatabase还提供了如下方法来判断当前上下文是否处于事务环境中 inTransaction(): 当程序执行endTransaction()方法时将会结束事务—那到底是提交事务呢，还是回滚事务呢，这取决于SQLiteDatabase是否调用了setTransactionSuccessful()方法来设置事务标志，如果设置了，则提交事务，否则程序将会回滚事务。 SQLiteOpenHelper是Android提供的一个管理数据库的工具类，可用于管理数据库的创建和版本更新。一般的用法是创建SQLiteOpenHelper的子类，并扩展它的onCreate(SQLiteDatabase db)和onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)方法 SQLiteOpenHelper包含如下常用的方法： Constructor SQLiteOpenHelper(Context context, String name, int version):SQLiteOpenHelper的构造函数 synchronized SQLiteDatabase getReadableDatabase():以读、写的方式打开数据库对应的SQLiteDatabase对象 synchronized SQLiteDatabase getWritableDatabase():以写的方式打开数据库对应的SQLiteDatabase对象 abstract void onCreate(SQLiteDatabase db):当第一次创建数据库时回调该方法 abstract void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion):当数据库版本更新时回调该方法 synchronized void close():关闭所有打开的SQLiteDatabase 8.4 手势(Gesture)Android手势行为分为两种： 第一种手势是系统默认手势行为，Android为其提供了相应的监听器 第二种手势是系统没有的手势，Android允许开发者添加手势，并提供相应的API识别用户手势 Android为手势检测提供了一个GestureDetector类，GestureDetector实例代表了一个手势检测器，创建GestureDetector时需要传入一个GestureDetector.OnGestureListener实例，GestureDetector.OnGestureListener就是一个监听器，负责对用户的手势行为提供响应 GestureDetector.OnGestureListener里包含的事件处理方法如下： boolean onDown(MotionEvent e):当触碰事件按下时触发该方法 boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY)：当用户在触摸屏上“拖过”时触发该方法，其中velocityX、velocityY分别表示动作的速度 abstract void onLongPress(MotionEvent e)：当用户在屏幕上长按时触发该方法 boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY)：当用户在屏幕上“滚动”时触发该方法 void onShowPress(MotionEvent e)：当用户在触摸屏上按下、而且还未移动和松开时触发该方法 boolean onSingleTapUp(MotionEvent e)：当用户在触摸屏上的轻击事件将会触发该方法 使用Android的手势检测只需要两个步骤： 创建一个GestureDetector对象，创建该对象必须实现一个GestureDetector.OnGestureListener监听器实例 为应用程序的Activity(偶尔也可为特定组件)的TouchEvent事件绑定监听器，在事件处理中指定把Activity(或特定组件)上的TouchEvent事件就会交给GestureDetector处理，而GestureDetector就会检测是否触发了特定的手势动作 public class GestureDetectorTest extends Activity implements OnGestureListener { private GestureDetector detector; public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); detector = new GestureDetector(this); } public boolean onTouchEvent(MotionEvent e) { return detector.onTouchEvent(e); } public boolean onDown(MotionEvent e) {} ... } Android除了提供了手势检测以外，还允许应用程序把用户手势（多个持续的触摸事件在屏幕上形成特定形状）添加到指定文件中，以备以后使用，如果程序需要，当用户下次再次画出该手势时，系统将可识别该手势。Android使用GestureLibrary来代表手势库，并提供了GestureLibraries工具类来创建手势库，GestureLibraries提供了如下4个静态方法从不同位置加载手势库 static GestureLibrary fromFile(String path): static GestureLibrary fromFile(File path): static GestureLibrary fromPrivateFile(Context context, String name): static GestureLibrary fromRawResource(Context context, int resourceId) 一旦在程序中获得了GestureLibrary对象之后，该对象提供了如下方法来添加手势、识别手势 void addGesture(String entryName, Gesture gesture): Set getGestures(String entryName): ArrayList getGestures(String entryName): ArrayList recognize(Gesture gesture): void removeEntry(String entryName): void removeGesture(String entryName, Gesture gesture): boolean save(): GestureLibrary提供了recognize(Gesture gesture)方法来识别手势，该方法会返回该手势库中所有与ges匹配的手势，它的返回值为ArrayList，其中Prediction封装了手势的匹配信息，Prediction对象的name属性代表了匹配的手势名，score属性代表了手势的相似度。 &lt;android.getsture.GestureOverlayView android:id=&quot;@+id/gesture&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:gestureStrokeType=&quot;multiple&quot; /&gt;//该参数控制手势是否需要多笔完成 public class AddGesture extends Activity { private EditText editText; private GestureOverlayView gestureView; public void onCreate(Bundle savedInstanceState) { //super...bindView... //保存Gesture gestureView.addGesturePerformedListener( new OnGesturePerformedListener() { @override public void onGesturePerformed(GestureOverlayView overlay, final Gesture gesture) { GestureLibrary gestureLib = GestureLibraries.fromFile(&quot;/mnt/sdcard/geture&quot;); gestureLib.addGesture(editText.getText().toString(), gesture); gestureLib.save(); } } ); //识别Gesture GestureLibrary gestureLib = GestureLibraries.fromFile(&quot;/mnt/sdcard/geture&quot;); gestureLib.load(); gestureView.addGesturePerformedListener( new OnGesturePerformedListener() { @override public void onGesturePerformed(GestureOverlayView overlay, final Gesture gesture) { ArrayList&lt;Prediction&gt; predictions = gestureLibrary.recognize(gesture); for (Prediction pred : predictions) { if (pred.score &gt; 2.0) { print(&quot;此 pred 满足要求&quot;); } } } } ); } } 自动朗读TTSAndroid提供了自动朗读支持。自动朗读支持可以对指定文本内容进行朗读，从而发出声音；不仅如此，Android的自动朗读支持还允许把文本对应的音频录制成音频文件，方便以后播放。这种自动朗读支持的英文名称为TextToSpeech，简称TTS。Android的自动朗读支持主要通过TextToSpeech来完成，该类提供了如下一个构造器： TextToSpeech(Context context, TextToSpeech.OnInitListener listener) public class Speech extends Activity { TextToSpeech tts; public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); tts = new TextToSpeech(this, new OnInitListener( @override public void onInit(int status) { if (status == TextToSpeech.SUCCESS) { int reslut = tts.setLanguage(Locale.US); if (result != TextToSpeech.LANG_COUNTRY_AVAILABLE &amp;&amp; reslut != TextToSpeech.LANG_AVAILABLE) { print(&quot;TTS暂时不支持这种语言的朗读&quot;); } } } )); button1.onclick( //播放转换的音频，参数TextToSpeech.QUEUE_ADD表示添加到发音任务队列，还有一个值TextToSpeech.QUEUE_FLUSH则表示会中断当前的发音任务队列 tts.speak(editText.getText.toString(), TextToSpeech.QUEUE_ADD, null); ); button2.onclick( //保存转换的音频 tts.synthesizeToFile(editText.getText.toString(), null, &quot;/mnt/sdcard/sound.wav&quot;) ); } //最后关闭TTS，回收资源 public void onDestroy() { if (tts != null) { tts.shutdown(); tts = null; } } }]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[疯狂Android第一部分]]></title>
    <url>%2F2012%2F08%2F30%2F%E7%96%AF%E7%8B%82Android%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[Android应用与开发环境1.1 Android的发展和简介Android系统的底层建立在Linux系统之上，该平台由操作系统、中间件、用户界面和应用软件四层构成，它采用一种被称为软件叠层的方式进行构建。这种软件叠层结构使得层与层之间相互分离，明确各层的分工。更加具体的层叠构造内容请参考上一章的介绍。 1.2 搭建Android环境安装ADT后，在Android SDK的文件夹下主要有这么几个文件夹： add-ons：该目录下存放额外的附件软件 build-tools:该目录下存放每个版本编译apk时所需要的工具 platforms：该目录下存放不同版本的Android版本 tools：该目录存放了大量的Android开发调试工具 docs：该文件夹下存放了Android SDK开发文件的API文档等 platform-tools：该文件夹下存放了Android平台相关工具 samples：该文件夹下存放了不同Android平台的示例程序 1.3 Android常用开发工具的用法android命令位于tools目录下，如果配置了环境变量，就可以在命令行下直接输入android命令，常用的有： list: 列出机器上所有已经安装的Android版本和AVD设备 list avd: 列出机器上所有已经安装的AVD设备 list target: 列出机器上所有已经安装的Android版本 create/move/delete/update avd: 创建/移动/删除/升价一个AVD create/update project: 创建/升级一个Android项目 emulator命令位于tools目录下，如果配置了环境变量，就可以在命令行下直接输入emulator命令打开虚拟机，常用的有： -avd crazyit: 运行名称为crazyit的AVD设备 -data myfile: 以myfile作为镜像文件来运行AVD设备 DDMS是Android提供的一个非常强大的调试环境，它的全称是Dalvik Debug Monitor Service，DDMS命令位于tools目录下，如果配置了环境变量，就可以在命令行下直接输入ddms命令看到其强大的调试窗口Android Debug Bridge(ADB)是一个功能非常强大的工具，它位于Android SDK安装目录的platform-tools子目录下，ADB工具既可完成模拟器文件与电脑文件的相互复制，也可安装APK应用，甚至直接切换到Android系统中执行Linux命令。 adb -devices: 查看当前运行的模拟器 adb push d:/abc.txt /sdcard/ 电脑与模拟器之间的相互复制 adb pull /sdcard/xyz.txt d:/ 电脑与模拟器之间的相互复制 adb shell：Android平台的内核是基于Linux的，有时希望直接打开Android平台的shell窗口，这样就可以在该窗口执行一些常用的Linux命令，如ls，mkdir，rm等 adb install text.apk/adb uninstall com.frand.text 安装/卸载应用程序 Dalvik虚拟机并不直接运行java二进制文件，而是运行它特有的.dex文件，因此我们需要通过DX工具将Android应用中的.class文件转换为.dex文件，dx命令存放于build-tools文件夹下对应的平台文件夹下dx --dex [--dump-to=&lt;file&gt;] [--core-libraray] [&lt;file&gt;.class|&lt;file&gt;.{zip,jar,apk} | &lt;directory&gt;] [–dump-to=]指定生成的.dex文件的文件名 [–core-libraray]后是指定需要转换的.class .zip .jar文件或目录 使用Android Asset Packaging Tool(AAPT)打包资源aapt -A &lt;附件资源路径&gt; -S &lt;资源路径&gt; -M &lt;Android应用清单文件&gt; -I &lt;额外添加的包&gt; And -F &lt;目标文件的路径&gt; aapt -A assets -S res -M AndroidManifest.xml -I D:\android-sdk-windows\platforms\android-9\atforms\android-9\android.jar -F bin\res.ap_ 用apkBuilder打包资源res.ap_和dex文件组成*.apk文件 手动编译APK的流程如下： 生成资源文件：使用Android SDK提供的aapt.exe生成R.java类文件 编译本地库：使用Android SDK提供的aidl.exe把.aidl转成.java文件（如果没有aidl，则跳过这一步） 编译java代码：使用JDK提供的javac.exe编译.java类文件生成class文件 生成dex文件：使用Android SDK提供的dx.bat命令行脚本生成classes.dex文件 打包资源文件：使用Android SDK提供的aapt.exe生成资源包.ap_文件（包括res、assets、androidmanifest.xml等） 生成apk文件：使用Android SDK提供的apkbuilder.bat将.ap_文件与.dex文件合成生成未签名的apk安装文件 对apk文件进行签名：使用jdk的jarsigner.exe对未签名的包进行apk签名 1.4 开始第一个Android应用1.5 Android应用工程结构分析1.6 Android应用的基本组件介绍Activity是Android应用中负责与用户交互的组件，View组件是所有UI控件，容器控件的基类，View组件就是用户实实在在看到的部分。但是View组件需要放到容器组件中，或者使用Activity将它显示出来。 Service与Activity的地位是并列的，它也代表一个单独的Android组件。Service与Activity的区别在于：Service通常位于后台运行，它一般不需要与用户交互，因此Service组件没有图形用户界面。与Activity组件需要继承Activity基类相似，Service组件需要继承Service基类。一个Service组件被运行起来后，它将拥有独立的生命周期，Service组件通常用于为其他组件提供后台服务或监控其他组件的运行状态。 BroadcastReceiver是Android应用中另一个重要的组件，顾名思义，BroadcastReceiver代表广播消息接收器。从代码实现的角度来看，BroadcastReceiver非常类似编程中的监听器。与普通事件监听器不同的是：普通事件监听器监听的事件源是程序中的对象；而BroadcastReceiver监听的事件源是Android应用中的其他组件。 对于Android应用而言，它们必须相互独立，各自运行在自己的Dalvik虚拟机实例中，如果这些Android应用之间需要实现实时的数据交换，这时Android系统为其提供了一个标准：ContentProvider。 Intent是Android应用内不同组件之间通信的载体，它封装了当前组件需要启动或触发的目标组件信息。当一个组件通过Intent表示了启动或触发另一个组件的意图后，这个意图可分为两类 显式Intent：明确指定需要启动或者触发的组件的类名 隐式Intent：只是指定需要启动或者触发组件应满足怎样的条件 Android系统如何判断被调用组件是否满足隐式Intent呢，这就需要靠IntentFilter来实现了，被调用组件可通过IntentFilter来声明自己所满足的条件–也就是声明自己到底能处理哪些隐式Intent。 Android应用的界面编程2.1 界面编程与视图(View)组件Android界面组件分为视图组件与容器组件。可以用代码控制UI界面，也可以使用XML布局文件控制UI界面 2.2 布局管理器布局管理器包括： 线性布局LinearLayout 表格布局TableLayout 帧布局FrameLayout 相对布局RelativeLayout 绝对布局AbsoluteLayout 2.3 基本界面组件此章学习的基本界面组件包括： 文本框（TextView）与编辑框（EditText）的功能和用法 按钮（Button）与图片按钮（ImageButton）组件的功能和用法 单选按钮（RadioButton）和复选框（CheckBox）介绍与应用 状态开关按钮（ToggleButton）的功能与用法 模拟时钟和数字时钟（AnalogClock和DigitalClock）的功能和用法 图像视图（ImageView）的功能和用法 scaleType属性设置所显示的图片如何缩放或移动来适应ImageView的大小，其中包括了几个属性：matrix/fitXY/fitStart/fitCenter/fitEnd/center/centerCrop/centerInside 八个ScaleType，其实可以分为三个类型： 以FIT_开头的4种，它们的共同点是都会对图片进行缩放； 以CENTER_开头的3种，它们的共同点是居中显示，图片的中心点会与ImageView的中心点重叠； ScaleType.MATRIX，这种就直接翻到最后看内容吧； 2.4 高级界面组件 自动完成文本框（AutoCompleteTextView）的功能和用法 下拉框（Spinner）的功能和用法 日期、时间选择器（DatePicker和TimePicker）的功能和用法 进度条（ProgressBar）的功能和用法 拖动条（seekBar）的功能和用法 星级评分条（RatingBar）的功能和用法 选项卡（TabHost）的功能和用法 滚动视图（ScrollView）的功能和用法 列表视图（ListView和ListActivity） 可展开的列表组件（ExpandableListView） 网格视图（GridView）和图像切换器（ImageSwitcher） 画廊视图（Gallery）的功能和用法 2.5 对话框Android提供了丰富的对话框支持，它提供了如下4种常用的对话框： AlertDialog ProgressDialog DatePickerDialog TimePickerDialog PopupWindow 2.6 消息提示 使用Toast显示提示信息框 Notification的功能与用法 2.7 菜单 选项菜单和子菜单 使用监听器来监听菜单事件 创建复选框菜单和单选菜单项 设置与菜单项关联的Activity 上下文菜单 事件处理3.1 Android的事件处理Android提供了强大的事件处理机制，包括两套事件处理机制： 基于监听的事件处理机制 基于回调的事件处理机制 3.2 基于监听的事件处理机制在事件监听的处理模型中，主要涉及如下三类对象： Event Source(事件源)：事件发生的场所，如按钮，窗口等 Event(事件)：事件封装了界面组件上发生的特定事情 Event Listener(事件监听器)：负责监听事件源所发生的事件，并对事件做出相应的相应 Android的事件处理机制是一种委派式(Delegation)事件处理方式：普通组件(事件源)将整个事件处理委托给特定的对象(事件监听器)，当该事件源发生指定的事件时，就通知所委托的事件监听器，由事件监听器来处理这个事件 所谓的事件监听器，其实就是实现了特定接口的Java类的实例。在程序中实现事件监听器，通常有如下几种形式： 内部类形式 外部类形式 Activity本身作为事件监听器类 匿名内部类 直接绑定到标签(android:onClick=””) 3.3 基于回调的事件处理基于回调的事件处理机制要通过自定义View来实现，自定义View时重写该View的事件处理方法即可 对于基于监听的事件处理模型来说，事件源和事件监听器是分离的，当事件源上发生特定事件后，该事件交给事件监听器负责处理；对于基于回调的事件处理模型来说，事件源和监听器是统一的，当事件源发生特定事件之后，该事件还是由事件源本身负责 几乎所有基于回调的事件处理方法都有一个boolean类型的返回值，该返回值用于标识该处理方法是否能完全处理该事件： 如果处理事件的回调方法返回true，表明该处理方法已完全处理该事件，该事件不会传播出去 如果处理事件的回调方法返回false，表明该处理方法并未完全处理该事件，该事件会传播出去 当组件上触发一个事件时，Android系统最先触发的应该是该按键上绑定的事件监听器，接着才触发该组件提供的事件回调方法，然后还会传播到该组件所在的Activity—但是如果我们让任何一个事件处理方法返回了true，那么该事件将不会继续向外传播 对比Android提供的两种事件处理方式，不难发现基于监听的事件方式具有更大优势： 基于监听的事件模型分工更明确，事件源，事件监听由两个类分开实现，因此具有更好的可维护性 Android的事件处理机制保证基于监听的事件监听器会被优先触发 3.4 响应系统设置事件Configuration类专门用于描述手机设备上的配置信息，这些配置信息既包括用户特定的配置项，也包括系统的动态设备配置。Configuration cfg = getResources().getConfiguration(); 如果程序需要监听系统设置的更改，则可以考虑重写Activity的onConfigurationChanged(Configuration cgf)方法，该方法是一个基于回调的事件处理方法：当系统设置发生更改时，该方法会被自动触发。 3.5 Handler消息传递机制Android的消息传递机制是另一种形式的“事件处理”，这种机制主要是为了解决Android应用的多线程为题—Android平台不允许Activity新启动的线程访问该Activity里的界面组件，这样就会导致新启动的线程无法动态改变界面组件的属性值。Handler类的主要作用有两个： 在新启动的线程中发送消息 在主线程中获取，处理消息 深入理解ActivityActivity是Android应用的重要组成单位之一（另外三个是Service、BroadcastReceiver和ContentProvider），而Activity又是Android应用最常见的组件之一 4.1 建立、配置和使用Activity继承方式：Activity--ContextThemeWrapper--ContextWrapper--Context 配置方式：AndroidManifest中：&lt;activity android:name=&quot;.SampleActivity&quot;/&gt; 启动方式：startActivity(intent)/startActivityForResult(intent,requestCode) 关闭方式：finish()/finishActivity(requestCode) 传递数据：putExtras(Bundle data)/putXxx(String key, Xxx data)/putSerializable(String key, Serializable data) 4.2 Activity的回调机制对于Java的程序员来说，程序架构在某个点上留的空，可以以如下两种方式存在： 以接口形式存在：该接口由开发者实现，实现该接口时将会实现该接口的方法，那么通用的程序架构就会回调该方法来完成业务的相关处理 以抽象方法的形式存在：这就是Activity的实现形式 4.3 Activity的生命周期归纳起来Activity大致会经过如下4个状态： 活动状态 暂停状态 停止状态 销毁状态 在这四个状态之间进行切换的时候，如下方法会被系统回调： onCreate(Bundle savedStatus)/onStart()/onRestart()/onResume()/onPause()/onStop()/onDestroy() onRestart先于onStart调用]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发入门]]></title>
    <url>%2F2012%2F07%2F27%2FAndroid%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[做Android开发已有月余，今天将此前学到的东西整理一下，包括Android开发环境的简介、Android系统架构的详解、Android开发环境的搭建 Android开发环境Android开发环境从底层到上层分别有硬件层、操作体统、JAVA运行环境、开发工具和模拟器的安装 硬件首先，最底层到应该是硬件到部分，CPU，内存，主板，硬盘等。 cat /proc/cpuinfo :CPU用到的是Pentium(R) Dual-Core CPU E5200 @ 2.50GHz cat /proc/meminfo :内存到总大小MemTotal: 2041792 kB 操作系统然后往上层走就是操作系统了，操作系统用的是ubuntu操作系统，linux的一种 cat /proc/version:Linux version 3.2.0-26-generic (buildd@batsu) (gcc version 4.6.3 (Ubuntu/Linaro 4.6.3-1ubuntu5) ) #41-Ubuntu SMP Thu Jun 14 17:49:24 UTC 2012 Ubuntu 3.2.0-26.41-generic 3.2.19 cat /etc/issue :frandfeng@frandfeng-Founder-PC:~$ cat /etc/issue Ubuntu 12.04 LTS \n \l 从这里可以看出用到的ubuntu版本是12.04LTS。Ubuntu诞生于2012年4月26日，是第四个ubuntu长期支持版本，可以运用到2017年，LTS是指Long-Term Support，即长期支持版本。 linux系列中ubuntu操作系统只是其中一种，Ubuntu是一个以桌面应用为主的linux操作系统。Ubuntu基于Debian发行版和GNOME桌面环境，与Debian的不同在于它每6个月会发布一个新版本。Ubuntu的目标在于为一般用户提供一个最新的、同时又相当稳定的主要由自由软件构建而成的操作系统。GNOME即GNU网络对象模型环境 (The GNU Network Object Model Environment)，GNU计划的一部分，开放源码运动的一个重要组成部分。是一种让使用者容易操作和设定电脑环境的工具。 当然，linux系列中到操作系统不仅Ubuntu，还有Debian、RedHat、Slackware等。 JAVA运行环境操作系统装好了之后就应该装JAVA运行环境了，即JDK的安装，JDK(Java Development Kit)是Sun Microsystems针对Java开发员的产品。自从Java推出以来，JDK已经成为使用最广泛的Java SDK。JDK 是整个Java的核心，包括了Java运行环境，Java工具和Java基础的类库，我们装到JDK是Java SE1.6，即Java standard edition，标准版，还有Java EE，enterprise edition，企业版和Java ME，micro edition，主要用于移动设备、嵌入式设备上的java应用程序。 开发工具JAVA运行环境下来就应该再装基于JAVA的IDE了，即Eclipse，IDE(Integrated Development Environment,集成开发环境)。IDE集成开发环境（简称IDE）软件是用于程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形工具界面工具。该程序可以独立运行，也可以和其它程序并用Eclipse 是一个开放源代码的、基于Java的可扩展开发平台。就其本身而言，它只是一个框架和一组服务，用于通过插件组件构建开发环境。幸运的是，Eclipse 附带了一个标准的插件集，包括Java开发工具（Java Development Kit，JDK）。 虽然大多数用户很乐于将 Eclipse 当作 Java 集成开发环境（IDE）来使用，但 Eclipse 的目标却不仅限于此。Eclipse 还包括插件开发环境（Plug-in Development Environment，PDE），这个组件主要针对希望扩展 Eclipse 的软件开发人员，因为它允许他们构建与 Eclipse 环境无缝集成的工具。 Eclipse的设计思想是：一切皆插件。Eclipse核心很小，其它所有功能都以插件的形式附加于Eclipse核心之上。Eclipse基本内核包括：图形API (SWT/Jface)， Java开发环境插件(JDT )，插件开发环境(PDE)等。 我们装到Eclipse版本是Version: Juno Release版的，除过这个版本，还有Eclipse Indigo -&gt;3.7/Eclipse Helios -&gt;3.6/Eclipse Galileo -&gt;3.5/Eclipse Ganymede -&gt;3.4/Eclipse Europa -&gt;3.3。 IDE装好了JAVA的库和运行环境到此结束，开始装有关Android的开发工具和Android运行环境了。 Android模拟器首先装Android运行环境，为了开发android应用，还必须添加一个android操作系统，用于模拟器模拟你的应用程序。当然还有一些其他部件需要安装。其实就是通过SDK 工具包中的Android SDK and AVD Manager来完成。Android SDK 指的既是Android专属的软件开发工具包。AVD的全称为：Android Virtual Device，就是Android运行的虚拟设备，他是Android的模拟器识别。建立的Android要运行，必须创建AVD，每个AVD上可以配置很多的运行项目。我们常用到的AVD版本有1.6/2.2/4.0/4.1. 然后就是Android的开发工具安装了。这个开发工具主要靠Eclipse中到ADT（Android Development Tools）来管理，下载ADT Plugin，Eclipse会自动进行配置和更新。 到此为止，所有到框架都搭建完成。然后就可以进行基于Android平台的开发了。 Android系统架构Android系统架构从底层到上层共分为四层，每一层都是将底层实现封装，留一些接口供上层调用。架构如图所示： Linux Kernel由上图中可以看出，Android系统最底层是LINUX KERNEL,即linux内核，他是硬件与软件之间的抽象层，包括显示驱动，相机驱动，内存驱动，进程通讯驱动，键盘驱动，wifi启动，多媒体驱动和电源驱动等。 Libraries And Android Runtime中间件包括两部分：函数库和运行时(libraries &amp; Android runtime) 函数库包括 SurfaceManager 显示系统管理库，负责把2D或3D内容显示到屏幕的库； Media Framework 媒体库，负责支持图像，支持多种视频和音频的录制和回放； SQlite 数据库，一个功能强大的轻量级嵌入式关系数据库； OpenGL ES(open graphic libaray for embed system),针对嵌入式系统的开放式图形库，主要负责三维图形的显示 FreeType库,一个完全免费(开源)的、高质量的且可移植的字体引擎，它提供统一的接口来访问多种字体格式文件 WebKit 浏览器引擎 SGL，SSL，“Secure Sockets Layer”安全套阶层，还有一些基本的C库等。 Android 运行时由两部分组成:Android核心库和Dalvik虚拟机.其中核心库提供了Java语言核心库所能使用的绝大部分功能,而虚拟机则负责运行Android运行程序. 此处的ARE和JRE有点类似.JRE包括JVM和其他功能函数库,而此处的Android运行时则包括Dalvik虚拟机和核心库集. 由于Android应用程序的编程语言是Java,因此有些人会把Dalvik虚拟机和JVM搞混,但实际上Dalvik并未遵守JVM规范,两者也不兼容.实际上,JVM虚拟机运行的是Java字节码(通常就是.class文件),但Dalvik运行的是其专有的dex(Dalvik Executable)文件.JVM直接从.class文件或JAR包中加载字节码然后运行;而Dalvik则无法直接从.class文件或jar包中加载字节码,它需要通过DX工具将应用程序的所有.class文件编译成.dex文件,Dalvik运行该.dex文件.还有一点,Dalvik虚拟机中,每一个Android 应用程序都在它自己的进程中运行，都有一个属于自己的Dalvik 虚拟机，这一点可以让系统在运行时可以达到优化，程序间的影响大大降低。 Dalvik虚拟机非常适合在移动端上使用,相对于在PC或服务器上运行的虚拟机而言,Dalvik虚拟机不需要很快的CPU计算速度和大量的内存空间,它主要有两个特点 运行专有的.dex文件.专有的.dex文件减少了.class文件中的冗余信息,而且会把所有的.class文件整合到一个文件中,从而提高运行性能;而且DX工具还会对.dex文件进行一些性能的优化. 基于寄存器实现.大多数虚拟机包括JVM都是基于栈的,而Dalvik虚拟机则是基于寄存器的.一般来说,基于寄存器的虚拟机具有更好的性能表现,但在硬件通用性上略差. 应用程序框架(Application Framework) 丰富而又可扩展性的视图（Views），可以用来构建应用程序， 它包括列表（lists），网格（grids）， 文本框（text boxes），按钮（ buttons）， 可嵌入的web 浏览器。 内容提供者（Content Providers）使得应用程序可以访问另一个应用程序的数据（如联系人数据库）， 或者共享它们自己的数据。 资源管理器（Resource Manager）提供非代码资源的访问，如本地字符串，图形，和布局文件（ layoutfiles ）。 通知管理器（Notification Manager） 使得应用程序可以在状态栏中显示自定义的提示信息。 活动管理器（ Activity Manager） 用来管理应用程序生命周期并提供常用的导航回退功能。 应用程序 (Applications)Android 系统会内置一些应用程序包包括email 客户端，SMS 短消息程序，日历，地图，浏览器，联系人管理程序等。所有的应用程序都是使用JAVA 语言编写的。，还可以使用自己的程序或者在网上下载到的程序。 Android开发环境的搭建Android开发环境的搭建包括安装JDK、安装eclipse、下载安装Android SDK Starter Package、安装ADT（Android Development Tools）插件、配置ADT插件(将ADT用来管理Android SDK Starter Package)、添加Android操作系统和部件，最后写一个Hello World。 安装JDKJDK(Java Development Kit)是Sun Microsystems针对Java开发员的产品。自从Java推出以来，JDK已经成为使用最广泛的Java SDK。JDK 是整个Java的核心，包括了Java运行环境，Java工具和Java基础的类库。JDK是学好Java的第一步。 首先到oracle的官网上下载linux版本的JDK。 下载回来之后，当然是直接运行安装即可.先把这个文件cp到你的安装目录下，然后在你的安装目录直接执行：./jdk-6u33-linux-i586.bin(当然如果执行失败是因为没有执行权限，那么还需要加上执行权限：chmod +x ./jdk-6u26-linux-i586.bin) 安装程序会自动给你安装到当前目录的jdk1.6.0_26目录下。 程序安装好了，接着需要设置环境变量。 执行： sudo gedit /etc/profile 在配置文件中加入如下部分： export JAVA_HOME=/home/jackwong/jdk1.6.0_26 export JRE_HOME=/home/jackwong/jdk1.6.0_26/jre export PATH=/home/jackwong/jdk1.6.0_26/bin:$PATH export CLASSPATH=.:/home/jackwong/jdk1.6.0_26/lib:/home/jackwong/jdk1.6.0_26/jre/lib 保存，然后注销当前用户，重新登录，环境变量就生效了。 验证是否安装成功： 执行： java -version 如果出现: java version “1.6.0_26”Java(TM) SE Runtime Environment (build 1.6.0_26-b06)Java HotSpot(TM) Server VM (build 20.0-b11, mixed mode) 这样的信息，就说明OK了。 注意，ubuntu默认已经安装了openjdk，所以你就算不安装jdk，执行java -version也不会报错，但是报告的信息和安装了jdk是不一样的，请注意区分。 安装eclipseEclipse 是一个开放源代码的、基于Java的可扩展开发平台。就其本身而言，它只是一个框架和一组服务，用于通过插件组件构建开发环境。幸运的是，Eclipse 附带了一个标准的插件集，包括Java开发工具（Java Development Kit，JDK）。 Eclipse的设计思想是：一切皆插件。Eclipse核心很小，其它所有功能都以插件的形式附加于Eclipse核心之上。Eclipse基本内核包括：图形API (SWT/Jface)， Java开发环境插件(JDT )，插件开发环境(PDE)等。 Eclipse IDE for Java Developers下载，解压：tar zvxf eclipse-java-helios-SR1-linux-gtk.tar.gz 下载安装Android SDK Starter Package针对Android平台到软件开发包，里边有各种类，各种插件，还有Android到模拟器。 Android SDK Starter Package这个只是SDK的核心基本工具，有了它，再利用它的管理工具下载其他你需要到部分。看到这个目录中有个android脚本文件了吗？执行它，就会启动Android SDK and AVD Manager,这个工具可以帮你下载其他你需要的部分，还可以创建模拟机。 下载地址是：http://developer.android.com/sdk/index.html 下载下来到文件是：android-sdk_r11-linux_x86.tgz，大约26M。 接下来当然是解包了：tar zvxf android-sdk_r11-linux_x86.tgz 解包完毕，就会在当前目录下出现android-sdk-linux_x86目录了。这个目录下就是sdk的基本工具了。记住这个目录，因为以后你运行工具或者设置ADT的时候，会需要这个目录的！ 安装ADT（AndroidDevelopment Tools）插件目前Android开发所用的开发工具是Eclipse，在Eclipse编译IDE环境中，安装ADT，为Android开发提供开发工具的升级或者变更，简单理解为在Eclipse下开发工具的升级下载工具。 启动 Eclipse, 然后选择 Help&gt; Install NewSoftware…. 单击右上角的Add按钮 在弹出的 Add Repository 对话框中，Name一栏目填写 “ADT Plugin”,在Location一栏就有两个选择，一个是填入下载网址：https://dl-ssl.google.com/android/eclipse/，这样就可以网上下载安装。第二个选择是如果我已经下载了ADT Plugin，那么就单击旁边的Archive按钮，直接找到插件所在到包即可，比如我用的就是第二种，我已经下载下来了，文件名是ADT-11.0.0.zip,5.3M。不管那一种，最后选择OK，即可。 然后在下面的软件列表中，把Developer SDK Tools前面的checkbox选上，然后单击下面的next按钮，然后就等着安装进度条完成吧，其中会出现安装软件的列表，你单击Next即可，然后会出现license,你必须选择agree才行，然后单击finish就完成了（当然其中有个下载过程，可能需要花费一点时间)。安装完成之后，重启eclipse即可 配置ADT 插件配置的内容就是要修改在eclipse中到ADT插件的引用指向，需要指向前面安装好的Android SDK目录，还记得这个目录吗？ 启动eclipse,选择Window&gt; Preferences.. 在弹出的Preferences对话框中左边选择Android标签，右边SDK location选择你当初Android SDK的目录即可。比如我到目录是：/home/jackwong/android-sdk-linux_x86，然后单击apply,再单击ok即可。 在这个过程中会弹出一个对话框问你是否要参加google的满意度调查报告。你可以选择参加还是不参加。单击process按钮即可。 安装好之后，你可以常用Help&gt; Check for Updates选项来保持ADT保持最新。 添加Android操作系统和部件到目前为止，基本配置都差不多了，但是为了开发android应用，还必须添加一个android操作系统，用于模拟器模拟你的应用程序。当然还有一些其他部件需要安装。其实就是通过SDK 工具包中的Android SDK and AVD Manager来完成。当然在eclipse中可以直接启动这个程序：Window &gt; Android SDK and AVD Manager. 当然也可以直接运行sdk目录下的tools目录下的android脚本来启动。 推荐的部件一般是： SDK Tools，这个你安装了sdk starter package实际上已经装好了。 SDK Platform-tools，这个要装。 SDK platform，这个至少需要一个。也就是操作系统，你可以下载多个，比如2.2，3.1你可以都下载，但是至少必须一个，因为模拟器运行的时候是必须要的。所以，如果你想各种平台都模拟测试一下，那么你就需要各种版本的android都下载一个。 我下载了SDK Platform-tools 5和Android 3.1，Android Compatibility Package三个包。 下载完成之后，Android的开发环境就搭建好了。 写一个hello,android测试程序试试验证成果的时候到了，启动eclipse,选择File-&gt;New-&gt;Project… 然后选择Android下的Android project, 然后填写下面的信息： project name:HelloAndroid 这是项目名称,也就是包含文件的目录名称 Application name:Hello,Android 这是应用程序名字,也是程序运行的时候显示在屏幕上方的文字 Package Name：my.android 这个不用解释，学过java的都应该知道，这是类的包名 Create Activity：helloandroidactivity 这是activity的名字，android程序要显示都是以activity来启动的，也就是一个activity子类的名字 其他可以不用改动，就用默认值，然后单击Finish就完成了项目的创建。 进入项目，打开helloandroidactivity.java文件， 把里面的onCreate方法的代码更新如下： import android.widget.TextView; public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); TextView tv = new TextView(this); tv.setText(&quot;Hello, Android!=你好,安卓！&quot;); setContentView(tv); } 保存，准备运行。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大四毕业有感]]></title>
    <url>%2F2012%2F06%2F22%2F%E5%A4%A7%E5%9B%9B%E6%AF%95%E4%B8%9A%E6%9C%89%E6%84%9F%2F</url>
    <content type="text"><![CDATA[这些天忙着写毕业设计，一直没发博。。。 转眼间，都大四要毕业了，今天毕业倒计时了 回想大一时光，那时候学校还在南充，记得一个人去南充，坐汽车，转火车，再转火车，又转汽车，辗转来到南充校区，然后就在那里开始了我人生中前两年的大学时光。现在想起来，那时候才是一个真正上进的好学生，每天早上坚持上早读，坚持上课，然后吃午饭，吃完午饭午睡一觉，下午有课就去上课，没课就去上自习。那时候坚持每天写作业，积极参加一些素质拓展，社团活动，还参加了青志协和学宣部的面试什么的，但是说起面试，我面试好像都没有怎么成功过，可能是与人交流不咋地吧。所以就好好练习说话，练口才，整天进图书馆看各方面的书。但是效果不怎么样，脸皮太薄太追求完美可能就是我失败的原因吧，那时候整天想着如何出人头地，如何做个成功人士，如何改变我在别人心目中的形象之类的。 大二的时候，参加了勤工助学，有幸认识了一个同级的小女生，一直想追，不过等到有关她的消息打探清楚后，才知道她是有男朋友的，所以YY便成了我每天的必修课，好像从那时候起，我便学会了YY，整天在YY，YY着她分手了，YY着我和她在一起了，YY着把她带我家去了，从那以后，我便深深喜欢上了YY，干什么事情都要首先YY一番，满足一下我的虚荣心，然后再拿现实做比较，真是惨不忍睹，事情过去之后再YY当时应该怎么做，就这样，大二的时光被我YY完了。 转眼大三了，学校搬到成都了，一下子感觉自己老了许多，当一名老师在台上激情的讲如何创业，做一名成功人士等等的时候，我完全感到自己的心已经老了，没有精力去听这些东西，没有心情听这些东西，要知道如果是两年前刚入校的我是肯定不会错过这次机会的，而现在的我呢，满不在乎，I don’t care。而那时候我care的是什么东西呢，我care的是奖学金，是钱，是班长，是权，是证书，是荣誉。还清楚的记得我为了拿奖学金，如何半夜11点多都还在背什么是影像图，什么是元数据，为了当上班长，如何拉票，如何请他们吃饭，为了证书，如何花掉自己很多时间去学习，如何连暑假都不回家，每天早上7点起的奋斗。 大四了，开始出去实习了，先去川师，然后去北师，最后又回到成都，辗转多处，大公司小公司去了不少，却没有几家合适的，当时脑子里想的都是工资、努力和前程。其他的什么东西都是浮云，就连一次导员通知我去领全国大学生英语竞赛的证书和奖品，我都没去，因为在我大四的眼界里，钱是最好的东西。每天坚持上班，不到迫不得已，绝不请假，学校也没回几次，就这样忙碌忙碌，终于，现在的我，才坚持了半年时间就疲了，这是我真正追求的东西吗，我的一生难道就只是在给钱做奴隶么。。。现在的我，快想通了，钱不是我唯一的追求，努力也不是成功的唯一要素。 现在要毕业了，回想大学四年间所追求的东西。。。 大一的被人认同感，大二的YY感，大三的权钱欲，好像都是有一种无形的虚荣心在作怪，它好像是我奋斗的动力，也是我变态心态的根源。大四了，好像对什么都毫不在乎了，好像觉得什么都是浮云，于是破罐子破摔，什么也不顾忌，于是发现这也是一种生活态度，只不过没有什么可追求的东西而已，除了钱，但是钱赚了，太低调又有谁能知道呢，没有对你肯定，太高调，惹来嫉妒，也没人给你肯定。。。 人生到底追求的是什么东西呢，星云大师说过，人之所以痛苦，是因为在追求错误的东西，也就是说，如果我们追求的是对的东西，我们就会感觉到快乐，可是，追求了这么多之后，我怎么没快乐过呢。。。]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法]]></title>
    <url>%2F2012%2F05%2F25%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(%E6%9C%AA%E5%AE%8C%E6%88%90)%2F</url>
    <content type="text"><![CDATA[树和二叉树]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构第二部分]]></title>
    <url>%2F2012%2F04%2F27%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86(%E6%9C%AA%E5%AE%8C%E6%88%90)%2F</url>
    <content type="text"><![CDATA[树和二叉树]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构第一部分]]></title>
    <url>%2F2012%2F03%2F30%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[绪论 数据(data)：是对客观事物的符号表示，在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称。 数据元素(data element)：是数据的基本单位，在计算机程序中经常作为一个整体进行考虑和处理。 数据对象(data object)：是性质相同的数据元素的集合，是数据的一个子集。 数据结构(data structure)：是相互之间存在一种或多种特定关系的数据元素的集合。 结构(structure)：数据源是都不是孤立存在的，而是它们之间存在着某种关系，这种关系就是结构。 根据数据元素之间的关系不同的特性，通常有下列4类基本结构：（逻辑结构） 集合：结构中的数据元素之间除了“同属一个集合”的关系之外，别无其他关系 线性结构：结构中的数据元素之间存在一个对一个的关系 树形结构：结构中的数据元素之间存在一个对多个的关系 图状结构或网状结构：结构中的数据元素之间存在多个对多个的关系 数据结构的形式定义为：数据结构是一个二元组 Data Structure = (D, S)；其中：D是数据元素的有限集，S是D上关系的有限集。 数据结构在计算机中的表示(又称映像)称为数据的物理结构，又称存储结构。 在计算机中表示信息的最小单位是二进制数的一位，叫做位(bit)。 在计算机中可以用一个由若干位组合起来形成一个位串表示一个数据元素，通常称这个位串为元素或结点。 当数据元素由若干个位串组成时，位串中对应于各个数据项的子位串称为数据域(data field)。 数据元素之间的关系在计算机中有两种不同的表示方法：顺序映像和非顺序映像，并由此得到两种不同的存储结构：顺序存储结构和链式存储结构。链式存储结构的特点是借助指示元素存储地址的指针来表示数据元素之间的逻辑关系。 数据类型(data type)是和数据结构密切相关的一个概念，它是一个值的集合和定义在这个值集合上的一组操作的总称。例如C语言中的整形变量，其值为一个整形集合和定义在这些值上的操作如加减乘除。 按“值”的不同特性，高级程序语言中的数据类型可分为两类：一类是非结构的原子类型，另一类是结构类型。 抽象数据类型(Abstract Data Type，简称ADT)是指一个数学模型以及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关，即不论其内部结构如何变化，只要它的数学特性不变，都不影响其外部的使用。 原子类型(atomic data type)：属原子类型的变量的值是不可分解的。 固定聚合类型(fixed-aggregate data type)：属该类型的变量，其值由确定数目的成分，按某种结构组成。 可变聚合类型(variable-aggregate data type):和固定聚合类型相比较，构成可变聚合类型“值”的成分的数目不确定。 和数据结构的形式定义相对应，抽象数据类型可用以下三元组表示(D, S, P)，其中D是数据对象，S是D上的关系集，P是对D的基本操作集本书采用如下格式定义抽象数据类型 ADT 抽象数据类型名 { 数据对象：&lt;数据对象的定义&gt; 数据关系：&lt;数据关系的定义&gt; 基本操作：&lt;基本操作的定义&gt; } ADT 抽象数据类型名； 多型数据类型(polymorphic data type):是指其值的成分不确定的数据类型，例如JAVA中的泛型。然而，不论其元素具有何种特性，元素之间的关系相同，基本操作也相同。从抽象数据类型的角度看，具有相同的数学抽象特性，故称之为多型数据类型。 算法(algorithm)是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或多个操作，此外，算法还具有5个重要特性：有穷性、确定性、可行性、有输入、有输出。 一个好的算法应考虑达到以下几个目标：正确性、可读性、健壮性、效率与低存储量需求。 为了便于比较同一问题的不同算法，通常的做法是，从算法中选取一种对于所研究的问题(或算法类型)来说是基本操作的原操作，以该基本操作重复执行的次数作为算法的时间量度。一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数f(n)，算法的时间度量记作:`T(n)=O(f(n))，它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度(asymoptotic time ecomplexity)，简称时间复杂度。 类似于时间复杂度，本书以空间复杂度(space complexity)作为算法所需存储空间的量度，记作S(n)=O(f(n))，其中n为问题的规模。 因为所占时间和空间都是依赖于特定的输入，本书的时间和空间的复杂度讨论都是基于最坏的情况来分析的。 线性表线性结构的特点是：在数据元素的非空有限集中： 存在唯一的一个被称作“第一个”的数据元素 存在唯一的一个被称作“最后一个”的数据元素 除第一个之外，集合中的每个数据元素均只有一个前驱 除最后一个之外，集合中的每个数据元素均只有一个后继 线性表(linear-list)是最常用且最简单的一种数据结构。简言之，一个线性表是n个数据元素的有限序列。 在稍微复杂的线性表中，一个数据元素可以由若干个数据项(item)组成，在这种情况下，常把数据元素称为记录(record)。含有大量记录的线性表又称为文件(file)。 线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素。假设线性表的每个元素需占用l个存储单元，并以所占的第一个单元的存储地址作为数据元素数据元素的存储位置。则线性表中第i+1个数据元素的存储位置LOC(ai+1)和第i个数据元素的存储位置LOC(ai)之间满足下列关系LOC(ai+1)=LOC(ai)+l，一般来说，线性表的第i个数据元素ai的存储位置为LOC(ai)=LOC(a1)+l*(i-1)。线性表的这种机内表示称作线性表的顺序存储结构或顺序映像(sequential mapping)，通常称这种存储结构的线性表为顺序表。也就是说，在计算机内用“物理位置相邻”来表示线性表中数据元素之间的逻辑关系。 typedef struct { ElemType *elem;//存储空间基址 int length;//当前长度 int listsize;//当前分配的存储容量 } SqList; 线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）。因此为了表示每个数据元素ai与其直接后继数据元素ai+1之间的逻辑关系，对数据元素ai来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。这两部分信息组成数据元素ai的存储映像，称为结点(node)。它包括两个域：其中存储数据元素信息的域称为数据域；存储直接后继存储位置的域称为指针域。指针域中存储的信息称作指针或链。n个结点链成一个链表，即为线性表的链式存储结构。 又由于此链表的每个结点中只包含一个指针域，故又称线性链表或单链表。单链表的整个链表的存取必须从头指针开始进行，头指针指示链表中第一个结点的存储位置。同时，由于最后一个数据元素没有直接后继，则线性链表中最后一个结点的指针为空NULL。 typedef struct LNode { ElemType data; struct LNode *next; } LNode, *LinkList; 有时，也可借用一维数组来描述线性链表，数组的一个分量表示一个结点，同时用游标(指示器cur)代替指针只是结点在数组中的相对位置。数组的第零分量可看成头结点，其指针域指示链表的第一个结点。为了和指针型描述的线性链表相区别，我们给这种用数组描述的链表起名为“静态链表”。 typedef struct { ElemType data; int cur; } 循环链表(circle linked list)是另一种形式的链式存储结构。它的特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环。由此，从表中任一结点厨房均可找到表中其他结点。循环链表的操作和线性链表基本一致，差别仅在于算法中的循环条件不是p或p-&gt;next是否为空，而是它们是否等于头指针。 双向链表：顾名思义，在双向链表的结点中有两个指针域，其一指向直接后继，另一指向直接前驱，在C语言中可描述如下： typedef struct DuLNode { ElemType data; struct DuLNode *prior; struct DuLNode *next; } 和单链的循环表类似，双向链表也可以有循环表。 栈和队列从数据结构的角度看，栈和队列也是线性表，其特殊性在于栈和队列的基本操作是线性表操作的子集，它们是操作受限的线性表，因此，可称为限定性的数据结构。 栈(stack)是限定仅在表尾进行插入或删除操作的线性表。因此对栈来说，表尾端有特殊含义，称为栈顶(top)，相应的，表头端称为栈底(bottom)。不含元素的空表称为空栈。栈的修改是按照后进先出的原则进行的，因此，栈又称后进先出的线性表(first in last out)。 和线性表类似，栈也有两种存储表示方法。 顺序栈，即栈的顺序存储结构是利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，同时附设指针top指示栈顶元素在顺序栈中的位置。栈的链式表示易于操作和实现，在此不作详细讨论。 和栈相反，队列(queue)是一种先进先出(first in first out)的线性表。它只允许在表的一端进行插入，而在另一端删除元素。在队列中，允许插入的一端叫做队尾(rear)，允许删除的一端称为对头(front)。栈也有顺序表示和链式表示两种。用链表示的队列简称为链队列。 和顺序栈相类似，在队列的顺序存储结构中，除了用一组地址连续的存储单元依次存放从队列头到队列尾的元素之外，尙需附设两个指针front和rear分别指示队列头元素及队列尾元素的位置。为了在C语言中描述方便起见，在此我们约定：初始化建空队列时令front=rear=0，每当插入新的队列尾元素时，尾指针增1，每当删除队列头元素时，头指针增1，因此在非空队列中，头指针始终指向队列头元素，而尾指针始终指向队列尾元素的下一个位置。在顺序队列中，当队尾指针到达分配的最大空间时不可再继续插入新的队列元素，否则会因为数组越界而遭致程序代码被破坏。 除了栈和队列以外，还有一种限定性数据结构是双端队列(deque)。双端队列是限定插入和删除操作在表的两端进行的线性表。 串计算机上的非数值处理的对象基本上是字符串数据。在较早的程序设计语言中，字符串是作为输入和输出的常量出现的。随着语言加工程序的发展，产生了字符串处理。这样，字符串也就作为一种变量类型出现在越来越多的程序设计语言中，同时也产生了一系列字符串的操作。字符串一般简称为串。 在不同类型的应用中，所处理的字符串具有不同的特点，要有效地实现字符串的处理，就必须根据具体情况使用合适的存储结构。这一章中会讨论一些基本的串处理操作和几种不同的存储结构。 串(string)(或字符串)是由零个或者多个字符组成的有限序列，一般记为s=&#39;a1a2...an&#39;(n&gt;=0)，其中，s是串的名，用单引号括起来的字符序列是串的值;ai(1&lt;=i&lt;=n)可以是字母、数字或其他字符;串中字符的数目n称为串的长度。零个字符的串称为空串(null string)，它的长度为0。 串中任意个连续的字符组成的子序列称为该串的子串。包含子串的串相应地称为主串。通常称字符在序列中的序号为该字符在串中的位置。子串在主串中的位置则以子串的第一个字符在主串中的位置来表示。 当切仅当两个串的值相等，才会称两个串是相等的。 值得一提的是，串值必须用一对单引号括起来，但单引号本身不属于串，它的作用只是为了避免与变量名或数的常量混淆而已。 在各种应用中，空格常常是串的字符集合中的一个元素，因而可以出现在其他字符中间。由一个或多个空格组成的串’ ‘称为空格串(blank string)，它的长度位串中空格字符的个数。 如果在程序设计语言中，串只是作为输入或输出的常量出现，则只需存储此串的串值，即字符序列即可。但在多数非数值处理的程序中，串也以变量的形式出现。串有3种机内表示方法，分别介绍如下： 定长顺序存储表示 类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。在串的定长顺序存储结构中，按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区，则可用定长数组如下描述之： #define MAXSTRLEN 255 typedef unsigned char SString[MAXSTRLEN+1]; 堆分配存储表示 这种存储表示的特点是，仍以一组地址连续的存储单元存放串值字符序列，但它们的存储空间时在程序执行过程中动态分配而得。在C语言中，存在一个称之为堆的自由存储区，并由C语言的动态分配函数malloc()和free()来管理。利用函数malloc()为每个新产生的串分配一块实际串长所需的存储空间，若分配成功，则返回一个指向起始地址的指针，作为串的基址，同时，为了以后方便处理，约定串长也作为存储结构的一部分 typedef struct { char *ch; int length; }HString; 以上两种存储表示通常为高级程序设计语言所采用。由于堆分配存储结构的串既有顺序存储结构的特点，处理方便，操作中对串长又没有任何限制，更显灵活，因此在串处理的应用程序中也常被选用。 块链存储表示 和线性表的链式存储结构相类似，也可以采用链表方式存储串值。由于串结构的特殊性-结构中的每个数据元素是一个字符，则用链表存储串值时，存在一个“结点大小”的问题，即每个结点可以存放一个字符，也可以存放多个字符。为了便于进行串的操作，当以链表存储串值时，除头指针外还可以附设一个尾指针指示链表中的最后一个结点，并给出当前串的长度。称如此定义的串存储结构为块链结构。设尾指针的目的是为了便于进行联结操作，但应注意联结时需处理第一个串尾的无效字符。 #define CHUNKSIZE 80 typedef struct Chunk { char ch[CHUNKSIZE]; struct Chunk *next; }Chunk; typedef struct { Chunk *head, *tail; int curlen; }LString; 在链式存储方式中，结点大小的选择和顺序存储方式的格式选择一样都很重要，它直接影响着串处理的效率。在各种串处理系统中，所处理的串往往很长或很多，这就要求我们考虑串值的存储密度：存储密度=串值所占的存储位/实际分配的存储位。显然，存储密度小(如结点大小为1时)，运算处理方便，然而存储占用量大。 串值的链式存储结构对某些串操作，如连接操作等有一定方便之处，但总的来说不如另外两种存储结构灵活，它占用存储量大且操作复杂。 子串的定位操作通常称作串的模式匹配，是各种串处理系统中最重要的操作之一。 数组和广义表前几章讨论的线性结构中的数据元素都是非结构的原子类型，元素的值是不再分解的。本章讨论的两种数据结构–数组和广义表可以看成是线性表在下述含义上的扩展，表中的数据元素本身也是一个数据结构。 我们可以把二维数组看成是这样一个定长线性表，它的每个数据元素也是一个定长的线性表。数组一旦被定义，它的维数和维界就不再改变。因此，除了结构的初始化和销毁之外，数组只有存取元素和修改元素值的操作。由于数组一般不作插入或删除操作，也就是说，一旦建立了数组，则结构中的数据元素和元素之间的关系就不再发生变动。因此，采用顺序存储结构表示数组时自然的事了。 由于存储单元是一维的结构，而数组是多维的结构，则用一组连续存储单元存放数组的数据元素就有个次序约定问题。相应的，对二维数组可有两种存储方式，一种以列序为主序的存储方式，一种是以行序为主序的存储方式。 由此，对于数组，一旦规定了它的维数和各维的长度，便可为它分配存储空间。反之，只要给出一组下标便可求得相应数组元素的存储位置。假设每个数据元素占L个存储单元，则二维数组A中任一元素aij的存储位置可由下式确定 LOC(i, j)=LOC(0, 0)+(b2xi+j)L，式中，LOC(i, j)是aij的存储位置；LOC(0, 0)是a00的存储位置，即二维数组A的起始存储地址，也称为基地址或基址。 在数值分析中经常出现一些阶数很高的矩阵，同事在矩阵中有许多值相同的元素或者是零元素。有时为了节省存储空间，可以对这类矩阵进行压缩存储。所谓压缩存储是指：为多个值相同的元只分配一个存储空间，对零元不分配空间 假若值相同的元素或者零元素在矩阵中的分布有一定规律，则我们称此类矩阵为特殊矩阵，反之称为稀疏矩阵。 顾名思义，广义表是线性表的推广。也有人称其为列表(lists,用复数形式以示与统称的表list的区别)。广泛地用于人工智能等领域的表处理语言LISP语言，把广义表作为基本的数据结构，就连程序也表示为一系列的广义表。广义表一般记作 LS = (a1, a2… an)，其中LS是广义表的名称，n是它的长度。在线性表的定义中，ai只限于是单个元素。而在广义表的定义中，ai可以是单个元素，可以是广义表，分别称为广义表LS的原子和子表。习惯上，用大写字母表示广义表的名称，用小写字母表示原子。当广义表LS非空时，称第一个元素a1为LS的表头(HEAD)，称其余元素组成的表时LS的表尾(TAIL)。 由于广义表中的数据元素可以具有不同的结构(或是原子，或是列表)，因此难以用顺序存储结构表示，通常采用链式存储结构，每个数据元素可用一个结点表示。由于列表中的元素可能为原子或列表，由此需要两种结构的结点，一种是表结点，用以表示列表，另一种是原子结点，用以表示原子。若列表不空，则可分解成表头和表尾，反之，一堆确定的表头和表尾可唯一确定列表。由此，一个表结点可由3个域组成：标志域、指示表头的指针域和指示表尾的指针域；而原子结点只需两个域：标志域和值域。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言程序设计教程2]]></title>
    <url>%2F2012%2F02%2F24%2FC%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%95%99%E7%A8%8B2%2F</url>
    <content type="text"><![CDATA[函数程序员在设计一个复杂的应用程序时，往往也就是把整个程序划分为若干功能较为单一的程序模块，然后分别予以实现，最后再把所有的程序模块像搭积木一样装配起来，这种策略被称为模块化程序设计方法。 每个C源程序都是由一个主函数和若干个其他函数组成的。函数时程序的基本组成单位，因此可以很方便地用函数作为程序模块来实现C语言程序。从函数的定义角度，函数可以分为库函数和用户自定义函数两种；从兼有其他语言功能角度分类，函数分有返回值函数和无返回值函数两种；从函数间传送的角度分类，函数分为无参函数和有参函数两种； 返回值类型 函数名(参数表) { 函数体; } 在主调函数中调用某函数之前应对该被调函数进行原型说明，这与使用变量之前要先进行变量说明是一样的。在主调函数中对被调函数作说明的目的是使编译器程序知道被调函数的返回值类型，以便在主调函数中按此种类型值做相应的处理类型说明符 被调用函数名(类型1 形参1, 类型2 形参2);或类型说明符 被调用函数名(类型1, 类型2);。函数的调用方法如下函数名(实际参数表); 一般来说，有两种方法可以把参数传递给函数，一种方法叫做传值调用，另一种方法是传址调用。 传值调用：把实参的值复制到函数的形参中 传址调用：将实参的存储地址作为参数传递给形参 数组也可以作为函数的参数使用，进行数据传送。数组用作函数参数有两种形式：一种是把数组元素(下标变量)作为实参使用；另一种是把数组名作为函数的形参和实参使用 在变量做函数参数时，所进行的值传递是单向的，即只能从实参传向形参，不能从形参传回实参。 函数的传值调用可以通过参数使用调用环境中变量的值，但不能改变那里的变量值。想要改变那里的变量值，就得利用指针机制：在调用时把变量的地址通过指针参数传进被调函数，在被调用函数里对参数指针间接访问，就能完成对变量的各种操作，包括对变量赋值。 在C语言中允许一个函数的返回值是一个指针(即地址)，这种返回指针值的函数称为指针型函数。定义指针型函数的一般形式为： 类型说明符 *函数名(形参表) { ...;//函数体 } 在C语言中一个函数总是占用一段连续的内存区，而函数名就是该函数所占内存区的首地址。我们可以给函数的首地址赋予一个指针变量，使该指针变量指向该函数，然后，通过指针变量就可以找到并调用这个函数。我们把这种指向函数的指针变量称为“函数指针变量”。函数指针变量定义的一般格式为：类型说明符 (*指针变量名)();。其中”类型说明符”表示被指函数的返回值的返回值类型，(*指针变量名)表示*后边的变量是定义的指针变量，空括号表示指针变量所指的是一个函数。调用函数的一般形式为(*指针变量名) (实参表) 在ANSI C标准中允许用结构变量作函数参数进行整体传送。但是这种传送要将全部的成员逐个传送，特别是成员为数组时将会使传送的时间和空间开销很大，严重地降低程序的效率，因此，最好的办法就是使用指针，即用指针变量作函数参数进行传送。这时由实参传向形参的只是地址，从而减少了时间和空间的开销。结构型函数是指返回值为结构变量的函数。返回指向结构变量指针的函数称为结构指针型函数，结构型函数返回的是结构变量，函数返回时要带回结构变量的各成员值，影响执行效率，而采用返回结构型指针的函数可以避免这一点。 函数的递归调用是指在调用一个函数的过程中，直接或间接地调用函数自身，这种函数称为递归函数。C语言允许函数的递归调用。在递归调用中，主调函数又是被调函数。 变量的存储类型C语言中的变量具有两个属性：数据类型和存储类型。数据类型确定了变量在内存中分配存储单元的大小，存储类型指数据在内存中的存储方式。变量的存储类型决定了变量的作用域和生命周期。存储方式分为静态存储和动态存储。 静态存储方式指在程序运行期间分配固定存储空间，在整个程序运行期间保持不变，直到程序运行结束才释放所占有的存储空间。动态存储方式指在程序运行的过程中，根据需要，使用时才分配存储空间，使用结束后立即释放。典型的例子是函数的形式参数。 在C程序中，函数之间的参数传送主要有两种方式：传值和传地址。 C程序中的每个变量都要经历 分配存储空间，用以存放该变量的值，然后在程序中使用变量，使用结束后释放所占有的存储空间的过程。这个过程称为变量的生命期。在变量的生存期内，该变量可以使用的范围称为变量的作用域。在变量作用域内引用变量，称变量在此作用域内可见。 变量的作用域是一个空间的概念，由定义变量语句的位置决定，根据变量定义语句的位置的不同，变量分为局部变量和全局变量。 C语言中的四种类型的变量： 自动变量：自动变量定义时，前面可以加关键字auto，其格式为auto 类型说明符 变量名表;。在函数内定义的变量称为内部变量，由于内部变量的作用域仅局限于其所在的函数，因此内部变量也称为“局部变量”。内部变量分为自动变量和静态局部变量。 外部变量：所有在函数外部定义的变量称为外部变量，外部变量是全局变量，外部变量可以被本源程序文件中的其他函数使用。外部变量的作用域从其定义的位置开始，一直到本源程序结束。由于外部变量在程序执行过程中，占有固定的存储单元，其生存期为整个程序。在C语言中，可以使用关键字extern，将外部变量的作用域扩展到外部变量定义之前或其他源程序文件中。也可以使用extern关键字进行引用性声明，引用性声明不分配存储空间extern 类型标识符 变量名表; 静态变量：定义变量时，前面加关键字static，则定义的变量就是静态变量。在编译时，系统分配固定的存储单元，并在程序运行过程中始终存在，直到源程序运行结束，因此静态变量的生存期为整个源程序。静态变量根据位置不同分为静态局部变量和静态全局变量。全局变量和静态全局变量的存储方式均为静态存储方式，两者的区别在于作用域扩展上的不同，静态全局变量的作用域为其所在的源程序文件，即只能被该源程序中的函数使用，而全局变量可以通过extern关键字将作用域扩展到其他源程序文件。所以在由多个源文件组成的C程序中，如要限制外部变量不能再其他源程序文件中使用，可以将其定义为静态外部变量。 寄存器变量：寄存器变量是指将局部变量的值存放在CPU的寄存器中的变量。由于寄存器的存钱速度远高于对内存的存取速度，因此，可以将使用频繁的局部变量定义为寄存器变量，可以提高程序的运算效率，寄存器变量定义形式如下：register 数据类型 变量名表; C程序在运行时使用的存储空间分为三个部分 程序区：用于存放程序代码 静态存储区：用于存放程序的全局数据和静态数据 动态存储区：用于存放自动变量、函数的形式参数、函数调用时的现场保护和返回地址 动态内存分配是指在程序运行过程中，根据需要而分配内存空间的方式，这种就可以解决有时分配过大或过小的问题。在C系统的函数库中提供的动态分配和释放内存空间的函数主要有： malloc函数：void *malloc(unsigned int size)在内存动态存储区分配一段长度为size个字节的连续空间，如果分配成功，函数返回一个指向该区域起始地址的指针，否则返回NULL指针 calloc函数：void *calloc(unsigned int n, unsigned int size);在内存动态存储区分配n个长度为size的连续空间，如果分配成功，函数返回一个指向该区域起始地址的指针，否则返回NULL指针 free函数：void free(void *p);释放指针p指向的存储空间，free函数无返回值 realloc函数：void *realloc(void *p, unsigned int size);将p所指向的存储空间，重新分配改变为size的字节，并将原存储空间存放的数据拷贝到新分配的存储空间，如果分配成功，函数返回一个指向该区域起始地址的指针，否则返回NULL指针。注意：为了增加或减少存储空间，系统新分配的起始地址不一定与原来的地址相同 位域、联合、枚举、定义类型及预处理功能8.1 位域及结构嵌套为了节省空间，C语言允许定义具有可变长度位的结构成员，这种成员称为位域。通过位域可以方便地用成员名访问小于一个字节的存储区。位域是结构成员的特殊形式，它需要定义位的长度。位域定义的一般形式是： //冒号表示使用的是位域，其后的长度表示需要分配的存储单元的位数 struct 结构名 { 类型 变量名1:长度; 类型 变量名2:长度; } //内存分配情况是位域变量总共占用2个字节其余位未用 //注意：在不同的机器里，位域变量从左到右还是从右到左的规则不同 struct { unsigned bit0:1; unsigned bit1:1; } 与结构成员的访问方式一样，位域可以用结构成员运算符”.”来访问。若位域是由指针访问的，必须使用箭头运算符。位域变量有某些限制，比如，不能取一个位域变量的地址；不允许超越整形量边界。 在C语言中，结构成员不仅可以是位数可变的位域变量，而且可以是另一个结构类型变量。这种情况被称为嵌套式结构。 8.2 联合联合是一种与结构相类似的构造类型，联合与结构一样，可以包括不同类型和长度的数据。联合与结构的主要区别在于，联合类型变量所占内存空间不是各个成员所需存储空间字节数的总和，而是联合成员中需要存储空间最大的成员所要求的字节数。这是因为C编译程序规定联合的各个成员共享一个公共存储空间。在任何给定的时刻，只能允许一个成员驻留在联合中，而对结构而言，则是所有成员一直都驻留在结构中。 union 联合名 { 类型 变量名; 类型 变量名; }联合变量; 使用联合不仅比使用结构更能节省一些存储空间，而且增加了处理数据的灵活性。 8.3 枚举通过列举一系列由用户自己确定的有序标识符所定义的类型叫枚举类型。标识符名称代表一个数据值，其间有先后次序，可以进行比较，通常把标识符称为枚举类型的元素。 枚举和结构一样，都是自定义的一种数据类型，枚举用关键字enum表示，定义枚举型的一般形式为：enum 枚举名{枚举表}; enum color {white, black, red}; enum color col; col = black; 枚举的作用域与变量一致，即在一个函数中定义的枚举型数据只限于在该函数中使用。而在程序中任何函数之外定义的外部枚举型数据可以为所有函数共用。 8.4 定义类型名-typedefC语言允许用户使用关键字typedef，为已有的类型定义一个新的名字，定义类型的一般形式为：typedef 类型 定义名;，例如 typedef int integer;，在这里，类型是任一种合法的数据类型，定义名是为这种类型新取的名字。 必须强调指出，typedef的作用，在任何意义上讲都不是创建一种新的数据类型，它仅仅为现有的类型赋给一个新的名字，也没有任何新语义。 8.5 预处理功能C语言的预处理程序负责分析和处理以“#”为首字符的预处理控制行。预处理控制行主要有宏替换、文件包含和条件编译。 用#define作为标志的预处理命令不仅可以定义符号常量及字符串，而且也可定义带参数的宏。宏替换命令#define用来定义一个宏标识符和一个字符串，在程序中每次遇到该标识符时，就用所定义的字符串替换，这个标识符也叫宏替换名，替换过程称为宏替换，宏替换命令的一般形式是：#define 宏标识符 字符串。注意#define、宏标识符、字符串各部分之间用空格分隔，其末尾不带分号，以换行结束。 宏标识符像函数一样可以带有形式参数。在程序中用到宏标识符时，实际参数将代替这些形式参数，使用更为灵活。带参数宏定义的一般形式是：#define 宏标识符(参数表) 表达式。标识符就是带参数宏的名字，参数表中的参数类似函数中的形式参数，宏标识符与左圆括号之间不能有空格；表达式是用于替换的表达式。宏调用的一般形式是宏标识符(参数表)，此处的宏标识符是已经被定义的宏标识符，参数表中的参数类似于函数中的实参数。 宏一旦被定义，在其所在的文件中均是存在和可见的，这一点很像外部变量。如果要对某一个宏定义撤销，可用如下预处理命令:#undef 宏标识符。 包含文件处理是用#include命令把给定的包含文件内容嵌入到另一个源程序文件中。其一般形式是：#include 文件名 或 #include &lt;文件名&gt;。#include预处理命令的实质是，告诉预处理程序将包含文件的内容嵌入到源文件中#include出现的地方。 需要嵌入的包含文件的存放地点，必须由文件的路径和文件名指定，并且被放在双引号内，系统约定先在引用包含文件的源文件所在的目录中查找，若找不到，再按系统指定的标准方式向外查找，如果已经知道被包含文件不在当前工作目录，可以使用尖括号形式查找标准目录。因此，从使用角度上看，在包含文件中使用双引号比使用尖括号更靠谱。 输入、输出及文件管理C语言的文件系统分为“缓冲型文件系统(buffered file system)”和“非缓冲型文件系统(unbuffered file system)”。通常把缓冲型文件系统提供的函数称为流式I/O函数，把非缓冲型文件系统提供的函数称为低级I/O函数。 fopen：打开文件函数 File *fp=fopen(filename, mode)其中fp定义为指向FILE类型的指针，filename表示要打开的文件名，mode表示使用该文件的模式，如可读r、可写w和可添加a。若要打开的文件不存在，fopen函数返回NULL指针，也就是0 fclose:关闭文件函数int fclose(File fp)其中fp是一个调用fopen函数所返回的文件指针。文件关闭成功返回0，返回其他值说明关闭出错。文件处理结束后，必须关闭文件。文件未关闭会引起很多问题，如数据丢失，文件损坏及其他一些错误。 stdin、stdout、stderr：当一个C程序开始执行时，系统首先自动打开预定义的三个流式文件：标准输入stdin，标准输出stdout和标准错误stderr。当程序运行结束后，系统又自动将这些标准文件关闭。用户则不能控制它们的打开和关闭。通常stdin被指定为键盘，用于从控制台读，stdout和stderr被指定为显示终端，用于向控制台写。但是用户在执行某个程序时，可以临时性地改变系统的设定，把标准设备文件指定为其他设备文件。 getc、putc简单字符输入输出：这两个函数时用于从一个打开的文件中读取一个字符或向打开的文件写入一个字符的函数。调用方式为int getc(FILE *fp);或int putc(int ch, FILE *fp)，这里，fp是由fopen函数打开文件时返回的文件指针。fp指针告诉这两个函数应该从哪一个磁盘文件去读字符或写入字符。 fgets、fputs行输入输出：fgets和fputs是用来从文件中读取字符串，或向文件中写字符串的函数，其调用方式是：char *fgets(char *str, int length, FILE *fp);和char *fputs(char *str, FILE *fp);，函数fgets从fp指向的文件读出字符串，一直读至换行符或第(length-1)个字符为止。 fread、fwrite数据块的输入输出：这是两个读写数据块的函数，其调用方式是int fread(void *buffer, int size, int n, FILE *fp);或int fwrite(void *buffer, int size, int n, FILE *fp);buffer是一个指向数据存储区的指针。在fread函数中，buffer接收从文件中读取的数据。在fwrite函数中，buffer中的数据向文件写入。读写的字段数用n表示（每个字段是size个字节），fp是已打开文件的文件指针。 fprintf、fscanf流式文件数据的格式化输入输出：这两个函数的操作对象是磁盘文件，以上的操作对象都不是磁盘文件，调用这两个函数的方式分别是fprintf(fp, &quot;控制字符串&quot;, &quot;参量表&quot;)和fscanf(fp, &quot;控制字符串&quot;, &quot;参量表&quot;)，其中，fp是由fopen函数返回的文件指针，fprintf函数将格式化的数据写入到fp指向的文本文件中，fscanf函数从fp指向的文本文件中读取格式化数据，两个函数的操作方法与printf和scanf函数完全相同。 fseek文件的随机访问：fseek函数可以改变文件的位置指针，以实现文件的随机访问。调用方式为：int fseek(FILE *stream, long offset, int origin);，即按偏移量offset和起始位置origin的值，设置与stream相连的文件位置指示器。操作成功返回值为0，否则返回值为非0。偏移量offset是从起始位置origin到要确定的新位置之间的的字节数目，当文件是结构类型时，可用sizeof()函数确定便宜量。起始位置用0，1，2表示，0表示从文件头开始，1表示从当前位置开始，2则表示从文件末端开始。 C高级程序应用10.1 链表链表是由链指针构成的一种动态数据结构。链表分为单向链表、双向链表和循环链表。单向链表只用一个链指针指向下一个结点。双向链表用两个链指针分别指向前一个结点和后一个结点。循环链表最后一个数据项的指针指向第一个数据项，因此循环链表是一个无表头和表尾的链表。 10.2 与操作系统密切相关的库函数在Windows操作系统中，用户可以通过图形化界面方便地完成操作系统的各种功能。而在DOS磁盘操作系统环境下，是通过在命令行输入命令并回车来完成相应的功能，目前在嵌入式系统编程等方面仍大量采用这种工作方式。 Turbo C库函数的一个重要特色就是设置有与操作系统密切相关的一些函数。这些函数包括： BIOS接口调用函数 DOS系统调用函数 时间和日期函数 10.3 图形程序Turbo C提供了非常丰富的图形函数，所有图形函数的原型均在graphics.h中，本节注意介绍图形模式的初始化、独立图形程序的建立、基本图形功能、图形窗口以及图形模式写的文本输出等函数。 10.4 声音程序Turbo C中提供了几个队扬声器操作的库函数： 接通扬声器：sound(int frequence);按照参数要求的频率发音 关闭扬声器：nosound(); Outportb(int port, char byte)/Inportb(int port)：通过对端口的直接操作函数来控制扬声器的发音。扬声器的端口地址为0x42，对端口的操作方式一般分两步：初始化端口、向端口传送频率值。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言程序设计教程1]]></title>
    <url>%2F2012%2F01%2F27%2FC%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%95%99%E7%A8%8B1%2F</url>
    <content type="text"><![CDATA[C语言概述1.1 计算机信息社会与C语言到目前为止，计算机语言大致可分为五代，第一代是机器语言，第二代是汇编语言，第三代是面向过程程序设计语言，第四代是面向对象程序设计语言，第五代是基于Web的语言。 高级语言源程序在计算机中有编译和解释两种执行方式 在解释方式下，源程序由解释程序边解释边执行，不生成目标程序，其执行程序速度较慢 在编译方式下，源程序首先必须经过编译程序的编译处理，产生相应的目标程序，然后再通过连接和装配，才能生成可执行程序 1.2 C语言简史及其特点ALGOL(1960)–CPL(1963)–BCPL(1967)–B(1970)–C(1972)–发表(1978)–ANSIC标准(1983)–ANSIC标准补充(1987)–获得ISO认证(1997) 1980年开始，贝尔实验室将Simula67中‘类’的概念引入C语言，1993年将其正式命名为C++ C语言不仅具有高级语言的特点，并且还有汇编语言的功能，同时具有极强的兼容性和良好的用户界面 1.3 基本程序结构C程序是一种结构化程序，程序由顺序、循环、分支三种结构组成 C程序中有三种类型的函数 主函数main 编译程序提供的函数 程序员自己设计的函数 一个函数由两部分构成 函数说明部分 和 函数体部分 1.4 基本语法单位在C语言中使用的词汇分为6类：关键字、标识符、操作符、分隔符、常量、注释符等 关键字：C语言规定的具有特定意义的字符串，通常也称保留字，用户定义的标识符不应与关键字相同。C语言的关键字分为以下几类：类型说明符(int) 语句定义符(if else) 预处理命令符(include) 标识符：用来表示变量名、数组名、函数名、指针名、结构名、联合名、枚举常量名、用户自定义的数据类型名及语句标号等的字符序列统称为标识符 操作符：在C语言中含有相当丰富的操作符。操作符与变量、函数一起组成表达方式，以表示各种运算功能 分隔符：在C语言中的分隔符有逗号和空格两种 常量：包括数值常数、字符常数、字符串常数以及枚举常数 C语句是组成C程序的基本单位，具有可执行的功能 函数时构成C程序的必不可少的一部分，它是一个相对独立的程序或模块 1.5 C程序的编写和运行步骤 程序编辑：程序员用任一编辑器将编写好的C程序输入计算机，并以文本文件的形式保存在计算机硬盘上 程序编译：编译是指将编译好的源文件翻译成二进制目标代码的过程 连接程序：编译后产生的目标文件是可重定位的程序模块，不能直接运行。这就需要把目标文件、其他分别进行编译生成的目标程序模块和系统提供的标准函数库连接在一起，以生成可运行的可执行文件 程序运行：生成可执行文件后，就可以在操作系统控制下运行。 总结起来，C程序的过程如下: .c文件–.cpp文件–.obj文件–.exe文件 1.6 算法表示方法程序 = 数据结构 + 算法 数据结构是程序中用到的数据的构造形式及其类型。对于面向对象程序设计，强调的是数据结构，而对于面向过程的程序设计语言，主要关注的是算法。算法是程序的核心，也是面向对象程序设计的基础。 所谓结构化编码时指任何复杂的程序皆可由顺序、分支、循环三种基本结构组成。对复杂的程序进行自顶向下、逐步细化的分析，进行模块化的划分。 程序设计的步骤是 设计算法–描述算法–编写程序–检查程序–编译调试和运行。 算法的描述方法有自然语言描述、伪代码、流程图、N-S图、PAD图等 基本数据类型及运算2.1 基本数据类型数据类型是数据的基本属性，描述的是数据的存储格式和运算规则。不同数据类型的数据，在内存中所需的存储空间大小、存储格式均有所不同、能支持的运算以及相应的运算规则也会有所不同 数据类型分为： 基本类型 整形：基本类型符为int，根据数据范围又可分为普通整形(int)、短整形(short)和长整形(long) 浮点类型：浮点类型分为单精度浮点数(float)，双精度浮点数(double)和长双精度浮点数(long double) 字符型：字符的基本类型符为char，可在其前面加修饰符前缀signed和unsigned，都是用1个字节来存放 构造类型 数组类型 结构类型 联合类型 枚举类型 指针类型 空类型 2.2 常量常量是在程序执行过程中其值不能改变的量。在C语言中有不同类型的常量，如整形常量、浮点型常量、字符型常量、字符串常量和符号常量。 整形常量也称作整常量，在C语言中整常量可以用以下3种形式表示：十进制、八进制(以0开头)和十六进制(以0x或0X开头) 浮点型常量如同一般语言中的实数(real number)，它有两种表示形式： 十进制数形式：由数字和小数点组成 指数形式：由十进制小数、阶码标志e或E以及指数(只能为整数，可以带符号)组成，6.5E-2 字符型常量是用单引号括起来的一个字符，如’A’,’a’等 字符串常量是用一对双引号括起来的零个或多个字符组成的序列，如“hello”等，其存储于字符常量的存储不同，字符串常量都会自动在其末尾加上’\0’作为字符串结束标志 符号常量出现的形式一般有两种，一种是在程序中直接使用给定的值(如圆周率)，另一种是用一个常量相关的标识符来替代常量出现在程序中(const修饰) 2.3 变量变量是在程序执行过程中其值可以改变的量，其定义格式为：类型说明符 变量名表;，C语言允许在定义变量的同时对变量进行初始化，初始化不是在编译阶段完成的，而是在程序运行时执行本函数时赋予初值的，相当于有一个赋值语句。定义时的变量名其实是一个符号地址，它指出了变量在内存中的存放位置，而变量值就是在相应内存单元中存放的数据。 2.4 运算符与表达式按运算符在表达式中的作用，C语言的运算符可分为算术运算符(加减乘除取余等)、赋值运算符、关系运算符(&gt;=、!=等)、逻辑运算符(!、&amp;&amp;、||)、位运算符(&lt;&lt;、&gt;&gt;、&amp;等)、条件运算符(?:)、逗号运算符以及一些特殊的运算符(地址运算符&amp;、sizeof运算符、强制类型转换运算符())。 2.5 混合运算与类型转换在计算表达式时，不但要考虑运算符的优先级和结合性，还要分析运算对象的数据类型。一个运算符对不同数据类型的数据的计算结果有可能不同。不同类型的数据在一起运算时，需要转换为相同的数据类型。转换的方式有两种：自动类型转换和强制类型转换。自动类型转换又称为隐式转换，而强制类型转换又称为显示转换。 自动类型转换是指系统根据规则，自动将两个不同数据类型的运算对象转换成同一数据类型的过程，转换的原则是为两个运算对象的计算结果尽可能提供多的存储空间 强制类型转换的格式为(数据类型名)(表达式名) 2.6 运算的优先级与结合性表达式的计算是与运算符的语义以及它们的优先级和结合性规则有关 运算符高的运算符先算，优先级低的运算符后算 优先级相同的运算符、根据结合性决定计算顺序(i/j*k从左至右，*p–从右至左) 不相关子表达式的计算顺序不确定(i++)+(i+j)由于不同环境的编译配置有肯能从左至右，也有可能从右至左计算，所以会导致计算结果不一致 有特殊规则的运算符（注意一下 &amp; 和 || 的中断处理） 2.7 数据的输入输出C语言中没有提供专门的输入/输出(I/O)语句，所有的I/O操作都必须通过函数调用来实现，如前面程序中用到的printf()，scanf()等都是系统提供的标准I/O库函数。标准C定义了15个标准库函数和相应的头文件。 字符输出函数putchar() 格式输出函数printf()printf(格式控制串, 参数1， 参数2，...) 字符输入函数getchar() 格式输入函数scanf()scanf(格式控制串, 参数1， 参数2，...) cincin&gt;&gt;i&gt;&gt;j从键盘拾入i和j的值 coutcout&lt;&lt;How are you输出字符串 控制语句C语言有三种基本语句： 顺序结构 选择结构 if(表达式) { ...; } else if (表达式) { ...; } else { ...; } switch(表达式) { case c1: S1; break; case c2: S2; break; ... default: Sn+1; break; } 循环结构 do { 语句(即循环体部分) } while (表达式); while(表达式) { 语句(即循环体部分); } for (表达式1; 表达式2; 表达式3) { 语句(即循环体部分); } C语言中的break，continue语句是专门用于跳出循环或终止一次循环过程的语句，被称为条件转向语句，而goto语句是用来跳转到通过’标号’指明的某条语句上去执行的语句，被称为无条件转向语句。 数组和结构数组是具有相同数据类型的数据的有序集合，他们有相同的标识符和数据类型，用一个统一的数组名及数组下标来唯一确定数组中的元素，它的声明格式如下类型说明符 数组名[常量表达式] 仿照用一维数组表示多个有序变量，则可用二维数组表示多个有序的一维数组，这时可将每个一维数组看做一个元素，以此构成一个更大的数组，这个数组就是一个二维数组，它的声明格式如下类型说明符 数组名[常量表达式1][常量表达式2]，其中常量表达式1规定了一维数组的个数，常量表达式2规定了一维数组中元素的个数。 在对数组的全部元素赋初值时，C语言规定可以省略第一维的长度，但不能省略第二维的长度，例如可以把int a[2][2]={1，2，3，4}写成int a[][2]={1，2，3，4}，但不能写成int a[2][]={1，2，3，4} 在C语言里，没有提供专门的字符串类型，所以需要使用字符数组来处理字符串。可以使用scanf函数和gets函数获得输入字符串，如scanf(&quot;%s&quot;, word);`gets(word)。可以使用printf函数和puts函数输出字符串，如prinft(“%s”, word);puts(word)` 在C语言里，字符串的应用非常广泛，为了简化用户的程序设计，C语言提供了丰富的字符串处理函数，这样可以大大减轻编程的工作量。其中主要包括有： 字符串长度测量函数strlen:strlen(字符数组名) 字符串复制函数strcpy:strcpy(字符数组名1，字符数组名2)将2复制到1中去 字符串连接函数strcat:strcat(字符数组名1，字符串2) 字符串比较函数strcmp:strcmp(字符数组名1，字符数组名2) 结构是具有不同数据类型的数据的集合，结构与数组相似，但其成员的数据类型可以不同，使用结构名及成员名来唯一确定结构中的成员。 struct 结构类型名 { 类型名1 成员名1; 类型名2 成员名2; ... 类型名n 成员名n; }; struct student { int age; char[20] name; } //定义 struct student stu1, stu2; //访问 stu1.age; stu2.name; 数组元素的类型可以是任何类型，当然也可以是结构类型，这种就被称为结构数组。结构数组与其他类型的数组一样，只是它的元素是结构类型。 指针指针变量与普通变量一样，在程序中需要先定义，再使用。指针变量定义的一般形式是：类型定义符 *指针变量名，其中，类型定义符是指针变量所指向的目标变量的数据类型，可以是C语言中规定的基本类型或用户自定义的数组、结构、联合等。*是一个说明符，仅向编译器说明其后所定义的是指针变量而不是一般变量。除0以外的整数值是不允许赋值给指针变量的p=0，因为指针变量中存放的是内存地址，而不是任何整数。 &amp;：取地址运算符 *：间接运算符：注意，在变量说明语句中的*意味着‘指向。。。的指针’，而在表达式中的*表示访问指针指向的目标变量 其实，数组名是一个指向该数组的指针。数组名是一个地址常量，不能被修改，在整个程序运行期间，其值是固定不变的。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C和OC的内存分配]]></title>
    <url>%2F2011%2F12%2F31%2FC%E5%92%8COC%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%2F</url>
    <content type="text"><![CDATA[在以前上课时经常死记硬背内存都有哪些区，自从参加工作后，从应用启动的过程可以明显的区分出内存的几个分区而不用死记硬背。由于OC是继承C来的，所以其内存分配方式基本相同，只不过iOS系统为每个app分配了一定额度的沙盒空间来供每一个app正常存储和运行。 不管是C程序还是iOS程序（为了简单，我们一iOS APP为例），当APP没有打开时，ipa或者app文件都是存在于ROM中，即我们说的iPhone16G的16G当中某一个叫Application的文件夹中，在其启动的时候iOS系统会先为app从RAM中分配一个独立的内存空间（即沙盒），app所有的内存操作都在这个独立的沙盒中进行。首先系统会加载二进制代码到内存中，然后加载常量区中的常量，接着加载全局区和静态区（初始化过的静态区和没有初始化过的静态区是分开的），之后程序会找main入口函数开始执行代码，在执行代码的过程中，会创建对象和一些局部变量，其中对象存放在堆中，变量存放在栈上，以上五个区中只有堆是由程序员自己创建和销毁，而其他四个都是系统自己管理。 由此可见，从低地址到高地址的的内存区域分别是代码区、常量区、全局区、堆区和栈区。 概念程序代码区代码区用来存放函数体的二进制代码，程序结束后由系统释放 常量区常量区用来存放常量字符串等，程序结束后由系统释放 全局区/静态区全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后有系统释放 全局变量和静态变量要尽量少用。因为这些变量在程序的生命周期中不会变释放，比较容易占用内存空间，不适合存储比较大量的数据。 堆区一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式类似于链表。堆区的变量地址是由下往上分配的，所以在同一线程中先声明的变量地址要比后声明的变量地址小。 堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 首先应该知道操作系统有一个记录空闲内存地址的链表。 当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。 由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中 堆是函数库内部数据结构，不一定唯一。 不同堆分配的内存无法互相操作。 堆空间的分配总是动态的 虽然程序结束时所有的数据空间都会被释放回系统，但是精确的申请内存，释放内存匹配是良好程序的基本要素。 栈区栈区用来存放局部变量，先进后出，一旦出了作用域就会被销毁。程序员不需要管理栈区变量的内存。栈区变量的大小是由上到下分配的，所以先声明的变量地址比后声明的变量地址要大。栈区存储在应用程序允许的内存空间的最上面。 栈是向低地址扩展的数据结构，是一块连续的内存的区域。是栈顶的地址和栈的最大容量是系统预先规定好的，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数 ) ,如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 存储每一个函数在执行的时候都会向操作系统索要资源，栈区就是函数运行时的内存，栈区中的变量由编译器负责分配和释放，内存随着函数的运行分配，随着函数的结束而释放，由系统自动完成。 静态分配是编译器完成的，比如自动变量(auto)的分配。 动态分配由alloca函数完成。 栈的动态分配无需释放(是自动的)，也就没有释放函数。 为可移植的程序起见，栈的动态分配操作是不被鼓励的！ 详解代码1：#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;iostream&gt; #include&lt;string.h&gt; static int a=1;//全局初始化区 int b=2;//全局初始化区 char *p;//全局未初始化区 char *p2;//全局未初始化区 int *p3;//全局未初始化区 int *p4;//全局未初始化区 char *p5={&quot;555555555&quot;};//全局初始化区 int main(){ static int c=3;//全局初始化区 int d=4;//内存栈 int e=7;//内存栈 char *p6={&quot;555555555&quot;};//内存栈 p=(char*)malloc(sizeof(char)*10);//内存堆 p2=(char*)malloc(sizeof(char)*10);//内存堆 p3=(int*)malloc(sizeof(int));//内存堆 p4=(int*)malloc(sizeof(int)*10);//内存堆 for(int i=0;i&lt;=9;i++)p4[i]=0x1;//内存栈 *p3=0x123; strcpy(p,&quot;123456789&quot;);//文字常量区 strcpy(p2,&quot;987654321&quot;); strcpy(p2,&quot;123456789&quot;); } 全局初始化区与静态初始化区是在同一段内存 连续分配的，按内存地址增长方向分配 全局初始化区与全局未初始化区不在同一段内存区，全局初始化区按内存地址增长方向分配，全局未初始化区没有规律 栈空间也是同一段内存 连续分配的，按内存地址减小方向分配 堆空间也是同一段内存 连续分配的，按内存地址增大方向分配 文字常量区在自己特有的内存段内，且有机制控制字符常量不被修改（当字符串相同的时候，系统有时还会将两个指针指向同一处） 代码2：在A.m里定义一个全局变量int i =1， 在B.m里直接访问。A中的任意方法都能访问i，但B中方法访问i时预编译不能通过，报use of undeclared identifier _i错误 在A.m里定义一个全局变量int i =1， 在B.m里 extern int i。A中的任意方法都能访问i，B中的方法对i也是可读可写。他们用的是同一个i 在A.m里定义一个静态全局变量static int i =1，在B.m里直接访问。A中的任意方法都能访问i，但B中方法访问i时预编译不能通过，报use of undeclared identifier _i错误 在A.m里定义一个静态全局变量static int i =1，在B.m里 extern int i;A中的任意方法都能访问i，但B中方法访问i时编译不能通过，报Undefined symbols i 错误 在A.m和B.m里分别定义静态全局变量static int i=200; static int i =300;则互不影响，有两个同名但不同存储位置的i，各源文件里的方法访问各自源文件里的i。 在A.m和B.m里分别定义静态全局变量static int i=200; 和全局变量 int i =300;仍然互不影响。如果我在A里extern int i了，A中方法访问的i仍然是200那个，而不是B中那个i 在A.m和B.m里分别定义全局变量int i=200; 和 int i =300;则编译不通过，报duplicate symbol _i错误同样在A.m和B.m里分别定义全局常量const int i =200;和全局变量int i =300 也编译不通过同样的上面7条都适用于全局常量。const int i = 11;和 static const int i =1不同的只是不加const可写，加了const只可读。 在A.h里声明全局变量extern int i;在A.m里定义全局变量int i = 1;在其他源文件里import “A.h”即可访问A中定义的i 全局变量加了static有内部之意，全局不加static则表示真正的全局 非静态全局变量具有全局作用域。 其只需在一个源文件中定义，就可以作用于所有的源文件。 其他不包括全局变量定义的源文件可以通过extern的方式引用。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jekyll的使用详解]]></title>
    <url>%2F2011%2F11%2F25%2FJekyll%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[上一章介绍了如何在GitHub Pages中搭建Jekyll，参照Jekyll官网给出的使用文档，这一章我们详细解读一下Jekyll，这是我后边找到的中文文档，可供参考 快速指南上一章简单说了，这是一个简单的静态网页生成器，具体的安装和使用方式请如下： ~ $ gem install jekyll ~ $ jekyll new myblog/. --force ~ $ cd myblog ~/myblog $ bundle install ~/myblog $ bundle exec jekyll serve =&gt; Now browse to http://localhost:4000 目录结构打开Jekyll生成的文件夹后，通过资源管理器可以观察到已经自动生成的目录结构，比较重要的几个如下： _config.yml :存储配置数据。把配置写在这个文件里面，可以让你不用在命令行中写 _drafts:草稿，格式是:没有日期.md _includes:包含一些模板，可以重复利用 _layouts:里面的文件通过{ content }包含_posts里面的文章 _posts:存放你要发表的文章。格式YEAR-MONTH-DAY-title.MARKUP _data:保存数据的。jekyll会自动加载这里的所有的YAML文件，如.yml、.yaml、.json、.csv等结尾的文件，比如你有一个members.yml。那么你可以通过site.data.members访问该文件里的数据 _site：jekyll生成的网站会放在该文件夹下，最好把它放到.gitignore文件里面，这样git就不会管理它了 .jekyll-metadata：这个文件帮助Jekyll记录网站文件的修改日志，在下一次生成网页的时候，只生成那些修改过的文件，这个文件可以加入到.gitignore文件中 index.html：网站首页，jekyll会自动转换并生成它 配置Jekyll有自带的默认配置，如果需要手动修改配置，则需要配置参考文档 头信息通过这个可以设置一些变量（甚至可以自定义变量），比如layout和title --- layout: post title: Blogging Like a Hacker --- 设置好变量以后，你就可以在当前页面或者你的页面依赖的_layouts或者_includes里的文件通过Liquid 标记，比如{page.title}访问了 撰写博客jekyll有一个最好的特性就是：你写文章并发表他们只是意味着你只要管理一些文本文件即可。而不需要配置和维护数据库以及良好的CMS系统 文章文件夹里面都是些md或者testile文件。只要有yaml front matter，它们就会被转换为html格式的静态页面 创建文章的文件创建一个文件YEAR-MONTH-DAY-title.md，YEAR是4位数，month和day是两位数 内容格式所有的文章都必须要有yaml front matter头 注意字符编码：将&lt;meta charset=&quot;utf-8&quot;&gt;包含在head标签里面来保证中文编码的正确性 引用图片和其它资源在根目录下创建文件夹比如assets和downloads，然后markdown语法访问通过这种形式：![截屏](/assets/screenshot.jpg) 说明：截屏链接的文字，（）里面的东西不会显示，是链接到的地址。site.url可以访问你配置的（_config.yml）的网站url 文章的目录 文章摘要 高亮代码片段通过Pygments or Rouge，Jekyll具有内建的语法高亮能力 使用草稿drafts里面的文章是你暂时不想发表的，并且可以没有日期前缀 jekyll serve –drafts 预览 jekyll build –drafts 编译 这两个方法可以使drafts中的草稿文章移动到posts中去，并且自动为其文件名加上当期日期的前缀 创建页面作为写文章的补充，Jekyll 还可以创建静态页面。利用 Jekyll 带来的便利，你只需要复制文件或文件夹，就是这么简单 主页像任何网站的配置一样，需要按约定在站点的根目录下找到 index.html 文件，这个文件将被做为主页显示出来。除非你的站点设置了其它的文件作为默认文件，这个文件就将是你的 Jekyll 生成站点的主页 其它的页面的位置将 HTML 文件或者 Markdown 放在哪里取决于你想让它们如何工作。有两种方式可以创建页面 将为页面准备的命名好的 HTML 文件或者 Markdown 文件放在站点的根目录下 在站点的根目录下为每一个页面创建一个文件夹，并把 index.html 文件或者 index.md 放在每个文件夹里 一般方式： |– _config.yml|– _includes/|– _layouts/|– _posts/|– _site/|– about.html # =&gt; http://example.com/about.html|– index.html # =&gt; http://example.com/└── contact.html # =&gt; http://example.com/contact.html 干净的url方式（不带有文件后缀） ├── _config.yml├── _includes/├── _layouts/├── _posts/├── _site/├── about/| └── index.html # =&gt; http://example.com/about/├── contact/| └── index.html # =&gt; http://example.com/contact/└── index.html # =&gt; http://example.com/ 静态文件为了渲染或转换内容，Jekyll提供了静态文件，静态文件中不包括YAML front matter，而是包括images，PDFs和一些没有被渲染的内容如果要访问这些静态内容，就需要用site.static_files中的metadata，如file.path/modified_time/extname 变量Jekyll会遍历带yaml front matter头的所有文件，然后都可以通过Liquid模板系统访问一些变量 全局变量 site：包含了网站信息和_config.yml里面的信息 page:在yaml front matter的自定义的变量通过page访问 layout:在yaml front matter的自定义的变量通过layout访问 content:_layouts里面，不定义在_post和其他页面中。包含了post和其他页面里面的文章内容 paginator:paginate在_config_yml里面配置以后，这个变量就可以用了 site变量 site.time:当前运行jekyll的时间 site.pages:所有的页面 site.posts:以时间逆序排序的所有的文章 site.data：包含从目录_data里面加载的数据列表 page变量 page.content:页面内容 page.title:文章标题 page.urL:页面地址：比如/2008/12/14/my-post.html page.date:页面的日期。可以在front matter重写：2008-12-14 10:30:00 +0900或者YYYY-MM-DD HH:MM:SS page.id:页面id。比如/2008/12/14/my-post 在RSS feeds里面有用 front matter里面可以自己定义变量：比如custom_css: true,然后你可以通过page.custom_css访问 Paginator变量 paginator.per_page：每一页的文章数 paginator.posts：那一页可用的文章 paginator.page：当前页的值 Paginator只在index.html(或者/blog/index.html)中有效 集合(Collections)并非所有的都会是文章或页面。也许您想要记录您开源项目中涉及的各种解决方案，团队成员，或是某次会议记录。集合（Collection）允许您定义一种新的文档类型，它既可以像页面和文章那样工作，也可以拥有它们特有的属性和命名空间 使用集合 让 Jekyll 读取您的集合:将下面的代码加入您的 _config.yml 文件，将my_collection 替换为您集合的名字 collections: my_collection: foo: bar 加入您的内容 选择性渲染你的集合文件为独立文件 Liquid 属性每个集合均可访问 Liquid 的site变量,每个集合都具有一个他本身的文档数组 数据文件除了 Jekyll 的内建变量之外，你还可以指定用于 Liquid 模板系统 的自定义数据。Jekyll 支持从 data 目录下的 YAML、JSON 和 CSV 载入数据，注意 CSV 文件必须包含表头行。这个强大的特性可以帮你避免模板中的重复，并能在不修改 _config.yml 的情况下设置网站特定的选项。 正如在目录结构中所描述的，_data 目录用于存储供 Jekyll 生成网站的附加数据。这些文件可以使用 .yml、.yaml、.json、csv 扩展名，并可通过 site.data 访问 资源Jekyll 提供了对 Sass 的内建支持，还能通过安装相应的 Ruby gem 支持 CoffeeScript。使用时只需创建以 .sass、.scss 或 .coffee 为扩展名的文件，并以两行 — 开头即可 博客迁移如果你要从其他博客迁移到 Jekyll，Jekyll 导入器可以帮助你]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Jekyll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在GitHubPages上搭建Jekyll]]></title>
    <url>%2F2011%2F10%2F28%2F%E5%9C%A8GitHubPages%E4%B8%8A%E6%90%AD%E5%BB%BAJekyll%2F</url>
    <content type="text"><![CDATA[在GitHub Pages上搭建blog，使我们既拥有绝对权限管理，又享受github带来的便利 Jekyll是一个静态站点生成器，提供了模板、变量、插件等功能，来生成整个网站 GitHub Pages是什么GITHUB是一种分布式的代码仓库管理工具，在GITHUB上每个项目都有一个主页，列出了项目的源文件。但是对于一个新手来说，看到一大堆源码，只会让人头晕脑涨，不知何处入手。他希望看到的是，一个简明易懂的网页，说明每一步应该怎么做。因此，github就设计了Pages功能，允许用户自定义项目首页，用来替代默认的源码列表。所以，github Pages可以被认为是用户编写的、托管在github上的静态网页。github提供模板，允许站内生成网页，但也允许用户自己编写网页，然后上传。有意思的是，这种上传并不是单纯的上传，而是会经过Jekyll程序的再处理。 Jekyll是什么Jekyll（发音/‘dʒiːk əl/，”杰克尔”）是一个静态站点生成器，它会根据网页源码生成静态文件。它提供了模板、变量、插件等功能，所以实际上可以用来编写整个网站整个思路到这里就很明显了。你先在本地编写符合Jekyll规范的网站源码，然后上传到github，由github生成并托管整个网站。 如何实现 注册登录GIT账号 在账号下添加新的git仓库（用户名+github+io） 安装jekyll并创建jekyll目录 安装jekyll目录需要的bundle包 创建Markdown或HTML页面 启动jekyll服务，通过http://localhost:4000访问并验证 将代码上传至github，通过域名来访问]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Jekyll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法的使用]]></title>
    <url>%2F2011%2F09%2F30%2FMarkdown%E8%AF%AD%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[从今天开始，坚持写博客，一般博客中会用到Markdown语法，先找一篇文章来学习总结一下其语法 Markdown语法的目标是实现易写易读，下边的内容就是介绍如何使用Markdown语法 嵌套HTMLMarkdown的语法在HTML标签中无效，但是HTML标签在Markdown语法中是可以直接使用的 特殊字符自动转换在HTML中，有两个字符需要特殊处理:&lt;和&amp;，如「AT&amp;T」 ，你必须要写成「AT&amp;T」，但是在Markdown中，他们可以进行自动转换，不需要特殊处理 段落和换行在Markdown中如果需要换行，则在行尾加上两个以上的空格，然后按回车键 标题Markdown支持两种标题语法，Setext和atx形式 Setex形式是用底线的形式，利用=(大标题)和-(小标题) Atx形式是在行首插入1到6个#，对应标题的大小 引言如果需要在文章中插入引言，则需要在每行的最前面加上&gt;，在引言中可以插入引言和其它的Markdown语法 列表Markdown支持有序的列表和无序的列表，列表中可以嵌套其它的Markdown语法，如引言或代码块 有序列表使用数字接着一个英文句号开头，然后一个空格或制表符 无序的列表使用星号／加号／减号作为列表标记，然后一个空格或制表符 程序块HTML会用&lt;pre&gt;和&lt;code&gt;标签把程序块包起来，Markdown直接简单地缩排4个空格或1个Tab就可以，这样就会转化成HTML的格式 分隔线可以在一行中用三个或以上的*,-,_来建立一个分隔线，行内不能有其他东西 链接Markdown支持两种形式的链接语法，行内和参考，不管用哪一种，链接的文字都是用[方括号]来标记 行内：在方括号的后面马上接着圆括号并插入网址链接即可 参考：在方括号的后面再跟一个方括号，方括号里边填入链接的标签，在文件的任意处，把标签的链接内容定义出来，定义形式为：[foo]: http://example.com/ “Optional Title Here” 强调Markdown使用星号(*)和下划线(_)作为标记强调的标记，被他们包围的文本会转化成斜体文本，用两个包围起来的话，则会被转化成加粗文本，如果要在蚊子前后直接插入普通的星号或下划线，可以用反斜线转义 程序码如果要标记行内一小段程序，可以用反引号把它包围起来 图片Markdown使用一种和链接很相似的语法来标记图片，同样允许两种样式：行内和参考 自动链接只要用方括号扩起来的字符，Markdown就会自动生成链接，链接的文字和链接位置一样，如&lt;http://example.com/&gt; 转义字符如果需要在Markdown中插入一些语法已标记字符，可以在前边加反斜线进行专义]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIS的一些基本概念]]></title>
    <url>%2F2011%2F08%2F26%2FGIS%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[前些天无聊至极，就翻阅了超图公司的 GIS Deskpro 相关产品的帮助文档，感觉对了解他们公司产品和服务没有多大的帮助，反倒觉得那帮助文档是一个很好的全面学习GIS专业知识的好帮手，现在把自己这几天学习到的东西整理一下下： 各桌面产品与功能模块:各桌面产品与功能模块包括： 桌面集成环境 地图模块 标准图幅图框模块 编辑模块 属性模块 配准模块 布局模块 三维模块 栅格分析模块 网络分析模块 工作空间工作空间用于保存用户的工作环境，包括： 当前打开的数据源（位置、别名和打开方式） 底图 专题地图 布局 符号库 线型库等 数据源数据源是由各种类型的数据集（如点、线、面类型数据，TIN、GRID、NetWork）组成的数据集集合, 数据源的属性包括数据源的基本信息和数据源的投影信息 数据集数据集是由同种类型数据组成的数据集合,包括十六种： 纯属性数据集 点数据集 线数据集 面数据集 文本数据集 网络数据集 三维点数据集(文本文件\属性生成或点数据集转换) 三维线数据集 CAD数据集 TIN数据集 路由数据集(存放线类型的数据，线对象的每个节点除了有地理坐标值，还有一个M坐标值，代表该节点到起点的距离) 影像数据集 DEM数据集 Grid数据集 MrSID数据集 ECW数据集 SDB 数据源一个SDB数据源文件包括SDB和SDD两个文件，由SDB文件存储空间数据，由SDD存储管理属性数据。SDD文件其实就是一个Access数据库，它管理着数据源中各数据集对应的属性表。一个数据集对应连接一个属性表，系统通过唯一标识SmID将数据集的每一个对象与对应属性表中的记录进行连接，建立起一一对应的关系。 地图的属性地图的属性，包括地图的信息以及地图上对象的设置信息 TININ是不规则三角网（Triangulated Irregular Network）的缩写，它是采用不规则三角形拟合地表。TIN数据集由存储有Z值的点组成，通过边相连形成连续的不重叠的三角面。主要用来描述数字高程表面。 TIN 的创建TIN通常可以由多种类型矢量数据集来创建, SuperMap 桌面产品提供了把点/三维点/线数据集转换成TIN数据的功能。 DEMDEM（Digital Elevation Modals，数字高程模型）是地面特性为高程和海拔高程的数字地面模型（DTM）。 DEM数据集可以通过线数据集、点线数据集联合以及TIN数据集来生成。 布局布局就是地图（包括专题图）、图例、地图比例尺、方向标图片、文本等各种不同地图内容的混合排版与布置，主要用于电子地图和打印地图。 创建布局创建一个布局就是将所需的布局元素添加到布局窗口中加以整理与修饰，以达到地图所要表示的用途。而布局元素包括了一些地图元素（地图、比例尺、方向标、图例、专题图图例）、绘制元素（点、直线、折线、矩形、圆角矩形、椭圆和多边形）、标注元素（文本和艺术字）和其他相关元素（表格和图片）。 DirectXDirectX加强3d图形和声音效果，并提供设计人员一个共同的硬件驱动标准，让游戏开发者不必为每一品牌的硬件来写不同的驱动程序，也降低用户安装及设置硬件的复杂度。 SuperMap SDX+SuperMap SDX+是SuperMap的空间引擎技术，它提供了一种通用的访问机制（或模式）来访问存储在不同引擎里的数据。这些引擎类型有数据库引擎、文件引擎和 Web 引擎. 引擎优化: 选择合适的硬件平台内存、硬盘、网络 选择使用文件缓存功能 为Layer设置合适的MinVisibleGeometrySize属性值 建立空间索引 建立空间索引 影像数据的优化 SuperMap SDX+ 空间索引 R树索引：R树空间索引方法是通过设计虚拟的矩形目标，将一些空间位置相近的目标对象，包含在这个矩形内，把这些矩形作为空间索引，它含有所包含的空间对象的指针。 四叉树索引： 图库索引 ：根据数据集的某一属性字段或根据给定的一个范围（图幅的长和宽），将空间对象进行分类，通过索引进行管理已分类的空间对象，以此提高查询检索速度。 动态索引：将数据集按照一定的规则划分成相等或不相等的网格，记录每一个地理对象所占的网格位置。在GIS中常用的是规则网格。当用户进行空间查询时，首先计算出用户查询对象所在的网格，通过该网格快速查询所选地理对象。可以优化查询操作。 事务的四个属性在数据库应用程序中，事务是一个比较常见的概念，它是作为单个逻辑工作单元执行的一系列操作。一个逻辑工作单元必须有四个属性，称为ACID（原子性、一致性、隔离性和持久性）属性，只有具备这些属性才能成为一个事务。 原子性:原子性决定事务不可分割，事务必须是原子工作单元，对于其数据所作的修改必须是全执行或全不执行。 一致性:事务在完成时必须使所有的数据都保持一致状态。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。事务结束时所有的内部数据结构（如B树索引或双向链表）都必须是正确的。 隔离性:由并发事务所作的修改必须与其它并发事务所作的修改隔离。事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据，这称为可串行性，因为它能够重新装载起始数据，并且回滚一系列事务，以使数据结束时的状态与原始事务执行的状态相同。 持久性:事务完成之后，它对于系统的影响是永久性的，即使出现系统故障，事务所作的修改也将一直保持。 地图投影的目的地图投影的目的：地球椭球体表面是曲面，而地图通常要绘制在平面图纸上，因此制图时首先要把曲面展为平面。然而球面是个不可展的曲面，所以必须采用特殊的方法将曲面展开，使其成为没有破裂或褶皱的平面，于是就出现了地图投影理论。 地球椭球体地球椭球体（Sphere/Spheroid）由于地球形状的不规则性，不同国家在不同的历史时期对地球进行过无数次测量，导致出现了大量的椭球体，但是由于没有一个椭球体能够准确的描述地球的整体形状，所以在应用时应该根据各个国家或地区的具体情况选择合适的地球椭球体。 大地参照系大地参照系（Datum）大地参照系确定了地球椭球体相对于地球球心的位置，为地表地物的测量提供了一个参照框架，确定了地表经纬网线的原点和方向 地理坐标系地理坐标系（Geographic Coordinate System）一般情况下，一个地理坐标系由三部分组成：大地参照系（Datum），本初子午线（Prime Meridian），角度单位（Angular Units）。 投影坐标系投影坐标系（Projected Coordinate System）投影坐标系是与地理坐标系相对的一个概念，是将椭球面上的点通过地图投影的方式投影到（地图）平面上，分为平面极坐标系和平面直角坐标系。平面直角坐标系按照直角坐标原理确定一点的平面位置，由原点及通过原点的两个垂直相交轴组成，这种坐标也叫笛卡尔坐标或直角坐标。测绘中的直角坐标系与数学中的不同点是，X轴和Y轴互换。 一般情况下，一个投影坐标系包含以下几部分，投影坐标系的名称，坐标单位，投影方式，地理坐标系，投影参数。投影参数常用的有以下几种:地图投影的方法： 几何透视法:以平面、圆柱面、圆锥面为承影面，将曲面（地球椭球体面）转绘到平面（地图）上的一种古老方法 数学解析法:是建立地球椭球体面上的经纬网与平面上相应经纬网之间对应关系的方法。实质就是直接确定球面上某点的地理坐标与平面上对应点的直角坐标之间的函数关系。当前绝大多数地图投影都采用这种方法。 地图投影分类 按投影变形性质分类:按照投影的变形性质可以分为以下几类：等角投影、等积投影、任意投影（等距投影是其中特例）。 按投影构成方式分类:根据投影构成方式可以分为两类：几何投影和解析投影。 几何投影包括方位投影、圆锥投影和圆柱投影。根据投影面与球面的位置关系的不同又可将其划分为：正轴投影、横轴投影、斜轴投影解析投影是不借助于辅助几何面，直接用解析法得到经纬网的一种投影。主要包括：伪圆锥投影，伪圆柱投影，伪方位投影，多圆锥投影。 投影方法目前常用的投影方法有莫卡托投影（正轴等角圆柱投影）、高斯-克吕格投影（等角横切圆柱投影）、UTM 投影（等角横轴割圆柱投影）、Lambert投影（等角正割圆锥投影）等。 莫卡托投影是一种“等角正切圆柱投影” 高斯-克吕格(Gauss-Kruger)投影，是一种“等角横切圆柱投影” UTM投影全称为“通用横轴墨卡托投影”，是一种“等角横轴割圆柱投影” 兰勃托(Lambert)投影，又名“”等角正割圆锥投影”， 坐标系分类数据的坐标系分为三类：平面坐标系、地理坐标系、投影坐标系。 ##数据编码数据编码：是数据在计算机中的存储方式。通常用来减少数据所占的存储空间以及提高数据的安全性，或者作为一种数据交换的格式。GIS数据分为有编码与无编码两种，而采用编码的主要目的，是用一定的压缩方法减少海量数据的存储，大大提高磁盘读写和网络传输的效率，显著提高性能。数据编码是一个压缩的概念，类似于ZIP，RAR等，矢量数据集有多种编码方式，典型的有SDC和SWC两种。 SWC，WORD编码类型，应用于矢量数据集（线、面类型）的一种编码方式，对点数据集不起作用。压缩比为4倍。精度损失为1/216。数据集中对象大小比较平均的情况下，推荐使用此种编码方式。SDC，DWORD编码类型，应用于矢量数据集（线、面类型）的一种编码方式，对点数据集不起作用。压缩比为2倍。精度损失为1/232，按照全球大小的对象估计，精度损失在毫米级。总结其优势：压缩速度快，损失小，原图和编码后的图对比浏览时，基本看不到差别。可以说SDC是几乎接近无损的一种编码方式，一般的数据推荐使用SDC。对一些在空间上相邻，有公共边的面状数据，用SDC编码完全没有问题，但用SWC，在放大很大时会有缝隙显现。数据压缩的代价：压缩之后的数据不可逆，即不可以返回数据压缩之前的状态，此外在精度上有一定的损失，对查询和分析有影响，如果进行非常精确的查询和空间分析等，SWC会导致一些结果上的误差，但SDC不会有影响，其产生的精度损失在空间分析的容限范围之内。 地图缓存地图缓存是一种用于改善地图浏览用户体验的优化策略。服务器端创建了地图缓存之后，客户端用户的每一次地图浏览，比如平移、放大、缩小地图，都会向服务器端发送一个URL请求，此时，服务器端按照匹配的条件，将已缓存的图片返回到客户端。通常将服务器端在发布地图服务之前，已经创建的地图缓存称为预缓存。 为什么使用地图缓存只需要付出一次缓存的代价，就可以提供给客户端地图显示以快速的响应速度。地图缓存是以一系列不同比例尺下地图图片形式提供的，因此不受矢量地图显示上的约束，比如地图信息量的大小、地物的复杂程度、是否带有标注、所使用的地图符号等限制。因为，一般情况下，地图渲染的细节越多，承载的信息量越丰富，同等环境下，绘制矢量地图就越慢，但使用了地图缓存，客户端在获得了同样分辨率显示效果的同时，等待时间却大大缩短，增强了用户的体验，满足系统对快速地图响应的要求。 GIS一般出现的问题与优化方法： 地图反走样 交叉线优化 图层顺序调整 文本层叠优化 地图显示速度优化 反走样 (antialiasing)：在光栅图形显示器上绘制非水平且非垂直的直线或多边形边界时，或多或少会呈现锯齿状或台阶状外观。这是因为直线、多边形、色彩边界等是连续的，而光栅则是由离散的点组成，在光栅显示设备上表现直线、多边形等，必须在离散位置采样。由于采样不充分重建后造成的信息失真，就叫走样(aliasing)。而用于减少或消除这种效果的技术，就称为反走样(antialiasing)。通过地图优化可以去除一些呈现锯齿状或台阶状的显示，提高地图的美观性：一般提高显示速度最好的方法就是减少地图中图层和显示对象，这样将减少系统更新，达到提供显示速度的目的。 地图显示速度优化 对象过滤显示过滤对象尺寸、过滤显示条件、文本字高过滤显示 图层过滤显示 层是否可显示、图层比例尺过滤显示 地图缓存用“地图缓存”功能对当前地图按照设置的比例尺和缓存范围生成一系列的缓存图片。在浏览此地图时可以直接读取缓存中的图片，从而提高地图显示的速度 建立索引提高矢量数据的查询、访问、排序、浏览等操作，提供了多种文件索引，包括字段索引、四叉树索引、R树索引、动态索引和图库索引（原三级索引） 创建影像金字塔 金字塔是栅格数据集的简化分辨率（reduced resolution）图像的集合。影像金字塔技术通过影像重采样方法，建立一系列不同分辨率的影像图层，每个图层分割存储，并建立相应的空间索引机制，从而提高缩放浏览影像时的显示速度。 无地图缩放动画效果 专题图种类SuperMap总共提供了七种专题图以供选择。从图中可以看出，单值专题图，范围分段专题图，统计专题图都具有专题图标签，它们在地图中显示为多种风格，在此称为多元风格专题图。而其他的等级符号专题图、点密度专题图、标签专题图和自定义专题图仅有一个专题图项，没有专题图标签，它们在地图中显示为单一风格，在此称为单一风格专题图。 多元风格专题图这些图都有配色方案，都有标签，都可以设置多个字段（值），在地图中显示可以用多种符号（线型、填充）来表达字段（值）信息，地图画面较为丰富。 单一风格专题图：只能设置一个字段通过一种符号（线型、填充）来表达字段值的信息 地图分类地图一般分为普通地图和专题地图，根据功能的不同又从专题地图里划分了统计地图。 普通地图是以相对均衡的详细程度表示制图区域内各种自然和社会经济现象的地图。其内容包含全地图要素 题地图是以普通地图为地理基础，着重表示制图区域内某一种或几种自然或社会经济现象的地图。这类地图的显著特点是，作为该图主题的专题要素予以详尽表示，其地理基础内容则视主题而异 常用的颜色模式： RGB 模式：RGB 是Red（红色）、Green（绿色）、Blue（蓝色）的缩写。由红、绿、蓝相叠加可以产生其它颜色，因此该模式也叫加色模式 CMYK 模式：CMYK 是Cyan（青）、Magenta（洋红）、Yellow（黄色）以及Black（黑色）的缩写。与RGB模式不同的是它的颜色合成方式不是颜色相加，而是颜色相减 HLS 模式：HLS 是Hue(色调)、Luminance(亮度)、Saturation(饱和度)的缩写。 色调色调是颜色的一种属性，它实质上是色彩的基本颜色，即我们经常讲的红、橙、黄、绿、青、蓝、紫七种，每一种代表一种色调。色调的调整也就是改变它的颜色。 亮度亮度就是各种颜色的图形原色（如RGB的原色为R、G、B三种或各种自的色调）的明暗度，亮度调整也就是明暗度的调整。而我们通常讲的灰度图像，就是在纯白色和纯黑色之间划分了多个级别的亮度，也就是从白到灰，再转黑。同理，在RGB 模式中则代表个原色的明暗度，即红绿蓝三原色的明暗度，从浅到深。 饱和度饱和度是指图像颜色的彩度.对于每一种颜色都有一种人为规定的标准颜色，饱和度就是用描述颜色与标准颜色之间的相近程度的物理量。调整饱和度就是调整图像的彩度。将一个图像的饱和度条为零时，图像则变成一个灰度图像。 地理空间数据交换格式地理空间数据交换格式（Geo-spatial data transfer format）分为矢量、影像和格网三类。其中矢量交换格式，是以VCT为扩展名。 对象（object）：即几何对象，在GIS中对离散空间实体的数字化表示。一个对象具有自己的属性和行为。单一对象（Single Object）：子对象（part）：简单对象（Simple Object）：复杂对象（Complex Object）：复合对象（Compound Object）：参数化对象：对象类型：绘制对象类型 对象运算对象运算主要包含了合并、求交、交集取反、擦除、擦除外部、组合、分解和保护性分解共8中对象运算方式。合并是同类型融合起来，组合是CAD图中的图形组合起来。参与操作的对象为非岛洞多边形的复杂面对象，则分解与保护性分解效果相同。 空间数据的查询和分析空间数据的查询和分析在GIS工程项目中处于核心地位，在使用GIS数据时，我们经常需要从已有的数据中查询出部分满足特定条件的数据。GIS 中的查询类型一般可以分为以下三种：单纯的属性查询、单纯的空间查询、以及与空间位置和属性同时相关的综合查询 SQL语句SQL语句是标准的计算机查询语句，SuperMap中的许多查询功能都是通过构建SQL语句来完成的,SQL表达式的语法为“Select …（需要输出的字段名） from … （数据集名）where…（查询条件）(order by …ascending/descending)（结果排序字段，可选）”。 对数值的查询 :对数值的查询可以使用＝, &lt;&gt;, &gt;, &lt;, &lt;=, &gt;=, Between 等等 模糊查询:模糊查询使用like，而且不同类型的数据源使用的匹配符不尽相同 查询特定值 :使用in，确定表达式的值是否等于指定列表内若干值中的任意一个值 查询某个字段值是否为空 ,使用is NULL (is not NULL) 通过构造语句进行查询 组合语句 :使用and，将两个或者多个查询语句组合起来 比较运算符在字符型字段中的应用 日期型字段的查询 :World_countries.dat = #08/10/94# 派生字段(Pop_2000-Pop_1990)/Pop_1990 as Growth_Rate SQL特殊 系统中提供的SQL查询条件运算符除了常用的数学运算符和逻辑运算符外，还提供了一些比较特殊的运算符 聚合函数对一组值执行计算并得到单一的值。除 COUNT 函数之外，聚合函数忽略空值。聚合函数经常与 SELECT 语句的 GROUP BY 子句一同使用。所有聚合函数都具有确定性。任何时候用一组给定的输入值调用它们时，都得到相同的值。除 COUNT() 外，其它聚合函数均不能对文本数据类型使用. 数学函数对数字表达式进行数学运算并返回运算结果。 数学函数在 SuperMap 中的表达式一般采用属性表的字段名或字段名构成的表达式，如Cos(Slope）、Ceiling(Pop/Area)等 字符串函数用于对字符和二进制字符串进行各种操作，它们返回对字符数据进行操作时通常所需要的值 日期函数用来显示关于日期的信息。这些函数适用于日期类型字段值，并对这些值执行算术运算。可将日期函数用于可使用表达式的任何地方。 空间查询空间查询是通过几何对象之间的空间位置关系来构建过滤条件的一种查询方式。相对于完全由属性过滤条件构建的基于属性的查询，基于空间位置关系且同时可以应用属性过滤条件的称为空间查询。 查询模式22种空间查询模式，其中有9种为基本算子，3种常用算子，10种为组合算子。空间查询涉及三个要素，分别是：搜索对象、被搜索图层及结果记录集]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>GIS</tag>
        <tag>SuperMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构在GIS中的应用]]></title>
    <url>%2F2011%2F07%2F29%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9C%A8GIS%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[计算机是一门研究用计算机进行信息表示和处理的科学。数据结构是数据在计算机中的逻辑和存储结构，GIS是地理信息系统的缩写，地理信息在计算机中的存储和应用非常普遍，所以，本篇文章将会探讨如何利用数据结构的知识，方便而快速的保存和处理地理信息。 这里面涉及到两个问题：信息表示、信息处理，信息表示会影响信息处理 数据结构研究的是信息表示的问题 算法研究的是信息处理的问题 信息表示直接关系到信息处理的算法与效率。信息 （数据）之间往往是有重要的结构关系，数据结构就是对数据表示以及其上操作或功能的封装，分逻辑结构和存储结构两个层面。 逻辑结构逻辑结构定义了数据之间的逻辑结构关系。 数据元素相互之间的关系称为结构，有四类基本结构：集合、线性结构、树形结构、图状结构（网状结构）。 集合结构中的数据元素除了同属于一种类型外，别无其它关系 线性结构中元素之间存在一对一关系 树形结构中元素之间存在一对多关系 图形结构中元素之间存在多对多关系 存储结构存储结构定义了数据实际在计算机中存储结构关系，是某种逻辑结构在计算机上的具体实现，分顺序存储结构和链式存储结构。 顺序存储方法：它是把逻辑上相邻的结点存储在物理位置相邻的存储单元里，结点间的逻辑关系由存储单元的邻接关系来体现，由此得到的存储表示称为顺序存储结构。顺序存储结构是一种最基本的存储表示方法，通常借助于程序设计语言中的数组来实现。 链接存储方法：它不要求逻辑上相邻的结点在物理位置上亦相邻，结点间的逻辑关系是由附加的指针字段表示的。由此得到的存储表示称为链式存储结构，链式存储结构通常借助于程序设计语言中的指针类型来实现。 索引存储方法：除建立存储结点信息外，还建立附加的索引表来标识结点的地址。 散列存储方法：就是根据结点的关键字直接计算出该结点的存储地址。 在GIS开发实现中，空间索引、空间数据存储、地图管理、地图符号化及渲染、空间分析等都会用到很多的数据结构，下面作一些简要介绍，仅供参考，读者可以有不同的实现，效率也会有一些差异。 数组和链表数组或链表，在GIS中应用最为广泛，几乎到处可见其身影。比如，线或多边形就是Point类型的数组，读shapefile文件时，文件已经记录下该要素包含的点数，数组的长度就被确定了，如果添加节点，最好采用封装好的动态数组或链表来存储；网格索引，用二维数组表示，每个数组元素记录下该网格范围所对应的数据存储地址，方便空间数据的检索；图层管理，一张地图是由若干个图层叠加而成，用数组或链表来存储这些图层信息，图层顺序调的整转化为数组或链表的删除和插入。 堆栈和队列堆栈和队列，也属于线性结构，只是比数组和链表多了一些限制，堆栈是先进后出，队列是先进先出。比如，线性四叉树索引，用中序遍历的方法降四叉树线性化，其中树的中序遍历，非递归算法就需要用到堆栈；GPS轨迹跟踪，随着GPS点的增加，轨迹会越来越长，在实时跟踪过程中，可能只需要保留当前最近一段时间的点，更早之前的点被保存到数据库中，不再绘制，所以，采用循环队列来存储GPS当前一些点，利用了GPS时间顺序先进先出的特点，同时能循环利用队列；客户端图片瓦片缓存池，也可以采用循环队列，当前可视范围内获取到的新瓦片插入到队列中，当队列满的时候，淘汰最早存放在队列中的瓦片，同时保持队列缓存池的容量。 优先队列优先队列，是不同于先进先出队列的另一种队列，每次从队列中取出的是具有最高优先权的元素，二叉堆就是优先队列，分最大堆和最小堆，它能快速地从一个集合中找出最大（小）的元素。最优路径，算法中经常执行一步就是从后继节点中找出最优的节点，采用的就是最小堆，它能迅速地找出到当前节点权值最小的节点。 树树，是一种递归定义的数据结构，一对多的关系，树是没有回路的连通图。四叉树索引，就是典型的树结构，按MBR（Minimum Bounding Rectangle 最小外包矩形）相交条件从树根一步步往下查找，筛选出要素子集；OGC中XML解析，XML（GML）结构本身也是树状结构；等高线，嵌套关系的表达，是树结构；属性数据词典库，采用Trie数据结构，多叉树的形式，建立属性词典库，通过字符串的匹配实现属性查询。 图图，是一种数据元素间为多对多关系的数据结构，通常采用邻接矩阵或邻接表的方式来存储。道路网或管网的拓扑构建，道路网或管网属于网状结构，用图来描述节点与弧段之间的拓扑关系，便于最优路径、最大流最小割通路、爆管、旅行商等网络分析。 哈希哈希，设计Hash函数代入key算出地址，存储value值，哈希查找效率高，但可能存在冲突，对内存空间占用相对较大一点。道路网或管网构建，以节点的node_id为key，以后继节点的集合为value；GML引擎，以图层编号为key，属于该图层的要素集合为value；线标注，线被裁减后，通过统一的key来拼接，以不同裁减路段集合为value。 以上简要介绍了GIS常用数据结构，但应用远远不止这些。数据结构＋算法＝程序，在数据表示和处理上，具体采用哪种逻辑结构，需要分析数据元素之间的逻辑关系，而确定了逻辑结构，还要考虑采用什么存储结构来实现，也是需要根据实际情况来分析的，数据结构直接关系到算法的具体实现及效率，在GIS开发实现中应用非常广泛。]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>GIS</tag>
      </tags>
  </entry>
</search>
