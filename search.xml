<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[京东MVCS框架]]></title>
    <url>%2F2018%2F01%2F26%2F%E4%BA%AC%E4%B8%9CMVCS%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[京东MVCS框架搭建 NSObject+SYKVO.h/NSObject+SYKVO.m typedef void(^SYKVOBlock)(id newValue); @interface NSObject (SYKVO) - (void)addObserverSuny:(NSObject *)observer keyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options block:(SYKVOBlock)block; // 默认是NSKeyValueObservingOptionNew - (void)addObserverSuny:(NSObject *)observer keyPath:(NSString *)keyPath block:(SYKVOBlock)block; @end CSBaseStore @protocol CSBaseStore &lt;NSObject&gt; - (CSBasePipeline*)pipeline; @end @interface CSBaseStore : NSObject&lt;CSBaseStore&gt; - (void)fecthSeverData; @end CSBasePipeline @interface CSBasePipeline : NSObject @end CSBaseViewController @interface CSBaseViewController : UIViewController @property (nonatomic, strong)CSBaseStore *store; - (instancetype)initWithViewClass:(Class)viewClass store:(CSBaseStore*)store; - (void)setupPipeline:(CSBasePipeline*)pipeline; - (void)addObserver; @end @interface CSBaseViewController () @property (nonatomic, strong)Class viewClass; @end @implementation CSBaseViewController - (instancetype)initWithViewClass:(Class)viewClass store:(CSBaseStore*)store{ self = [super init]; if (self) { self.viewClass = viewClass; _store = store; } return self; } - (void)loadView{ self.view = [self.viewClass new]; } - (void)viewDidLoad { [super viewDidLoad]; [self setupPipeline:_store.pipeline]; [self.view setupPipeline:_store.pipeline]; [self addObserver]; } - (void)setupPipeline:(CSBasePipeline*)pipeline{ } @end UIView+CSBase @interface UIView (CSBase) - (void)setupPipeline:(CSBasePipeline*)pipeline; @end @implementation UIView (CSBase) - (void)setupPipeline:(CSBasePipeline*)pipeline{ } @end CSBaseScene @interface CSBaseScene : NSObject @property(nonatomic, strong)Class viewClss; @property(nonatomic, strong)Class controllerClass; @property(nonatomic, strong)Class storeClass; - (instancetype)initWithScenceWithViewClass:(Class)viewClass controllerClass:(Class)controllerClass store:(Class)storeClass; @end @implementation CSBaseScene - (instancetype)initWithScenceWithViewClass:(Class)viewClass controllerClass:(Class)controllerClass store:(Class)storeClass{ self = [super init]; if (self) { NSAssert([viewClass isSubclassOfClass:[UIView class]], @&quot;%@必须是UIView的子类&quot;, NSStringFromClass(viewClass)); NSAssert([controllerClass isSubclassOfClass:[CSBaseViewController class]], @&quot;%@必须是CSBaseViewController的子类&quot;, NSStringFromClass(controllerClass)); NSAssert([storeClass conformsToProtocol:@protocol(CSBaseStore)], @&quot;%@必须实现CSBaseStore协议&quot;, NSStringFromClass(storeClass)); _viewClss = viewClass; _controllerClass = controllerClass; _storeClass = storeClass; } return self; } @end CSBaseMediator @interface CSBaseMediator : NSObject + (UIViewController*)viewControllerWithScreen:(CSBaseScene*)scene; @end @implementation CSBaseMediator // 1 数据 2 控制器和视图 + (UIViewController*)viewControllerWithScreen:(CSBaseScene*)scene{ CSBaseStore *store = [scene.storeClass new]; // pipeline UIViewController* viewCtr = [[scene.controllerClass alloc] initWithViewClass:scene.viewClss store:store]; return viewCtr; } @end CSBaseService @interface CSBaseService : NSObject @end @implementation CSBaseService @end CSBaseStorage @interface CSBaseStorage : NSObject - (NSData*)readDataFromFile:(NSString*)filePath; - (BOOL)writeDataToFile:(NSString*)filePath; @end @implementation CSBaseStorage @end AppDelegate - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { CSBaseScene *homepageScene = [[CSBaseScene alloc] initWithScenceWithViewClass:[HomePageView class] controllerClass:[HomePageViewCtr class] store:[HomePageStore class]]; UIViewController *homePage = [CSBaseMediator viewControllerWithScreen:homepageScene]; // HomePageViewCtr *homePage = [HomePageViewCtr new]; UINavigationController *nav = [[UINavigationController alloc] initWithRootViewController:homePage]; self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds]; self.window.backgroundColor = [UIColor whiteColor]; self.window.rootViewController = nav; [self.window makeKeyAndVisible]; return YES; } HomePageViewCtr @interface HomePageViewCtr : CSBaseViewController @end @interface HomePageViewCtr () @property (nonatomic, strong)HomePagePipeline *homepagePipeline; @end @implementation HomePageViewCtr - (void)viewDidLoad { [super viewDidLoad]; self.title = @&quot;Home&quot;; [self.store fecthSeverData]; } //在框架里面进行掉用了，只需要赋值就ok了 - (void)setupPipeline:(__kindof CSBasePipeline*)pipeline{ _homepagePipeline = pipeline; } - (void)addObserver{ [_homepagePipeline addObserverSuny:self keyPath:@&quot;clipButton&quot; block:^(id newValue) { NSLog(@&quot;点击事件，做push处理或者其他处理&quot;); }]; [_homepagePipeline addObserverSuny:self keyPath:@&quot;isLoading&quot; block:^(id newValue) { NSLog(@&quot;处理网络数据&quot;); }]; } @end HomePageView @interface HomePageView : UIView @end @interface HomePageView () @property (nonatomic, strong)HomePagePipeline *homepagePipeline; @end @implementation HomePageView //在框架里面进行掉用了，只需要赋值就ok了 - (void)setupPipeline:(__kindof CSBasePipeline*)pipeline{ _homepagePipeline = pipeline; } - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event{ _homepagePipeline.clipButton = YES; } @end HomePagePipeline @interface HomePagePipeline : CSBasePipeline @property (nonatomic, strong)FctPipeline *fctPipleline; @property (nonatomic, assign)BOOL clipButton; @property (nonatomic, assign)BOOL isLoading; @property (nonatomic, strong)NSMutableArray *netArr; @end @implementation HomePagePipeline @end HomePageStore @interface HomePageStore : CSBaseStore - (void)fecthSeverData; @end @interface HomePageStore () @property (nonatomic, strong)HomePagePipeline *homePagePipeline; @end @implementation HomePageStore{ HomePagePipeline *_homePagePipeline; } - (CSBasePipeline*)pipeline{ return self.homePagePipeline; } - (HomePagePipeline*)homePagePipeline{ if (!_homePagePipeline) { _homePagePipeline = [HomePagePipeline new]; } return _homePagePipeline; } // 进行网络数据下载操作 - (void)fecthSeverData{ [self performSelector:@selector(loadingFinish) withObject:nil afterDelay:3]; } - (void)loadingFinish{ self.homePagePipeline.isLoading = YES; self.homePagePipeline.netArr = [NSMutableArray array]; } @end]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大四毕业有感]]></title>
    <url>%2F2012%2F06%2F22%2F%E5%A4%A7%E5%9B%9B%E6%AF%95%E4%B8%9A%E6%9C%89%E6%84%9F%2F</url>
    <content type="text"><![CDATA[这些天忙着写毕业设计，一直没发博。。。 转眼间，都大四要毕业了，今天毕业倒计时了 回想大一时光，那时候学校还在南充，记得一个人去南充，坐汽车，转火车，再转火车，又转汽车，辗转来到南充校区，然后就在那里开始了我人生中前两年的大学时光。现在想起来，那时候才是一个真正上进的好学生，每天早上坚持上早读，坚持上课，然后吃午饭，吃完午饭午睡一觉，下午有课就去上课，没课就去上自习。那时候坚持每天写作业，积极参加一些素质拓展，社团活动，还参加了青志协和学宣部的面试什么的，但是说起面试，我面试好像都没有怎么成功过，可能是与人交流不咋地吧。所以就好好练习说话，练口才，整天进图书馆看各方面的书。但是效果不怎么样，脸皮太薄太追求完美可能就是我失败的原因吧，那时候整天想着如何出人头地，如何做个成功人士，如何改变我在别人心目中的形象之类的。 大二的时候，参加了勤工助学，有幸认识了一个同级的小女生，一直想追，不过等到有关她的消息打探清楚后，才知道她是有男朋友的，所以YY便成了我每天的必修课，好像从那时候起，我便学会了YY，整天在YY，YY着她分手了，YY着我和她在一起了，YY着把她带我家去了，从那以后，我便深深喜欢上了YY，干什么事情都要首先YY一番，满足一下我的虚荣心，然后再拿现实做比较，真是惨不忍睹，事情过去之后再YY当时应该怎么做，就这样，大二的时光被我YY完了。 转眼大三了，学校搬到成都了，一下子感觉自己老了许多，当一名老师在台上激情的讲如何创业，做一名成功人士等等的时候，我完全感到自己的心已经老了，没有精力去听这些东西，没有心情听这些东西，要知道如果是两年前刚入校的我是肯定不会错过这次机会的，而现在的我呢，满不在乎，I don’t care。而那时候我care的是什么东西呢，我care的是奖学金，是钱，是班长，是权，是证书，是荣誉。还清楚的记得我为了拿奖学金，如何半夜11点多都还在背什么是影像图，什么是元数据，为了当上班长，如何拉票，如何请他们吃饭，为了证书，如何花掉自己很多时间去学习，如何连暑假都不回家，每天早上7点起的奋斗。 大四了，开始出去实习了，先去川师，然后去北师，最后又回到成都，辗转多处，大公司小公司去了不少，却没有几家合适的，当时脑子里想的都是工资、努力和前程。其他的什么东西都是浮云，就连一次导员通知我去领全国大学生英语竞赛的证书和奖品，我都没去，因为在我大四的眼界里，钱是最好的东西。每天坚持上班，不到迫不得已，绝不请假，学校也没回几次，就这样忙碌忙碌，终于，现在的我，才坚持了半年时间就疲了，这是我真正追求的东西吗，我的一生难道就只是在给钱做奴隶么。。。现在的我，快想通了，钱不是我唯一的追求，努力也不是成功的唯一要素。 现在要毕业了，回想大学四年间所追求的东西。。。 大一的被人认同感，大二的YY感，大三的权钱欲，好像都是有一种无形的虚荣心在作怪，它好像是我奋斗的动力，也是我变态心态的根源。大四了，好像对什么都毫不在乎了，好像觉得什么都是浮云，于是破罐子破摔，什么也不顾忌，于是发现这也是一种生活态度，只不过没有什么可追求的东西而已，除了钱，但是钱赚了，太低调又有谁能知道呢，没有对你肯定，太高调，惹来嫉妒，也没人给你肯定。。。 人生到底追求的是什么东西呢，星云大师说过，人之所以痛苦，是因为在追求错误的东西，也就是说，如果我们追求的是对的东西，我们就会感觉到快乐，可是，追求了这么多之后，我怎么没快乐过呢。。。]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法]]></title>
    <url>%2F2012%2F05%2F25%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(%E6%9C%AA%E5%AE%8C%E6%88%90)%2F</url>
    <content type="text"><![CDATA[树和二叉树]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构第二部分]]></title>
    <url>%2F2012%2F04%2F27%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86(%E6%9C%AA%E5%AE%8C%E6%88%90)%2F</url>
    <content type="text"><![CDATA[树和二叉树]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构第一部分]]></title>
    <url>%2F2012%2F03%2F30%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[绪论 数据(data)：是对客观事物的符号表示，在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称。 数据元素(data element)：是数据的基本单位，在计算机程序中经常作为一个整体进行考虑和处理。 数据对象(data object)：是性质相同的数据元素的集合，是数据的一个子集。 数据结构(data structure)：是相互之间存在一种或多种特定关系的数据元素的集合。 结构(structure)：数据源是都不是孤立存在的，而是它们之间存在着某种关系，这种关系就是结构。 根据数据元素之间的关系不同的特性，通常有下列4类基本结构：（逻辑结构） 集合：结构中的数据元素之间除了“同属一个集合”的关系之外，别无其他关系 线性结构：结构中的数据元素之间存在一个对一个的关系 树形结构：结构中的数据元素之间存在一个对多个的关系 图状结构或网状结构：结构中的数据元素之间存在多个对多个的关系 数据结构的形式定义为：数据结构是一个二元组 Data Structure = (D, S)；其中：D是数据元素的有限集，S是D上关系的有限集。 数据结构在计算机中的表示(又称映像)称为数据的物理结构，又称存储结构。 在计算机中表示信息的最小单位是二进制数的一位，叫做位(bit)。 在计算机中可以用一个由若干位组合起来形成一个位串表示一个数据元素，通常称这个位串为元素或结点。 当数据元素由若干个位串组成时，位串中对应于各个数据项的子位串称为数据域(data field)。 数据元素之间的关系在计算机中有两种不同的表示方法：顺序映像和非顺序映像，并由此得到两种不同的存储结构：顺序存储结构和链式存储结构。链式存储结构的特点是借助指示元素存储地址的指针来表示数据元素之间的逻辑关系。 数据类型(data type)是和数据结构密切相关的一个概念，它是一个值的集合和定义在这个值集合上的一组操作的总称。例如C语言中的整形变量，其值为一个整形集合和定义在这些值上的操作如加减乘除。 按“值”的不同特性，高级程序语言中的数据类型可分为两类：一类是非结构的原子类型，另一类是结构类型。 抽象数据类型(Abstract Data Type，简称ADT)是指一个数学模型以及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关，即不论其内部结构如何变化，只要它的数学特性不变，都不影响其外部的使用。 原子类型(atomic data type)：属原子类型的变量的值是不可分解的。 固定聚合类型(fixed-aggregate data type)：属该类型的变量，其值由确定数目的成分，按某种结构组成。 可变聚合类型(variable-aggregate data type):和固定聚合类型相比较，构成可变聚合类型“值”的成分的数目不确定。 和数据结构的形式定义相对应，抽象数据类型可用以下三元组表示(D, S, P)，其中D是数据对象，S是D上的关系集，P是对D的基本操作集本书采用如下格式定义抽象数据类型 ADT 抽象数据类型名 { 数据对象：&lt;数据对象的定义&gt; 数据关系：&lt;数据关系的定义&gt; 基本操作：&lt;基本操作的定义&gt; } ADT 抽象数据类型名； 多型数据类型(polymorphic data type):是指其值的成分不确定的数据类型，例如JAVA中的泛型。然而，不论其元素具有何种特性，元素之间的关系相同，基本操作也相同。从抽象数据类型的角度看，具有相同的数学抽象特性，故称之为多型数据类型。 算法(algorithm)是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或多个操作，此外，算法还具有5个重要特性：有穷性、确定性、可行性、有输入、有输出。 一个好的算法应考虑达到以下几个目标：正确性、可读性、健壮性、效率与低存储量需求。 为了便于比较同一问题的不同算法，通常的做法是，从算法中选取一种对于所研究的问题(或算法类型)来说是基本操作的原操作，以该基本操作重复执行的次数作为算法的时间量度。一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数f(n)，算法的时间度量记作:`T(n)=O(f(n))，它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度(asymoptotic time ecomplexity)，简称时间复杂度。 类似于时间复杂度，本书以空间复杂度(space complexity)作为算法所需存储空间的量度，记作S(n)=O(f(n))，其中n为问题的规模。 因为所占时间和空间都是依赖于特定的输入，本书的时间和空间的复杂度讨论都是基于最坏的情况来分析的。 线性表线性结构的特点是：在数据元素的非空有限集中： 存在唯一的一个被称作“第一个”的数据元素 存在唯一的一个被称作“最后一个”的数据元素 除第一个之外，集合中的每个数据元素均只有一个前驱 除最后一个之外，集合中的每个数据元素均只有一个后继 线性表(linear-list)是最常用且最简单的一种数据结构。简言之，一个线性表是n个数据元素的有限序列。 在稍微复杂的线性表中，一个数据元素可以由若干个数据项(item)组成，在这种情况下，常把数据元素称为记录(record)。含有大量记录的线性表又称为文件(file)。 线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素。假设线性表的每个元素需占用l个存储单元，并以所占的第一个单元的存储地址作为数据元素数据元素的存储位置。则线性表中第i+1个数据元素的存储位置LOC(ai+1)和第i个数据元素的存储位置LOC(ai)之间满足下列关系LOC(ai+1)=LOC(ai)+l，一般来说，线性表的第i个数据元素ai的存储位置为LOC(ai)=LOC(a1)+l*(i-1)。线性表的这种机内表示称作线性表的顺序存储结构或顺序映像(sequential mapping)，通常称这种存储结构的线性表为顺序表。也就是说，在计算机内用“物理位置相邻”来表示线性表中数据元素之间的逻辑关系。 typedef struct { ElemType *elem;//存储空间基址 int length;//当前长度 int listsize;//当前分配的存储容量 } SqList; 线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）。因此为了表示每个数据元素ai与其直接后继数据元素ai+1之间的逻辑关系，对数据元素ai来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。这两部分信息组成数据元素ai的存储映像，称为结点(node)。它包括两个域：其中存储数据元素信息的域称为数据域；存储直接后继存储位置的域称为指针域。指针域中存储的信息称作指针或链。n个结点链成一个链表，即为线性表的链式存储结构。 又由于此链表的每个结点中只包含一个指针域，故又称线性链表或单链表。单链表的整个链表的存取必须从头指针开始进行，头指针指示链表中第一个结点的存储位置。同时，由于最后一个数据元素没有直接后继，则线性链表中最后一个结点的指针为空NULL。 typedef struct LNode { ElemType data; struct LNode *next; } LNode, *LinkList; 有时，也可借用一维数组来描述线性链表，数组的一个分量表示一个结点，同时用游标(指示器cur)代替指针只是结点在数组中的相对位置。数组的第零分量可看成头结点，其指针域指示链表的第一个结点。为了和指针型描述的线性链表相区别，我们给这种用数组描述的链表起名为“静态链表”。 typedef struct { ElemType data; int cur; } 循环链表(circle linked list)是另一种形式的链式存储结构。它的特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环。由此，从表中任一结点厨房均可找到表中其他结点。循环链表的操作和线性链表基本一致，差别仅在于算法中的循环条件不是p或p-&gt;next是否为空，而是它们是否等于头指针。 双向链表：顾名思义，在双向链表的结点中有两个指针域，其一指向直接后继，另一指向直接前驱，在C语言中可描述如下： typedef struct DuLNode { ElemType data; struct DuLNode *prior; struct DuLNode *next; } 和单链的循环表类似，双向链表也可以有循环表。 栈和队列从数据结构的角度看，栈和队列也是线性表，其特殊性在于栈和队列的基本操作是线性表操作的子集，它们是操作受限的线性表，因此，可称为限定性的数据结构。 栈(stack)是限定仅在表尾进行插入或删除操作的线性表。因此对栈来说，表尾端有特殊含义，称为栈顶(top)，相应的，表头端称为栈底(bottom)。不含元素的空表称为空栈。栈的修改是按照后进先出的原则进行的，因此，栈又称后进先出的线性表(first in last out)。 和线性表类似，栈也有两种存储表示方法。 顺序栈，即栈的顺序存储结构是利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，同时附设指针top指示栈顶元素在顺序栈中的位置。栈的链式表示易于操作和实现，在此不作详细讨论。 和栈相反，队列(queue)是一种先进先出(first in first out)的线性表。它只允许在表的一端进行插入，而在另一端删除元素。在队列中，允许插入的一端叫做队尾(rear)，允许删除的一端称为对头(front)。栈也有顺序表示和链式表示两种。用链表示的队列简称为链队列。 和顺序栈相类似，在队列的顺序存储结构中，除了用一组地址连续的存储单元依次存放从队列头到队列尾的元素之外，尙需附设两个指针front和rear分别指示队列头元素及队列尾元素的位置。为了在C语言中描述方便起见，在此我们约定：初始化建空队列时令front=rear=0，每当插入新的队列尾元素时，尾指针增1，每当删除队列头元素时，头指针增1，因此在非空队列中，头指针始终指向队列头元素，而尾指针始终指向队列尾元素的下一个位置。在顺序队列中，当队尾指针到达分配的最大空间时不可再继续插入新的队列元素，否则会因为数组越界而遭致程序代码被破坏。 除了栈和队列以外，还有一种限定性数据结构是双端队列(deque)。双端队列是限定插入和删除操作在表的两端进行的线性表。 串计算机上的非数值处理的对象基本上是字符串数据。在较早的程序设计语言中，字符串是作为输入和输出的常量出现的。随着语言加工程序的发展，产生了字符串处理。这样，字符串也就作为一种变量类型出现在越来越多的程序设计语言中，同时也产生了一系列字符串的操作。字符串一般简称为串。 在不同类型的应用中，所处理的字符串具有不同的特点，要有效地实现字符串的处理，就必须根据具体情况使用合适的存储结构。这一章中会讨论一些基本的串处理操作和几种不同的存储结构。 串(string)(或字符串)是由零个或者多个字符组成的有限序列，一般记为s=&#39;a1a2...an&#39;(n&gt;=0)，其中，s是串的名，用单引号括起来的字符序列是串的值;ai(1&lt;=i&lt;=n)可以是字母、数字或其他字符;串中字符的数目n称为串的长度。零个字符的串称为空串(null string)，它的长度为0。 串中任意个连续的字符组成的子序列称为该串的子串。包含子串的串相应地称为主串。通常称字符在序列中的序号为该字符在串中的位置。子串在主串中的位置则以子串的第一个字符在主串中的位置来表示。 当切仅当两个串的值相等，才会称两个串是相等的。 值得一提的是，串值必须用一对单引号括起来，但单引号本身不属于串，它的作用只是为了避免与变量名或数的常量混淆而已。 在各种应用中，空格常常是串的字符集合中的一个元素，因而可以出现在其他字符中间。由一个或多个空格组成的串’ ‘称为空格串(blank string)，它的长度位串中空格字符的个数。 如果在程序设计语言中，串只是作为输入或输出的常量出现，则只需存储此串的串值，即字符序列即可。但在多数非数值处理的程序中，串也以变量的形式出现。串有3种机内表示方法，分别介绍如下： 定长顺序存储表示 类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。在串的定长顺序存储结构中，按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区，则可用定长数组如下描述之： #define MAXSTRLEN 255 typedef unsigned char SString[MAXSTRLEN+1]; 堆分配存储表示 这种存储表示的特点是，仍以一组地址连续的存储单元存放串值字符序列，但它们的存储空间时在程序执行过程中动态分配而得。在C语言中，存在一个称之为堆的自由存储区，并由C语言的动态分配函数malloc()和free()来管理。利用函数malloc()为每个新产生的串分配一块实际串长所需的存储空间，若分配成功，则返回一个指向起始地址的指针，作为串的基址，同时，为了以后方便处理，约定串长也作为存储结构的一部分 typedef struct { char *ch; int length; }HString; 以上两种存储表示通常为高级程序设计语言所采用。由于堆分配存储结构的串既有顺序存储结构的特点，处理方便，操作中对串长又没有任何限制，更显灵活，因此在串处理的应用程序中也常被选用。 块链存储表示 和线性表的链式存储结构相类似，也可以采用链表方式存储串值。由于串结构的特殊性-结构中的每个数据元素是一个字符，则用链表存储串值时，存在一个“结点大小”的问题，即每个结点可以存放一个字符，也可以存放多个字符。为了便于进行串的操作，当以链表存储串值时，除头指针外还可以附设一个尾指针指示链表中的最后一个结点，并给出当前串的长度。称如此定义的串存储结构为块链结构。设尾指针的目的是为了便于进行联结操作，但应注意联结时需处理第一个串尾的无效字符。 #define CHUNKSIZE 80 typedef struct Chunk { char ch[CHUNKSIZE]; struct Chunk *next; }Chunk; typedef struct { Chunk *head, *tail; int curlen; }LString; 在链式存储方式中，结点大小的选择和顺序存储方式的格式选择一样都很重要，它直接影响着串处理的效率。在各种串处理系统中，所处理的串往往很长或很多，这就要求我们考虑串值的存储密度：存储密度=串值所占的存储位/实际分配的存储位。显然，存储密度小(如结点大小为1时)，运算处理方便，然而存储占用量大。 串值的链式存储结构对某些串操作，如连接操作等有一定方便之处，但总的来说不如另外两种存储结构灵活，它占用存储量大且操作复杂。 子串的定位操作通常称作串的模式匹配，是各种串处理系统中最重要的操作之一。 数组和广义表前几章讨论的线性结构中的数据元素都是非结构的原子类型，元素的值是不再分解的。本章讨论的两种数据结构–数组和广义表可以看成是线性表在下述含义上的扩展，表中的数据元素本身也是一个数据结构。 我们可以把二维数组看成是这样一个定长线性表，它的每个数据元素也是一个定长的线性表。数组一旦被定义，它的维数和维界就不再改变。因此，除了结构的初始化和销毁之外，数组只有存取元素和修改元素值的操作。由于数组一般不作插入或删除操作，也就是说，一旦建立了数组，则结构中的数据元素和元素之间的关系就不再发生变动。因此，采用顺序存储结构表示数组时自然的事了。 由于存储单元是一维的结构，而数组是多维的结构，则用一组连续存储单元存放数组的数据元素就有个次序约定问题。相应的，对二维数组可有两种存储方式，一种以列序为主序的存储方式，一种是以行序为主序的存储方式。 由此，对于数组，一旦规定了它的维数和各维的长度，便可为它分配存储空间。反之，只要给出一组下标便可求得相应数组元素的存储位置。假设每个数据元素占L个存储单元，则二维数组A中任一元素aij的存储位置可由下式确定 LOC(i, j)=LOC(0, 0)+(b2xi+j)L，式中，LOC(i, j)是aij的存储位置；LOC(0, 0)是a00的存储位置，即二维数组A的起始存储地址，也称为基地址或基址。 在数值分析中经常出现一些阶数很高的矩阵，同事在矩阵中有许多值相同的元素或者是零元素。有时为了节省存储空间，可以对这类矩阵进行压缩存储。所谓压缩存储是指：为多个值相同的元只分配一个存储空间，对零元不分配空间 假若值相同的元素或者零元素在矩阵中的分布有一定规律，则我们称此类矩阵为特殊矩阵，反之称为稀疏矩阵。 顾名思义，广义表是线性表的推广。也有人称其为列表(lists,用复数形式以示与统称的表list的区别)。广泛地用于人工智能等领域的表处理语言LISP语言，把广义表作为基本的数据结构，就连程序也表示为一系列的广义表。广义表一般记作 LS = (a1, a2… an)，其中LS是广义表的名称，n是它的长度。在线性表的定义中，ai只限于是单个元素。而在广义表的定义中，ai可以是单个元素，可以是广义表，分别称为广义表LS的原子和子表。习惯上，用大写字母表示广义表的名称，用小写字母表示原子。当广义表LS非空时，称第一个元素a1为LS的表头(HEAD)，称其余元素组成的表时LS的表尾(TAIL)。 由于广义表中的数据元素可以具有不同的结构(或是原子，或是列表)，因此难以用顺序存储结构表示，通常采用链式存储结构，每个数据元素可用一个结点表示。由于列表中的元素可能为原子或列表，由此需要两种结构的结点，一种是表结点，用以表示列表，另一种是原子结点，用以表示原子。若列表不空，则可分解成表头和表尾，反之，一堆确定的表头和表尾可唯一确定列表。由此，一个表结点可由3个域组成：标志域、指示表头的指针域和指示表尾的指针域；而原子结点只需两个域：标志域和值域。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言程序设计教程2]]></title>
    <url>%2F2012%2F02%2F24%2FC%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%95%99%E7%A8%8B2%2F</url>
    <content type="text"><![CDATA[函数程序员在设计一个复杂的应用程序时，往往也就是把整个程序划分为若干功能较为单一的程序模块，然后分别予以实现，最后再把所有的程序模块像搭积木一样装配起来，这种策略被称为模块化程序设计方法。 每个C源程序都是由一个主函数和若干个其他函数组成的。函数时程序的基本组成单位，因此可以很方便地用函数作为程序模块来实现C语言程序。从函数的定义角度，函数可以分为库函数和用户自定义函数两种；从兼有其他语言功能角度分类，函数分有返回值函数和无返回值函数两种；从函数间传送的角度分类，函数分为无参函数和有参函数两种； 返回值类型 函数名(参数表) { 函数体; } 在主调函数中调用某函数之前应对该被调函数进行原型说明，这与使用变量之前要先进行变量说明是一样的。在主调函数中对被调函数作说明的目的是使编译器程序知道被调函数的返回值类型，以便在主调函数中按此种类型值做相应的处理类型说明符 被调用函数名(类型1 形参1, 类型2 形参2);或类型说明符 被调用函数名(类型1, 类型2);。函数的调用方法如下函数名(实际参数表); 一般来说，有两种方法可以把参数传递给函数，一种方法叫做传值调用，另一种方法是传址调用。 传值调用：把实参的值复制到函数的形参中 传址调用：将实参的存储地址作为参数传递给形参 数组也可以作为函数的参数使用，进行数据传送。数组用作函数参数有两种形式：一种是把数组元素(下标变量)作为实参使用；另一种是把数组名作为函数的形参和实参使用 在变量做函数参数时，所进行的值传递是单向的，即只能从实参传向形参，不能从形参传回实参。 函数的传值调用可以通过参数使用调用环境中变量的值，但不能改变那里的变量值。想要改变那里的变量值，就得利用指针机制：在调用时把变量的地址通过指针参数传进被调函数，在被调用函数里对参数指针间接访问，就能完成对变量的各种操作，包括对变量赋值。 在C语言中允许一个函数的返回值是一个指针(即地址)，这种返回指针值的函数称为指针型函数。定义指针型函数的一般形式为： 类型说明符 *函数名(形参表) { ...;//函数体 } 在C语言中一个函数总是占用一段连续的内存区，而函数名就是该函数所占内存区的首地址。我们可以给函数的首地址赋予一个指针变量，使该指针变量指向该函数，然后，通过指针变量就可以找到并调用这个函数。我们把这种指向函数的指针变量称为“函数指针变量”。函数指针变量定义的一般格式为：类型说明符 (*指针变量名)();。其中”类型说明符”表示被指函数的返回值的返回值类型，(*指针变量名)表示*后边的变量是定义的指针变量，空括号表示指针变量所指的是一个函数。调用函数的一般形式为(*指针变量名) (实参表) 在ANSI C标准中允许用结构变量作函数参数进行整体传送。但是这种传送要将全部的成员逐个传送，特别是成员为数组时将会使传送的时间和空间开销很大，严重地降低程序的效率，因此，最好的办法就是使用指针，即用指针变量作函数参数进行传送。这时由实参传向形参的只是地址，从而减少了时间和空间的开销。结构型函数是指返回值为结构变量的函数。返回指向结构变量指针的函数称为结构指针型函数，结构型函数返回的是结构变量，函数返回时要带回结构变量的各成员值，影响执行效率，而采用返回结构型指针的函数可以避免这一点。 函数的递归调用是指在调用一个函数的过程中，直接或间接地调用函数自身，这种函数称为递归函数。C语言允许函数的递归调用。在递归调用中，主调函数又是被调函数。 变量的存储类型C语言中的变量具有两个属性：数据类型和存储类型。数据类型确定了变量在内存中分配存储单元的大小，存储类型指数据在内存中的存储方式。变量的存储类型决定了变量的作用域和生命周期。存储方式分为静态存储和动态存储。 静态存储方式指在程序运行期间分配固定存储空间，在整个程序运行期间保持不变，直到程序运行结束才释放所占有的存储空间。动态存储方式指在程序运行的过程中，根据需要，使用时才分配存储空间，使用结束后立即释放。典型的例子是函数的形式参数。 在C程序中，函数之间的参数传送主要有两种方式：传值和传地址。 C程序中的每个变量都要经历 分配存储空间，用以存放该变量的值，然后在程序中使用变量，使用结束后释放所占有的存储空间的过程。这个过程称为变量的生命期。在变量的生存期内，该变量可以使用的范围称为变量的作用域。在变量作用域内引用变量，称变量在此作用域内可见。 变量的作用域是一个空间的概念，由定义变量语句的位置决定，根据变量定义语句的位置的不同，变量分为局部变量和全局变量。 C语言中的四种类型的变量： 自动变量：自动变量定义时，前面可以加关键字auto，其格式为auto 类型说明符 变量名表;。在函数内定义的变量称为内部变量，由于内部变量的作用域仅局限于其所在的函数，因此内部变量也称为“局部变量”。内部变量分为自动变量和静态局部变量。 外部变量：所有在函数外部定义的变量称为外部变量，外部变量是全局变量，外部变量可以被本源程序文件中的其他函数使用。外部变量的作用域从其定义的位置开始，一直到本源程序结束。由于外部变量在程序执行过程中，占有固定的存储单元，其生存期为整个程序。在C语言中，可以使用关键字extern，将外部变量的作用域扩展到外部变量定义之前或其他源程序文件中。也可以使用extern关键字进行引用性声明，引用性声明不分配存储空间extern 类型标识符 变量名表; 静态变量：定义变量时，前面加关键字static，则定义的变量就是静态变量。在编译时，系统分配固定的存储单元，并在程序运行过程中始终存在，直到源程序运行结束，因此静态变量的生存期为整个源程序。静态变量根据位置不同分为静态局部变量和静态全局变量。全局变量和静态全局变量的存储方式均为静态存储方式，两者的区别在于作用域扩展上的不同，静态全局变量的作用域为其所在的源程序文件，即只能被该源程序中的函数使用，而全局变量可以通过extern关键字将作用域扩展到其他源程序文件。所以在由多个源文件组成的C程序中，如要限制外部变量不能再其他源程序文件中使用，可以将其定义为静态外部变量。 寄存器变量：寄存器变量是指将局部变量的值存放在CPU的寄存器中的变量。由于寄存器的存钱速度远高于对内存的存取速度，因此，可以将使用频繁的局部变量定义为寄存器变量，可以提高程序的运算效率，寄存器变量定义形式如下：register 数据类型 变量名表; C程序在运行时使用的存储空间分为三个部分 程序区：用于存放程序代码 静态存储区：用于存放程序的全局数据和静态数据 动态存储区：用于存放自动变量、函数的形式参数、函数调用时的现场保护和返回地址 动态内存分配是指在程序运行过程中，根据需要而分配内存空间的方式，这种就可以解决有时分配过大或过小的问题。在C系统的函数库中提供的动态分配和释放内存空间的函数主要有： malloc函数：void *malloc(unsigned int size)在内存动态存储区分配一段长度为size个字节的连续空间，如果分配成功，函数返回一个指向该区域起始地址的指针，否则返回NULL指针 calloc函数：void *calloc(unsigned int n, unsigned int size);在内存动态存储区分配n个长度为size的连续空间，如果分配成功，函数返回一个指向该区域起始地址的指针，否则返回NULL指针 free函数：void free(void *p);释放指针p指向的存储空间，free函数无返回值 realloc函数：void *realloc(void *p, unsigned int size);将p所指向的存储空间，重新分配改变为size的字节，并将原存储空间存放的数据拷贝到新分配的存储空间，如果分配成功，函数返回一个指向该区域起始地址的指针，否则返回NULL指针。注意：为了增加或减少存储空间，系统新分配的起始地址不一定与原来的地址相同 位域、联合、枚举、定义类型及预处理功能8.1 位域及结构嵌套为了节省空间，C语言允许定义具有可变长度位的结构成员，这种成员称为位域。通过位域可以方便地用成员名访问小于一个字节的存储区。位域是结构成员的特殊形式，它需要定义位的长度。位域定义的一般形式是： //冒号表示使用的是位域，其后的长度表示需要分配的存储单元的位数 struct 结构名 { 类型 变量名1:长度; 类型 变量名2:长度; } //内存分配情况是位域变量总共占用2个字节其余位未用 //注意：在不同的机器里，位域变量从左到右还是从右到左的规则不同 struct { unsigned bit0:1; unsigned bit1:1; } 与结构成员的访问方式一样，位域可以用结构成员运算符”.”来访问。若位域是由指针访问的，必须使用箭头运算符。位域变量有某些限制，比如，不能取一个位域变量的地址；不允许超越整形量边界。 在C语言中，结构成员不仅可以是位数可变的位域变量，而且可以是另一个结构类型变量。这种情况被称为嵌套式结构。 8.2 联合联合是一种与结构相类似的构造类型，联合与结构一样，可以包括不同类型和长度的数据。联合与结构的主要区别在于，联合类型变量所占内存空间不是各个成员所需存储空间字节数的总和，而是联合成员中需要存储空间最大的成员所要求的字节数。这是因为C编译程序规定联合的各个成员共享一个公共存储空间。在任何给定的时刻，只能允许一个成员驻留在联合中，而对结构而言，则是所有成员一直都驻留在结构中。 union 联合名 { 类型 变量名; 类型 变量名; }联合变量; 使用联合不仅比使用结构更能节省一些存储空间，而且增加了处理数据的灵活性。 8.3 枚举通过列举一系列由用户自己确定的有序标识符所定义的类型叫枚举类型。标识符名称代表一个数据值，其间有先后次序，可以进行比较，通常把标识符称为枚举类型的元素。 枚举和结构一样，都是自定义的一种数据类型，枚举用关键字enum表示，定义枚举型的一般形式为：enum 枚举名{枚举表}; enum color {white, black, red}; enum color col; col = black; 枚举的作用域与变量一致，即在一个函数中定义的枚举型数据只限于在该函数中使用。而在程序中任何函数之外定义的外部枚举型数据可以为所有函数共用。 8.4 定义类型名-typedefC语言允许用户使用关键字typedef，为已有的类型定义一个新的名字，定义类型的一般形式为：typedef 类型 定义名;，例如 typedef int integer;，在这里，类型是任一种合法的数据类型，定义名是为这种类型新取的名字。 必须强调指出，typedef的作用，在任何意义上讲都不是创建一种新的数据类型，它仅仅为现有的类型赋给一个新的名字，也没有任何新语义。 8.5 预处理功能C语言的预处理程序负责分析和处理以“#”为首字符的预处理控制行。预处理控制行主要有宏替换、文件包含和条件编译。 用#define作为标志的预处理命令不仅可以定义符号常量及字符串，而且也可定义带参数的宏。宏替换命令#define用来定义一个宏标识符和一个字符串，在程序中每次遇到该标识符时，就用所定义的字符串替换，这个标识符也叫宏替换名，替换过程称为宏替换，宏替换命令的一般形式是：#define 宏标识符 字符串。注意#define、宏标识符、字符串各部分之间用空格分隔，其末尾不带分号，以换行结束。 宏标识符像函数一样可以带有形式参数。在程序中用到宏标识符时，实际参数将代替这些形式参数，使用更为灵活。带参数宏定义的一般形式是：#define 宏标识符(参数表) 表达式。标识符就是带参数宏的名字，参数表中的参数类似函数中的形式参数，宏标识符与左圆括号之间不能有空格；表达式是用于替换的表达式。宏调用的一般形式是宏标识符(参数表)，此处的宏标识符是已经被定义的宏标识符，参数表中的参数类似于函数中的实参数。 宏一旦被定义，在其所在的文件中均是存在和可见的，这一点很像外部变量。如果要对某一个宏定义撤销，可用如下预处理命令:#undef 宏标识符。 包含文件处理是用#include命令把给定的包含文件内容嵌入到另一个源程序文件中。其一般形式是：#include 文件名 或 #include &lt;文件名&gt;。#include预处理命令的实质是，告诉预处理程序将包含文件的内容嵌入到源文件中#include出现的地方。 需要嵌入的包含文件的存放地点，必须由文件的路径和文件名指定，并且被放在双引号内，系统约定先在引用包含文件的源文件所在的目录中查找，若找不到，再按系统指定的标准方式向外查找，如果已经知道被包含文件不在当前工作目录，可以使用尖括号形式查找标准目录。因此，从使用角度上看，在包含文件中使用双引号比使用尖括号更靠谱。 输入、输出及文件管理C语言的文件系统分为“缓冲型文件系统(buffered file system)”和“非缓冲型文件系统(unbuffered file system)”。通常把缓冲型文件系统提供的函数称为流式I/O函数，把非缓冲型文件系统提供的函数称为低级I/O函数。 fopen：打开文件函数 File *fp=fopen(filename, mode)其中fp定义为指向FILE类型的指针，filename表示要打开的文件名，mode表示使用该文件的模式，如可读r、可写w和可添加a。若要打开的文件不存在，fopen函数返回NULL指针，也就是0 fclose:关闭文件函数int fclose(File fp)其中fp是一个调用fopen函数所返回的文件指针。文件关闭成功返回0，返回其他值说明关闭出错。文件处理结束后，必须关闭文件。文件未关闭会引起很多问题，如数据丢失，文件损坏及其他一些错误。 stdin、stdout、stderr：当一个C程序开始执行时，系统首先自动打开预定义的三个流式文件：标准输入stdin，标准输出stdout和标准错误stderr。当程序运行结束后，系统又自动将这些标准文件关闭。用户则不能控制它们的打开和关闭。通常stdin被指定为键盘，用于从控制台读，stdout和stderr被指定为显示终端，用于向控制台写。但是用户在执行某个程序时，可以临时性地改变系统的设定，把标准设备文件指定为其他设备文件。 getc、putc简单字符输入输出：这两个函数时用于从一个打开的文件中读取一个字符或向打开的文件写入一个字符的函数。调用方式为int getc(FILE *fp);或int putc(int ch, FILE *fp)，这里，fp是由fopen函数打开文件时返回的文件指针。fp指针告诉这两个函数应该从哪一个磁盘文件去读字符或写入字符。 fgets、fputs行输入输出：fgets和fputs是用来从文件中读取字符串，或向文件中写字符串的函数，其调用方式是：char *fgets(char *str, int length, FILE *fp);和char *fputs(char *str, FILE *fp);，函数fgets从fp指向的文件读出字符串，一直读至换行符或第(length-1)个字符为止。 fread、fwrite数据块的输入输出：这是两个读写数据块的函数，其调用方式是int fread(void *buffer, int size, int n, FILE *fp);或int fwrite(void *buffer, int size, int n, FILE *fp);buffer是一个指向数据存储区的指针。在fread函数中，buffer接收从文件中读取的数据。在fwrite函数中，buffer中的数据向文件写入。读写的字段数用n表示（每个字段是size个字节），fp是已打开文件的文件指针。 fprintf、fscanf流式文件数据的格式化输入输出：这两个函数的操作对象是磁盘文件，以上的操作对象都不是磁盘文件，调用这两个函数的方式分别是fprintf(fp, &quot;控制字符串&quot;, &quot;参量表&quot;)和fscanf(fp, &quot;控制字符串&quot;, &quot;参量表&quot;)，其中，fp是由fopen函数返回的文件指针，fprintf函数将格式化的数据写入到fp指向的文本文件中，fscanf函数从fp指向的文本文件中读取格式化数据，两个函数的操作方法与printf和scanf函数完全相同。 fseek文件的随机访问：fseek函数可以改变文件的位置指针，以实现文件的随机访问。调用方式为：int fseek(FILE *stream, long offset, int origin);，即按偏移量offset和起始位置origin的值，设置与stream相连的文件位置指示器。操作成功返回值为0，否则返回值为非0。偏移量offset是从起始位置origin到要确定的新位置之间的的字节数目，当文件是结构类型时，可用sizeof()函数确定便宜量。起始位置用0，1，2表示，0表示从文件头开始，1表示从当前位置开始，2则表示从文件末端开始。 C高级程序应用10.1 链表链表是由链指针构成的一种动态数据结构。链表分为单向链表、双向链表和循环链表。单向链表只用一个链指针指向下一个结点。双向链表用两个链指针分别指向前一个结点和后一个结点。循环链表最后一个数据项的指针指向第一个数据项，因此循环链表是一个无表头和表尾的链表。 10.2 与操作系统密切相关的库函数在Windows操作系统中，用户可以通过图形化界面方便地完成操作系统的各种功能。而在DOS磁盘操作系统环境下，是通过在命令行输入命令并回车来完成相应的功能，目前在嵌入式系统编程等方面仍大量采用这种工作方式。 Turbo C库函数的一个重要特色就是设置有与操作系统密切相关的一些函数。这些函数包括： BIOS接口调用函数 DOS系统调用函数 时间和日期函数 10.3 图形程序Turbo C提供了非常丰富的图形函数，所有图形函数的原型均在graphics.h中，本节注意介绍图形模式的初始化、独立图形程序的建立、基本图形功能、图形窗口以及图形模式写的文本输出等函数。 10.4 声音程序Turbo C中提供了几个队扬声器操作的库函数： 接通扬声器：sound(int frequence);按照参数要求的频率发音 关闭扬声器：nosound(); Outportb(int port, char byte)/Inportb(int port)：通过对端口的直接操作函数来控制扬声器的发音。扬声器的端口地址为0x42，对端口的操作方式一般分两步：初始化端口、向端口传送频率值。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言程序设计教程1]]></title>
    <url>%2F2012%2F01%2F27%2FC%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%95%99%E7%A8%8B1%2F</url>
    <content type="text"><![CDATA[C语言概述1.1 计算机信息社会与C语言到目前为止，计算机语言大致可分为五代，第一代是机器语言，第二代是汇编语言，第三代是面向过程程序设计语言，第四代是面向对象程序设计语言，第五代是基于Web的语言。 高级语言源程序在计算机中有编译和解释两种执行方式 在解释方式下，源程序由解释程序边解释边执行，不生成目标程序，其执行程序速度较慢 在编译方式下，源程序首先必须经过编译程序的编译处理，产生相应的目标程序，然后再通过连接和装配，才能生成可执行程序 1.2 C语言简史及其特点ALGOL(1960)–CPL(1963)–BCPL(1967)–B(1970)–C(1972)–发表(1978)–ANSIC标准(1983)–ANSIC标准补充(1987)–获得ISO认证(1997) 1980年开始，贝尔实验室将Simula67中‘类’的概念引入C语言，1993年将其正式命名为C++ C语言不仅具有高级语言的特点，并且还有汇编语言的功能，同时具有极强的兼容性和良好的用户界面 1.3 基本程序结构C程序是一种结构化程序，程序由顺序、循环、分支三种结构组成 C程序中有三种类型的函数 主函数main 编译程序提供的函数 程序员自己设计的函数 一个函数由两部分构成 函数说明部分 和 函数体部分 1.4 基本语法单位在C语言中使用的词汇分为6类：关键字、标识符、操作符、分隔符、常量、注释符等 关键字：C语言规定的具有特定意义的字符串，通常也称保留字，用户定义的标识符不应与关键字相同。C语言的关键字分为以下几类：类型说明符(int) 语句定义符(if else) 预处理命令符(include) 标识符：用来表示变量名、数组名、函数名、指针名、结构名、联合名、枚举常量名、用户自定义的数据类型名及语句标号等的字符序列统称为标识符 操作符：在C语言中含有相当丰富的操作符。操作符与变量、函数一起组成表达方式，以表示各种运算功能 分隔符：在C语言中的分隔符有逗号和空格两种 常量：包括数值常数、字符常数、字符串常数以及枚举常数 C语句是组成C程序的基本单位，具有可执行的功能 函数时构成C程序的必不可少的一部分，它是一个相对独立的程序或模块 1.5 C程序的编写和运行步骤 程序编辑：程序员用任一编辑器将编写好的C程序输入计算机，并以文本文件的形式保存在计算机硬盘上 程序编译：编译是指将编译好的源文件翻译成二进制目标代码的过程 连接程序：编译后产生的目标文件是可重定位的程序模块，不能直接运行。这就需要把目标文件、其他分别进行编译生成的目标程序模块和系统提供的标准函数库连接在一起，以生成可运行的可执行文件 程序运行：生成可执行文件后，就可以在操作系统控制下运行。 总结起来，C程序的过程如下: .c文件–.cpp文件–.obj文件–.exe文件 1.6 算法表示方法程序 = 数据结构 + 算法 数据结构是程序中用到的数据的构造形式及其类型。对于面向对象程序设计，强调的是数据结构，而对于面向过程的程序设计语言，主要关注的是算法。算法是程序的核心，也是面向对象程序设计的基础。 所谓结构化编码时指任何复杂的程序皆可由顺序、分支、循环三种基本结构组成。对复杂的程序进行自顶向下、逐步细化的分析，进行模块化的划分。 程序设计的步骤是 设计算法–描述算法–编写程序–检查程序–编译调试和运行。 算法的描述方法有自然语言描述、伪代码、流程图、N-S图、PAD图等 基本数据类型及运算2.1 基本数据类型数据类型是数据的基本属性，描述的是数据的存储格式和运算规则。不同数据类型的数据，在内存中所需的存储空间大小、存储格式均有所不同、能支持的运算以及相应的运算规则也会有所不同 数据类型分为： 基本类型 整形：基本类型符为int，根据数据范围又可分为普通整形(int)、短整形(short)和长整形(long) 浮点类型：浮点类型分为单精度浮点数(float)，双精度浮点数(double)和长双精度浮点数(long double) 字符型：字符的基本类型符为char，可在其前面加修饰符前缀signed和unsigned，都是用1个字节来存放 构造类型 数组类型 结构类型 联合类型 枚举类型 指针类型 空类型 2.2 常量常量是在程序执行过程中其值不能改变的量。在C语言中有不同类型的常量，如整形常量、浮点型常量、字符型常量、字符串常量和符号常量。 整形常量也称作整常量，在C语言中整常量可以用以下3种形式表示：十进制、八进制(以0开头)和十六进制(以0x或0X开头) 浮点型常量如同一般语言中的实数(real number)，它有两种表示形式： 十进制数形式：由数字和小数点组成 指数形式：由十进制小数、阶码标志e或E以及指数(只能为整数，可以带符号)组成，6.5E-2 字符型常量是用单引号括起来的一个字符，如’A’,’a’等 字符串常量是用一对双引号括起来的零个或多个字符组成的序列，如“hello”等，其存储于字符常量的存储不同，字符串常量都会自动在其末尾加上’\0’作为字符串结束标志 符号常量出现的形式一般有两种，一种是在程序中直接使用给定的值(如圆周率)，另一种是用一个常量相关的标识符来替代常量出现在程序中(const修饰) 2.3 变量变量是在程序执行过程中其值可以改变的量，其定义格式为：类型说明符 变量名表;，C语言允许在定义变量的同时对变量进行初始化，初始化不是在编译阶段完成的，而是在程序运行时执行本函数时赋予初值的，相当于有一个赋值语句。定义时的变量名其实是一个符号地址，它指出了变量在内存中的存放位置，而变量值就是在相应内存单元中存放的数据。 2.4 运算符与表达式按运算符在表达式中的作用，C语言的运算符可分为算术运算符(加减乘除取余等)、赋值运算符、关系运算符(&gt;=、!=等)、逻辑运算符(!、&amp;&amp;、||)、位运算符(&lt;&lt;、&gt;&gt;、&amp;等)、条件运算符(?:)、逗号运算符以及一些特殊的运算符(地址运算符&amp;、sizeof运算符、强制类型转换运算符())。 2.5 混合运算与类型转换在计算表达式时，不但要考虑运算符的优先级和结合性，还要分析运算对象的数据类型。一个运算符对不同数据类型的数据的计算结果有可能不同。不同类型的数据在一起运算时，需要转换为相同的数据类型。转换的方式有两种：自动类型转换和强制类型转换。自动类型转换又称为隐式转换，而强制类型转换又称为显示转换。 自动类型转换是指系统根据规则，自动将两个不同数据类型的运算对象转换成同一数据类型的过程，转换的原则是为两个运算对象的计算结果尽可能提供多的存储空间 强制类型转换的格式为(数据类型名)(表达式名) 2.6 运算的优先级与结合性表达式的计算是与运算符的语义以及它们的优先级和结合性规则有关 运算符高的运算符先算，优先级低的运算符后算 优先级相同的运算符、根据结合性决定计算顺序(i/j*k从左至右，*p–从右至左) 不相关子表达式的计算顺序不确定(i++)+(i+j)由于不同环境的编译配置有肯能从左至右，也有可能从右至左计算，所以会导致计算结果不一致 有特殊规则的运算符（注意一下 &amp; 和 || 的中断处理） 2.7 数据的输入输出C语言中没有提供专门的输入/输出(I/O)语句，所有的I/O操作都必须通过函数调用来实现，如前面程序中用到的printf()，scanf()等都是系统提供的标准I/O库函数。标准C定义了15个标准库函数和相应的头文件。 字符输出函数putchar() 格式输出函数printf()printf(格式控制串, 参数1， 参数2，...) 字符输入函数getchar() 格式输入函数scanf()scanf(格式控制串, 参数1， 参数2，...) cincin&gt;&gt;i&gt;&gt;j从键盘拾入i和j的值 coutcout&lt;&lt;How are you输出字符串 控制语句C语言有三种基本语句： 顺序结构 选择结构 if(表达式) { ...; } else if (表达式) { ...; } else { ...; } switch(表达式) { case c1: S1; break; case c2: S2; break; ... default: Sn+1; break; } 循环结构 do { 语句(即循环体部分) } while (表达式); while(表达式) { 语句(即循环体部分); } for (表达式1; 表达式2; 表达式3) { 语句(即循环体部分); } C语言中的break，continue语句是专门用于跳出循环或终止一次循环过程的语句，被称为条件转向语句，而goto语句是用来跳转到通过’标号’指明的某条语句上去执行的语句，被称为无条件转向语句。 数组和结构数组是具有相同数据类型的数据的有序集合，他们有相同的标识符和数据类型，用一个统一的数组名及数组下标来唯一确定数组中的元素，它的声明格式如下类型说明符 数组名[常量表达式] 仿照用一维数组表示多个有序变量，则可用二维数组表示多个有序的一维数组，这时可将每个一维数组看做一个元素，以此构成一个更大的数组，这个数组就是一个二维数组，它的声明格式如下类型说明符 数组名[常量表达式1][常量表达式2]，其中常量表达式1规定了一维数组的个数，常量表达式2规定了一维数组中元素的个数。 在对数组的全部元素赋初值时，C语言规定可以省略第一维的长度，但不能省略第二维的长度，例如可以把int a[2][2]={1，2，3，4}写成int a[][2]={1，2，3，4}，但不能写成int a[2][]={1，2，3，4} 在C语言里，没有提供专门的字符串类型，所以需要使用字符数组来处理字符串。可以使用scanf函数和gets函数获得输入字符串，如scanf(&quot;%s&quot;, word);`gets(word)。可以使用printf函数和puts函数输出字符串，如prinft(“%s”, word);puts(word)` 在C语言里，字符串的应用非常广泛，为了简化用户的程序设计，C语言提供了丰富的字符串处理函数，这样可以大大减轻编程的工作量。其中主要包括有： 字符串长度测量函数strlen:strlen(字符数组名) 字符串复制函数strcpy:strcpy(字符数组名1，字符数组名2)将2复制到1中去 字符串连接函数strcat:strcat(字符数组名1，字符串2) 字符串比较函数strcmp:strcmp(字符数组名1，字符数组名2) 结构是具有不同数据类型的数据的集合，结构与数组相似，但其成员的数据类型可以不同，使用结构名及成员名来唯一确定结构中的成员。 struct 结构类型名 { 类型名1 成员名1; 类型名2 成员名2; ... 类型名n 成员名n; }; struct student { int age; char[20] name; } //定义 struct student stu1, stu2; //访问 stu1.age; stu2.name; 数组元素的类型可以是任何类型，当然也可以是结构类型，这种就被称为结构数组。结构数组与其他类型的数组一样，只是它的元素是结构类型。 指针指针变量与普通变量一样，在程序中需要先定义，再使用。指针变量定义的一般形式是：类型定义符 *指针变量名，其中，类型定义符是指针变量所指向的目标变量的数据类型，可以是C语言中规定的基本类型或用户自定义的数组、结构、联合等。*是一个说明符，仅向编译器说明其后所定义的是指针变量而不是一般变量。除0以外的整数值是不允许赋值给指针变量的p=0，因为指针变量中存放的是内存地址，而不是任何整数。 &amp;：取地址运算符 *：间接运算符：注意，在变量说明语句中的*意味着‘指向。。。的指针’，而在表达式中的*表示访问指针指向的目标变量 其实，数组名是一个指向该数组的指针。数组名是一个地址常量，不能被修改，在整个程序运行期间，其值是固定不变的。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C和OC的内存分配]]></title>
    <url>%2F2011%2F12%2F31%2FC%E5%92%8COC%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%2F</url>
    <content type="text"><![CDATA[在以前上课时经常死记硬背内存都有哪些区，自从参加工作后，从应用启动的过程可以明显的区分出内存的几个分区而不用死记硬背。由于OC是继承C来的，所以其内存分配方式基本相同，只不过iOS系统为每个app分配了一定额度的沙盒空间来供每一个app正常存储和运行。 不管是C程序还是iOS程序（为了简单，我们一iOS APP为例），当APP没有打开时，ipa或者app文件都是存在于ROM中，即我们说的iPhone16G的16G当中某一个叫Application的文件夹中，在其启动的时候iOS系统会先为app从RAM中分配一个独立的内存空间（即沙盒），app所有的内存操作都在这个独立的沙盒中进行。首先系统会加载二进制代码到内存中，然后加载常量区中的常量，接着加载全局区和静态区（初始化过的静态区和没有初始化过的静态区是分开的），之后程序会找main入口函数开始执行代码，在执行代码的过程中，会创建对象和一些局部变量，其中对象存放在堆中，变量存放在栈上，以上五个区中只有堆是由程序员自己创建和销毁，而其他四个都是系统自己管理。 由此可见，从低地址到高地址的的内存区域分别是代码区、常量区、全局区、堆区和栈区。 概念程序代码区代码区用来存放函数体的二进制代码，程序结束后由系统释放 常量区常量区用来存放常量字符串等，程序结束后由系统释放 全局区/静态区全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后有系统释放 全局变量和静态变量要尽量少用。因为这些变量在程序的生命周期中不会变释放，比较容易占用内存空间，不适合存储比较大量的数据。 堆区一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式类似于链表。堆区的变量地址是由下往上分配的，所以在同一线程中先声明的变量地址要比后声明的变量地址小。 堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 首先应该知道操作系统有一个记录空闲内存地址的链表。 当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。 由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中 堆是函数库内部数据结构，不一定唯一。 不同堆分配的内存无法互相操作。 堆空间的分配总是动态的 虽然程序结束时所有的数据空间都会被释放回系统，但是精确的申请内存，释放内存匹配是良好程序的基本要素。 栈区栈区用来存放局部变量，先进后出，一旦出了作用域就会被销毁。程序员不需要管理栈区变量的内存。栈区变量的大小是由上到下分配的，所以先声明的变量地址比后声明的变量地址要大。栈区存储在应用程序允许的内存空间的最上面。 栈是向低地址扩展的数据结构，是一块连续的内存的区域。是栈顶的地址和栈的最大容量是系统预先规定好的，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数 ) ,如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 存储每一个函数在执行的时候都会向操作系统索要资源，栈区就是函数运行时的内存，栈区中的变量由编译器负责分配和释放，内存随着函数的运行分配，随着函数的结束而释放，由系统自动完成。 静态分配是编译器完成的，比如自动变量(auto)的分配。 动态分配由alloca函数完成。 栈的动态分配无需释放(是自动的)，也就没有释放函数。 为可移植的程序起见，栈的动态分配操作是不被鼓励的！ 详解代码1：#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;iostream&gt; #include&lt;string.h&gt; static int a=1;//全局初始化区 int b=2;//全局初始化区 char *p;//全局未初始化区 char *p2;//全局未初始化区 int *p3;//全局未初始化区 int *p4;//全局未初始化区 char *p5={&quot;555555555&quot;};//全局初始化区 int main(){ static int c=3;//全局初始化区 int d=4;//内存栈 int e=7;//内存栈 char *p6={&quot;555555555&quot;};//内存栈 p=(char*)malloc(sizeof(char)*10);//内存堆 p2=(char*)malloc(sizeof(char)*10);//内存堆 p3=(int*)malloc(sizeof(int));//内存堆 p4=(int*)malloc(sizeof(int)*10);//内存堆 for(int i=0;i&lt;=9;i++)p4[i]=0x1;//内存栈 *p3=0x123; strcpy(p,&quot;123456789&quot;);//文字常量区 strcpy(p2,&quot;987654321&quot;); strcpy(p2,&quot;123456789&quot;); } 全局初始化区与静态初始化区是在同一段内存 连续分配的，按内存地址增长方向分配 全局初始化区与全局未初始化区不在同一段内存区，全局初始化区按内存地址增长方向分配，全局未初始化区没有规律 栈空间也是同一段内存 连续分配的，按内存地址减小方向分配 堆空间也是同一段内存 连续分配的，按内存地址增大方向分配 文字常量区在自己特有的内存段内，且有机制控制字符常量不被修改（当字符串相同的时候，系统有时还会将两个指针指向同一处） 代码2：在A.m里定义一个全局变量int i =1， 在B.m里直接访问。A中的任意方法都能访问i，但B中方法访问i时预编译不能通过，报use of undeclared identifier _i错误 在A.m里定义一个全局变量int i =1， 在B.m里 extern int i。A中的任意方法都能访问i，B中的方法对i也是可读可写。他们用的是同一个i 在A.m里定义一个静态全局变量static int i =1，在B.m里直接访问。A中的任意方法都能访问i，但B中方法访问i时预编译不能通过，报use of undeclared identifier _i错误 在A.m里定义一个静态全局变量static int i =1，在B.m里 extern int i;A中的任意方法都能访问i，但B中方法访问i时编译不能通过，报Undefined symbols i 错误 在A.m和B.m里分别定义静态全局变量static int i=200; static int i =300;则互不影响，有两个同名但不同存储位置的i，各源文件里的方法访问各自源文件里的i。 在A.m和B.m里分别定义静态全局变量static int i=200; 和全局变量 int i =300;仍然互不影响。如果我在A里extern int i了，A中方法访问的i仍然是200那个，而不是B中那个i 在A.m和B.m里分别定义全局变量int i=200; 和 int i =300;则编译不通过，报duplicate symbol _i错误同样在A.m和B.m里分别定义全局常量const int i =200;和全局变量int i =300 也编译不通过同样的上面7条都适用于全局常量。const int i = 11;和 static const int i =1不同的只是不加const可写，加了const只可读。 在A.h里声明全局变量extern int i;在A.m里定义全局变量int i = 1;在其他源文件里import “A.h”即可访问A中定义的i 全局变量加了static有内部之意，全局不加static则表示真正的全局 非静态全局变量具有全局作用域。 其只需在一个源文件中定义，就可以作用于所有的源文件。 其他不包括全局变量定义的源文件可以通过extern的方式引用。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jekyll的使用详解]]></title>
    <url>%2F2011%2F11%2F25%2FJekyll%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[上一章介绍了如何在GitHub Pages中搭建Jekyll，参照Jekyll官网给出的使用文档，这一章我们详细解读一下Jekyll，这是我后边找到的中文文档，可供参考 快速指南上一章简单说了，这是一个简单的静态网页生成器，具体的安装和使用方式请如下： ~ $ gem install jekyll ~ $ jekyll new myblog/. --force ~ $ cd myblog ~/myblog $ bundle install ~/myblog $ bundle exec jekyll serve =&gt; Now browse to http://localhost:4000 目录结构打开Jekyll生成的文件夹后，通过资源管理器可以观察到已经自动生成的目录结构，比较重要的几个如下： _config.yml :存储配置数据。把配置写在这个文件里面，可以让你不用在命令行中写 _drafts:草稿，格式是:没有日期.md _includes:包含一些模板，可以重复利用 _layouts:里面的文件通过{ content }包含_posts里面的文章 _posts:存放你要发表的文章。格式YEAR-MONTH-DAY-title.MARKUP _data:保存数据的。jekyll会自动加载这里的所有的YAML文件，如.yml、.yaml、.json、.csv等结尾的文件，比如你有一个members.yml。那么你可以通过site.data.members访问该文件里的数据 _site：jekyll生成的网站会放在该文件夹下，最好把它放到.gitignore文件里面，这样git就不会管理它了 .jekyll-metadata：这个文件帮助Jekyll记录网站文件的修改日志，在下一次生成网页的时候，只生成那些修改过的文件，这个文件可以加入到.gitignore文件中 index.html：网站首页，jekyll会自动转换并生成它 配置Jekyll有自带的默认配置，如果需要手动修改配置，则需要配置参考文档 头信息通过这个可以设置一些变量（甚至可以自定义变量），比如layout和title --- layout: post title: Blogging Like a Hacker --- 设置好变量以后，你就可以在当前页面或者你的页面依赖的_layouts或者_includes里的文件通过Liquid 标记，比如{page.title}访问了 撰写博客jekyll有一个最好的特性就是：你写文章并发表他们只是意味着你只要管理一些文本文件即可。而不需要配置和维护数据库以及良好的CMS系统 文章文件夹里面都是些md或者testile文件。只要有yaml front matter，它们就会被转换为html格式的静态页面 创建文章的文件创建一个文件YEAR-MONTH-DAY-title.md，YEAR是4位数，month和day是两位数 内容格式所有的文章都必须要有yaml front matter头 注意字符编码：将&lt;meta charset=&quot;utf-8&quot;&gt;包含在head标签里面来保证中文编码的正确性 引用图片和其它资源在根目录下创建文件夹比如assets和downloads，然后markdown语法访问通过这种形式：![截屏](/assets/screenshot.jpg) 说明：截屏链接的文字，（）里面的东西不会显示，是链接到的地址。site.url可以访问你配置的（_config.yml）的网站url 文章的目录 文章摘要 高亮代码片段通过Pygments or Rouge，Jekyll具有内建的语法高亮能力 使用草稿drafts里面的文章是你暂时不想发表的，并且可以没有日期前缀 jekyll serve –drafts 预览 jekyll build –drafts 编译 这两个方法可以使drafts中的草稿文章移动到posts中去，并且自动为其文件名加上当期日期的前缀 创建页面作为写文章的补充，Jekyll 还可以创建静态页面。利用 Jekyll 带来的便利，你只需要复制文件或文件夹，就是这么简单 主页像任何网站的配置一样，需要按约定在站点的根目录下找到 index.html 文件，这个文件将被做为主页显示出来。除非你的站点设置了其它的文件作为默认文件，这个文件就将是你的 Jekyll 生成站点的主页 其它的页面的位置将 HTML 文件或者 Markdown 放在哪里取决于你想让它们如何工作。有两种方式可以创建页面 将为页面准备的命名好的 HTML 文件或者 Markdown 文件放在站点的根目录下 在站点的根目录下为每一个页面创建一个文件夹，并把 index.html 文件或者 index.md 放在每个文件夹里 一般方式： |– _config.yml|– _includes/|– _layouts/|– _posts/|– _site/|– about.html # =&gt; http://example.com/about.html|– index.html # =&gt; http://example.com/└── contact.html # =&gt; http://example.com/contact.html 干净的url方式（不带有文件后缀） ├── _config.yml├── _includes/├── _layouts/├── _posts/├── _site/├── about/| └── index.html # =&gt; http://example.com/about/├── contact/| └── index.html # =&gt; http://example.com/contact/└── index.html # =&gt; http://example.com/ 静态文件为了渲染或转换内容，Jekyll提供了静态文件，静态文件中不包括YAML front matter，而是包括images，PDFs和一些没有被渲染的内容如果要访问这些静态内容，就需要用site.static_files中的metadata，如file.path/modified_time/extname 变量Jekyll会遍历带yaml front matter头的所有文件，然后都可以通过Liquid模板系统访问一些变量 全局变量 site：包含了网站信息和_config.yml里面的信息 page:在yaml front matter的自定义的变量通过page访问 layout:在yaml front matter的自定义的变量通过layout访问 content:_layouts里面，不定义在_post和其他页面中。包含了post和其他页面里面的文章内容 paginator:paginate在_config_yml里面配置以后，这个变量就可以用了 site变量 site.time:当前运行jekyll的时间 site.pages:所有的页面 site.posts:以时间逆序排序的所有的文章 site.data：包含从目录_data里面加载的数据列表 page变量 page.content:页面内容 page.title:文章标题 page.urL:页面地址：比如/2008/12/14/my-post.html page.date:页面的日期。可以在front matter重写：2008-12-14 10:30:00 +0900或者YYYY-MM-DD HH:MM:SS page.id:页面id。比如/2008/12/14/my-post 在RSS feeds里面有用 front matter里面可以自己定义变量：比如custom_css: true,然后你可以通过page.custom_css访问 Paginator变量 paginator.per_page：每一页的文章数 paginator.posts：那一页可用的文章 paginator.page：当前页的值 Paginator只在index.html(或者/blog/index.html)中有效 集合(Collections)并非所有的都会是文章或页面。也许您想要记录您开源项目中涉及的各种解决方案，团队成员，或是某次会议记录。集合（Collection）允许您定义一种新的文档类型，它既可以像页面和文章那样工作，也可以拥有它们特有的属性和命名空间 使用集合 让 Jekyll 读取您的集合:将下面的代码加入您的 _config.yml 文件，将my_collection 替换为您集合的名字 collections: my_collection: foo: bar 加入您的内容 选择性渲染你的集合文件为独立文件 Liquid 属性每个集合均可访问 Liquid 的site变量,每个集合都具有一个他本身的文档数组 数据文件除了 Jekyll 的内建变量之外，你还可以指定用于 Liquid 模板系统 的自定义数据。Jekyll 支持从 data 目录下的 YAML、JSON 和 CSV 载入数据，注意 CSV 文件必须包含表头行。这个强大的特性可以帮你避免模板中的重复，并能在不修改 _config.yml 的情况下设置网站特定的选项。 正如在目录结构中所描述的，_data 目录用于存储供 Jekyll 生成网站的附加数据。这些文件可以使用 .yml、.yaml、.json、csv 扩展名，并可通过 site.data 访问 资源Jekyll 提供了对 Sass 的内建支持，还能通过安装相应的 Ruby gem 支持 CoffeeScript。使用时只需创建以 .sass、.scss 或 .coffee 为扩展名的文件，并以两行 — 开头即可 博客迁移如果你要从其他博客迁移到 Jekyll，Jekyll 导入器可以帮助你]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Jekyll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在GitHubPages上搭建Jekyll]]></title>
    <url>%2F2011%2F10%2F28%2F%E5%9C%A8GitHubPages%E4%B8%8A%E6%90%AD%E5%BB%BAJekyll%2F</url>
    <content type="text"><![CDATA[在GitHub Pages上搭建blog，使我们既拥有绝对权限管理，又享受github带来的便利 Jekyll是一个静态站点生成器，提供了模板、变量、插件等功能，来生成整个网站 GitHub Pages是什么GITHUB是一种分布式的代码仓库管理工具，在GITHUB上每个项目都有一个主页，列出了项目的源文件。但是对于一个新手来说，看到一大堆源码，只会让人头晕脑涨，不知何处入手。他希望看到的是，一个简明易懂的网页，说明每一步应该怎么做。因此，github就设计了Pages功能，允许用户自定义项目首页，用来替代默认的源码列表。所以，github Pages可以被认为是用户编写的、托管在github上的静态网页。github提供模板，允许站内生成网页，但也允许用户自己编写网页，然后上传。有意思的是，这种上传并不是单纯的上传，而是会经过Jekyll程序的再处理。 Jekyll是什么Jekyll（发音/‘dʒiːk əl/，”杰克尔”）是一个静态站点生成器，它会根据网页源码生成静态文件。它提供了模板、变量、插件等功能，所以实际上可以用来编写整个网站整个思路到这里就很明显了。你先在本地编写符合Jekyll规范的网站源码，然后上传到github，由github生成并托管整个网站。 如何实现 注册登录GIT账号 在账号下添加新的git仓库（用户名+github+io） 安装jekyll并创建jekyll目录 安装jekyll目录需要的bundle包 创建Markdown或HTML页面 启动jekyll服务，通过http://localhost:4000访问并验证 将代码上传至github，通过域名来访问]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Jekyll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法的使用]]></title>
    <url>%2F2011%2F09%2F30%2FMarkdown%E8%AF%AD%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[从今天开始，坚持写博客，一般博客中会用到Markdown语法，先找一篇文章来学习总结一下其语法 Markdown语法的目标是实现易写易读，下边的内容就是介绍如何使用Markdown语法 嵌套HTMLMarkdown的语法在HTML标签中无效，但是HTML标签在Markdown语法中是可以直接使用的 特殊字符自动转换在HTML中，有两个字符需要特殊处理:&lt;和&amp;，如「AT&amp;T」 ，你必须要写成「AT&amp;T」，但是在Markdown中，他们可以进行自动转换，不需要特殊处理 段落和换行在Markdown中如果需要换行，则在行尾加上两个以上的空格，然后按回车键 标题Markdown支持两种标题语法，Setext和atx形式 Setex形式是用底线的形式，利用=(大标题)和-(小标题) Atx形式是在行首插入1到6个#，对应标题的大小 引言如果需要在文章中插入引言，则需要在每行的最前面加上&gt;，在引言中可以插入引言和其它的Markdown语法 列表Markdown支持有序的列表和无序的列表，列表中可以嵌套其它的Markdown语法，如引言或代码块 有序列表使用数字接着一个英文句号开头，然后一个空格或制表符 无序的列表使用星号／加号／减号作为列表标记，然后一个空格或制表符 程序块HTML会用&lt;pre&gt;和&lt;code&gt;标签把程序块包起来，Markdown直接简单地缩排4个空格或1个Tab就可以，这样就会转化成HTML的格式 分隔线可以在一行中用三个或以上的*,-,_来建立一个分隔线，行内不能有其他东西 链接Markdown支持两种形式的链接语法，行内和参考，不管用哪一种，链接的文字都是用[方括号]来标记 行内：在方括号的后面马上接着圆括号并插入网址链接即可 参考：在方括号的后面再跟一个方括号，方括号里边填入链接的标签，在文件的任意处，把标签的链接内容定义出来，定义形式为：[foo]: http://example.com/ “Optional Title Here” 强调Markdown使用星号(*)和下划线(_)作为标记强调的标记，被他们包围的文本会转化成斜体文本，用两个包围起来的话，则会被转化成加粗文本，如果要在蚊子前后直接插入普通的星号或下划线，可以用反斜线转义 程序码如果要标记行内一小段程序，可以用反引号把它包围起来 图片Markdown使用一种和链接很相似的语法来标记图片，同样允许两种样式：行内和参考 自动链接只要用方括号扩起来的字符，Markdown就会自动生成链接，链接的文字和链接位置一样，如&lt;http://example.com/&gt; 转义字符如果需要在Markdown中插入一些语法已标记字符，可以在前边加反斜线进行专义]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIS的一些基本概念]]></title>
    <url>%2F2011%2F08%2F26%2FGIS%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[前些天无聊至极，就翻阅了超图公司的 GIS Deskpro 相关产品的帮助文档，感觉对了解他们公司产品和服务没有多大的帮助，反倒觉得那帮助文档是一个很好的全面学习GIS专业知识的好帮手，现在把自己这几天学习到的东西整理一下下： 各桌面产品与功能模块:各桌面产品与功能模块包括： 桌面集成环境 地图模块 标准图幅图框模块 编辑模块 属性模块 配准模块 布局模块 三维模块 栅格分析模块 网络分析模块 工作空间工作空间用于保存用户的工作环境，包括： 当前打开的数据源（位置、别名和打开方式） 底图 专题地图 布局 符号库 线型库等 数据源数据源是由各种类型的数据集（如点、线、面类型数据，TIN、GRID、NetWork）组成的数据集集合, 数据源的属性包括数据源的基本信息和数据源的投影信息 数据集数据集是由同种类型数据组成的数据集合,包括十六种： 纯属性数据集 点数据集 线数据集 面数据集 文本数据集 网络数据集 三维点数据集(文本文件\属性生成或点数据集转换) 三维线数据集 CAD数据集 TIN数据集 路由数据集(存放线类型的数据，线对象的每个节点除了有地理坐标值，还有一个M坐标值，代表该节点到起点的距离) 影像数据集 DEM数据集 Grid数据集 MrSID数据集 ECW数据集 SDB 数据源一个SDB数据源文件包括SDB和SDD两个文件，由SDB文件存储空间数据，由SDD存储管理属性数据。SDD文件其实就是一个Access数据库，它管理着数据源中各数据集对应的属性表。一个数据集对应连接一个属性表，系统通过唯一标识SmID将数据集的每一个对象与对应属性表中的记录进行连接，建立起一一对应的关系。 地图的属性地图的属性，包括地图的信息以及地图上对象的设置信息 TININ是不规则三角网（Triangulated Irregular Network）的缩写，它是采用不规则三角形拟合地表。TIN数据集由存储有Z值的点组成，通过边相连形成连续的不重叠的三角面。主要用来描述数字高程表面。 TIN 的创建TIN通常可以由多种类型矢量数据集来创建, SuperMap 桌面产品提供了把点/三维点/线数据集转换成TIN数据的功能。 DEMDEM（Digital Elevation Modals，数字高程模型）是地面特性为高程和海拔高程的数字地面模型（DTM）。 DEM数据集可以通过线数据集、点线数据集联合以及TIN数据集来生成。 布局布局就是地图（包括专题图）、图例、地图比例尺、方向标图片、文本等各种不同地图内容的混合排版与布置，主要用于电子地图和打印地图。 创建布局创建一个布局就是将所需的布局元素添加到布局窗口中加以整理与修饰，以达到地图所要表示的用途。而布局元素包括了一些地图元素（地图、比例尺、方向标、图例、专题图图例）、绘制元素（点、直线、折线、矩形、圆角矩形、椭圆和多边形）、标注元素（文本和艺术字）和其他相关元素（表格和图片）。 DirectXDirectX加强3d图形和声音效果，并提供设计人员一个共同的硬件驱动标准，让游戏开发者不必为每一品牌的硬件来写不同的驱动程序，也降低用户安装及设置硬件的复杂度。 SuperMap SDX+SuperMap SDX+是SuperMap的空间引擎技术，它提供了一种通用的访问机制（或模式）来访问存储在不同引擎里的数据。这些引擎类型有数据库引擎、文件引擎和 Web 引擎. 引擎优化: 选择合适的硬件平台内存、硬盘、网络 选择使用文件缓存功能 为Layer设置合适的MinVisibleGeometrySize属性值 建立空间索引 建立空间索引 影像数据的优化 SuperMap SDX+ 空间索引 R树索引：R树空间索引方法是通过设计虚拟的矩形目标，将一些空间位置相近的目标对象，包含在这个矩形内，把这些矩形作为空间索引，它含有所包含的空间对象的指针。 四叉树索引： 图库索引 ：根据数据集的某一属性字段或根据给定的一个范围（图幅的长和宽），将空间对象进行分类，通过索引进行管理已分类的空间对象，以此提高查询检索速度。 动态索引：将数据集按照一定的规则划分成相等或不相等的网格，记录每一个地理对象所占的网格位置。在GIS中常用的是规则网格。当用户进行空间查询时，首先计算出用户查询对象所在的网格，通过该网格快速查询所选地理对象。可以优化查询操作。 事务的四个属性在数据库应用程序中，事务是一个比较常见的概念，它是作为单个逻辑工作单元执行的一系列操作。一个逻辑工作单元必须有四个属性，称为ACID（原子性、一致性、隔离性和持久性）属性，只有具备这些属性才能成为一个事务。 原子性:原子性决定事务不可分割，事务必须是原子工作单元，对于其数据所作的修改必须是全执行或全不执行。 一致性:事务在完成时必须使所有的数据都保持一致状态。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。事务结束时所有的内部数据结构（如B树索引或双向链表）都必须是正确的。 隔离性:由并发事务所作的修改必须与其它并发事务所作的修改隔离。事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据，这称为可串行性，因为它能够重新装载起始数据，并且回滚一系列事务，以使数据结束时的状态与原始事务执行的状态相同。 持久性:事务完成之后，它对于系统的影响是永久性的，即使出现系统故障，事务所作的修改也将一直保持。 地图投影的目的地图投影的目的：地球椭球体表面是曲面，而地图通常要绘制在平面图纸上，因此制图时首先要把曲面展为平面。然而球面是个不可展的曲面，所以必须采用特殊的方法将曲面展开，使其成为没有破裂或褶皱的平面，于是就出现了地图投影理论。 地球椭球体地球椭球体（Sphere/Spheroid）由于地球形状的不规则性，不同国家在不同的历史时期对地球进行过无数次测量，导致出现了大量的椭球体，但是由于没有一个椭球体能够准确的描述地球的整体形状，所以在应用时应该根据各个国家或地区的具体情况选择合适的地球椭球体。 大地参照系大地参照系（Datum）大地参照系确定了地球椭球体相对于地球球心的位置，为地表地物的测量提供了一个参照框架，确定了地表经纬网线的原点和方向 地理坐标系地理坐标系（Geographic Coordinate System）一般情况下，一个地理坐标系由三部分组成：大地参照系（Datum），本初子午线（Prime Meridian），角度单位（Angular Units）。 投影坐标系投影坐标系（Projected Coordinate System）投影坐标系是与地理坐标系相对的一个概念，是将椭球面上的点通过地图投影的方式投影到（地图）平面上，分为平面极坐标系和平面直角坐标系。平面直角坐标系按照直角坐标原理确定一点的平面位置，由原点及通过原点的两个垂直相交轴组成，这种坐标也叫笛卡尔坐标或直角坐标。测绘中的直角坐标系与数学中的不同点是，X轴和Y轴互换。 一般情况下，一个投影坐标系包含以下几部分，投影坐标系的名称，坐标单位，投影方式，地理坐标系，投影参数。投影参数常用的有以下几种:地图投影的方法： 几何透视法:以平面、圆柱面、圆锥面为承影面，将曲面（地球椭球体面）转绘到平面（地图）上的一种古老方法 数学解析法:是建立地球椭球体面上的经纬网与平面上相应经纬网之间对应关系的方法。实质就是直接确定球面上某点的地理坐标与平面上对应点的直角坐标之间的函数关系。当前绝大多数地图投影都采用这种方法。 地图投影分类 按投影变形性质分类:按照投影的变形性质可以分为以下几类：等角投影、等积投影、任意投影（等距投影是其中特例）。 按投影构成方式分类:根据投影构成方式可以分为两类：几何投影和解析投影。 几何投影包括方位投影、圆锥投影和圆柱投影。根据投影面与球面的位置关系的不同又可将其划分为：正轴投影、横轴投影、斜轴投影解析投影是不借助于辅助几何面，直接用解析法得到经纬网的一种投影。主要包括：伪圆锥投影，伪圆柱投影，伪方位投影，多圆锥投影。 投影方法目前常用的投影方法有莫卡托投影（正轴等角圆柱投影）、高斯-克吕格投影（等角横切圆柱投影）、UTM 投影（等角横轴割圆柱投影）、Lambert投影（等角正割圆锥投影）等。 莫卡托投影是一种“等角正切圆柱投影” 高斯-克吕格(Gauss-Kruger)投影，是一种“等角横切圆柱投影” UTM投影全称为“通用横轴墨卡托投影”，是一种“等角横轴割圆柱投影” 兰勃托(Lambert)投影，又名“”等角正割圆锥投影”， 坐标系分类数据的坐标系分为三类：平面坐标系、地理坐标系、投影坐标系。 ##数据编码数据编码：是数据在计算机中的存储方式。通常用来减少数据所占的存储空间以及提高数据的安全性，或者作为一种数据交换的格式。GIS数据分为有编码与无编码两种，而采用编码的主要目的，是用一定的压缩方法减少海量数据的存储，大大提高磁盘读写和网络传输的效率，显著提高性能。数据编码是一个压缩的概念，类似于ZIP，RAR等，矢量数据集有多种编码方式，典型的有SDC和SWC两种。 SWC，WORD编码类型，应用于矢量数据集（线、面类型）的一种编码方式，对点数据集不起作用。压缩比为4倍。精度损失为1/216。数据集中对象大小比较平均的情况下，推荐使用此种编码方式。SDC，DWORD编码类型，应用于矢量数据集（线、面类型）的一种编码方式，对点数据集不起作用。压缩比为2倍。精度损失为1/232，按照全球大小的对象估计，精度损失在毫米级。总结其优势：压缩速度快，损失小，原图和编码后的图对比浏览时，基本看不到差别。可以说SDC是几乎接近无损的一种编码方式，一般的数据推荐使用SDC。对一些在空间上相邻，有公共边的面状数据，用SDC编码完全没有问题，但用SWC，在放大很大时会有缝隙显现。数据压缩的代价：压缩之后的数据不可逆，即不可以返回数据压缩之前的状态，此外在精度上有一定的损失，对查询和分析有影响，如果进行非常精确的查询和空间分析等，SWC会导致一些结果上的误差，但SDC不会有影响，其产生的精度损失在空间分析的容限范围之内。 地图缓存地图缓存是一种用于改善地图浏览用户体验的优化策略。服务器端创建了地图缓存之后，客户端用户的每一次地图浏览，比如平移、放大、缩小地图，都会向服务器端发送一个URL请求，此时，服务器端按照匹配的条件，将已缓存的图片返回到客户端。通常将服务器端在发布地图服务之前，已经创建的地图缓存称为预缓存。 为什么使用地图缓存只需要付出一次缓存的代价，就可以提供给客户端地图显示以快速的响应速度。地图缓存是以一系列不同比例尺下地图图片形式提供的，因此不受矢量地图显示上的约束，比如地图信息量的大小、地物的复杂程度、是否带有标注、所使用的地图符号等限制。因为，一般情况下，地图渲染的细节越多，承载的信息量越丰富，同等环境下，绘制矢量地图就越慢，但使用了地图缓存，客户端在获得了同样分辨率显示效果的同时，等待时间却大大缩短，增强了用户的体验，满足系统对快速地图响应的要求。 GIS一般出现的问题与优化方法： 地图反走样 交叉线优化 图层顺序调整 文本层叠优化 地图显示速度优化 反走样 (antialiasing)：在光栅图形显示器上绘制非水平且非垂直的直线或多边形边界时，或多或少会呈现锯齿状或台阶状外观。这是因为直线、多边形、色彩边界等是连续的，而光栅则是由离散的点组成，在光栅显示设备上表现直线、多边形等，必须在离散位置采样。由于采样不充分重建后造成的信息失真，就叫走样(aliasing)。而用于减少或消除这种效果的技术，就称为反走样(antialiasing)。通过地图优化可以去除一些呈现锯齿状或台阶状的显示，提高地图的美观性：一般提高显示速度最好的方法就是减少地图中图层和显示对象，这样将减少系统更新，达到提供显示速度的目的。 地图显示速度优化 对象过滤显示过滤对象尺寸、过滤显示条件、文本字高过滤显示 图层过滤显示 层是否可显示、图层比例尺过滤显示 地图缓存用“地图缓存”功能对当前地图按照设置的比例尺和缓存范围生成一系列的缓存图片。在浏览此地图时可以直接读取缓存中的图片，从而提高地图显示的速度 建立索引提高矢量数据的查询、访问、排序、浏览等操作，提供了多种文件索引，包括字段索引、四叉树索引、R树索引、动态索引和图库索引（原三级索引） 创建影像金字塔 金字塔是栅格数据集的简化分辨率（reduced resolution）图像的集合。影像金字塔技术通过影像重采样方法，建立一系列不同分辨率的影像图层，每个图层分割存储，并建立相应的空间索引机制，从而提高缩放浏览影像时的显示速度。 无地图缩放动画效果 专题图种类SuperMap总共提供了七种专题图以供选择。从图中可以看出，单值专题图，范围分段专题图，统计专题图都具有专题图标签，它们在地图中显示为多种风格，在此称为多元风格专题图。而其他的等级符号专题图、点密度专题图、标签专题图和自定义专题图仅有一个专题图项，没有专题图标签，它们在地图中显示为单一风格，在此称为单一风格专题图。 多元风格专题图这些图都有配色方案，都有标签，都可以设置多个字段（值），在地图中显示可以用多种符号（线型、填充）来表达字段（值）信息，地图画面较为丰富。 单一风格专题图：只能设置一个字段通过一种符号（线型、填充）来表达字段值的信息 地图分类地图一般分为普通地图和专题地图，根据功能的不同又从专题地图里划分了统计地图。 普通地图是以相对均衡的详细程度表示制图区域内各种自然和社会经济现象的地图。其内容包含全地图要素 题地图是以普通地图为地理基础，着重表示制图区域内某一种或几种自然或社会经济现象的地图。这类地图的显著特点是，作为该图主题的专题要素予以详尽表示，其地理基础内容则视主题而异 常用的颜色模式： RGB 模式：RGB 是Red（红色）、Green（绿色）、Blue（蓝色）的缩写。由红、绿、蓝相叠加可以产生其它颜色，因此该模式也叫加色模式 CMYK 模式：CMYK 是Cyan（青）、Magenta（洋红）、Yellow（黄色）以及Black（黑色）的缩写。与RGB模式不同的是它的颜色合成方式不是颜色相加，而是颜色相减 HLS 模式：HLS 是Hue(色调)、Luminance(亮度)、Saturation(饱和度)的缩写。 色调色调是颜色的一种属性，它实质上是色彩的基本颜色，即我们经常讲的红、橙、黄、绿、青、蓝、紫七种，每一种代表一种色调。色调的调整也就是改变它的颜色。 亮度亮度就是各种颜色的图形原色（如RGB的原色为R、G、B三种或各种自的色调）的明暗度，亮度调整也就是明暗度的调整。而我们通常讲的灰度图像，就是在纯白色和纯黑色之间划分了多个级别的亮度，也就是从白到灰，再转黑。同理，在RGB 模式中则代表个原色的明暗度，即红绿蓝三原色的明暗度，从浅到深。 饱和度饱和度是指图像颜色的彩度.对于每一种颜色都有一种人为规定的标准颜色，饱和度就是用描述颜色与标准颜色之间的相近程度的物理量。调整饱和度就是调整图像的彩度。将一个图像的饱和度条为零时，图像则变成一个灰度图像。 地理空间数据交换格式地理空间数据交换格式（Geo-spatial data transfer format）分为矢量、影像和格网三类。其中矢量交换格式，是以VCT为扩展名。 对象（object）：即几何对象，在GIS中对离散空间实体的数字化表示。一个对象具有自己的属性和行为。单一对象（Single Object）：子对象（part）：简单对象（Simple Object）：复杂对象（Complex Object）：复合对象（Compound Object）：参数化对象：对象类型：绘制对象类型 对象运算对象运算主要包含了合并、求交、交集取反、擦除、擦除外部、组合、分解和保护性分解共8中对象运算方式。合并是同类型融合起来，组合是CAD图中的图形组合起来。参与操作的对象为非岛洞多边形的复杂面对象，则分解与保护性分解效果相同。 空间数据的查询和分析空间数据的查询和分析在GIS工程项目中处于核心地位，在使用GIS数据时，我们经常需要从已有的数据中查询出部分满足特定条件的数据。GIS 中的查询类型一般可以分为以下三种：单纯的属性查询、单纯的空间查询、以及与空间位置和属性同时相关的综合查询 SQL语句SQL语句是标准的计算机查询语句，SuperMap中的许多查询功能都是通过构建SQL语句来完成的,SQL表达式的语法为“Select …（需要输出的字段名） from … （数据集名）where…（查询条件）(order by …ascending/descending)（结果排序字段，可选）”。 对数值的查询 :对数值的查询可以使用＝, &lt;&gt;, &gt;, &lt;, &lt;=, &gt;=, Between 等等 模糊查询:模糊查询使用like，而且不同类型的数据源使用的匹配符不尽相同 查询特定值 :使用in，确定表达式的值是否等于指定列表内若干值中的任意一个值 查询某个字段值是否为空 ,使用is NULL (is not NULL) 通过构造语句进行查询 组合语句 :使用and，将两个或者多个查询语句组合起来 比较运算符在字符型字段中的应用 日期型字段的查询 :World_countries.dat = #08/10/94# 派生字段(Pop_2000-Pop_1990)/Pop_1990 as Growth_Rate SQL特殊 系统中提供的SQL查询条件运算符除了常用的数学运算符和逻辑运算符外，还提供了一些比较特殊的运算符 聚合函数对一组值执行计算并得到单一的值。除 COUNT 函数之外，聚合函数忽略空值。聚合函数经常与 SELECT 语句的 GROUP BY 子句一同使用。所有聚合函数都具有确定性。任何时候用一组给定的输入值调用它们时，都得到相同的值。除 COUNT() 外，其它聚合函数均不能对文本数据类型使用. 数学函数对数字表达式进行数学运算并返回运算结果。 数学函数在 SuperMap 中的表达式一般采用属性表的字段名或字段名构成的表达式，如Cos(Slope）、Ceiling(Pop/Area)等 字符串函数用于对字符和二进制字符串进行各种操作，它们返回对字符数据进行操作时通常所需要的值 日期函数用来显示关于日期的信息。这些函数适用于日期类型字段值，并对这些值执行算术运算。可将日期函数用于可使用表达式的任何地方。 空间查询空间查询是通过几何对象之间的空间位置关系来构建过滤条件的一种查询方式。相对于完全由属性过滤条件构建的基于属性的查询，基于空间位置关系且同时可以应用属性过滤条件的称为空间查询。 查询模式22种空间查询模式，其中有9种为基本算子，3种常用算子，10种为组合算子。空间查询涉及三个要素，分别是：搜索对象、被搜索图层及结果记录集]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>GIS</tag>
        <tag>SuperMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构在GIS中的应用]]></title>
    <url>%2F2011%2F07%2F29%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9C%A8GIS%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[计算机是一门研究用计算机进行信息表示和处理的科学。数据结构是数据在计算机中的逻辑和存储结构，GIS是地理信息系统的缩写，地理信息在计算机中的存储和应用非常普遍，所以，本篇文章将会探讨如何利用数据结构的知识，方便而快速的保存和处理地理信息。 这里面涉及到两个问题：信息表示、信息处理，信息表示会影响信息处理 数据结构研究的是信息表示的问题 算法研究的是信息处理的问题 信息表示直接关系到信息处理的算法与效率。信息 （数据）之间往往是有重要的结构关系，数据结构就是对数据表示以及其上操作或功能的封装，分逻辑结构和存储结构两个层面。 逻辑结构逻辑结构定义了数据之间的逻辑结构关系。 数据元素相互之间的关系称为结构，有四类基本结构：集合、线性结构、树形结构、图状结构（网状结构）。 集合结构中的数据元素除了同属于一种类型外，别无其它关系 线性结构中元素之间存在一对一关系 树形结构中元素之间存在一对多关系 图形结构中元素之间存在多对多关系 存储结构存储结构定义了数据实际在计算机中存储结构关系，是某种逻辑结构在计算机上的具体实现，分顺序存储结构和链式存储结构。 顺序存储方法：它是把逻辑上相邻的结点存储在物理位置相邻的存储单元里，结点间的逻辑关系由存储单元的邻接关系来体现，由此得到的存储表示称为顺序存储结构。顺序存储结构是一种最基本的存储表示方法，通常借助于程序设计语言中的数组来实现。 链接存储方法：它不要求逻辑上相邻的结点在物理位置上亦相邻，结点间的逻辑关系是由附加的指针字段表示的。由此得到的存储表示称为链式存储结构，链式存储结构通常借助于程序设计语言中的指针类型来实现。 索引存储方法：除建立存储结点信息外，还建立附加的索引表来标识结点的地址。 散列存储方法：就是根据结点的关键字直接计算出该结点的存储地址。 在GIS开发实现中，空间索引、空间数据存储、地图管理、地图符号化及渲染、空间分析等都会用到很多的数据结构，下面作一些简要介绍，仅供参考，读者可以有不同的实现，效率也会有一些差异。 数组和链表数组或链表，在GIS中应用最为广泛，几乎到处可见其身影。比如，线或多边形就是Point类型的数组，读shapefile文件时，文件已经记录下该要素包含的点数，数组的长度就被确定了，如果添加节点，最好采用封装好的动态数组或链表来存储；网格索引，用二维数组表示，每个数组元素记录下该网格范围所对应的数据存储地址，方便空间数据的检索；图层管理，一张地图是由若干个图层叠加而成，用数组或链表来存储这些图层信息，图层顺序调的整转化为数组或链表的删除和插入。 堆栈和队列堆栈和队列，也属于线性结构，只是比数组和链表多了一些限制，堆栈是先进后出，队列是先进先出。比如，线性四叉树索引，用中序遍历的方法降四叉树线性化，其中树的中序遍历，非递归算法就需要用到堆栈；GPS轨迹跟踪，随着GPS点的增加，轨迹会越来越长，在实时跟踪过程中，可能只需要保留当前最近一段时间的点，更早之前的点被保存到数据库中，不再绘制，所以，采用循环队列来存储GPS当前一些点，利用了GPS时间顺序先进先出的特点，同时能循环利用队列；客户端图片瓦片缓存池，也可以采用循环队列，当前可视范围内获取到的新瓦片插入到队列中，当队列满的时候，淘汰最早存放在队列中的瓦片，同时保持队列缓存池的容量。 优先队列优先队列，是不同于先进先出队列的另一种队列，每次从队列中取出的是具有最高优先权的元素，二叉堆就是优先队列，分最大堆和最小堆，它能快速地从一个集合中找出最大（小）的元素。最优路径，算法中经常执行一步就是从后继节点中找出最优的节点，采用的就是最小堆，它能迅速地找出到当前节点权值最小的节点。 树树，是一种递归定义的数据结构，一对多的关系，树是没有回路的连通图。四叉树索引，就是典型的树结构，按MBR（Minimum Bounding Rectangle 最小外包矩形）相交条件从树根一步步往下查找，筛选出要素子集；OGC中XML解析，XML（GML）结构本身也是树状结构；等高线，嵌套关系的表达，是树结构；属性数据词典库，采用Trie数据结构，多叉树的形式，建立属性词典库，通过字符串的匹配实现属性查询。 图图，是一种数据元素间为多对多关系的数据结构，通常采用邻接矩阵或邻接表的方式来存储。道路网或管网的拓扑构建，道路网或管网属于网状结构，用图来描述节点与弧段之间的拓扑关系，便于最优路径、最大流最小割通路、爆管、旅行商等网络分析。 哈希哈希，设计Hash函数代入key算出地址，存储value值，哈希查找效率高，但可能存在冲突，对内存空间占用相对较大一点。道路网或管网构建，以节点的node_id为key，以后继节点的集合为value；GML引擎，以图层编号为key，属于该图层的要素集合为value；线标注，线被裁减后，通过统一的key来拼接，以不同裁减路段集合为value。 以上简要介绍了GIS常用数据结构，但应用远远不止这些。数据结构＋算法＝程序，在数据表示和处理上，具体采用哪种逻辑结构，需要分析数据元素之间的逻辑关系，而确定了逻辑结构，还要考虑采用什么存储结构来实现，也是需要根据实际情况来分析的，数据结构直接关系到算法的具体实现及效率，在GIS开发实现中应用非常广泛。]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>GIS</tag>
      </tags>
  </entry>
</search>
