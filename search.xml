<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[京东MVCS框架]]></title>
    <url>%2F2018%2F01%2F26%2F%E4%BA%AC%E4%B8%9CMVCS%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[京东MVCS框架搭建 NSObject+SYKVO.h/NSObject+SYKVO.m typedef void(^SYKVOBlock)(id newValue); @interface NSObject (SYKVO) - (void)addObserverSuny:(NSObject *)observer keyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options block:(SYKVOBlock)block; // 默认是NSKeyValueObservingOptionNew - (void)addObserverSuny:(NSObject *)observer keyPath:(NSString *)keyPath block:(SYKVOBlock)block; @end CSBaseStore @protocol CSBaseStore &lt;NSObject&gt; - (CSBasePipeline*)pipeline; @end @interface CSBaseStore : NSObject&lt;CSBaseStore&gt; - (void)fecthSeverData; @end CSBasePipeline @interface CSBasePipeline : NSObject @end CSBaseViewController @interface CSBaseViewController : UIViewController @property (nonatomic, strong)CSBaseStore *store; - (instancetype)initWithViewClass:(Class)viewClass store:(CSBaseStore*)store; - (void)setupPipeline:(CSBasePipeline*)pipeline; - (void)addObserver; @end @interface CSBaseViewController () @property (nonatomic, strong)Class viewClass; @end @implementation CSBaseViewController - (instancetype)initWithViewClass:(Class)viewClass store:(CSBaseStore*)store{ self = [super init]; if (self) { self.viewClass = viewClass; _store = store; } return self; } - (void)loadView{ self.view = [self.viewClass new]; } - (void)viewDidLoad { [super viewDidLoad]; [self setupPipeline:_store.pipeline]; [self.view setupPipeline:_store.pipeline]; [self addObserver]; } - (void)setupPipeline:(CSBasePipeline*)pipeline{ } @end UIView+CSBase @interface UIView (CSBase) - (void)setupPipeline:(CSBasePipeline*)pipeline; @end @implementation UIView (CSBase) - (void)setupPipeline:(CSBasePipeline*)pipeline{ } @end CSBaseScene @interface CSBaseScene : NSObject @property(nonatomic, strong)Class viewClss; @property(nonatomic, strong)Class controllerClass; @property(nonatomic, strong)Class storeClass; - (instancetype)initWithScenceWithViewClass:(Class)viewClass controllerClass:(Class)controllerClass store:(Class)storeClass; @end @implementation CSBaseScene - (instancetype)initWithScenceWithViewClass:(Class)viewClass controllerClass:(Class)controllerClass store:(Class)storeClass{ self = [super init]; if (self) { NSAssert([viewClass isSubclassOfClass:[UIView class]], @&quot;%@必须是UIView的子类&quot;, NSStringFromClass(viewClass)); NSAssert([controllerClass isSubclassOfClass:[CSBaseViewController class]], @&quot;%@必须是CSBaseViewController的子类&quot;, NSStringFromClass(controllerClass)); NSAssert([storeClass conformsToProtocol:@protocol(CSBaseStore)], @&quot;%@必须实现CSBaseStore协议&quot;, NSStringFromClass(storeClass)); _viewClss = viewClass; _controllerClass = controllerClass; _storeClass = storeClass; } return self; } @end CSBaseMediator @interface CSBaseMediator : NSObject + (UIViewController*)viewControllerWithScreen:(CSBaseScene*)scene; @end @implementation CSBaseMediator // 1 数据 2 控制器和视图 + (UIViewController*)viewControllerWithScreen:(CSBaseScene*)scene{ CSBaseStore *store = [scene.storeClass new]; // pipeline UIViewController* viewCtr = [[scene.controllerClass alloc] initWithViewClass:scene.viewClss store:store]; return viewCtr; } @end CSBaseService @interface CSBaseService : NSObject @end @implementation CSBaseService @end CSBaseStorage @interface CSBaseStorage : NSObject - (NSData*)readDataFromFile:(NSString*)filePath; - (BOOL)writeDataToFile:(NSString*)filePath; @end @implementation CSBaseStorage @end AppDelegate - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { CSBaseScene *homepageScene = [[CSBaseScene alloc] initWithScenceWithViewClass:[HomePageView class] controllerClass:[HomePageViewCtr class] store:[HomePageStore class]]; UIViewController *homePage = [CSBaseMediator viewControllerWithScreen:homepageScene]; // HomePageViewCtr *homePage = [HomePageViewCtr new]; UINavigationController *nav = [[UINavigationController alloc] initWithRootViewController:homePage]; self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds]; self.window.backgroundColor = [UIColor whiteColor]; self.window.rootViewController = nav; [self.window makeKeyAndVisible]; return YES; } HomePageViewCtr @interface HomePageViewCtr : CSBaseViewController @end @interface HomePageViewCtr () @property (nonatomic, strong)HomePagePipeline *homepagePipeline; @end @implementation HomePageViewCtr - (void)viewDidLoad { [super viewDidLoad]; self.title = @&quot;Home&quot;; [self.store fecthSeverData]; } //在框架里面进行掉用了，只需要赋值就ok了 - (void)setupPipeline:(__kindof CSBasePipeline*)pipeline{ _homepagePipeline = pipeline; } - (void)addObserver{ [_homepagePipeline addObserverSuny:self keyPath:@&quot;clipButton&quot; block:^(id newValue) { NSLog(@&quot;点击事件，做push处理或者其他处理&quot;); }]; [_homepagePipeline addObserverSuny:self keyPath:@&quot;isLoading&quot; block:^(id newValue) { NSLog(@&quot;处理网络数据&quot;); }]; } @end HomePageView @interface HomePageView : UIView @end @interface HomePageView () @property (nonatomic, strong)HomePagePipeline *homepagePipeline; @end @implementation HomePageView //在框架里面进行掉用了，只需要赋值就ok了 - (void)setupPipeline:(__kindof CSBasePipeline*)pipeline{ _homepagePipeline = pipeline; } - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event{ _homepagePipeline.clipButton = YES; } @end HomePagePipeline @interface HomePagePipeline : CSBasePipeline @property (nonatomic, strong)FctPipeline *fctPipleline; @property (nonatomic, assign)BOOL clipButton; @property (nonatomic, assign)BOOL isLoading; @property (nonatomic, strong)NSMutableArray *netArr; @end @implementation HomePagePipeline @end HomePageStore @interface HomePageStore : CSBaseStore - (void)fecthSeverData; @end @interface HomePageStore () @property (nonatomic, strong)HomePagePipeline *homePagePipeline; @end @implementation HomePageStore{ HomePagePipeline *_homePagePipeline; } - (CSBasePipeline*)pipeline{ return self.homePagePipeline; } - (HomePagePipeline*)homePagePipeline{ if (!_homePagePipeline) { _homePagePipeline = [HomePagePipeline new]; } return _homePagePipeline; } // 进行网络数据下载操作 - (void)fecthSeverData{ [self performSelector:@selector(loadingFinish) withObject:nil afterDelay:3]; } - (void)loadingFinish{ self.homePagePipeline.isLoading = YES; self.homePagePipeline.netArr = [NSMutableArray array]; } @end]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS的学习及总结]]></title>
    <url>%2F2013%2F12%2F27%2FCSS%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8F%8A%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[基本介绍div是用于存放html元素，文字，图片，视频的元素 css 是层叠样式表，用于指定div中的内容的样式 test.html： &lt;!DOCTYPE HTML PUBLIC &quot;-//w3c//DTD HTML 4.0 Transitional//EN&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;快速入门&lt;/title&gt; &lt;link href=&quot;my.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot;/&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;style1&quot;&gt; &lt;table&gt; &lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; my.css中指定： .style1{ width:300px; height:200px; border:1px solid red; margin:100px 0px 0px 200px; } .style1 table{ border:1px solid black; width:298px; height:190px; } .style1 table td{ border: 1px solid black; text-align:center; } div+css优势 大大缩减页面代码，提高页面浏览速度,缩减带宽成本; 结构清晰，容易被搜索引擎搜索到，天生优化了seo 缩短改版时间。只要简单的修改几个CSS文件就可以重新设计一个有成百上千页面的站点。 强大的字体控制和排版能力。CSS控制字体的能力比糟糕的FONT标签好多了，有了CSS，我们不再需要用FONT标签或者透明的1 px GIF图片来控制标题，改变字体颜色，字体样式等等。服合WEB2.0标准 使用元素来编写，使用myeclipse来开发，因为myeclipse有提示功能 &lt;span style=&quot;font-size:30px;color: blue;&quot;&gt;栏目一&lt;/span&gt;&lt;br/&gt; &lt;元素名 style=”属性名：属性值；属性名：属性值2；”/&gt; css的三种选择器 类选择器 .类选择器名{ 属性名:属性值; … } my.css文件 .style1{ font-size: 20px; font-weight: bold; background-color: purple; } &lt;span class=&quot;style1&quot;&gt;栏目一&lt;/span&gt; id选择器 #id选择器名{ 属性名：属性值； } 案例： #style2{ font-size: 30px; background-color: skyblue; } &lt;span id=&quot;style2&quot;&gt;这是一则重要的新闻&lt;/span&gt; Html选择器 /*html选择器body(button,input,form...)*/ body { color:silver; } 通配符选择器 如果希望所有的元素都符合某一种样式，可以使用通配符选择器。 基本语法： /*使用通配符选择器对外边距和内边距清零*/ * { margin: 0; padding: 0; } * { /*margin: 0; 将外边距清零*/ /*margin-top:10px;分别设置四个方向的外边距 margin-left:10px; margin-right:0px; margin-bottom:opx;*/ /*margin:10px 0px 0px 10px;顺时针方向：上，右，下，左 */ margin:10px 0px 0px;/*10表示上，左右，下*/ padding: 0;/*将内边距清零，padding的规范跟margin一样/ } 父子选择器 &lt;span id=&quot;style2&quot;&gt;这是一则&lt;span&gt;非常重要&lt;/span&gt;的新闻&lt;/span&gt;&lt;br/&gt; my.css添加一个父子选择器 /*父子选择器*/ #style2 span { font-style:italic; color:red; } 注意: 子选择器标签必须是html可以识别的标记 父子选择器可以有多级 父子选择器可以适用于id选择器和class选择器 结论：当一个元素同时被id选择器 类选择器 html选择器修饰时，优先级为：id选择器&gt;类选择器&gt;html选择器&gt;通配符选择器, 一个元素最多有一个id选择器，但是可以有多个类选择器 在有些css中，我们可以把多个class选择器，id选择器，html选择器，共同的部分提取出来，写在一起，这样的好处是可以简化css文件 /*广告2*/ .ad_2{ width :457px; background-color:#7CF574; margin:5px 0 0 6px; } /*房地产广告*/ .ad_house{ height:196px; background-color:#7CF574; margin:5px 0 0 5px; } .ad_2,.ad_house{ width :152px; float:left } 块元素和行内元素 行内元素(inline element),又叫内联元素:内联元素只能容纳文本或者其他内联元素,常见内联元素&lt;span&gt; &lt;a&gt; 块元素(block element):块元素一般都从新行开,可以容纳文本,其它内联元素和其它块元素，即使内容不能占满一行，块元素也要把整行占满。常见块元素&lt;div&gt; &lt;p&gt; 块元素和行内元素-区别 行内元素只占内容的宽度,块元素内容不管内容多少要占全行。 行内元素只能容纳文本和其它行内元素，块元素可以容纳文本，行内元素和块元素.(与浏览器类版本和类型有关) 一些css属性对行内元素不生效，比如margin,left,right,width,height.建议尽可能使用块元素定位。(与浏览器类版本和类型有关) 请注意:行内元素和块元素可以相互转换 display:inline -&gt; 转为行内元素 (比如div) display:block -&gt; 转为块元素 (比如a) 流流: 在现实生活中就是流水,在网页设计中就是指元素(标签)的排列方式。 标准流: 元素在网页中就象流水，排在前面的元素(标签)内容前面出现，排后面的元素(标签)内容后面出现 非标准流: 当某个元素(标签)脱离了标准流[比如因为相对定位]排列，我们统称为非标准流排列 css盒子模型我们可以把盒子模型转移到我们日常生活中的盒子(箱子)上来理解，日常生活中所见的盒子也具有这些属性，所以叫它盒子模式。那么内容就是盒子里装的东西；而填充就是怕盒子里装的东西（贵重的）损坏而添加的泡沫或者其它抗震的辅料；边框就是盒子本身了；至于边界则说明盒子摆放的时候的不能全部堆在一起，要留一定空隙保持通风，同时也为了方便取出嘛。 与现实生活中盒子不同的是，现实生活中的东西一般不能大于盒子,否则盒子会被撑坏的，而CSS盒子具有弹性，里面的东西大过盒子本身最多把它撑大,但它不会损坏的。 细节说明： html元素都可以看成一个盒子 盒子模型的参照物不一样，则使用的css属性不一样，比如从div1的角度看，是margin-right，从div2的角度看，则是margin-left 如果不希望破坏整个外观，则尽量使用margin布局，因为padding可能会改变盒子的大小（相当于这个盒子有弹性），margin如果过大，盒子内容被挤到盒子外边去，但是盒子本身没有变化 浮动浮动是一个重要的概念：分为左浮动，右浮动，清除浮动 特别强调：浮动对块元素和行内元素都是生效的。 你可以这么理解浮动:如果一个元素右/左浮动则: 它本身会尽可能向右/左移动，直到碰到边框或者别的浮动元素 元素向右/左浮动，就相当于让出自己的左/右边,别的元素就会在它的左/右边排列。 浮动-清除浮动 如果不希望别的元素在某个元素的左边或者右边，可以使用清除浮动的方法 clear:right ; clear: left; clear:both 定位CSS定位(Positioning)属性允许你对元素进行定位.position 属性值： static (默认值)：元素框正常生成。块级元素生成一个矩形框，作为文档流/标准流的一部分，行内元素则会创建一个或多个行框，置于其父元素中。 relative：元素框偏移某个距离。元素仍保持其未定位前的形状，它原本所占的空间仍保留,从这一角度看，好像该元素仍然在文档流/标准流中一样。 absolute：元素框从文档流完全删除，并相对于其包含块定位。包含块可能是文档中的另一个元素或者是初始包含块。元素原先在正常文档流中所占的空间会关闭，就好像元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。 fixed：元素框的表现类似于将 position 设置为 absolute，不过其包含块是视窗本身。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Html的学习及总结]]></title>
    <url>%2F2013%2F11%2F29%2FHtml%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8F%8A%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Html基础什么是HtmlHTML（HyperText Mark-up Language）即超文本标记语言或超文本链接标示语言，是目前网络上应用最为广泛的语言，也是构成网页文档的主要语言。HTML文本是由HTML命令组成的描述性文本，HTML命令可以说明文字、图形、动画、声音、表格、链接等。 HTML的结构包括头部（Head）、主体（Body）两大部分，其中头部描述浏览器所需的信息，而主体则包含所要说明的具体内容。 HTML可以编写静态网页. 该静态网页可以包括文字、图形、动画、声音、表格、链接。从而构成一个个漂亮的网页。 W3C的介绍W3C是英文 World Wide Web Consortium 的缩写，中文意思是W3C理事会或万维网联盟。W3C于1994年10月在麻省理工学院计算机科学实验室成立。创建者是万维网的发明者Tim Berners-Lee。W3C组织是对网络标准制定的一个非赢利组织，像HTML、XHTML、CSS、XML的标准就是由W3C来定制。W3C会员（大约500名会员）包括生产技术产品及服务的厂商、内容供应商、团体用户、研究实验室、标准制定机构和政府部门，一起协同工作，致力在万维网发展方向上达成共识。 html-&gt;xhtml-&gt;xmlhtml语言本身有一些缺陷(比如内容和形式不能分离,标记单一,数据不能复用等),随着xml的兴起，xml越来越受到国际认可，所以人们希望xml来弥补html的不足,但是目前有成千上万的网页都是html编写的，所以完全使用xml来替代html还为时过早,于是w3c在2000推出xhtml1.0，建立XHTML的目的就是实现HTML向XML的过渡。 Html的运行原理 本地运行html文件 使用 浏览器（软件）打开 远程访问运行你的电脑（浏览器），另一台电脑访问远程服务器 html的开发工具 记事本 editplus vim frontpage dw zend studio 其它的ide myeclipse/vs/idea ###html的基本结构&lt;元素名 [属性]&gt;元素内容&lt;/元素名&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;第一个网页&lt;/title&gt; &lt;/head&gt; &lt;body&gt;hello&lt;/body&gt; &lt;/html&gt; 不管这html文件有多复杂，它的基本结构是 &lt;元素名 [属性]&gt;元素内容&lt;/元素名&gt; 元素也叫标记 &lt;font size=2 color=red&gt;举头望明月&lt;/font&gt;&lt;/br&gt; 案例 &lt;p&gt;段落标记&lt;/p&gt; 跳转到下一行的下一行 &lt;font size=””&gt;字体标记&lt;/font&gt;size取值1到7 &lt;h#&gt;标题字体&lt;/h#&gt; #=1，2，3，4，5，6 &lt;b&gt;&lt;/b&gt;：字体加粗 &lt;/br&gt;换到下一行 将html的内容放在体内 &lt;html&gt; &lt;head&gt; &lt;title&gt;第一个网页&lt;/title&gt;//文件的头部，此处可以略去不写 &lt;/head&gt; &lt;body&gt; &lt;!==我们的内容放在这部分中==&gt;//注释这样写 &lt;h3&gt;静夜思&lt;/h3&gt; &lt;p&gt;&lt;b&gt;床前明月光&lt;/b&gt;&lt;/p&gt;疑是地上霜&lt;/br&gt; &lt;font size=2 color=red&gt;举头望明月&lt;/font&gt;&lt;/br&gt; 低头思故乡&lt;/br&gt; &lt;/body&gt; &lt;/html&gt; html的标记/元素html的标记/元素的认识 HTML标记是用来组成HTML元素的 HTML标记用两个尖括号”&lt;&gt;”括起来 HTML标记一般是双标记，如和 前一个标记是起始标记, 后一个标记为结束标记 两个标记之间的文本是html元素的内容 某些标记称为“单标记”,因为它只需单独使用就能完整地表达意思,如 html标记和html元素可以看做是同一个概念，在我的课程中为统一说法，就叫html元素 html的标记/元素 html超链接 &lt;a href=“url地址” target=&quot;_self/_blank&quot;&gt;&lt;/a&gt;`` html图像元素 &lt;img src=&quot;http://www.baidu.com/img/baidu_jgylogo3.gif&quot; &gt;&lt;/img&gt; &lt;img src=&quot;d://1.jpg&quot; width=300 border=1 &gt;&lt;/img&gt; 加边框 html表格 &lt;table border=“边框宽度” cellspacing=“空隙大小” cellpadding=“填充大小”&gt; &lt;tr align=center&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;/tr&gt; &lt;tr align=center&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; 无序列表ul/li &lt;ul type=“属性值”&gt; &lt;li&gt;列表内容&lt;/li&gt; &lt;/ul&gt; type=”square”设定符号款式，其值有三种，如下，默认为 type=”disc”： type=”disc” 时的列项符号为实心圆点。 type=”circle” 时的列项符号为空心圆。 type=”square” 时的列项符号为空心正方形。 html列表-有序列表 &lt;ol type=“属性值” start=“起始值”&gt; &lt;li&gt;列表内容&lt;/li&gt; &lt;/ol&gt; type设定数目款式，其值有五种 1 阿拉伯数字 1, 2, 3, … a 小写字母 a, b, c, … A 大写字母 A, B, C, … i 小写罗马数字 i, ii, iii, … I 大写罗马数字 I, II, III, … html列表-框架 &lt;frameset frameborder=“边框大小” cols=‘”各窗口百分比，隔开” rows=“各窗口百分比”&gt; &lt;frame name=“给frame取名” src=“html路径” noresize&gt; &lt;/frameset&gt; form(表单)元素介绍 html表单元素主要是让用户输入数据，提交给服务器 &lt;form action=&quot;url&quot; method=*&gt; ... ... &lt;input type=submit&gt; &lt;input type=reset&gt; &lt;/form&gt; //星号*部分可以为GET,也可以是 POST type表示输入框的类型，有以下几种：type = text（文本框）、password（密码框）、hidden（隐藏框）、checkbox（复选框）、radio（单选框）、submit（提交按钮）、reset（重置按钮）、image（图片按钮）&lt;input type=”image” src=””&gt; name 是给该表单元素取名,action指定把请求提交给哪个页面,post不会在地址栏上显示，但是get会在地址栏上显示，这样很危险 html的加强 语言字符集 您在浏览主页时，最好自己在浏览器的选项菜单内选择相应的语言。但是如果 HTML 文件里写明了设置，浏览器就会自动设置语言选项。 &lt;head&gt; &lt;title&gt;hello&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=gbk&quot;&gt; &lt;/head&gt; 背景色彩和文字色彩 &lt;body link=red text=blue&gt;你好,文本是蓝色，链接是红色 &lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt; &lt;/body&gt; 页面空白 让文本靠近左上角 &lt;body leftmargin=0 topmargin=0&gt;你好 &lt;/body&gt; target &lt;a href=url target=_blank&gt; 新窗口 &lt;a href=url target=_self&gt; 本窗口 &lt;a href=url target=_parent&gt; 父窗口 &lt;a href=url target=_top&gt; 整个浏览器窗口 &lt;a href=url target=指向frame的名字&gt; 标识线 &lt;hr color=”red”/&gt; 字体大小 &lt;font style=”font-size:150px”&gt;标题&lt;/font&gt; 次句可以将字体无限放大，因为用&lt;h1&gt;最大此时满足不了需要face=”华文新魏” 可以给字设置不同的字体 图像 &lt;img src=”d://1.jpg” alt=”这是小狗”&gt; &lt;/img&gt; 鼠标点到图片时，显示文字 会移动的文字 &lt;marquee&gt;啦啦啦，我会移动耶！&lt;/marquee&gt;]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springMvc的学习和总结]]></title>
    <url>%2F2013%2F10%2F25%2FspringMvc%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93(%E6%9C%AA%E5%AE%8C%E6%88%90)%2F</url>
    <content type="text"></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Server</tag>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>Framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring的学习和总结]]></title>
    <url>%2F2013%2F09%2F27%2Fspring%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[spring是什么 struts 是 web 框架 (jsp/action/actionfrom) hibernate 是 orm框架,处于持久层. spring 是容器框架,用于配置bean,并维护bean之间关系的框架 spring中有一个非常概念: bean (是java中的任何一种对象 javabean/service/action/数据源./ dao, ioc(控制反转 inverse of control) di( dependency injection 依赖注入) 快速入门开发一个spring项目 引入spring的开发包(最小配置spring.jar 该包把常用的jar都包括, 还要 写日志包 common-logging.jar 创建spring的一个核心文件 applicationContext.xml, [hibernate有核心 hibernate.cfg.xml struts核心文件 struts-config.xml], 该文件一般放在src目录下,该文件中引入 xsd文件 ： 配置bean &lt;!-- 在容器文件中配置bean(service/dao/domain/action/数据源) --&gt; &lt;!-- bean元素的作用是，当我们的spring框架加载时候，spring就会自动的创建一个bean对象，并放入内存 UserService userSerivce=new UserService(); userSerivce.setName(&quot;韩顺平&quot;); --&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.service.UserService&quot;&gt; &lt;!-- 这里就体现出注入的概念. --&gt; &lt;property name=&quot;name&quot;&gt; &lt;value&gt;韩顺平&lt;/value&gt; &lt;/property&gt; &lt;!-- 有可以用这种方式来注入 --&gt; &lt;property name=&quot;name&quot; value=“韩顺平” /&gt; &lt;/bean&gt; 传统的方法和使用spring的方法 使用spring ，没有new 对象,我们把创建对象的任务交给spring框架，spring实际上是一个容器框架，可以配置各种bean(action/service/domain/dao),并且可以维护bean与bean的关系,当我们需要使用某个bean的时候，我们可以getBean(id),使用即可 ioc是什么?ioc(inverse of controll ) 控制反转: 所谓控制反转就是把创建对象(bean),和维护对象(bean)的关系的权利从程序中转移到spring的容器(applicationContext.xml),而程序本身不再维护 DI是什么? di(dependency injection) 依赖注入: 实际上di和ioc是同一个概念，spring设计者认为di更准确表示spring核心技术 学习框架，最重要的就是学习各个配置. 装配bean（两种方式）包括bean工厂模式和应用上下文模式两种 什么是bean工厂？ 最简单的容器，提供了基础的依赖注入支持。创建各种类型的Bean. 工厂设计模式，创建分发各种bean。配置好它们之间的写作关系，参与bean的生命周期。 //如果我们使用beanfactory去获取bean，当你只是实例化该容器， 那么容器的bean不被实例化,只有当你去使用getBean某个bean时，才会实时的创建. BeanFactory factory = new XmlBeanFactory( new ClassPathResource(&quot;com/hsp/ioc/beans.xml&quot;)); factory.getBean(&quot;student&quot;); bean工厂只把bean的定义信息载进来，用到的时候才实例化。 什么是应用上下文(ApplicationContext)？ 建立在bean工厂基础之上，提供系统架构服务。 //从ApplicationContext中取bean //当我们去实例化beans.xml,该文件中配置的bean被实例(该bean scope是 singleton)从bean中取出student ApplicationContext ac=new ClassPathXmlApplicationContext(&quot;com/hsp/ioc/beans.xml&quot;); 三种经常用到的实现： ClassPathXmlApplicationContext:从类路径中加载。 FileSystemXmlApplicationContext:从文件系统加载。 ApplicationContext ac=new FileSystemXmlApplicationContext(&quot;文件路径beans.xml / applicationContext.xml&quot;); XmlWebApplicationContext:从web系统中加载 结论: 如果使用ApplicationContext ，则配置的bean如果是 singlton不管你用不用，都被实例化.(好处就是可以预先加载,缺点就是耗内存) 如果是 BeanFactory ,则当你获取beanfacotry时候，配置的bean不会被马上实例化，当你使用的时候，才被实例(好处节约内存,缺点就是速度) 规定: 一般没有特殊要求，应当使用ApplicatioContext完成(90%) bean 的 scope的细节 singleton: 单例 默认值 prototype: 原型 request: 一次请求有效( java web开发中) session: session级有效(java web开发中) bean的生命周期 实例化(当我们的程序加载beans.xml文件)，把我们的bean(前提是scope=singleton)实例化到内存 调用set方法设置bean的属性 如果你实现了bean名字关注接口(BeanNameAware) 则，可以通过setBeanName获取bean的id号 如果你实现了 bean工厂关注接口，(BeanFactoryAware),则可以获取BeanFactory 如果你实现了 ApplicationContextAware接口，则调用方法setApplicationContext，该方法传递ApplicationContext public void setApplicationContext(ApplicationContext arg0) throws BeansException { System.out.println(&quot;setApplicationContext&quot;+arg0); } 如果bean 和 一个后置处理器关联,则会自动去调用 Object postProcessBeforeInitialization方法 如果你实现InitializingBean接口，则会调用 afterPropertiesSet 如果自己在 则可以在bean定义自己的初始化方法 init. 如果bean 和 一个后置处理器关联,则会自动去调用 Object postProcessAfterInitialization方法 使用我们的bean 容器关闭 可以通过实现DisposableBean 接口来调用方法 destory 可以在 调用定制的销毁方法 小结: 我们实际开发中往往，没有用的这么的过程,常见的是:1-&gt;2-&gt;6-&gt;10-&gt;9-&gt;11 问题:通过BeanFactory来获取bean对象，bean的生命周期是否和Applicationcontext 是一样吗? 具体只有1、2、3、4、7、8、10、11、12、13 装配bean尽量使用 scope=”singleton” ,不要使用prototype,因为这样对我们的性能影响较大 如何给类型注入值&lt;!-- 通过set方法注入依赖 --&gt; &lt;bean id=&quot;foo&quot; class=&quot;...Foo&quot;&gt; &lt;property name=&quot;name&quot;&gt; &lt;value&gt;tom&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;name&quot;&gt; &lt;ref bean=&quot;bar&quot;&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;bar&quot; class=&quot;...Bar&quot;&gt; &lt;/bean&gt; &lt;!-- 内部bean --&gt; &lt;bean id=&quot;foo&quot; class=&quot;...Foo&quot;&gt; &lt;property name=&quot;bar&quot;&gt; &lt;bean class=&quot;...Bar&quot;&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 继承配置 --&gt; &lt;!-- 配置一个学生对象 --&gt; &lt;bean id=&quot;student&quot; class=&quot;com.hsp.inherit.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;顺平&quot; /&gt; &lt;property name=&quot;age&quot; value=&quot;30&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置Grdate对象 --&gt; &lt;bean id=&quot;grdate&quot; parent=&quot;student&quot; class=&quot;com.hsp.inherit.Gradate&quot;&gt; &lt;!-- 如果自己配置属性name,age,则会替换从父对象继承的数据 --&gt; &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt; &lt;property name=&quot;degree&quot; value=&quot;学士&quot;/&gt; &lt;/bean&gt; &lt;!-- 给数组注入值 --&gt; &lt;property name=&quot;empName&quot;&gt; &lt;list&gt; &lt;value&gt;小明&lt;/value&gt; &lt;ref bean=&quot;emp1&quot;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 给set注入值 set不能有相同的对象 --&gt; &lt;property name=&quot;empsets&quot;&gt; &lt;set&gt; &lt;value&gt;小明&lt;/value&gt; &lt;ref bean=&quot;emp1&quot; /&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- 给map注入值 map只有key不一样，就可以装配value --&gt; &lt;property name=&quot;empMaps&quot;&gt; &lt;map&gt; &lt;entry key=&quot;11&quot; value=&quot;小明&quot; /&gt; &lt;entry key=&quot;11&quot; value-ref=&quot;emp1&quot; /&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- 装配Properties： --&gt; &lt;property name=&quot;barlist&quot;&gt; &lt;props&gt; &lt;prop key=&quot;key1&quot;&gt;bar1&lt;/prop&gt; &lt;prop key=&quot;key2&quot;&gt;bar2&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- 设置null：--&gt; &lt;property name=&quot;barlist&quot;&gt; &lt;null/&gt; &lt;/property&gt; 目前我们都是通过set方式给bean注入值，spring还提供其它的方式注入值，比如通过构造函数注入值! 如果属性是类类型，则使用ref=&quot;&quot; &lt;bean id=&quot;employee&quot; class=&quot;com.hsp.contructor.Employee&quot;&gt; &lt;constructor-arg index=&quot;0&quot; type=&quot;java.lang.String&quot; value=&quot;顺平&quot; /&gt; &lt;constructor-arg index=&quot;1&quot; type=&quot;int&quot; value=&quot;20&quot;/&gt; &lt;constructor-arg index=&quot;2&quot; type=&quot;double&quot; value=&quot;34.5&quot; /&gt; &lt;/bean&gt; set注入的缺点是无法清晰表达哪些属性是必须的，哪些是可选的，构造注入的优势是通过构造强制依赖关系，不可能实例化不完全的或无法使用的bean。 自动装配bean的属性值&lt;bean id=&quot;foo&quot; class=&quot;...Foo&quot; autowire=&quot;autowire type&quot;&gt; 有四种自动装配类型： 1. byName寻找和属性名相同的bean,若找不到，则装不上。 2. byType:寻找和属性类型相同的bean,找不到,装不上,找到多个抛异常。 3. constructor:查找和bean的构造参数一致的一个或多个bean，若找不到或找到多个，抛异常。按照参数的类型装配 4. autodetect: (3)和(2)之间选一个方式。不确定性的处理与(3)和(2)一致。 5. defualt : 这个需要在&lt;beans default-autorwire=“指定” /&gt; 6. no : 不自动装配，这是autowrite的默认值 混合使用手动和自动组装&lt;bean id=&quot;bar&quot; class=&quot;...Bar&quot; autowire=&quot;byName&quot;&gt; &lt;property name=&quot;cousedao&quot;&gt; &lt;ref bean=&quot;somebean&quot; /&gt; &lt;/property&gt; &lt;/bean&gt; spring2.5提供了&lt;context:annotation-config /&gt;配置.该配置可激活在类中探测到的各种注解,@Required @Autowire @PostConstrct @PreDestroy @Resource @EJB @PersistenceContext @WebServiceRef等等 使用spring的特殊bean让spring特殊对待这些bean。使它们可以： 通过配置后加工bean，涉及到Bean和Bean工厂生命周期。 改变依赖注入，将字符串转换成其它类型。 从属性文本装载信息，包括信息国际化。 监听并处理其它bean及spring发布的系统消息。 知道自己在spring中的唯一表识。 例如：使用spring的特殊bean,完成分散配置: beans.xml 说明: 当通过 context:property-placeholder 引入 属性文件的时候，有多个需要使用 , 号间隔. &lt;!-- 引入我们的db.properties文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:com/hsp/dispatch/db.properties,classpath:com/hsp/dispatch/db2.properties&quot;/&gt; &lt;!-- 配置一DBUtil对象 $占位符号 --&gt; &lt;bean id=&quot;dbutil&quot; class=&quot;com.hsp.dispatch.DBUtil&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;${name}&quot; /&gt; &lt;property name=&quot;drivername&quot; value=&quot;${drivername}&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;${url}&quot; /&gt; &lt;property name=&quot;pwd&quot; value=&quot;${pwd}&quot; /&gt; &lt;/bean&gt; &lt;!-- 配置一DBUtil对象 --&gt; &lt;bean id=&quot;dbutil2&quot; class=&quot;com.hsp.dispatch.DBUtil&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;${db2.name}&quot; /&gt; &lt;property name=&quot;drivername&quot; value=&quot;${db2.drivername}&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;${db2.url}&quot; /&gt; &lt;property name=&quot;pwd&quot; value=&quot;${db2.pwd}&quot; /&gt; &lt;/bean&gt; db.properties: name=scott drivername=oracle:jdbc:driver:OracleDirver url=jdbc:oracle:thin:@127.0.0.1:1521:hsp pwd=tiger AOP编程aop( aspect oriented programming ) 面向切面(方面)编程,是对所有对象或者是一类对象编程,核心是“在不增加代码的基础上，还增加新功能” 汇编(伪机器指令 mov jump) 面向机器c语言(面向过程)-&gt;系统软件(操作系统，数据库, 杀毒软件，防火墙,驱动..) aop特别提醒: aop编程，实际上在开发框架本身用的多,在实际项目中，用的不是很多,但是将来会越来越多，这个一个趋势. 定义接口 编写对象(被代理对象=目标对象) 编写通知（前置通知目标方法调用前调用） 在beans.xml文件配置 配置 被代理对象=目标对象 配置通知 配置代理对象 是 ProxyFactoryBean的对象实例 织入通知 配置被代理对象 提问? 说spring的aop中，当你通过代理对象去实现aop的时候，获取的ProxyFactoryBean是什么类型？ 答: 返回的是一个代理对象,如果目标对象实现了接口，则spring使用jdk 动态代理技术,如果目标对象没有实现接口，则spring使用CGLIB技术.]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Server</tag>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>Framework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struts的学习和总结]]></title>
    <url>%2F2013%2F08%2F30%2Fstruts%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[为什么有struts struts是一个框架 struts是一个web框架 struts提高了程序规范的同时，也约束了程序的自由 struts的优势 程序更加规范化 成都开发的效率提高了 程序的可读性增加了 程序的可维护性增加了 struts的不足之处 form表单有点鸡肋 action是单态(对网站并发性有影响)（在整个程序运行过程中，始终是一个对象） 因为我们队mvc理解的不同,可能造成不同公司写程序的时候,规范不统一,这样不利于程序的维护和扩展,所以我们有必要用一个统一的规范来开发项目(struts) struts的原理 一个请求从浏览器发送给ｗｅｂ服务器,http://localhost:8080/web应用/action web服务器首先解析主机、然后解析web应用的名称、再解析出资源名、转发给总司令ActionServlet(该类由struts框架提供给我们的无需编写,只需配置) ActionServlet有一个文件struts-config.xml,该文件配置了表单actionForm(军火库),还配置了action,以及他们之间的对应关系 当ActionServlet拿到命令后它会查询struts-config.xml文件去填充数据,把用户的数据填充到表单里边 下个动作就是去调用指定的action(小队长),action去从表单中读取数据,调用某个model(士兵,如service)完成任务,完成任务把结果返回给ActionServlet总司令(返回一个执行的结果) 总司令又去查询struts-config.xml文件,决定跳转到哪个jsp页面,返回一个执行结果(形成静态html文件)，直接返回给web服务器，服务器再把静态页面以http响应给浏览器 手写版struts登录系统 先创建一个web工程 把struts开发包引入到工程 编写login.jsp 编写ActionForm(用户表单)和Action(小队长-登录小队长) 编写struts-config.xml文件，该文件用于配置action和actionForm，对应关系，跳转位置，一般放在web-inf目录下 写出welcome.jsp和error.jsp 在web.xml中配置ActionServlet 开始使用struts public class ActionForm extends ActionForm { private String userName; private String password; } public class LoginAction extends Action { @override public ActionForward execute(ActionMapping mapping, UserForm form, HttpServletRequest request, HttpServletResponse response) throws Exception { UserForm userForm = (UserForm)form; if (&quot;123&quot;.equals(userForm.getPassword())) { request.setAttribute(&quot;username&quot;, userForm.getUserName()) return mapping.findForward(&quot;ok&quot;) } else { return mapping.findForward(&quot;err&quot;) } } } &lt;struts-config&gt; &lt;form-beans&gt; &lt;!-- name是表单名，可以随意写，但是我们建议取名规范 表单类名小写 --&gt; &lt;!-- type用于指定表单类全路径 --&gt; &lt;form-bean name=&quot;userForm&quot; type=&quot;com.hsp.forms.UserForm&quot; /&gt; &lt;/form-beans&gt; &lt;!-- 配置action --&gt; &lt;action-mappings&gt; &lt;!-- 配置具体的一个action path表示将来访问该action资源名 name用于关联某个表单 type用于指定action类全路径 --&gt; &lt;!-- scope表示表单的生命周期是request级别的还是session级别 --&gt; &lt;action path=&quot;/login&quot; name=&quot;userForm&quot; scope=&quot;request/session&quot; type=&quot;com.hsp.actions.LoginAction&quot;&gt; &lt;!-- 配置跳转关系 --&gt; &lt;!-- name表示结果名称， path转发到哪个页面 --&gt; &lt;forward name=&quot;ok&quot; path=&quot;/WEB-INF/wel.jsp&quot; /&gt; &lt;forward name=&quot;err&quot; path=&quot;/WEB-INF/err.jsp&quot; /&gt; &lt;/action&gt; &lt;/action-mappings&gt; &lt;/struts-config&gt; &lt;servlet&gt; &lt;servlet-name&gt;action&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.struts.action.ActionServlet&lt;/servlet-name&gt; &lt;init-param&gt; &lt;param-name&gt;config&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/struts-config.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;action&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 在登录成功后的页面上加上”wel 用户名 返回首页” &lt;body&gt; wel &lt;%= request.getAttribute(&quot;username&quot;).toString() %&gt;&lt;br&gt; &lt;a href=&quot;struts/index.jsp&quot;&gt;返回重新登录&lt;/a&gt; &lt;/body&gt; 使用filter配合struts解决中文乱码 public class MyFilter extends HttpServlet implements Filter { @Override public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2) throws IOException, ServletException { arg0.setCharacterEncoding(&quot;utf-8&quot;); arg1.setCharacterEncoding(&quot;utf-8&quot;); arg2.doFilter(arg0, arg1); arg1.setContentType(&quot;text/html;charset=utf-8&quot;) } } &lt;filter&gt; &lt;filter-name&gt;MyFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.chao98.services.MyFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;MyFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 注：struts-conig.xml文件的路径不一定在WEB-INF目录下,并且可以有多个struts-config.xml文件，只需要在web.xml文件中配置路径，并且用逗号隔开即可 工具版structs登录系统 用工具引入struts包和配置文件，然后自己配置struts-config.xml，完成开发 完全依赖MyEclipse提供的工具完成struts开发]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Server</tag>
        <tag>Java</tag>
        <tag>Struts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hibernate的学习和总结]]></title>
    <url>%2F2013%2F07%2F26%2Fhibernate%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[hibernate是什么 hibernate 是一个框架(framework) hibernate 是一个orm框架,(object relation mapping) 对象关系映射 框架 hibernate 处于我们项目的持久层位置(正因为如此，所以有人又把hibernate称为 持久层框架) hibernate 实际上就是对jdbc进行了轻量级的封装 hibernate 的基础还是我们java 反射机制 总结: hibernate 是对jdbc进行轻量级封装的 orm 框架，充当项目的持久层 为什么有hibernate 引入hibernate可以使工作人员角色细化，让程序员更关心业务流程。让数据库人员关注数据库相关的各种操作。 分层更清晰，耦合性更小。 通用性强：可以更轻松的从一个数据库平台转移到别的平台。 对象化：把关系数据库变成了Java的对象，更加方便操作。 性能保证：hibernate可能按不同的数据库，处理不同的操作是用最优化的SQL语句，不用我们去想，对于分等算法，在hibernate中会显得更简单，可靠。 增加了程序的鲁棒性（健壮性）! hibernate的原理hibernate是 轻量级的 ORM 框架，ORM全称object/relation mapping [对象/关系 映射]。 对象关系映射（Object Relation Mapping，简称ORM）是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术。 简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将java程序中的对象自动持久化到关系数据库中。本质上就是将数据从一种形式转换到另外一种形式。 结论:使用orm技术(hibernate是其中最为流行的)可以在java程序以类和对象的方式去操控数据库表和记录. 第一个hibernate项目hibernate开发方式的三种方式: 由Domain object -&gt; mapping-&gt;db。(官方推荐) 由DB开始，用工具生成mapping和Domain object。(使用较多) 由映射文件开始。 这里我们说明如果要自动的创建出对应的数据库，需要做配置(hibernate.cfg.xml) &lt;property name=&quot;hbm2ddl.auto&quot;&gt;create&lt;/property&gt; 这里有四个配置值: create , update , create-drop, validate create : 当我们的应用程序加载hibernate.cfg.xml [ new Configuration().config(); ]就会根据映射文件，创建出数据库, 每次都会重新创建， 原来表中的数据就没有!!! update: 如果数据库中没有该表，则创建，如果有表，则看有没有变化，如果有变化，则结构更新，而数据会保留 create-drop: 在显式关闭sessionFactory时，将drop掉数据库的schema validate: 相当于每次插入数据之前都会验证数据库中的表结构和hbm文件的结构是否一致 在开发测试中，我们配置哪个都可以测试，最好自己配置一次，让对应的数据库生成，完后取消配置，但是如果项目发布后，就取消配置，如果要配置，就配置成update 配置成update到底会不会影响数据？？？ 开发hibernate流程 引入hiberate的包 编写POJO类(Users类) 编写对象映射文件User.hbm.xml 配置hibernate.cfg.xml 编写测试类，并测试. 请解释什么是pojo类，它有什么要求: pojo类是和一张表对应 一般我们放在 com.xxx.domain下 pojo 需要一个主键属性(用于标示一个pojo对象) 除了主键属性外，它应当还有其属性，属性的访问权限是private 提供 set /get 方法 它应当有一个无参的构造方法(hibernate 反射) pojo类其实就是javabean/ 有些老程序员 叫他 date对象 domain对象的细节: 需要一个无参的构造函数(用于hibernate反射该对象) 应当有一个无业务逻辑的主键属性. 给每个属性提供 get set方法. 在domian对象中的属性，只有配置到了对象映射文件后，才会被hiberante管理. 属性一般是private范围 hibernate核心类和接口的使用Configuraion类 负责管理hibernate的配置信息 读取hibernate.cfg.xml 加载hibernate.cfg.xml配置文件中配置的驱动,url,用户名,密码,连接池. 管理 *.hbm.xml对象关系文件. hibernate.cfg.xml文件 该文件主要用于指定各个参数,是hibernate核心文件 默认放在src目录下，也可以放在别的目录下。 指定连接数据库的驱动、用户名、密码、url、连接池.. 指定对象关系映射文件的位置. 也可使用hibernate.properties文件来替代该文件.(推荐使用hibernate.cfg.xml)。 对象关系映射文件(*.hbm.xml) 该文件主要作用是建立表和类的映射关系，是不可或缺的重要文件. 一般放在其映射的类同一个目录下,但不是必须的。 命名方式一般是 类名.hbm.xml,但不是必须的。 对对象关系映射文件的说明 对象关系文件中，有些属性是可以不配，hibernate会采用默认机制，比如 table 值不配，则以类的小写做表名 type不配置，则hibernate会根据类的属性类型，选择一个适当的类型### SessionFactory(会话工厂)，他是一个接口1. 缓存sql语句和某些数据2. 在应用程序初始化的时候创建,是一个重量级的类(吃内存),一般用单例模式保证一个应用中只需要一个SessionFactory实例.3. 如果某个应用访问多个数据库，则要创建多个会话工厂实例,一般是一个数据库一个会话工厂实例.4. 通过SessionFactory接口可以获得Session(会话)实例.openSession/getCurrentSession，如果需要能获取getCurrentSession则要在hibernate.cfg.xml中配置&lt;property name=&quot;current_session_context_class&quot;&gt;thread&lt;/property&gt;来线程绑定### Session(会话)接口1. Session一个实例代表与数据库的一次操作(当然一次操作可以是crud组合)2. Session实例通过SessionFactory获取，用完需要关闭。3. Session是线程不同步的(不安全),因此要保证在同一线程中使用,可以用getCurrentSessiong()。4. Session可以看做是持久化管理器,它是与持久化操作相关的接口### openSession()和 getCurrentSession()区别1. 采用getCurrentSession()创建的session会绑定到当前线程中，而采用openSession()创建的session则不会2. 采用getCurrentSession()创建的session在commit或rollback时会自动关闭，而采用openSession()创建的session必须手动关闭.3. 使用getCurrentSession()需要在hibernate.cfg.xml文件中加入4. 每次openSession() 是获取一个新的session5. 如果是通过getCurrentSession() 获取 sesssion ,进行查询需要事务提交.（视频中举例，如果没有事务，就不能查出结果）&gt; ①如果需要在同一线程中，保证使用同一个Session则，使用getCurrentSession()&gt;&gt; ②如果在一个线程中，需要使用不同的Session,则使用opentSession()如下配置: 如果使用的是本地事务（jdbc事务）&lt;property name=&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;/property&gt; 如果使用的是全局事务（jta事务）&lt;property name=&quot;hibernate.current_session_context_class&quot;&gt;jta&lt;/property&gt;&gt; 简单解释一下jdbc事务和jta事务的区别吧!&gt;&gt; 1. 全局事务是指跨数据库的事务，如建行给工行转账时的事务控制&gt; 2. 本地事务是指针对一个数据库的事务### Session会话接口的几个重要方法1. 保存一个对象(记录)—save方法2. 删除一个对象(记录)—delete方法3. 查询一个对象(记录)—get/load方法4. 修改一个对象(记录)—update方法### session get()和load()区别1. get()方法直接返回实体类,如果查不到数据则返回null。load()会 返回一个实体代理对象（当前这个对象可以自动转化为实体对象）， 但当代理对象被调用时，如果没有数据不存在，就会抛出个 org.hibernate.ObjectNotFoundException异常2. load先到缓存(session缓存/二级缓存)中去查，如果没有则返回一个 代理对象（不马上到DB中去找），等后面使用这个代理对象操作的时 候，才到DB中查询,这就是我们常说的 load在默认情况下支持延迟加 载（lazy）3. get先到缓存(session缓存/二级缓存)中去查，如果没有就到DB中去 查（即马上发出sql）。&gt; 总之，如果你确定DB中有这个对象就用load(),不确定就用get()（这样效率高）&gt; load/get -&gt; 一级缓存(session缓存) -&gt; 二级缓存(内存和文件缓存) -&gt; 数据库，get方法会一步一步往下查找，load方法只会进行一级和二级缓存，不会查询数据库，只有当用到结果时，才会去数据库中查找### openSession()和 getCurrentSession()联系在 SessionFactory启动的时候，Hibernate 会根据配置创建相应的 CurrentSessionContext,在getCurrentSession()被调用的时候，实际被执行的方法是 CurrentSessionContext.currentSession()。在currentSession()执行时，如果当前Session为空，currentSession会调用SessionFactory的openSession package com.hsp.util; import org.hibernate.Session; import org.hibernate.SessionFactory; import org.hibernate.cfg.Configuration; final public class HibernateUtil { //SqlHelper private static SessionFactory sessionFactory=null; //使用线程局部模式 private static ThreadLocal threadLocal=new ThreadLocal(); private HibernateUtil(){}; static { sessionFactory=new Configuration().configure(“com/hsp/config/hsp.cfg.xml”).buildSessionFactory(); } //获取全新的全新的sesession public static Session openSession(){ return sessionFactory.openSession(); } //获取和线程关联的session public static Session getCurrentSession(){ Session session=threadLocal.get(); //判断是否得到 if(session==null){ session=sessionFactory.openSession(); //把session对象设置到 threadLocal,相当于该session已经和线程绑定 threadLocal.set(session); } return session; } }### Transaction(事务)接口事务简单的说,就是一组对数据库的操作集合,它们要么全部成功,要么全部失败.这个可以保证数据的一致性,事务具有原子性。1. Transaction是底层的事物实现中抽象出来的接口2. 可能是一个jdbc或者jta的事务,这样有利于hibernate在不同执行环境的移植。3. hibernate要求显示的调用事务(如果仅仅是查询可以不调用.)### Query接口Query接口类型的对象可以对数据库操作,它可以使用Hql,Qbc,Qbe和原生SQL(native Sql)对数据库操作.官方推荐使用Hql语句。这里我们给大家举例简单说明，后面有一个章节专门讲解Hql的使用，Query接口查询出来的结果是一个List接口类型的对象。### Criteria接口Criteria接口也可用于面向对象方式的查询，关于它的具体用法我们这里先不做介绍,简单看几个案例. //最简单案例:返回50条记录 Criteria crit = sess.createCriteria(Cat.class); crit.setMaxResults(50); List cats = crit.list(); 限制结果集内容 List cats = sess.createCriteria(Cat.class) .add( Restrictions.like(“name”, “Fritz%”) ) .add( Restrictions.between(“weight”, minWeight, maxWeight) ) .list();Criteria是一种比HQL更面向对象的查询方式；Criteria的创建方式： Criteria crit = session.createCriteria(DomainClass.class); //简单属性条件如： criteria.add(Restrictions.eq(propertyName, value)), criteria.add(Restrictions.eqProperty(propertyName,otherPropertyName))Criteric 优点是更加面向对象，如果你的hql语句不太了解，可以使用。缺点是: 功能不如hql强大.而且hql是hibernate官方推荐使用的语句### HQL面向对象的查询语言，与SQL不同，HQL中的对象名是区分大小写的（除了JAVA类和属性其他部分不区分大小写）；HQL中查的是对象而不是表，并且支持多态；HQL主要通过Query来操作，Query的创建方式： Query q = session.createQuery(hql); from Person from User user where user.name=:name from User user where user.name=:name and user.birthday &lt; :birthday1. 检索类的全部属性（from Student）2. 检索类的部分属性（select 属性1,属性2 from Student）3. 使用函数 1. UniqueResult:当session.createQuery(“from xxx where cardid=‘xxx’”).uniqueResult();返回的结果只有一个对象时，可以使用uniqueResult()得到该对象。但是，如果结果是多条，使用该方法就会抛出异常 2. 当要过滤重复的数据时，可以使用distinct关键字:(select distinct sage,ssex from Student) 3. between…and(select distinct sage,ssex from Student where sage between 20 and 22) 4. in/not in(from Student where sdept in (‘计算机系’,’英语系’)) 5. group by 分组查询(select avg(sage),sdept from Student group by sdept) 6. having 对分组查询后的结果，进行筛选(select count(*),sdept from Student group by sdept having count(*)&gt;3) 7. 聚集函数的使用 count(),avg(),max(),min(),sum(); 8. 分页显示对象(setFirstResult,setMaxResult)4. 模糊查询 like 属性 ‘%_’5. 参数绑定 &gt; 使用绑定参数的好处: &gt; &gt; 1. 可读性好. &gt; 2. 性能提高. &gt; 3. 防止sql注入 &gt; //如果按冒号的方式 Query q=session.createQuery(from Student where sdept=:dept and sage&gt;:age) //也可使用setInteger()，setString() …来指定值 q.setParameter(参数名,值) 参数绑定有两种形式 如果我们的参数是 :冒号形式给出的，则我们的参数绑定应当这样: List list=session.createQuery(“from Student where sdept=:a1 and sage&gt;:sage”) .setString(“a1”, “计算机系”).setString(“sage”, “2”).list(); 还有一种形式: Query q=session.createQuery(from Student where sdept=? and sage&gt;?) 如果我们的参数是以 ? 形式给出的则，参数绑定应当: List list=session.createQuery(“from Student where sdept=? and sage&gt;?”) .setString(0, “计算机系”).setString(1, “2”).list(); &gt; 总结：如果是冒号形式，只能按属性名称方式填值，如果是按问号形式给出的，只能按照位置方式填值6. 在映射文件中得到hql语句 hibernate提供了一种更加灵活的查询方法: 把hql语句配置到 对象关系映射文件， &lt;![CDATA[select sname,ssex from Student where sage&gt;22]]&gt; 在程序中，我们这样获取并执行: List list=session.getNamedQuery(“myquerytest”).list(); System.out.println(list.size()); Iterator it=list.iterator(); while(it.hasNext()){ Object obj[]=(Object[])it.next(); System.out.println(“n=”+obj[0]); }7. 子查询 可以在sql中，我们经常使用子查询处理复杂的查询要求 对于简单的表(没有外键或是被别的表关联的表)，比如第二讲的admin【管理员表】和 employee【雇员表】就是简单的POJO 。但是我们项目中很多表和别的表都会有关联,在hibernte中的对象存在三种关系 1. one-to-one 2. one-to-many 【many-to-one】 3. many-to-many [课程 — 学生 中间表] 并且还有所谓的单向和双向之分: 我们的Student【学生表】和 Course【课程表】就是多对多,多对多一般都会通过一个中间表转成one-to-many 和 many-to-one比如.我们这里用了一个 中间表 StudCourse【学生-课程表】把关系简化成 one-to-many 和 many-to-one ，我们看看对象配置文件可以看出8. 多表查询 studCourse 作为中间表，将多对多的关系简化成 one-to-many和 many-to-one 的关系，这个也是在表的设计中惯用的一种数据库设计模式，下面我们就看看hql 如何处理多表查询的问题 在项目开发过程中，我们不可能只对一张表进行操作，一定有多张表联合查询，下面看看在hql中如何对多表查询: //比如: 请显示林青霞 选择的所有课程名，和成绩。 “select s1.sname,s2.course.cid,c1.cname,s2.grade from Student as s1,StudCourse as s2,Course as c1 where s1.sname=’林青霞’ and s1.sname=s2.student.sname and c1.cid=s2.course.cid“ 简单的:select s1.course.cname,s1.grade from Studcourse s1 where s1.student.sname=’林可欣’### hibernate对象的三种状态瞬时(transient)：数据库中没有数据与之对应，超过作用域会被JVM垃圾回收器回收，一般是new出来且与session没有关联的对象。（不处于session的管理，在数据库中没有对应的记录）持久(persistent)：数据库中有数据与之对应，当前与session有关联，并且相关联的session没有关闭，事务没有提交；持久对象状态发生改变，在事务提交时会影响到数据库，hibernate能检测到。（处于session的管理下，并在数据库中有对应的记录）脱管/游离(detached)：数据库中有数据与之对应，但当前没有session与之关联；脱管对象状态发生改变，hibernate不能检测到(没有处于session的管理，在数据库中有对应的记录)&gt; 如何判断一个对象处于怎样的状态?&gt;&gt; 主要的依据是: 1. 看该对象是否处于session, 2, 看在数据库中有没有对应的记录&gt;&gt; 瞬时态: 没有session管理,同时数据库没有对应记录&gt; 持久态: 有session管理，同时在数据库中有记录&gt; 脱管态/游离态： 没有session管理，但是在数据库中有记录.### 懒加载简述: 当我们查询一个对象的时候，在默认情况下,返回的只是该对象的普通属性,当用户去使用对象属性时，才会向数据库发出再一次的查询.这种现象我们称为 lazy现象.懒加载(Load On Demand)是一种独特而又强大的数据获取方法 ，是指程序推迟访问数据库，这样做可以保证有时候不必要的访问数据库，因为访问一次数据库是比较耗时的。解决方法可以这样: Domain Object 写成final的, final的对象不会懒加载 显式初始化 Hibernate.initized(代理对象)或直接调用一次xxx.getXxx() 修改对象关系文件 lazy 改写 lazy=false 通过过滤器(web项目) openSessionInView 在ssh中，可以实现在service层，标注方式解决懒加载### 对象对应关系* many-to-one 的many这方，如果你配置了cfg文件,那么hibernate就会在 查询学生 many 方时，把它相互关联的对象也查询,这里我们可以看出，对select语句查询影响不大 //column设置的值为外键名 one-to-many 的 one 的这方，如果你配置 &lt;set name=”集合对象属性名”&gt; &lt;key column=”外键名”/&gt; &lt;one-to-many class=”集合放入的类名”/&gt; &lt;/set&gt; //如 &lt;class name=&quot;Department&quot; lazy=&quot;false&quot; &lt;set name=&quot;stus&quot; cascade=&quot;save-update&quot; lazy=&quot;false&quot;&gt; &lt;key column=&quot;dept_id&quot; /&gt; &lt;one-to-many class=&quot;Student&quot; /&gt; &lt;/set&gt; &lt;/class&gt; one-to-one 基于主键的one-to-one(idCard又是主键，又是外键) //Person映射文件： &lt;one-to-one name=“idCard” /&gt; //IdCard映射文件： &lt;id name=”id”&gt; &lt;generator class=”foreign”&gt; &lt;param name=”property”&gt;person&lt;/param&gt; &lt;/generator&gt; &lt;/id&gt; //[没有constraned true将不会生成外键约束] &lt;one-to-one name=”person” constrained=”true”/&gt; 基于外健的one-to-one，可以描述为多对一，加unique=“true”约束 //Person映射文件： &lt;one-to-one name=“idCard” /&gt; //IdCard映射文件： &lt;many-to-one name=”person” column=”person_id” unique=”true” not-null=”true”/&gt; many-to-many 在操作和性能方面都不太理想，所以多对多的映射使用较少，实际使用中最好转换成一对多的对象模型；Hibernate会为我们创建中间关联表，转换成两个一对多。 &lt;set name=“xxx&quot; table=“xxx&quot;&gt; &lt;key column=“xxx&quot;/&gt; &lt;many-to-many class=“xxx&quot; column=“xxx&quot;/&gt; &lt;/set&gt; 级联操作Casade用来说明当对主对象进行某种操作时是否对其关联的从对象也作类似的操作，常用的cascade:none,all,save-update ,delete,lock,refresh,evict,replicate,persist,merge,delete-orphan(one-to-many) 。一般对many-to-one,many-to-many不设置级联，在和中设置级联 在集合属性和普通属性中都能使用cascade 一般讲cascade配置在one-to-many(one的一方,比如Employee-Department),和one-to-one(主对象一方) 缓存和加强缓存的作用主要用来提高性能，可以简单的理解成一个Map；使用缓存涉及到三个操作：把数据放入缓存、从缓存中获取数据、删除缓存中的无效数据。 一级缓存，Session级共享。save,update,saveOrUpdate,load,get,list,iterate,lock这些方法都会将对象放在一级缓存中，一级缓存不能控制缓存的数量，所以要注意大批量操作数据时可能造成内存溢出；可以用evict,clear方法清除缓存中的内容。 二级缓存, SessionFacotry级共享 什么操作会向一级缓存放入数据？ save,update,saveOrUpdate,load,get,list,iterate,lock 什么操作会从一级缓存取数据？ get / load / list 一级缓存不需要配置，就可以使用,它本身没有保护机制，所以我们程序员要考虑这个问题,我们可以同 evict 或者 clear来清除session缓存中对象. evict 是清除一个对象，clear是清除所有的sesion缓存对象 session级缓存中对象的生命周期, 当session关闭后，就自动销毁 我们可以自己用HashMap来模拟一个Session缓存，加深对缓存的深入 为什么需要二级缓存? 因为一级缓存有限(生命周期短),所以我们需要二级缓存(SessionFactory缓存)来弥补这个问题 需要配置 二级缓存是交给第三方去处理,常见的Hashtable , OSCache , EHCache 二级缓存的原理 二级缓存的对象可能放在内存，也可能放在磁盘 使用OsCache来演示二级缓存的使用 //可以在.cfg.xml文件中配置 &lt;property name=&quot;hbm2ddl.auto&quot;&gt;update&lt;/property&gt; &lt;!-- 启动二级缓存 --&gt; &lt;property name=&quot;cache.use_second_level_cache&quot;&gt;true&lt;/property&gt; &lt;!-- 指定使用哪种二级缓存 --&gt; &lt;property name=&quot;cache.provider_class&quot;&gt;org.hibernate.cache.OSCacheProvider&lt;/property&gt; &lt;mapping resource=&quot;com/hsp/domain/Department.hbm.xml&quot; /&gt; &lt;mapping resource=&quot;com/hsp/domain/Student.hbm.xml&quot; /&gt; &lt;!-- 指定哪个domain启用二级缓存 特别说明二级缓存策略: 1. read-only 2. read-write 3. nonstrict-read-write 4. transcational --&gt; &lt;class-cache class=&quot;com.hsp.domain.Student&quot; usage=&quot;read-write&quot;/&gt; //也可以直接在.hbm.xml文件中配置 &lt;cache usage=&quot;read-write&quot; /&gt; 可以把文件oscache.properties放在 src目录下，这样你可以指定放入二级缓存的对象capacity 大小. 默认1000 hibernate二级缓存策略 只读缓存(read-only) 读写缓存(read-write) [ 银行，财务软件] 不严格读写缓存(nonstrict-read-write) [bbs 被浏览多少次] 事务缓存(transactional) 在配置了二级缓存后，请大家要注意可以通过 Statistics,查看你的配置命中率高不高 &lt;property name=&quot;hibernate.generate_statistics&quot;&gt;true&lt;/property&gt; //SessionFactory对象. Statistics statistics= getSessionFactory().getStatistics(); System.out.println(statistics); System.out.println(&quot;放入&quot;+statistics.getSecondLevelCachePutCount()); System.out.println(&quot;命中&quot;+statistics.getSecondLevelCacheHitCount()); System.out.println(&quot;错过&quot;+statistics.getSecondLevelCacheMissCount()); 主键增长策略hibernate标示符生成器(策略) increment 由Hibernate自动以递增方式生成标识符，每次增量为1。 优点：不依赖于底层数据库系统，适用于所有的数据库系统。 缺点：适用于单进程环境下，在多线程环境下很可能生成相同主键值，而且OID必须为数值类型,比如long,int,short类型 配置方式: &lt;id name=“id” type=”long” column=”ID”&gt; &lt;generator class=”increment”/&gt; &lt;/id&gt; indentity 由底层数据库生成标识符。 前提条件：数据库支持自动增长字段类型,比如(sql server,mysql),而且OID必须为数值类型,比如long,int,short类型 配置文件: &lt;id name=”id” type=”long” column=”ID”&gt; &lt;generator class=”identity”/&gt; &lt;/id&gt; sequence 依赖于底层数据库系统的序列 前提条件:需要数据库支持序列机制（如:oracle等）,而且OID必须为数值类型,比如long,int,short类型。 配置文件: &lt;id name=”id” type=”java.lang.Long” column=”ID”&gt; &lt;generator class=”sequence”&gt; &lt;param name=”sequence”&gt;my_seq&lt;/param&gt; &lt;/generator&gt; &lt;/id&gt; hilo hilo标识符生成器由Hibernate按照一种high/low算法生成标识符，他从数据库中的特定表的字段中获取high值，因此需要额外的数据库表保存主键生成的历史状态，hilo生成方法不依赖于底层数据库，因此适用于每一种数据库,但是OID必须为数值类型(long,int,shor类型)。 配置文件: &lt;id name=”id” type=”java.lang.Integer” column=”ID”&gt; &lt;generator class=”hilo”&gt; &lt;param name=”table”&gt;my_hi_value&lt;/param&gt; &lt;param name=”column”&gt;next_value&lt;/param&gt; &lt;/generator&gt; &lt;/id&gt; native native生成器能根据底层数据库系统的类型，自动选择合适的标识符生成器，因此非常适用于跨数据库平台开发，他会由Hibernate根据数据库适配器中的定义,自动采用identity,hilo,sequence的其中一种作为主键生成方式，但是OID必须为数值类型(比如long,short,int等) 配置文件: &lt;id name=”id” type=”java.lang.Integer” column=”ID”&gt; &lt;generator class=”native”/&gt; &lt;/id&gt; assigned 采用assign生成策略表示由应用程序逻辑来负责生成主键标识符,OID类型没有限制。 配置文件: &lt;id name=”id” type=”java.lang.Integer” column=”ID”&gt; &lt;generator class=”assigned”/&gt; &lt;/id&gt; uuid 由Hibernate基于128位唯一值产生算法，根据当前设备IP，时间，JVM启动时间，内部自增量等4个参数生成16进制数值作为主键，一般而言,利用uuid方式生成的主键提供最好的数据插入性能和数据库平台适应性. OID一般使用是String类型,大家去试试数值可否? 配置文件: &lt;id name=”id” type=”java.lang.String” column=”ID”&gt; &lt;generator class=”uuid”/&gt; &lt;/id&gt; foreign 第一种方式:以独立主键类映射复合主键，这样可以达到将逻辑加以隔离的目的 配置文件如下： &lt;composite-id name=&quot;id&quot; class=&quot;com.test.model.pojo.CustomersId&quot;&gt; &lt;key-property name=&quot;cusname&quot; type=&quot;java.lang.String&quot;&gt; &lt;column name=&quot;CUSNAME&quot; length=&quot;40&quot; /&gt; &lt;/key-property&gt; &lt;key-property name=&quot;homeaddress&quot; type=&quot;java.lang.String&quot;&gt; &lt;column name=&quot;HOMEADDRESS&quot; length=&quot;50&quot; /&gt; &lt;/key-property&gt; &lt;key-property name=&quot;birthday&quot; type=&quot;java.util.Date&quot;&gt; &lt;column name=&quot;BIRTHDAY&quot; length=&quot;7&quot; /&gt; &lt;/key-property&gt; &lt;/composite-id&gt; 给出一个简单原则: 针对oracle [主键是int/long/short 建议使用 sequence] 主键是String 使用uuid或者assinged 针对 mysql [主键是 int/long/short 建议使用increment/assigend ,如果是字串 UUId/assigned] 针对 sql server [主键是 int/long/short 建议使用 identity/native/assinged ,如果主键是字串，使用uuid/assigned ] one-to-one 又是基于主键的则使用foreign Hibernate不适合的场景 不适合OLAP(On-Line Analytical Processing联机分析处理)，以查询分析数据为主的系统；适合OLTP（on-line transaction processing联机事务处理） 对于些关系模型设计不合理的老系统，也不能发挥hibernate优势。 数据量巨大，性能要求苛刻的系统，hibernate也很难达到要求, 批量操作数据的效率也不高。]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Server</tag>
        <tag>Java</tag>
        <tag>Hibernate</tag>
        <tag>DataBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习]]></title>
    <url>%2F2013%2F06%2F28%2FAndriod%E5%AD%A6%E4%B9%A05(%E6%9C%AA%E5%AE%8C%E6%88%90)%2F</url>
    <content type="text"><![CDATA[树和二叉树]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习]]></title>
    <url>%2F2013%2F05%2F31%2FAndriod%E5%AD%A6%E4%B9%A04(%E6%9C%AA%E5%AE%8C%E6%88%90)%2F</url>
    <content type="text"><![CDATA[树和二叉树]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习]]></title>
    <url>%2F2013%2F04%2F26%2FAndriod%E5%AD%A6%E4%B9%A03(%E6%9C%AA%E5%AE%8C%E6%88%90)%20%2F</url>
    <content type="text"><![CDATA[树和二叉树]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习]]></title>
    <url>%2F2013%2F03%2F29%2FAndriod%E5%AD%A6%E4%B9%A03(%E6%9C%AA%E5%AE%8C%E6%88%90)%2F</url>
    <content type="text"><![CDATA[树和二叉树]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习]]></title>
    <url>%2F2013%2F02%2F22%2FAndriod%E5%AD%A6%E4%B9%A02(%E6%9C%AA%E5%AE%8C%E6%88%90)%2F</url>
    <content type="text"><![CDATA[树和二叉树]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习]]></title>
    <url>%2F2013%2F01%2F25%2FAndriod%E5%AD%A6%E4%B9%A0(%E6%9C%AA%E5%AE%8C%E6%88%90)%2F</url>
    <content type="text"><![CDATA[树和二叉树]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AS从入门到精通]]></title>
    <url>%2F2012%2F12%2F28%2FAS%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A(%E6%9C%AA%E5%AE%8C%E6%88%90)%2F</url>
    <content type="text"><![CDATA[在今年5月16日的I/O大会上，谷歌推出新的Android开发环境——Android Studio，经过我这一段时间的实际应用，切身体会到android Studio和eclipse之间的优劣之处，现在将其总结如下： 工程管理： 新建工程时，Android Studio和eclipse新建工程的文件夹组织方式不同，开发环境之间的共容性较差，比如要将eclipse中的project导入到Android Studio中需费一定的周折，而要将Android Studio中的工程导入到eclipse中，却没有比较简单的方法，只能一个文件一个文件的拷贝。 新建工程后，设置工程的属性比较难，在eclipse中直接去properties设置就可以，但是在Android Studio中，0.1版提供了一个界面设置project structure，我设置过很多次，遇到各种问题，在Android Studio中新建的工程问题较少，但是从eclipse中导入的工程就比较容易出BUG，比如找不到Lib，找不到sdk，当升级到0.1.1版的时候直接没有界面了，当点击project structure的时候，提示：我们以后会提供一个界面来配置工程的设置，但是在这之前需要自己在gradle里去手动设置。 新建或导入工程后，要删除工程，Android Studio只能去workspace文件夹去删除，而不能在开发环境中删除。 在eclipse中引用库项目非常简单，库项目properties里android lib打钩，然后就可以直接在项目中引用了，但是在Android Studio中，由于时间的关系，我到现在没找到解决方法。 综上所述，在管理工程这块，可能是对Android Studio比较陌生，不习惯，总觉得android Studio远不如eclipse. IDE界面： Android Studio提供的dock留边停靠完胜eclipse,在eclipse中要是想用更大的视野来显示一个view，而隐藏其他的view的一个方法就是点X，关闭后要打开就比较麻烦了，而Android Studio是将常用的view最小化dock到其边界，更加人性化，已操作和灵活。 第二点，eclipse的启动速度令人蛋碎呢，每次开机先启eclipse，后启动其他程序，其他程序都百米5s的速度，eclipse都还没上起跑线。 还有eclipse的死机问题非常严重，我的ubuntu每天都要因为eclipse死机的问题来重启，有的时候甚至一天五六次。 项目编码： Android studio中的图标在每行最开始表示，使开发者更加可视化了自己的界面，程序等，这是Android Studio的最大亮点。 错误提示不比eclipse提示，eclipse放在错误上边即可提示，android studio需要按快捷键command+1才能显示。 拷贝一个方法或字段到另一个地方时，eclipse中是连它的引入类一起拷贝，比如拷贝List时会连import java.util.List和import android.Bluetooth.BluetoothDevice一起拷贝过去，而android Studio会给用户提供一个选择，要拷什么不要拷什么会给用户一个界面来勾选。 Android Studio 中 command+W可以直接快速定位到最近编辑的文件，不知道eclipse中有没有，暂时没有发现。 inspect code,利用android lit可以帮助开发者自动检查代码中的错误和有可能出现bug的地方。 在Android Studio中code assistance要远远强大于eclipse，比如你可以先调用方法，再写方法时会有提示，而在eclipse中只能傻傻地自己写，没有提示。还有一个，拷贝string或color中的value前选择value的时候，eclipse的反应速度慢到无法忍受。 res资源： Android studio中的颜色等都在每行最开始表示，使开发者更加可视化了自己的界面，程序等，这是Android Studio的最大亮点。 在代码中可以看到资源中不痛分辨率下的drawable图像，将光标放置图像名字中间，点View-quick documation即可看到,由于是在本环境中打开，而不是像eclipse中重启程序打开，所以打开图像的速度远远小于eclipse。 生成res的values文件更简单，感觉创建时更倾向于android开发，android专用，不像eclipse那么复杂。 提示更加完善，比如如果将Button拼成Bitton，Android Studio会自动检查出来，如果没有layout_width或layout_height，会自动检查出来并提供选项让开发者选择。 在android Studio中提供了一个Preview视图，可以和layout.xml文件进行关联，在xml文件中改属性，或添加组件，会动态在Preview视图中表现出来，而且可以添加不同语系，不痛屏幕尺寸的android设备。 编译代码： 在eclipse中编译速度感觉要慢于Android Studio，但是在eclipse中有一个build automatically的功能，觉得挺好用，在android Studio中未找到，只能在每次安装前手动编译。 编译后选择运行的平台，eclipse中会自动打开软件，而android Studio会安装软件，需要手动打开。 LOG查看： log查看相比较而言，还是android Studio稍微先进于eclipse，在eclipse很多次，我删掉的tag，第二次打开eclipse，它又存在于左边的list当中，Adnroid studio看起来界面比较友好，使人更容易找出log。 以上几点是我在这段时间来试用android studio和eclipse的真实体验，优缺点介绍的不那么完善，可能其中也存在一些问题，毕竟仁者见仁，智者见智，我觉得相对而言，总体还是Android studio 略胜eclipse一筹，由于android studio是新版本，还是不断的完善当中，所以建议初学者可以直接学习用android studio来开发，因为在我看来，android Studio代替eclipse来写android程序已经是大趋势，不可避免的了，谁先掌握了此工具的用法，谁就会比其他开发者更有优势，编程优势，面试优势等，但是毕竟android studio才刚出现，还年轻，难免会出现一些比较难解的bug，所以建议有经验的开发者暂时先用eclipse来开发，毕竟熟悉了那么长时间了，不会像android Studio那样，如果中奖碰上大的bug，那真是叫天不应，入地无门啊，整个项目的进度就得耽搁很久了 。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[疯狂Android第四部分]]></title>
    <url>%2F2012%2F11%2F30%2F%E7%96%AF%E7%8B%82Android%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[Android的网络应用Android完全支持JDK本身的TCP、UDP网络通信API。可以使用ServerSocket、Socket来建立基于TCP/IP协议的网络通信；也可以使用DatagramSocket、DatagramPacket、MulticastSocket来建立基于UDP协议的网络通信。 13.1 基于TCP协议的网络通信TCP/IP通信协议是一种可靠的网络协议，它在通信的两端各建立一个Socket，从而在通信的两端之间形成网络虚拟链路。一旦建立了虚拟的网络链路，两端的程序就可以通过虚拟链路进行通信。 IP协议是Internet上使用的一个关键协议，它的全称是Internet Protocol，即Internet协议，通常简称IP协议。通过使用IP协议，使Internet成为一个允许连接不同类型的计算机和不同操作系统的网络。要使两台计算机彼此之间进行通信，必须使两台计算机使用同一种“语言”，IP协议只保证计算机能发送和接收分组数据。IP协议负责将消息从一个主机传送到另一个主机，消息在传送过程中被分割成一个个小包。 尽管计算机通过安装IP软件，保证了计算机之间可以发送和接收数据，但IP协议还不能解决数据分组在传输过程中可能出现的问题。因此，若要解决可能出现的问题，连接上Internet的计算机还需要安装TCP协议来提供可靠并且无差别的通信服务。TCP协议被称作一种端对端协议，这是因为它为两台计算机之间的连接起了重要作用。当一台计算机需要与另一台远程计算机连接时，TCP协议会让他们建立一个连接：用于发送和接收数据的虚拟链路。TCP协议负责收集这些信息包，并将其按适当的次序放好传送，在接收端收到后再将其正确的还原。TCP协议保证了数据包在传送过程中准确无误。TCP协议使用重发机制：当一个通信实体发送一个消息给另一个通信实体后，需要收到另一个通信实体的确认信息，如果没有收到另一个通信实体的确认信息，则会再次重发刚才发送的信息。 使用ServerSocket创建TCP服务器端 //创建一个ServerSocket，用于监听客户端Socket的连接请求 ServerSocket ss = new ServerSocket(30000); //采用循环不断接受来自客户端的请求 while(true) { //每当接收到客户端Socket的请求，服务器也对应产生一个Socket Socket s = ss.accept(); //下面就可以使用Socket进行通信了 OutputStream os = ss.getOutputStream(); os.write(&quot;你好，你收到的服务器的新年祝福！&quot;.getBytes(&quot;utf-8&quot;)); os.close(); s.close(); } 客户端使用Socket进行通信 try { //建立到连接远程服务器的Socket Socket socket = new Socket(&quot;192.168.1.88&quot;, 30000); //将Socket对应的输入流包装成BufferedReader BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); String line = br.readLine(); system.out.printLine(&quot;来自服务器的数据：&quot;+line); br.close(); socket.close(); } catch (IOException e) { e.printStackTrace(); } 实际应用中的客户端则可能需要和服务器端保持长时间通信，即服务器需要不断地读取客户端数据，并向客户端写入数据，客户端也需要不断地读取服务器数据，并向服务器写入数据。为了解决这个问题，应该分别为服务器和客户端单独启动一条线程来负责读取对方数据。 服务端多线程Socket public class MyServer { public static ArrayList&lt;Socket&gt; socketList = new ArrayList&lt;Socket&gt;(); public static void main(String[] args) { ServerSocket ss = new ServerSocket(30000); while(true) { //此行代码会阻塞，将一直等待别人的连接 Socket s = ss.accept(); socketList.add(s); //每当客户端连接后启动一条ServerThread线程为该客户端服务 new Thread(new ServerThread(s)).start(); } } } public class ServerThread implements Runnable { Socket s = null; BufferedReader br = null; public ServerThread(Socket s) { this.s = s; br = new BufferedReader(new InputStreamReader(s.getInputStream(), &quot;utf-8&quot;)); } public void run() { String content = null; while((content=readFromClient())!=null) { for (Socket s : MyServer.socketList) { //遍历socketList的每个socket并向每个socket发送刚才读到的内容 OutputStream os = s.getOutputStream(); os.write((content+&quot;\n&quot;).getBytes(&quot;utf-8&quot;)); } } } public void readFromClient() { return br.readLine(); } } 客户端多线程Socket public class MultiThreadClient extends Activity { public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); Handler handler = new Handler() { public void handle(Message message) { if (msg.what == OX123) { show.append(&quot;\n&quot;+msg.obj.toString()); } } }; try { s = new Socket(&quot;192.168.1.88&quot;, 30000); new Thread(new ClientThread(s, handler)).start(); } send.setOnClickListener(new OnClickListener(){ public void onClick(View v) { os.write(input.getText().toString()+&quot;\r\n&quot;); input.setText(&quot;&quot;); } }); } } public class ClientThread implements Runnable { private Socket s; private Handler handler; private BufferedReader br; public ClientThread(Socket s, Handler handler) { this.s = s; this.handler = handler; this.br = new BufferedReader(new InputStreamReader(s.getInputStream())); } public void run() { String content = null; while((content = br.readLine()) != null) { Message msg = new Message(); msg.what = 0X123; msg.obj = content; handler.sendMessage(msg); } } } 13.2 使用URL访问网络资源URL(Uniform Resource Locator)对象代表统一资源定位器，它是指向互联网资源的指针。URL可以由协议名、主机、端口和资源组成，即 protocol://host:port/resourceName URL类提供了多个构造器用于创建对象，一旦获得了URL对象之后，可以调用如下常用方法来访问该URL对应的资源。getFile()/getHost()/getPath()/getPort()/getProtocol()/getQuery()/openConnection()/openStream()等 //打开URL的流并解析图片，将其显示在ImageView上 URL url = new URL(&quot;http://www.crazyit.org/attachments/.../1.png&quot;); InputStream is = url.openStream(); Bitmap bitmap = BitmapFactory.decodeStream(is); show.setImageBitmap(bitmap); is.close(); //保存URL对应的资源到本地 is = url.openStream(); OutputStream os = openFileOutput(&quot;crazyit.png&quot;, MODE_WORLD_READABLE); byte[] buff = new byte[1024]; int hasRead = 0; while((hasRead == is.read(buff)) &gt; 0) { os.write(buff, 0, hasRead); } is.close(); os.close(); URL的openConnection()方法将返回一个URLConnection对象，该对象表示应用程序和URL之间的通信连接。程序可以通过URLConnection实例向该URL发送请求，读取URL引用的资源。通常创建一个和URL的连接，并发送请求、读取此URL引用的资源需要如下几个步骤： 通过调用URL对象openConnection()方法来创建URLConnection对象 设置URLConnection的参数和普通请求属性 如果只是发送Get方式请求，使用connect方法建立和远程资源之间的实际连接即可；如果用post方式的请求，需要获取URLConnection实例对应的输出流来发送请求参数 远程资源变为可用，程序可以访问远程资源的头字段，或通过输入流读取远程资源的数据 public class GetPostUtil { public static String sendGet(String url, String params) { String urlName = url + &quot;?&quot; + params; URL realUrl = new URL(urlName); URLConnection conn = realUrl.openConnection(); //设置通用的请求属性,如connection, user-agent conn.setRequestProperty(&quot;accept&quot;, &quot;/*&quot;); conn.connect(); BufferedReader in = new BufferedReader(conn.getInputStream()); while ((String line = in.readLine) != null) { result += &quot;\n&quot; + line; } in.close(); } public static String sendPost(String url, String params) { URL realUrl = new URL(url); URLConnection conn = realUrl.openConnection(); //设置通用的请求属性,如connection, user-agent conn.setRequestProperty(&quot;accept&quot;, &quot;/*&quot;); conn.setDoOutput(true); conn.setDoInput(true); //获取URLConnection对象对应的输出流 PrintWriter out = new PrintWriter(conn.getOutputStream()); //发送请求参数 out.print(params); out.flush(); BufferedReader in = new BufferedReader(conn.getInputStream()); while ((String line = in.readLine) != null) { result += &quot;\n&quot; + line; } out.close(); in.close(); } } 13.3 使用HTTP访问网络前面介绍了URLConnection已经可以非常方便地与指定站点交换信息，URLConnection还有一个子类，HttpURLConnection，HttpURLConnection在URLConnection的基础上做了进一步改进，增加了一些用于操作HTTP资源的便捷方法： int getResponseCode() String getResponseMessage() String getRequestMethod(&quot;GET/POST&quot;) String setRequestMethod(String method) HttpURLConnection已经可以完成HTTP的请求了，但是在很多情况下，要涉及一些复杂的如Session，cookie的处理，用HttpURLConnection处理起来就比较负责了，所以Apache开源组织提供了一个HttpClient项目，它是一个增强版的HttpURLConnection；其使用方法如下 HttpGet get = new HttpGet(&quot;http://192.168.1.88:8888/foo/secret.jsp&quot;); HttpResponse httpResponse = httpClient.execute(get); HttpEntity entity = httpResponse.getEntity(); if (entity != null) { BufferedReader br = new BufferedReader(new InputStreamReader(entity.getContent())); while((String line = br.readLine()) != null) { response.append(line+&quot;\n&quot;); } } HttpPost post = new HttpPost(&quot;http://192.168.1.88:8888/foo/login.jsp&quot;); List&lt;NameValuePair&gt; params = new ArrayList&lt;NameValuePair&gt;(); params.add(new NameValuePair(&quot;name&quot;, name)); params.add(new NameValuePair(&quot;pass&quot;, pass)); post.setEntity(new UrlEncodedFormEntity(params, HTTP.UTF_8)); HttpResponse httpResponse = httpClient.execute(post); if (httpResponse.getStatusLine().getStatusCode()==200) { HttpEntity entity = httpResponse.getEntity(); String msg = EntityUtils.toString(entity); Toast.makeText(HttpClient.this, msg, 5000).show(); } 13.4 使用WebView视图显示网页WebView组件本身就是一个浏览器实现，它的内核基于开源WebKit引擎。它有如下一些方法：goback()/goForward()/loadUrl(String url)/zoomIn()/zoomOut() WebView提供了一个loadData(String data, String mineType, String encoding)方法，该方法可用于加载并显示HTML代码。但在使用过程中，当它加载包含中文的HTML内容时，WebView将显示乱码。好在WebView还提供了一个loadDataWithBaseURL(String baseUrl, String data, String mineType, String endcoding, String historyUrl)方法，该方法中文不会显示乱码 13.5 使用WebService进行网络编程Web Service主要的设计思想是：充分利用Web分布式编程模型的松散耦合性，允许各种平台、各种编程语言的应用可以交换数据，可以无缝的整合在一起。也就是说，Web Service提供了一种建立分布式应用的平台，使得不同操作平台上、不同语言实现的软件、所有已开发部署的软件都可以充分利用这个平台实现分布式计算。 与其他网络集成技术相比，Web Service具有如下两大优势： Web Service使用SOAP作为基本通信协议，更加简单易用 Web Service采用已经广泛使用的技术和协议，如XML、HTTP等，因此Web Service更容易掌握 Web Service平台主要涉及的技术有SOAP(Simple Object Access Protocol, 简单对象访问协议)，WSDL(Web Service Description Language, Web Service描述语言)，UDDI(Universal Description，Description and Integration, 统一描述、发现和整合协议) SOAP(Simple Object Access Protocol, 简单对象访问协议) 是一种具有扩展性的XML消息协议。SOAP允许一个应用程序向另一个应用程序发送XML消息，SOAP消息是从SOAP发送者传至SOAP接收者的单路消息，任何应用程序均可作为发送者和接收者。SOAP协议仅定义消息结构和消息处理的协议，与底层的传输协议独立。因此，SOAP协议能通过HTTP，JMS或SMTP协议传输。SOAP依赖于XML文档来构建，一条SOAP消息就是一份特定的XML文档，SOAP消息包含如下几个主要元素Envelope根元素/Header元素/Body元素 WSDL(Web Service Description Language, Web Service描述语言)使用XML描述Web Service，包括访问和使用Web Service所必须的信息，定义该Web Service的位置、功能及如何通信等描述信息。一般来说，只要调用者能够获取Web Service对应的WSDL，就可以从中了解它所提供的服务及如何调用Web Service，因为一份WSDL文件清晰地定义了三个方面的内容WHAT/HOW/WHERE UDDI(Universal Description，Description and Integration, 统一描述、发现和整合协议)是一套信息注册规范，它具有基于Web/分布式的特点。它包括一组允许企业向外注册Web Service，以使其他企业发现访问的实现标准。UDDI的核心组件是UDDI注册中心，它使用XML文件来描述企业及其提供的Web Service。 Java本身提供了丰富的Web Service支持，比如sun公司制定的JAX-WS2规范，还有Apache开源组织所提供的Axis1、Axis2、CXF等，这些技术不仅可以用于非常方便的对外提供Web Service，也可以用于简化Web Service的客户端编程。 Google为Android平台开发Web Service客户端提供了ksoap2-android项目，但这个项目并未直接集成在Android平台中，还需要开发人员自行下载jar包 //创建HttpTransportSE传输对象 HttpTransportSE ht = new HttpTransportSE(SERVICE_URL); //使用SOAP1.1协议创建Envelop对象 SoapSerializationEnvelope envelope = new SoapSerializationEnvelope(SoapEnvelope.VER11); //实例化SoapObject对象 SoapObject soapObject = new SoapObject(SERVICE_NS, &quot;getUserList&quot;); soapObject.addProperty(&quot;arg0&quot;, &quot;客户端参数：&quot;); //将soapObject对象设置为SoapSerializationEnvelope对象的传出SOAP消息 envelope.body = soapObject; ht.call(null, envelope); if (evenlope.getResponse() != null) { SoapObject result = (SoapObject)envelope.bodyIn; SoapObject detail1 = (SoapObject)result.getProperty(0); system.out.printLine(&quot;用户名：&quot;+detail1.getProperty(0)); } 管理Android手机桌面Android系统提供了一个桌面–也就是用户启动后第一次看到的界面，桌面上通常放置一些常用的程序和功能。Android桌面上首先看到壁纸，也就是手机桌面上的那张图片，接着可以看到手机桌面规则排列的多个图标，这些图标就是Android桌面组件，分别代表快捷方式、实时文件夹与桌面控件三类。每个快捷方式与实时文件夹只占用桌面的一个摆放位置，桌面控件则可以很大，一个桌面控件就可以占据多个摆放位置。 14.1 管理手机桌面关于如何添加、删除手机桌面上三类控件和壁纸的问题，都是一些操作步骤，此处不再赘述。 14.2 改变手机壁纸Android允许使用WallpaperManager来改变手机壁纸，该对象中改变手机壁纸的方法如下： setBitmap(Bitmap bitmap):将壁纸设置为bitmap所代表的位图 setResource(Int resId):将壁纸设置为resid资源所代表的图片 setStream(InputStream data):将壁纸设置为data数据所代表的图片 除此之外，Android系统还提供了一种实时壁纸的功能，所谓实时壁纸，就是指手机桌面不再是简单的图片，而是运行中的动画，这个动画是由程序实时绘制的，因此被称为实时壁纸。 为了开发实时壁纸，Android提供了WallpaperService基类，实时壁纸的实现类需要继承该类。在Android中开发实时壁纸的步骤如下： 开发一个类继承WallpaperService基类 继承WallpaperService基类时必须重写onCreateEngine()方法，该方法返回WallpaperService.Engine子类对象 开发者需要实现WallpaperService.Engine子类，并重写其中的onVisibilityChanged(boolean visible)和onOffsetChanged()方法。不仅如此，由于WallpaperService.Engine子类采用了与SurfaceView相同的绘图机制，因此还可选择性地重写在SurfaceHolder.Callback中的三个方法。重写这些方法时刻通过SurfaceHolder动态地绘制图形。 定义了该Service类之后，接下来还需要在AndroidManifest.xml文件中配置该Service，配置实时壁纸Service和配置普通Service存在小小的区别，它需要指定如下项 &lt;service android:label=&quot;@string/app_name&quot; android:name=&quot;.LiveWallpaper&quot; android:permission=&quot;android.permission.BIND_WALLPAPER&quot; &gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.service.wallpaper.WallpaperService&quot; /&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;android.service.wallpaper&quot; android:resource=&quot;@xml/livewallpaper&quot; /&gt; &lt;/service&gt; 14.3 桌面快捷方式对于一个希望拥有更多用户的应用来说，用户桌面可以说是所有软件的必争之地，如果用户在手机桌面上建立了该软件的快捷方式，用户将会更频繁的使用该软件。 在程序中把一个软件的快捷方式添加到桌面上，只需要如下几步即可： 创建一个添加快捷方式的Intent，该Intent的Action属性值应该为com.android.launcher.INSTALL_SHORTCUT 通过为该Intent添加Extra属性来设置快捷方式的标题、图标及快捷方式对应启动的程序 调用sendBroadcast()方法发送广播即可添加快捷方式 在程序中添加快捷方式需要的相应权限即可 Intent addIntent = new Intent(&quot;com.android.launcher.INSTALL_SHORTCUT&quot;); Intent myIntent = new Intent(AddShortcut.this, AddShortcut.class); addIntent.putExtra(Intent.EXTRA_SHORTCUT_NAME, title); addIntent.putExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE, icon); addIntent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, myIntent); sendBroadcast(addIntent); &lt;uses-permission android:name=&quot;com.android.lancher.permission.INSTALL_SHORTCUT&quot; /&gt; 通过上面的程序已经可以在桌面上为该程序添加快捷方式，但是这种添加方式需要先运行程序，并通过程序中的某个按钮来添加快捷方式，这种方式未免显得有些繁琐。为了让指定应用程序出现在桌面设置中，只要配置该Activity时指定相应的元素即可 &lt;activity android:name=&quot;.AddShortcut&quot; android:label=&quot;@string/app_name&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.CREATE_SHORTCUT&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 14.4 管理桌面小控件桌面小控件是通过Broadcast的形式来控制的，因此每个桌面小控件都对应于一个BroadcastReceiver。为了简化桌面小控件的开发，Android系统提供了一个AppWidgetProvider类，它就是BroadcastReceiver的子类，也就是说开发者开发桌面小控件只要继承AppWidgetProvider类即可。 为了开发桌面小控件，开发者只要开发一个继承AppWidgetProvider的子类，并重写AppWidgetProvider不同状态的生命周期方法即可。AppWidgetProvider里提供如下四个不同的生命周期方法 onUpdate/onDeleted/onEnabled/onDisabled。 public class DesktopApp extends AppWidgetProvider { public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) { RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.main); remoteViews.setImageViewResource(R.id.show, R.drawable.logo); ComponentName componentName = new Component(context, DesktopApp.class); appWidgetManager.updateAppWidget(componentName, remoteViews); } } 由于AppWidgetProvider继承了BroadcastReceiver，因此AppWidgetProvider的本质还是一个BroadcastReceiver，为此需要在AndroidManifest.xml文件中使用元素来配置它，配置该元素时需要为它指定相应的&lt;intent-filter…/&gt;和&lt;meta-data…/&gt; &lt;receiver android:name=&quot;.DesktopApp&quot; android:label=&quot;@string/app_name&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.appwidget.action.APPWIDGET_UPDATE&quot; /&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;android.appwidget.provider&quot; android:resource=&quot;@xml/appwidget_provider&quot; /&gt; &lt;/receiver&gt; 上面配置文件的粗体字代码指定该桌面小控件使用@xml/appwidget_provider作为meta-data，因此还需要在应用的res/xml目录下添加appwidget_provider.xml文件 &lt;appwidget-provider xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:minWidth=&quot;140dp&quot; android:minHeight=&quot;50dp&quot; android:updatePeriodMillis=&quot;1000&quot; android:initialLayout=&quot;@layout/main&quot; /&gt; 14.5 实时文件夹(LiveFolder)所谓实时文件夹，是指用于显示ContentProvider提供的数据的桌面组件。当用户把实时文件夹添加到系统桌面上之后，如果用户单击该实时文件夹图标，系统将会显示从指定ContentProvider查出来的全部数据。开发实时文件夹很简单，实时文件夹也是一个普通的Activity，只是该Activity并不会加载任何显示界面。开发实时文件夹的Activity同样需要集成Activity，并重写Activity的onCreate(Bundle savedInstanceState)方法 public class ContactsLiveFolder extends Activity { public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); if (getIntent().getAction().equals(LiveFolders.ACTION_CREATE_LIVE_FOLDER)) { Intent intent = new Intent(); intent.setData(Uri.parse(&quot;content://contacts/live_folders/people&quot;)); intent.putExtra(LiveFolders.EXTRA_LIVE_FOLDER_BASE_INTENT, new Intent(Intent.ACTION_VIEW, ContactsContract.Contacts.CONTENT_URI)); intent.putExtra(LiveFolders.EXTRA_LIVE_FOLDER_NAME, &quot;电话本&quot;); intent.putExtra(LiveFOLDERS.EXTRA_LIVE_FOLDER_ICON, Intent.ShortcutIconResource.fromContext(this, R.drawable.icon)); intent.putExtra(LiveFolders.EXTRA_LIVE_FOLDER_DISPLAY_MODE, LiveFolders.DISPLAY_MODE_LIST); setResult(RESULT_OK, intent); } else { setResult(RESULT_CANCELED); } finish(); } } 提供了该Activity之后，还需要将该Activity配置成一个实时文件夹，这需要在配置该Activity时通过&lt;intent-filter…/&gt;元素的&lt;action…/&gt;子元素来指定。也就是在AndroidManifest.xml文件中增加如下配置片段 &lt;activity android:name=&quot;.ContactsLiveFolder&quot; android:label=&quot;@string/app_name&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.CREATE_LIVE_FOLDER&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 传感器应用开发在Android系统中开发传感器应用十分简单，因为Android系统为传感器支持强大的管理服务。开发传感器应用的步骤如下： public class AccelerometerTest extends Activity implements SensorEventListener { SensorManager sensorManager; public void onCreate(Bundle savedInstaceState) { super.onCreate(savedInstanceState); sensorManager = (SensorManager)getSystemService(Context.SENSOR_SERVICE); } protected void onResume() { Sensor sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER); //this:监听传感器事件的监听器 sensor:传感器对象 rate:获取的频率 //频率由快到慢的顺序为 SensorManager.SENSOR_DELAY_FASTEST, SENSOR_DELAY_GAME, SENSOR_DELAY_NORMAL, SENSOR_DELAY_UI sensorManager.registerSensor(this, sensor, SensorManager.SENSOR_DELAY_GAME); } protected void onStop() { sensorManager.unregisterListener(this); super.onStop(); } public void onSensorChanged(SensorEvent event) { ...;//当传感器的值发生改变时触发该方法 } public void onAccuracyChanged(Sensor sensor, int accuracy) { ...;//当传感器的精度发生改变时触发该方法 } } 有些手机不支持传感器，模拟器也不支持传感器，开发某些具有传感器功能的APP为了调试，可以借助于一款名叫SensorMimulator的传感器模拟工具，通过此工具，可以模拟出传感器的一些数据来实验，具体操作此处不再介绍 上面介绍了速度传感器，除此之外，安卓设备一般还支持方向传感器、磁场传感器、温度传感器、光传感器、压力传感器等 方向传感器用于感应手机设备的摆放状态。其可以返回三个角度，这三个角度即可确定手机的摆放状态 磁场传感器主要用于读取手机设备外部的磁场强度。其可以返回三个数据，三个数据分别代表周围磁场分解到X、Y、Z三个方向上的磁场分量，磁场数据的单位和微特斯拉(uT) 温度传感器用户获取手机设备所处环境的温度。其可以返回一个数据，代表手机设备周围的温度，单位是摄氏度 光传感器用于获取手机设备所处环境的光的强度。其可以返回一个数据，代表手机设备周围光的强度，该数据的单位是勒克斯(lx) 压力传感器用于获取手机设备所处环境的压力的大小。其可以返回一个数据，代表手机设备周围压力的大小，该数据的单位是百帕斯卡hectopascal（hPa） GPS应用开发GPS是英文Global Position System(全球定位系统)的简称，GPS是20世纪70年代由美国陆海空三军联合研制的新一代空间卫星导航定位系统。 Android为GPS功能支持专门提供了一个LocationManager类，它的作用与TelephonyManager、AudioManager等服务类的作用相似，所有GPS定位相关的服务，对象都将由该对象来产生。 LocationManager lm = (LocationManager)getSystemService(Context.LOCATION_SERVICE); LocationProvider对象就是定位组件的抽象表示，通过LocationProvider可以获取该定位组件的相关信息 Location对象就是一个代表位置信息的抽象类 public class AllProvidersTest extends Activity { public void onCreate(Bundle savedInstanceState) { ListView providers; LocationManager lm; public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); providers = (ListView)findViewById(R.id.providers); lm = (LocationManager)getSystemService(Context.LOCATION_SERVICE); //providerNames会有network（NETWORK_PROVIDER），passive(PASSIVE_PROVIDER)，gps(GPS_PROVIDER)三个值 List&lt;String&gt; providerNames = lm.getAllProviders(); ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1, providerNames); providers.setAdapter(adapter); } } } 此程序可以列出所有支持的位置服务提供者，如何获取某一个LocationProvider呢，有两种方式 直接获取：LocationProvider lp = lm.getProvider(LocationManager.GPS_PROVIDER); 根据条件获取：LocationProvider lp = lm.getBestProvider(new Criteria(), true); 其中 Criteria 类的对象可以设置条件，如高度，方向等过滤条件 获取到了位置管理者LocationManager，就可以获取定位数据了 public class LocationTest extends Activity { LocationManager lm; public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); lm = (LocationManager)getSystemService(Context.LOCATION_SERVICE); Location location = lm.getLastKnownLocation(LocationManager.GPS_PROVIDER); updateView(location); lm.requestLocationUpdates(LocationManager.GPS_PROVIDER, 3000, 8, new LocationListener() { public void onLocationChanged(Location location) { updateView(location); ...;//当GPS定位信息发生改变时，更新位置 } public void onProviderDisabled(String provider) { ...;//当位置提供者不能用时 } public void onProviderEnabled(String provider) { ...;//当位置提供者正常使用时 } public void onStatusChanged(String provider, int status, Bundle extras) { ...;//当位置提供者状态改变时 } }); } } &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt; 前面介绍LocationManager时已经提到，该API提供了一个addProximityAlert(double latitude, double longtitude, float radius, long expiration, PendingIntent intent)方法来添加一个临近警告，其中expiration参数表示经过多少毫秒后该临近警告就会过期失效，-1表示永不过期。 使用Google Map服务疯狂连连看电子拍卖系统]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[疯狂Android第三部分]]></title>
    <url>%2F2012%2F10%2F26%2F%E7%96%AF%E7%8B%82Android%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[使用ContentProvider实现数据共享为了在应用程序之间交换数据，Android提供了ContentProvider，ContentProvider是不同应用程序之间进行数据交换的标准API，当一个应用程序需要把自己的数据暴露给其他程序使用时，该应用程序就可通过提供ContentProvider来实现；其他应用程序就可通过ContentResolver来操作ContentProvider暴露的数据 ContentProvider也是Android应用的四大组件之一，与Activity、Service、BroadcastReceiver相似，都需要在AndroidManifest.xml中进行配置 ContentProvider是不同应用程序之间进行数据交换的标准API，ContentProvider以某种Uri的形式对外提供数据，允许其他应用访问或修改数据；其他应用程序使用ContentResolver根据Uri去访问操作指定数据。 完整地开发一个ContentProvider的步骤如下： 定义自己的ContentProvider类，该类需要集成Android提供的ContentProvider基类 向Android系统注册这个Provider，也就是在AndroidManifest.xml文件中注册这个ContentProvider，就像注册Activity一样。注册ContentProvider时需要为它绑定一个域名 &lt;!--下面配置中name属性指定ContentProvider类 authorities就相当于为该ContentProvider指定域名--&gt; &lt;provider android:name=&quot;.DictProvider&quot; android:authorities=&quot;org.crazyit.providers.dictprovider&quot; /&gt; 应用程序对数据的操作无非就是CRUD操作，因此DictProvider除了需要继承ContentProvider之外，还需要实现ContentProvider内的几个方法： public boolean onCreate();该方法在ContentProvider创建后会被调用，当其他应用程序的第一次访问ContentProvider时，该ContentProvider会被创建出来，并立即回调该onCreate()方法 public Uri insert(Uri uri, ContentValues values);根据Uri插入Values对应的数据 public int delete(Uri uri, String selection, String[] selectionArgs);根据Uri删除select条件所匹配的全部记录 public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs):根据Uri修改select条件所匹配的全部记录 public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder):根据Uri查询出select条件所匹配的全部记录，其中projection就是一个列名列表，表明只选择出指定的数据列 public String getType(Uri uri):返回当前Uri所代表的数据的MIME类型。如果该Uri对应数据可能包括多条记录，那么MIME类型字符串应该以vnd.android.cursor.dir开头，如果该Uri对应的数据只包含一条记录，那么返回MIME字符串应该以vnd.android.cursor.item开头 形如content://org.crazyit.providers.dictProvider/words的Uri可分为3个部分 content:// 这个部分是Android所规定的，是固定的 org.crazyit.providers.dictProvider:这个部分就是ContentProvider的authority，系统就是由这个部分来找到操作哪个ContentProvider。只要访问指定的ContentProvider，这个部分总是固定的 words:资源部分(或者是数据部分)，当访问者需要访问不同资源时，这个部分是动态改变的 Context提供了如下方法来获取ContentResolver对象getContentResolver()，ContentResolver和ContentProvider的方法对应，支持的方法有： insert(Uri uri, ContentValues values); delete(Uri uri, String selection, String[] selectionArgs); update(Uri uri, ContentValues values, String selection, String[] selectionArgs): query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder): 一般来说，ContentProvider是单例模式的，当多个应用程序通过ContentResolver来操作ContentProvider提供的数据时，ContentResolver调用操作将会委托同一个ContentProvider处理 public final class Words { //定义该ContentProvider的Authority public static final String AUTHORITY = @&quot;org.crazyit.providers.dictProvider&quot;; //定义一个静态内部类 public static final class Word implements BaseColumn { public final String _ID = &quot;_id&quot;; public final String WORD = &quot;word&quot;; public final String DETAIL = &quot;detail&quot;; //定义该Content提供服务的两个Uri public final Uri DICT_CONTENT_URI = Uri.parse(&quot;content://&quot;+AUTHORITY+&quot;/words&quot;); public final Uri WORD_CONTENT_URI = Uri.parse(&quot;content://&quot;+AUTHORITY+&quot;/word&quot;); } } public class DictProvider extends ContentProvider { private static UriMatcher matcher = new UriMatcher(UriMatcher.NO_MATCH); private static final int WORDS = 1; private static final int WORD = 2; private MyDatabaseHelper dbOpenHelper; static { matcher.addURI(Words.AUTHORITY, &quot;words&quot;, WORDS); matcher.addURI(Words.AUTHORITY, &quot;word/#&quot;, WORD); } public boolean onCreate() { dbOpenHelper = new MyDataBaseHelper(this.getContext(), &quot;myDict.db3&quot;, 1); return true; } public Uri insert(Uri uri, ContentValues values) { SQLiteDatabase db = dbOpenHelper.getReadableDatabase(); long rowId = db.insert(&quot;dict&quot;, Words.Word._ID, values); if (rowId &gt; 0) { Uri wordUri = ContentUris.withAppendedId(uri, rowId); getContext().getContentResolver().notifyChange(wordUri, null); return wordUri; } return null; } public int delete(Uri uri, String selection, String[] selectionArgs) { SQLiteDatabase db = dbOpenHelper.getReadableDatabase(); int num = 0; switch (matcher.match(uri)) { case WORDS: num = db.delete(&quot;dict&quot;, selection, selectionArgs); break; case WORD: long id = ContentUris.parseId(uri); String where = Words.Word._ID+&quot;=&quot;+id; if (selection != null &amp;&amp; !selection.equals(&quot;&quot;)) { where = where + &quot; and &quot; + selection; } num = db.delete(&quot;dict&quot;, where, selectionArgs); break; default: throw new IllegalArgumentException(&quot;未知Uri:&quot;+uri); } getContext().getContentResolver().nofityChange(uri, null); return num; } ... } public class DictResolver extends Activity { ContentResolver contentResolver; public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); contentResolver = getContentResolver(); insert.setOnClickListener(new OnClickListener() { public void onClick(View source) { ContentValues values = new ContentValues(); values.put(Words.Word.WORD, word); values.put(Words.Word.DETAIL, detail); contentResolver.insert(Words.Word.DICT_CONTENT_URI, values); } }); } } 在上边例子中，为了确定ContentProvider实际能匹配的Uri，以及确定每个方法中Uri参数所操作的数据，Android系统提供了UriMatcher工具类，该类提供了两个方法： void addURI(String authority, String path, int code):向UriMatcher对象注册Uri，其中authority和path组成一个Uri，Code则代表该Uri对应的标识码 int match(Uri):根据前面注册的Uri来判断指定Uri对应的标识码，如果没有匹配，则返回-1 Android还提供了一个ContentUris工具类，它是一个操作Uri字符串的工具类，它提供了两个方法： withAppendedId(uri, id):用于为路径加上ID部分 parseId(uri):用于从指定Uri中解析出包含的ID值 有些时候，只有第一个和第二个应用程序知道共享的数据发生变化，第三个应用如果想知道，就需要监听ContentProvider所共享数据的改变，这就需要利用ContentObserver了。监听ContentProvider数据改变的监听器需要继承ContentObserver类，并重写该基类所定义的onChange(boolean selfChange)方法，当它所监听的ContentProvider的数据发生改变时，该onChange方法将会被触发。 getContext().getContentResolver().notifyChange(uri, null);null可以为ContentObserver实例，表示当前应用监听器数据的变化；这行代码可以通知所有注册在该Uri上的监听者，该ContentProvider所共享的数据发生了改变 为了监听指定ContentProvider的数据变化，需要通过ContentResolver向指定Uri注册ContentObserver监听器。ContentObserver提供了如下方法来注册监听器： registerContentObserver(Uri uri, boolean notifyForDescendents, ContentObserver observer)：uri指该监听器所监听的ContentProvider的Uri；notifyForDescendents如果为true，则子uri也会被监听，如果为false，则不会监听子uri；observer则是监听器实例 getContentObserver().registerContentObserver(Uri.parse(&quot;content://&quot;+AUTHORITY+&quot;/words&quot;), true, new DictObserver(new Handler())); public class Monitor extends Activity { public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); getContentResolver().registerContentObserver(Uri.parse(&quot;content://&quot;+AUTHORITY+&quot;/words&quot;), true, new DictObserver(new Handler())); } public final class DictObserver extends ContentObserver { public DictObserver(Handler handler) { super(hander); } public void onChange(boolean selfChange) { ... } } } Service与BroadcastReceiverService是Android四大组件中与Activity最相似的组件，他们都代表可执行的程序，Service与Activity的区别在于，Service一直在后台运行，它没有用户界面，所以绝不会到前台来。一旦Service被启动起来之后，它就与Activity一样。它完全具有自己的生命周期。 本章还将向读者介绍BroadcastReceiver组件。BroadcastReceiver组件就像一个全局的事件监听器，只不过它用于监听系统发出的Broadcast。通过BroadcastReceiver，即可在不同应用程序之间进行通信。 10.1 Service简介就像开发Activity需要两个步骤一样，开发Service也需要两个步骤： 定义一个继承Service的子类 在AndroidManifest.xml文件中配置该Service Service与Activity还有一点相似之处，它们都是从Context派生出来的，因此它们都可以调用Context里定义的如getResource()，getContentResolver()等方法 与Activity相似的是，Service中也定义了生命周期方法，如下所示： abstract IBinder onBind(Intent intent):该方法是Service子类必须实现的方法，该方法返回一个IBinder对象，应用程序可通过该对象与Service组件通信 void onCreate():当该Service第一次被创建时将立即回调该方法 void onDestroy():当该Service被关闭之前将会回调该方法 void onStartCommand(Intent intent, int flags, int startId):该方法的早期版本时void onStart(Intent intent, int startId)，每次客户端调用startService(Intent)方法启动该Service时都会回调该方法 boolean onUnbind(Intent intent):当该Service上绑定的所有客户端都断开连接时将会回调该方法 定义了上边的Service之后，接下来需要在AndroidManifest.xml文件中配置该Service &lt;service android:name=&quot;.FirstService&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;org.crazyit.service.FIRST_SERVICE&quot;&gt; &lt;/intent-filter&gt; &lt;/service&gt; 当该Service开发完成之后，接下来就可在程序中运行该Service了，Android系统中运行Service有如下两种方式 通过Context的startService()方法，通过该方法启动Service，访问者与Service之间没有联系，即使访问者退出了，Service仍然运行 通过Context的bindService()方法，使用该方法启动Service，访问者与Service绑定在了一起，访问者一旦退出，Service也就终止 当程序通过startService()和stopService()启动，关闭Service时，Service与访问者之间基本上不存在太多的数据关联，因此Service和访问者之间也无法进行通信、数据交换。 如果Service和访问者之间需要进行方法调用或者数据交换，则应使用bindService()和unbindService()方法启动、关闭服务。 Context的bindService()方法的完整方法签名为：bindService(Intent service, ServiceConnection conn, int flags)，该方法的三个参数的解释如下： service：该参数通过Intent指定要启动的Service conn：该参数是一个ServiceConnection对象，该对象用于监听访问者与Service之间的连接情况。当访问者与Service之间连接成功时将回调该ServiceConnection对象的onServiceConnected(ComponentName name, IBinder service)方法，当访问者与Service断开连接时将回调该ServiceConnection对象的onServiceDisconnected(ComponentName, name)方法 flags：指定绑定时是否自动创建Service(如果Service还未创建)。该参数可指定为0（不自动创建）或BIND_AUTO_CREATE（自动创建） 注意到ServiceConnection对象的onServiceConnected方法中有一个IBinder对象，该对象即可实现与被绑定Service之间的通信 public class BindService extends Service { private MyBinder binder = new MyBinder(); public class MyBinder extends Binder { public int getXxx() { return ... } } public IBinder onBind(Intent intent) { return binder; } public void onCreate() { super.onCreate(); } public boolean onUnbind(Intent intent) { return truel } public void onDestory() { super.onDestory(); } } public class MainActivity extends Activity { BindService.MyBinder binder; private ServiceConnection conn = new ServiceConnection() { public void onServiceConnected(componentName name, IBinder service) { binder = (BindService.MyBinder)service; } public void onServiceDisconnected(ComponentName name) { ... } public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); final Intent intent = new Intent(); intent.setAction(&quot;org.crazyit.service.BIND_SERVICE&quot;); bindButton.setOnClickListener(new OnClickListener(){ public void onClick(View Source) { bindService(intent, conn, Service.BIND_AUTO_CREATE) } }); unbindButton.setOnClickListener(new OnClickListener(){ public void onClick(View source) { unbindService(conn); } }); getDataButton.setOnClickListener(new OnclickListener(){ public void onClick(View source) { print(binder.getXxx()); } }); } } } 通过前面两个示例，读者应该已经大致明白Service的生命周期了。随着应用程序启动Service方式不同，Service的生命周期也略有差异 如果应用程序通过startService方法来启动Service，Service的生命周期是：启动-onCreate-onStart-运行-onDestory 如果应用程序通过bindService方法来启动Service，Service的生命周期是：启动-onCreate-onBind-交互-onUnbind-onDestory 10.2 跨进程调用Service(AIDL服务)Android用AIDL(Android Interface Definition Language)来定义远程接口，AIDL的语法与Java接口很相似，但存在一些差异 AIDL定义接口的源代码必须以.aidl结尾 AIDL接口中用到的数据类型，除了基本类型、String、List、Map、CharSequence之外，其他类型全部都需要导包，及时它们在同一个包中也需要导包 // ICat.aidl package service.crazyit.org.aidlservice; interface ICat { void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString); String getColor(); double getWeight(); } //AidlService.java public class AidlService extends Service { private CatBinder catBinder; public class CatBinder extends ICat.Stub { @Override public double getWeight() throws RemoteException { return 100; } } @Override public IBinder onBind(Intent intent) { return catBinder; } @Override public void onCreate() { super.onCreate(); catBinder = new CatBinder(); } @Override public void onDestroy() { super.onDestroy(); } } //MainActivity.java public class MainActivity extends AppCompatActivity { private ICat catService; private ServiceConnection conn = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { catService = ICat.Stub.asInterface(service); } @Override public void onServiceDisconnected(ComponentName name) { catService = null; } }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); final Intent intent = new Intent(); intent.setAction(&quot;org.crazyit.aidl.action.AIDL_SERVICE&quot;); bindService(intent, conn, Service.BIND_AUTO_CREATE); new Thread(new Runnable() { @Override public void run() { try { Thread.sleep(5000); Log.d(&quot;frand&quot;, catService.getWeight()+&quot;&quot;); } catch (RemoteException e) { e.printStackTrace(); } catch (InterruptedException e) { e.printStackTrace(); } } }).start(); } } 10.3 电话管理器(TelephonyManager)TelephonyManager是一个管理手机通话状态、电话网络信息的服务类，该类提供了大量的getXxx()方法来获取电话网络的相关信息，在程序中获取TelephonyManager十分简单，只要调用如下代码即可TelephonyManager tManager = (TelephonyManager)getSystemService(Context.TELEPHONY_SERVICE);，接下来就可以通过TelephonyManager获取相关信息或者进行相关操作了 getDeviceId()/getDeviceSoftwareVersion()/getNetworkOperator()/getNetworkOperatorName()/getPhoneType()/getCellLocation()/getSimCountryIso()/getSimSerialNumber()/getSimState()等 //监听手机来电，如果是黑名单，则自动挂断 public class MonitorPhone extends Activity { public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); TelephonyManager tManager = (TelephonyManager)getSystemService(Context.TELEPHONY_SERVICE); PhoneStateListener listener = new PhoneStateListener() { public void onCallStateChanged(int state, String incomingNumber) { switch(state) { case TelephonyManager.CALL_STATE_IDLE: break; case TelephonyManager.CALL_STATE_OFFHOOK: break; case TelephonyManager.CALL_STATE_RINGING: if (isBlock(incomingNumber)) { Method method = Class.forName(&quot;android.os.ServiceManager&quot;).getMethod(&quot;getService&quot;, String.class); IBinder binder = (IBinder)method.invoke(null, new Object[]{TELEPHONY_SERVICE}); ITelephony telephony = ITelephony.Stub.asInterface(binder); telephony.endCall(); } break; default: break; } } }; tManager.listen(listener, PhoneStateListener.LISTEN_CALL_STATE); } } 10.4 短信管理器SmsManager是Android提供的另一个非常常见的服务，SmsManager提供了系列sendXxxMessage()方法用于发送短信，不过就现在实际应用来看，短信通常都是普通的文本内容，也就是调用sendTextMessage()方法进行发送即可 SmsManager sManager = SmsManager.getDefault(); PendingIntent pi = PendingIntent.getActivity(SendSms.this, 0, new Intent(), 0); sManager.sendTextMessage(number, null, content, pi, null); &lt;uses-permission android:name=&quot;android.permission.SEND_SMS&quot; /&gt; 10.5 音频管理器(AudioManager)在某些时候，程序需要管理系统音量，或者直接让系统静音，这就可以借助于Android提供的AudioManager来实现。程序一样是调用getSystemService()方法来获取系统的音频管理器。接下来就可调用AudioManager的方法来控制手机音频了。 adjustStreamVolume(int streamType, int direction, int flags):调整手机指定类型的声音。其中第一个参数streamType指定声音类型，该参数可接受如下几个值 STREAM_ALARM:手机闹铃的声音 STREAM_DTMF:DTMF音调的声音（键盘音） STREAM_MUSIC:手机音乐的声音 STREAM_NOTIFICATION:系统提示的声音 STREAM_RING:电话铃声的声音 STREAM_SYSTEM:手机系统的声音 STREAM_VOICE_CALL:语言电话的声音 第二个参数指定对声音进行增大、还是减少；第三个参数时调整声音时的标志，例如指定FLAG_SHOW_UI，则指定调整声音时显示音量进度条。 SetMicrophoneMute(boolean on):设置是否让麦克风静音 setMode(int mdoe):设置声音模式，可设置的值有NORMAL，RINGTONE和IN_CALL setRingerMode(int ringerMode):设置手机的电话铃声模式，支持如下几个属性 RINGER_MODE_NORMAL:正常的手机铃声 RINGER_MODE_SILENT:手机铃声静音 RINGER_MODE_VIBRATE:手机振动 setSpeakerPhoneOn(boolean on):设置是否打开扩音器 setStreamMute(int streamType, boolean state):将手机的指定类型的声音调整为静音，其中streamType和adjustStreamVolume方法中第一个参数的意义相同 setStreamVolume(int streamType, int index, int flags):直接设置手机的指定类型的音量 AudioManager aManager = (AudioManager)getSystemService(Service.AUDIO_SERVICE); 10.6 振动器系统获取Vibrator也是调用Context的getSystemService()方法即可，接下来就可调用vibrator的方法来控制手机振动了，其使用方法比较简单，只有三个简单的方法来控制手机振动： void vibrate(long milliseconds):控制手机振动多少毫秒 void vibrate(long[] pattern, int repeat):指定手机以pattern指定的模式振动 cancel():关闭手机振动 Vibrator vibrator = (Vibrator)getSystemService(Service.VIBRATOR_SERVICE); vibrator.vibrate(2000); &lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot; /&gt; 10.7 手机闹钟服务(AlarmManager)AlarmManager通常的用途就是用来开发手机闹钟，但实际上它的作用不止于此。它的本质是一个全局的定时器，AlarmManager可在指定时间或者指定周期启动其他组件(包括Activity、Service、BroadcastReceiver) AlarmManager不仅可用于开发闹钟应用，还可以作为一个全局定时器使用，Android应用中的程序也是通过Context的getSystemService()方法来获取AlarmManager对象，一旦程序获取了AlarmManager对象之后，就可调用它的如下方法来设置定时启动指定组件： void set(int type, long triggerAtTime, PedingIntent operation):设置在triggerAtTime时间启动由operation参数指定的组件。其中第一个参数指定定时服务的类型，该参数可接受如下值： ELAPSED_REALTIME:指定从现在开始时间过了一定时间后启动operation所对应的组件 ALAPSED_REALTIME_WAKEUP:即使系统关机也会执行operation所对应的组件 RTC:指定当系统调用System.currentTimeMillis()方法返回值与triggerAtTime相等时启动operation所对应的组件 RTC_WAKEUP:即使系统关机也会执行operation所对应的组件 void setInexactRepeating(int type, long triggerAtTime, long interval, PendingIntent operation):设置一个非精确的周期性任务。例如我们设置Alarm每个小时启动一次，但系统并不一定在每个小时的开始启动Alarm服务 void setRepeating(int type, long triggerAtTime, long interval, PendingIntent operation):设置一个周期性执行的定时任务 void cancel(PedingIntent operation):取消AlarmManager的定时任务 public class AlarmChangeWallpaper extends Activity { public void onCreate(Bundle savedInstance) { super.onCreate(savedInstance); setContentView(R.layout.main); AlarmManager aManager = (AlarmManager)getSystemService(Service.ALARM_SERVICE); Intent intent = new Intent(AlarmChangeWallpaper.this, ChangeService.class); final PendingIntent pi = PendingIntent.getService(AlarmChangeWallpaper.this, 0, intent, 0); aManager.setRepeating(AlarmManager.RTC_WAKEUP, 0, 5000, pi); } } public class ChangeService extends Service { WallpaperManager wManager; public void onCreate() { super.onCreate(); wManager = WallpaperManager.getInstance(this); } public void onStart(Intent intent, int startId) { wManager.setResource(wallpapers[count++]); super.onStart(intent, startId); } public void onBind(Intent intent) { return null; } } &lt;uses-permision android:name=&quot;android.permission.SET_WALLPAPER&quot; /&gt; 10.8 广播消息Android系统的四大组件还有一种BroadcastReceiver，这种组件本质上就是一种全局监听器，用于监听系统全局的广播消息。由于BroadcastReceiver是一种全局的监听器，因此它可以非常方便地实现系统中不同组件之间的通信。 BroadcastReceiver用于接收程序（包括用户开发的程序和系统内建的程序）所发出的Broadcast Intent，与应用程序启动Activity，Service相同的是，程序启动BroadcastReceiver也只需要两步： 创建需要启动的BroadcastReceiver的Intent 调用Context的sendBroadcast()或sendOrderedBroadcast()方法来启动指定的BroadcastReceiver 当程序发出一个Broadcast Intent之后，所有匹配该Intent的BroadcastReceiver都有可能被启动 与Activity、Service具有完整生命周期不同的是，BroadcastReceiver本质上只是一个系统级的监听器，它专门负责 监听各程序所发出的Broadcast。与前面介绍的各种OnXXXListener不同的是，它是一个系统级的监听器，它有自己的进程，当程序退出时，只要存在与之匹配的Intent被广播出来，BroadcastReceiver总会被激发。 一旦实现了BroadcastReceiver的onReceive方法，接下来就应该指定该BroadcastReceiver能匹配的Intent，此时有两种方式： 使用代码进行指定，调用BroadcastReceiver的Context的registerReceiver(BroadcastReceiver receiver, IntentFilter filter)方法指定: IntentFilter filter = new IntentFilter(&quot;android.provider.telephony.SMS_RECEIVERD&quot;); IncomingSMSReceiver receiver = new IncomingReceiver(); register(receiver, filter); 在AndroidManifest.xml文件中配置，代码如下: &lt;receiver android:name=&quot;.IncomingReceiver&quot; &gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.provider.telephoy.SMS_RECEIVED&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 每次系统broadcast事件发生之后，系统就会创建对应的BroadcastReceiver实例，并自动触发它的onReceive方法，onReceive方法执行完后，BroadcastReceiver的实例就会被销毁。如果BroadcastReceiver的onReceive方法不能在10秒内执行完成，Android会认为该程序无响应。所以不要在BroadcastReceiver的onReceive方法里执行一些耗时的操作，否则会弹出ANR（Application No Response）的对话框 在程序中发送广播十分简单，只要调用Context的sendBroadcast(Intent intent)方法即可，这条广播将会启动intent参数所对应的BroadcastReceiver。 Broadcast被分为如下两种： Normal Broadcast(普通广播):这种广播完全是异步的，可以在同一时刻被所有接收者接收到，消息传递的效率比较高。但缺点是接收者不能将处理结果传递给下一个接收者，并且无法终止Broadcast Intent的传播 Ordered Broadcast(有序广播):这种广播的接收者将按预先声明的优先级依次接收Broadcast。优先级别声明在&lt;intent-filter…/&gt;元素的android:priority属性中，数越大优先级别越高，取值范围为-1000~1000之间，优先级别也可以调用IntentFilter对象的setPriority()进行设置。Ordered Broadcast接收者可以调用BroadcastReceiver的abordBroadcast()方法终止Broadcast Intent的传播，Broadcast Intent一旦终止，后面的接收者就无法接收到Broadcast。另外，Ordered Broadcast的接收者可以将数据传递给下一个接收者 //发送广播 Intent intent = new Intent(); intent.setAction(&quot;org.crazyit.action.CRAZY_BROADCAST&quot;); sendOrderedBroadcast(intent, null); //第一个BroadcastReceiver Bundle bundle = new Bundle(); bundle.putString(&quot;first&quot;, &quot;第一个BroadcastReceiver存入的消息&quot;); setResultExtra(bundle); abortBroadcast(); &lt;receiver android:name=&quot;.MyReceiver&quot; &gt; &lt;intent-filter android:priority=&quot;20&quot;&gt; &lt;action android:name=&quot;org.crazyit.action.CRAZY_BROADCAST&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; //第二个BroadcastReceiver Bundle bundle = getResultExtra(true); String first = bundle.getString(&quot;first&quot;); 10.9 接收系统广播消息如果应用需要在系统特点时刻执行某些操作，就可以通过监听系统广播来实现。Android的大量系统事件都会对外发送标准广播。下面是Android常见的广播Action常量 ACTION_TIME_CHANGED:时间改变 ACTION_DATE_CHANGED:日期改变 ACTION_TIMEZONE_CHANGED:时区改变 ACTION_BOOT_COMPLETED:启动完成 ACTION_PACKAGE_ADDED:添加包 ACTION_PACKAGE_CHANGED:包被删除 ACTION_PACKAGE_REMOVED:包被删除 ACTION_PACKAGE_RESTARTED:包被重启 ACTION_PACKAGE_DATA_CLEARED:包数据被清空 ACTION_BATTERY_CHANGED:电池电量改变 ACTION_BATTERY_LOW:电池电量低 ACTION_POWER_CONNECTED:系统连接电源 ACTION_POWER_DISCONNECTED:系统断开电源 ACTION_SHUTDOWN:系统被关闭 多媒体应用开发11.1 音频和视频的播放Android提供了简单的API来播放音频、视频：MediaPlayer；使用MediaPlayer十分简单，当程序控制MediaPlayer对象装载音频完成以后，程序可以调用MediaPlayer的如下三个方法进行播放控制： start():开始或恢复播放 stop():停止播放 pause():暂停播放 为了让MediaPlayer来装载指定音频文件，MediaPlayer提供了如下简单的静态方法： static MediaPlayer create(Context context, Uri uri):从指定Uri来装载音频文件，并返回对象 static MediaPlayer create(Context context, int resid):从resid资源ID对应的资源装载音频文件并返回 如果程序需要使用MediaPlayer循环播放多个音频文件，使用MediaPlayer的静态create方法就不太合适了，此时可通过MediaPlayer的setDataSource()方法来装载指定的音频文件 void setDataSource(String path/FileDescriptor fd):指定装载path路径或fd所代表的文件 void setDataSource(FileDescriptor fd, long offset, long length):指定fd文件的offset开始length长度的文件内容 void setDataSource(Context context, Uri uri):指定装载uri所代表的文件 执行上面所示的setDataSource方法之后，MediaPlayer并未真正去装载那些文件，还需要调用MediaPlayer的prepare()方法去准备，所谓准备，就是让MediaPlayer真正去装载音频文件 除此之外，MediaPlayer还提供了一些绑定事件监听器的方法，用于监听MediaPlayer播放过程中所发生的特定事件，绑定事件监听器的方法如下： setOnCompletionListener(MediaPlayer.OnCompletionListener listener): setOnErrorListener(MediaPlayer.OnErrorListener listener): setOnPreparedListener(MediaPlayer.OnPreparedListener listener): setOnSeekCompleteListener(MediaPlayer.OnSeekCompleteListener listener): 如果应用程序经常需要播放密集、短促的音效，这是还用MediaPlayer就显得有些不合适了。MediaPlayer存在如下缺点： 占用资源较多，延时时间较长 不支持多个音效同时播放 为了解决这个问题，Android提供了SoundPool来播放音效，SoundPool使用音效池的概念来管理多个短促的音效，它与MediaPlayer相比，占用资源量低延时更小，而且还支持自行设置声音的品质、音量、缩放比率等参数。它的构造器如下： SoundPool(int maxStreams, int streamType, int srcQuality):第一个参数指定支持多少个声音，第二个参数指定声音类型，第三个参数指定声音品质 一旦得到了SoundPool对象之后，接下来就可调用SoundPool的多个重载的load方法来加载声音了，SoundPool提供了如下4个load方法 int load(Context context, int resId, int priority): int load(FileDescriptor fd, long offset, long length, int priority) int load(AssetFileDescriptor afd, int priority) int load(String path, int priority) 上面4个方法都有一个priority参数，该参数目前还没有任何作用，Android建议将该参数设为1，保持和未来的兼容性；上面的4个方法加载声音之后都会返回该声音的ID，以后程序就可以通过该声音的ID来播放指定声音，SoundPool提供的播放指定声音的方法如下： int play(int soundID, float leftVolume, float rightVolume, int priority, int loop, float rate):该方法的第一个参数指定播放哪个声音，leftVolume和rightVolume指定左、右的音量，priority指定播放声音的优先级，数值越大，优先级越高；loop指定是否循环，0为不循环，-1为循环；rate指定播放的比率，数值可从0.5到2，1为正常比率 为了更好的管理SoundPool所加载的每个声音的ID，程序一般会使用一个HashMap&lt;Integer, Integer&gt;对象来管理声音 SoundPool soundPool = new SoundPool(10, AudioManager.STREAM_SYSTEM, 5); HashMap soundMap = new HashMap&lt;Integer, Integer&gt;(); soundMap.put(1, soundPool.load(this, R.raw.bomb, 1)); btn.setOnClickListener(new OnClickListener(){ public void onClick(View v) { soundPool.play(soundMap.get(1), 1, 1, 0, 0, 1); } }); SoundPool虽然可以一次性加载多个声音，但由于内存限制，因此更应该避免使用SoundPool来播放歌曲或者做游戏背景音乐，只有那些短促、密集的声音才考虑使用SoundPool进行播放 使用VideoView播放视频的步骤如下： &lt;VideoView android:id=&quot;@+id/video&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; /&gt; VideoView videoView = (VideoView)findViewById(R.id.video); MediaController mediaController = new MediaController(this); File video = new File(&quot;/mnt/sdcard/movie.mp4&quot;); if (video.exist()) { videoView.setVideoPath(video.getAbsolutePath()); videoView.setMediaController(mediaController); mediaController.setMediaPlayer(videoPlayer); videoView.requestFocus(); } 11.2 使用MediaRecorder录制音频为了在Android应用中录制音频，Android提供了MediaRecorder类，使用MediaRecorder录制音频的过程很简单，按如下步骤进行即可： 创建MediaRecorder对象 调用MediaRecorder对象的setAudioSource()方法设置声音来源，一般传入MediaRecorder.AudioSource.MIC参数指定录制来自麦克风的声音 调用MediaRecorder对象的setOutputFormat设置所录制的音频文件格式 调用MediaRecorder对象的setAudioEncoder()、setAudioEncodingBitRate(int bitRate)、setAudioSamplingRate()设置所录制的声音的编码格式、编码位率、采样率等 调用MediaRecorder的setOutputFile(String path)方法设置录制音频文件的保存位置 调用MediaRecorder的prepare()方法准备开始录制 调用MediaRecorder的start()方法开始录制 调用MediaRecorder的stop()方法停止录制，并调用release()方法释放资源 File soundFile = new File(&quot;/file/sound.amr&quot;); MediaRecorder mediaRecorder = new MediaRecorder(); mediaRecorder.setAudioSource(MediaRecorder.AudioSource.MIC); mediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP); mediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.ARM_NB); mediaRecorder.setOutputFile(soundFile.getAbsolutePath); mediaRecorder.prepare(); mediaRecorder.start(); &lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt; 11.3 控制摄像头拍照和录视频短片使用MediaRecorder拍照代码： SurfaceView surfaceView = (SurfaceView)findViewById(R.id.sufaceView); SufaceHolder surfaceHolder = surfaceView.getHolder(); Camera camera = Camera.open(); Camera.Parameters parameters = camera.getParameters(); parameters.setPreviewSize(screenWidth, screenHeight); parameters.setPreviewFrameRate(4); parameters.setPictureFormat(PixelFormat.JPEG); parameters.set(&quot;jpeg-quality&quot;, 85); parameters.setPictureSize(screenWidth, screenHeight); camera.setParameters(parameters); camera.PreviewDisplay(surfaceHolder); camera.startPreview(); camera.autoFocus(null); camera.takePicture(null, null, myjpegCallback); PictureCallback myjpegCallback = new PictureCallback() { public void onPictureTaken(byte[] data, Camera camera) { Bitmap bm = BitmapFactory.decodeByteArray(data, 0, data.length); File file = new File(Environment.getExternalStorageDirectory(), &quot;logo.jpg&quot;); FileOutputStream outStream = new FileOutputStream(file); bm.compress(CompressFormat.JPEG, 100, outStream); outStream.close(); camera.stopPreview(); camera.startPreview(); } }; &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt; &lt;uses-permission android:name=&quot;android.hardware.camera&quot; /&gt; &lt;uses-permission android:name=&quot;android.hardware.camera.autofocus&quot; /&gt; MediaRecorder除了可用于录制音频外，还可用于录制视频。使用MediaRecorder录制视频与录制音频的步骤基本相同。只是录制视频时不仅需要采集声音，还需要采集图像，为了让MediaRecorder录制时采集图像，应该在调用setAudioSource(int audio_source)方法时再调用setVideoSource(int video_source)方法来设置图像来源。录视频代码如下： //设置从摄像头采集图像 mediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA); //设置视频文件的输出格式(必须在设置声音编码格式、图像编码格式之前设置) mediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4); mediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.DEFAULT); mediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.MPEG_4_SP); mediaRecorder.setVideoSize(320, 280); mediaRecorder.setVideoFrameRate(4); //使用指定的SurfaceView来预览视频 mediaRecorder.setPreviewDisplay(sView.getHolder().getSurface()); mediaRecorder.prepare(); mediaRecorder.start(); OpenGL与3D应用开发这个部分的知识比较少用，以后会总结]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[疯狂Android第二部分]]></title>
    <url>%2F2012%2F09%2F28%2F%E7%96%AF%E7%8B%82Android%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[使用Intent和IntentFilter进行通信 不管是启动一个Activity也好，Service或者BroadcastReceiver组件也好，Android使用统一的Intent对象来封装意图，用Intent可以提供一致的编程模型 在某些时候，应用程序只是想启动具有某种特征的组件，并不想和某个具体的组件耦合，用Intent明显利于高层次的解耦 5.1 Intent对象详解Intent对象大致包含Component、Action、Category、Data、Type、Extra这7个属性，其中Component用于明确指定需要启动的目标组件，而Extra用于携带需要交换的数据 5.2 Intent的属性及intent-filter配置Intent的Action、Category属性都是一个普通的字符串，其中Action代表Intent所要完成的一个抽象动作，而Category则用于为Action增加额外的附加类别信息，通常Action属性会和Category属性结合使用，在注册Activity时可以有一个或多个Action和Category，但是Action中，如果过滤规则中能够匹配到其中一个，是可以成功的；而过滤规则需要满足对应所有的category，才可以成功的 Data属性通常用于向Action属性提供操作的数据 Type属性用于明确指定Data属性所指定数据的类型或MIME类型，当Intent不指定Data属性时Type属性才会起作用，否则Android系统将会根据Data属性值来分析数据的类型，因此指定Data后无须指定Type属性 Intent的Extra属性通常用于在多个Action之间进行数据交换，Intent的Extra属性值应该是一个Bundle对象，Bundle对象就像一个Map对象，它可以存入多组key-value对，这样就可以通过Intent在不同的Activity之间进行数据交换了 Android应用的资源如果从物理存在形式来分，Android应用的源代码大致可分为如下三大类： 界面布局文件：XML文件，文件中每个标签都对应于相应的View标签 Java源文件：应用中的Activity、Service、BroadcastReceiver、ContentProvider四大组件都是采用Java代码来实现的 资源文件：主要以各种XML为主，还包括.png/.jpg/.gif图片资源 Android应用下除了res目录用于存放资源之外，assets目录也可用于存放资源。一般来说，assets目录下存放的资源代表应用无法直接访问的原生资源，应用程序需要通过AssetManager以二进制流的形式来读取资源，而res目录下的资源，Android SDK会在编译该应用时，自动在R.java文件中为这些资源创建索引，程序可直接通过R资源清单类进行访问 6.1 资源的类型及存储方式Android应用资源可分为两大类： 无法直接访问的原生资源，保存在assets目录下 可通过R资源清单类访问的资源，保存在res目录下 一旦将应用程序的各种资源分别保存在Android应用的/res目录下，接下来既可以在Java程序中使用这些资源，也可以在其他XML资源中使用这些资源 由于Android SDK会在编译应用时在R类中为/res目录下所有资源创建索引项，因此在Java代码中访问资源主要通过R类来完成[&lt;package_name&gt;.]R.&lt;resource_type&gt;.&lt;resource_name&gt; 当定义XML资源文件时，其中的XML元素可能需要指定不同的值，这些值就可以设置为已定义的资源项。在XML中使用资源的完整语法格式为：@[&lt;package_name&gt;:]&lt;resource_type&gt;/&lt;resource_name&gt; 6.2 使用字符串、颜色、尺寸资源字符串资源、颜色资源、尺寸资源，它们对应的XML文件都将位于/res/value目录下，它们的默认的文件名为strings.xml/colors.xml/dimens.xml 6.3 数组(Array)资源Android同样采用位于/res/value目录下的arrays.xml文件来定义数组，定义数组时XML资源文件的根元素也是&lt;resources…/&gt;元素，该元素内可包含如下三种子元素&lt;array.../&gt; &lt;string-array.../&gt; &lt;integer-array.../&gt; 6.4 使用Drawable资源Drawable资源通常保存在/res/drawable目录，实际上可能保存在/res/drawable-lmhdpi目录下，图片资源是最简单的Drawable资源，我们只要把.png .jpg .gif等格式的图片放入/res/drawable-xxx目录下，Android SDK就会在编译应用时自动加载该图片，并在R资源清单类中生成该资源的索引 StateListDrawable用于组织多个Drawable对象，当使用StateListDrawable作为目标组件的背景，前景图片时，StateListDrawable对象所显示的Drawable对象会随目标组件状态的改变而自动切换。 定义StateListDrawable对象的XML文件的根元素为&lt;selector.../&gt;，该元素可以包含多个&lt;item.../&gt;元素，该元素可以指定如下属性color/drawable/state_xxx 与StateListDrawable有点类似，LayerDrawable也可包含一个Drawable数组，因此系统将会按这些Drawable对象的数组顺序来绘制它们，索引最大的Drawable对象将会被绘制在最上面。 定义LayerDrawable对象的XML文件的根元素为&lt;layer-list.../&gt;，该元素可以包含多个&lt;item.../&gt;元素，该元素可指定如下属性drawable/id/bottom|top|left|right ShapeDrawable用于定义一个基本的几何图形(如矩形、圆形、线条等) 定义ShapeDrawable的XML文件的根元素是&lt;Shape.../&gt;元素，该元素可指定如下属性android:shape=[rectangle|oval|line|ring]，该元素下边可指定如下元素&lt;corners.../&gt; &lt;gradient.../&gt; &lt;padding.../&gt; &lt;size.../&gt; &lt;solid.../&gt; &lt;stroke.../&gt; ClipDrawable代表从其他位图上截取的一个“图片片段”，在XML文件中定义ClipDrawable对象使用&lt;clip.../&gt;元素，该元素可以指定三个属性drawable/clipOrientation/gravity AnimationDrawable代表一个动画资源，Android中既支持传统的逐帧动画（类似于电影方式、一张图片一张图片的切换），也支持通过平移、变化计算出来的补间动画 下面以逐帧动画原理来介绍定义AnimationDrawable资源, 定义逐帧动画的XML资源文件以元素作为根元素,该元素内可指定&lt;item…./&gt;子元素,将其设置为ImageView的background后,便可将item内的图片文件逐帧播放 下面以补间动画文理来介绍如何定义AnimationDrawable资源，定义补间动画的XML资源文件以&lt;set…/&gt;元素作为根元素，该元素内可以指定如下4个元素：alpha/scale/tanslate/rotate 6.5 使用原始XML资源在某些时候，Android应用有一些初始化的配置信息、应用相关的数据资源需要保存、一般推荐使用XML文件来保存它们，这种资源就被称为原始XML资源。 原始XML资源一般保存在/res/xml路径下，一般默认没有此目录，开发者应该自行手动创建xml目录，一旦成功的定义了原始XML资源，接下来在XML文件中可通过如下语法格式来访问它：@[&lt;package_name&gt;:]xml/file_name，在Java代码中通过[&lt;package_name&gt;.]R.xml.&lt;file_name&gt;来访问它 6.6 使用布局(Layout)资源Layout资源文件应放在/res/layout目录下，Layout资源文件的根元素通常是各种布局管理器，比如LinearLayout、RelativeLayout等 一旦在Android项目中定义了Layout资源，接下来在XML文件中可通过如下语法格式来访问它：@[&lt;package_name&gt;:]layout/file_name，在Java代码中通过[&lt;package_name&gt;.]R.layout.&lt;file_name&gt;来访问它 6.7 使用菜单(Menu)资源菜单资源文件通常应该放在/res/menu目录下，菜单资源的根元素通常是&lt;menu…/&gt;元素，&lt;menu…/&gt;元素无须指定任何属性。&lt;menu.../&gt;元素内可包含如下子元素&lt;item.../&gt; &lt;group.../&gt;，&lt;group.../&gt;子元素用于控制整组菜单的行为，该元素可指定如下常用属性 checkableBehavior：指定该组菜单的选择行为 menuCategory：对菜单进行分类，指定菜单的优先级 visible：该菜单是否可见 enable：该菜单是否可用 归纳起来，使用XML资源定义菜单有如下两个好处： XML资源文件不仅负责定义应用界面，也负责定义菜单，这样可把所有界面相关的内容交给XML文件管理，而Java代码的功能更集中 后期更新维护应用时，如果需要更新、维护菜单，打开、编辑XML文件即可，避免对Java文件的修改 6.8 样式(Style)和主题(theme)资源Android的样式资源文件也放在/res/values目录下，样式资源文件的根元素是&lt;resources.../&gt;元素，该元素内可包含多个&lt;style.../&gt;子元素，每个&lt;style.../&gt;子元素定义一个样式，&lt;style.../&gt;元素指定如下两个属性 name 和 parent，&lt;style.../&gt;元素内可包含多个&lt;item.../&gt;子元素，每个&lt;item.../&gt;子元素定义一个格式项，如android:textColor 与样式资源非常相似，主题资源的XML文件通常也放在/res/values目录下，主题资源的XML文档同样以&lt;resource.../&gt;元素作为根元素，同样使用&lt;style.../&gt;来定义主题。 主题与样式的区别主要体现在： 主题不能作用于单个的View组件，主题应该对整个应用中的所有Activity起作用，或对指定Activity起作用 主题定义的格式应该是改变窗口外观的格式，例如窗口标题、窗口边框等 6.9 属性（Attribute）资源属性资源文件也放在/res/values目录下，属性资源文件的跟元素也是&lt;resources.../&gt;，该元素里包含如下两个子元素 attr子元素：定义一个属性 declare-styleable子元素：定义一个styleable对象，每个styleable对象就是一组attr属性的集合 &lt;declare-styleable name=&quot;MyImageView&quot;&gt; &lt;attr name=&quot;imgSrc&quot; format=&quot;reference&quot;/&gt; &lt;/declare-styleable&gt; 6.10 使用原始资源类似声音文件及其他各种类型的文件，只要Android没有为之提供专门的支持，这种资源都被称为原始资源。Android的原始资源可以放在如下两个地方 位于/res/raw目录下，Android SDK会处理该目录下原始资源，Android SDK会在R清单类中为该目录下的资源生成一个索引 位于/assets/目录下，该目录下的资源是更彻底的原始资源。Android应用需要通过AssetManager来管理该目录下的原始资源 6.11 国际化和资源自适应Android应用使用res/values目录下的资源文件来保存程序中用到的字符串信息，为了给这些消息提供不同语言，国家的版本，开发者需要为values目录添加几个不同的语言国家版本，不同values文件夹的命名方式为： values-语言代码-r国家代码 图形与图像处理7.1 使用简单图片当我们为Android应用增加了Drawable资源后，Android SDK会为这份资源在R清单文件中创建一个索引项：R.drawable.file_name，接下来可以在XML资源文件中通过@drawable/file_name来访问该对象，也可在Java代码中通过R.drawable.file_name方位该Drawable对象 Bitmap代表一张位图，BitmapDrawable里封装的图片就是一个Bitmap对象。开发者为了把Bitmap对象包装成BitmapDrawable对象，可以调用BitmapDrawable的构造器BitmapDrawable drawable = new BitmapDrawable(bitmap)，如果需要获取BitmapDrawable所封装的Bitmap对象，则可调用BitmapDrawable的getBitmap()方法Bitmap bitmap = drawable.getBitmap(); 除此之外，Bitmap还提供了一些静态方法来创建新的Bitmap对象，例如： createBitmap(Bitmap src, int x, int y, int width, int height) createScaledBitmap(Bitmap src, int dstWidth, int dstHeight, boolean filter) createBitmap(int width, int height, Bitmap.Config config) createBitmap(Bitmap src, int x, int y, int width, int height, Matrix m, boolen filter) BitmapFactory是一个工具类，它用于提供大量的方法，这些方法可用于从不同的数据源来解析、创建Bitmap对象。BitmapFactory包含了如下方法： decodeByteArray(byte[] data, int offset, int length) decodeFile(String pathName) decodeFileDescriptor(FileDescriptor fd) decodeResource(Resources res, int id) decodeStream(InputStream is) 由于手机内存的限制，如果系统不停的去解析、创建Bitmap对象，可能由于前面创建Bitmap所占的内存还没有回收，而导致程序运行时引发OutOfMemory错误，Android为Bitmap提供了两个方法来判断它是否已回收 1. boolean isRecycled() 2. void recycle() 7.2 绘图Android的绘图应该继承View组件，并重写它的onDraw(Canvas canvas)方法即可；此时涉及一个绘图API：Canvas，Canvas代表了依附于指定View的画布，它提供了很多的方法来绘制各种图形，比如drawArc,drawBitmap,drawLine,drawRect,drawText等；这些方法的参数中都涉及一个绘图API：Paint，Paint代表了Canvas上的画笔，因此Paint类主要用于设置绘制风格，包括画笔颜色，粗细，填充风格，渐变Shader等 Android提供的Path是一个非常有用的类，它可以预先在View上将N个点连成一条路径，然后调用Canvas的drawPath(path, paint)即可沿着路径绘制图形，实际上Android还未路径绘制提供了PathEffect来定义绘制效果，如ComposePathEffect,CornerPathEffect,DashPathEffect,DiscretePathEffect,PathDashPathEffect,SumPathEffect等 为了让View组件上绘制的图形发生改变(无非是位置、大小、角度等发生改变)，这就需要程序采用变量来记住这些状态数据–如果需要游戏动画随用户操作而改变，就为用户动作编写事件监听器，在监听器中修改这些数据；如果需要游戏动画自行改变，那就是随时间的流失而改变，就需要使用定时器(Timer)，让Timer控制这些状态数据定期修改；不管使用哪种方式，每次View组件上的图形状态数据发生了改变，都应该通知View组件重写调用onDraw(Canvas canvas)方法重绘该组件。通知View重绘可调用invalidate(在UI线程中)或postInvalidate(在非UI线程中) 7.3 图形特效处理Matrix是Android提供的一个矩阵工具类，它本身并不能对图像或组件进行变换，但它可与其他API结合来控制图形、组件的变换，使用Matrix控制图像或组件的变换步骤如下 获取Matrix对象，该Matrix对象既可新创建，也可直接获取其他对象内封装的Matrix 调用Matrix的方法进行平移、旋转、缩放、倾斜等 将程序对Matrix所做的变换应用到指定图像或组件 Matrix提供了如下方法来控制平移、旋转和缩放setTranslate/setSkew/setRotate/setScale drawBitmapMesh(Bitmap bitmap, int meshWidth, int meshHeight, float[] vers, int vertOffset, int[] colors, int colorOffset, Paint paint)方法是Canvas提供，该方法可以对bitmap进行扭曲，其中的关键参数说明如下 bitmap:指定需要扭曲的源位图 meshWidth:该参数控制在横向上把该源位图划分成多少格 meshHeight:该参数控制在纵向上把该源位图划分成多少格 verts:该参数时一个长度为(meshWidth+1)*(meshHeight+1)*2的数组，它记录了扭曲后的位图各顶点位置。虽然它是一个数组，实际上它记录的数据是形如(x0, y0)、(x1, y1)、(x2, y2)、格式的数据，这些数组元素控制对bitmap位图的扭曲效果 verOffset:控制verts数组中从第几个数组元素开始才对bitmap进行扭曲 前面介绍Paint时提到其包含了一个setShader(Shader)方法，该方法控制画笔的渲染效果，Shader本身是一个抽象类，它提供了如下实现类：BitmapShader(位图平铺)/LinearGradient(线性渐变)/RadialGradient(圆形渐变)/SweepGradient(角度渐变)/ComposeGradient(组合渲染) 7.4 逐帧动画逐帧(Frame)动画是最容易理解的动画，它要求开发者能把动画过程的每张静态图片都收集起来，然后由Android来控制依次显示这些静态图片，然后利用人眼视觉暂留的原理，给用户造成动画的错觉 定义逐帧动画的XML资源文件以元素作为根元素,该元素内可指定&lt;item…./&gt;子元素,并指定各个item的持续时间，将其设置为ImageView的background后,便可将item内的图片文件逐帧播放 Android完全支持在Java代码中创建逐帧动画，如果开发者喜欢，开发者完全可以先创建AnimationDrawable对象，然后调用addFrame(Drawable frame, int duration)向该动画中添加帧，每调用一次addFrame方法，就向&lt;animation-list…/&gt;元素中添加一个&lt;item…/&gt;子元素 7.5 补间动画Android除了支持逐帧动画之外，也提供了对补间动画(Tween)动画的支持，补间动画就是指开发者只需指定开始、结束关键帧，而动画变化的中间帧由系统计算并补齐 Android使用Animation代表抽象的动画类，它包括如下几个子类alphaAnimation/ScaleAnimation/TranslateAnimation/RotateAnimation，一旦为补间动画指定了3个必要信息，Android就会根据动画的开始帧、结束帧、动画持续时间计算出需要在中间补入多少帧，并计算所有补入帧的图形 Interpolator根据特定算法计算出整个动画所需要动态插入帧的密度和位置，简单的说，Interpolator负责控制动画的变化速度，这就使得基本的动画效果能以匀速、加速、减速、抛物线速度等各种速度变化 Android为Interpolator提供了如下几个实现类，分别用于实现不同动画的变化速度： LinearInterpolator：匀速改变 AccelerateInterpolator：动画开始较慢，然后加速 AccelerateDecelerateInterpolator：动画在开始和结束时慢，在中间的时候加速 CycleInterpolator：变化速度按正弦曲线改变 DecelerateInterpolator：动画开始比较快，然后减速 自定义补间动画并不难，需要继承Animation类，继承Animation时关键是要重写该抽象基类的applyTransformation(float interpolatedTime, Transform t)方法，该方法中的两个参数的说明如下： interpolatedTime：代表了动画的时间进行比例，不管动画实际的持续时间如何，当动画播放时，该参数总是自动从0变到1 Transformation：该参数代表了补间动画在不同时刻对图形或组件的变形程度 从上面的介绍可以看出，实际自定义动画的关键就在于重写applyTransformation方法时根据interpolatedTime时间来动态地计算动画对图片或视图的变形程度 7.6 使用SurfaceView实现动画虽然前面大量介绍了使用自定义View来进行绘图，但是绘图机制存在如下两个缺陷： View缺乏双缓冲机制，界面会出现闪烁 当程序需要更新View上的图像时，程序必须重绘View上显示的整张图片 SurfaceView运行在非UI线程中画图，即可自己启动一个线程来画图，不会导致UI卡顿 由于View存在上面两个缺陷，所以通过自定义View来实现绘图、尤其是游戏中的绘图时性能并不好。Android提供了一个SurfaceView来代替View，在实现游戏绘图方面，SurfaceView比View更加出色，因此一般推荐使用SurfaceView SurfaceView一般会与SurfaceHolder结合使用，SurfaceHolder用于向与之关联的SurfaceView上绘图，调用SurfaceView的getHolder()方法即可获取SurfaceView关联的SurfaceHolder。SurfaceHolder提供了如下方法来获取Canvas对象： Canvas lockCanvas():锁定整个SurfaceView对象，获取该Surface上的Canvas Canvas lockCanvas(Rect dirty):锁定SurfaceView上的Rect划分的区域，获取该Surface上的Canvas 当对同一个SurfaceView调用上面两个方法时，两个方法所返回的是同一个Canvas对象，但当程序调用第二个方法获取指定区域的Canvas时，SurfaceView将只对Rect所圈出来的区域进行更新，通过这种方式可以提高画面的更新速度。 当通过lockCanvas获取指定了SurfaceView上的Canvas之后，接下来程序就可以调用Canvas进行绘图了，Canvas绘图完成后通过如下方法来释放绘图、提交所绘制的图形unlockCanvasAndPost(canvas) 需要指出的是，当调用SurfaceHolder的unlockCanvasAndPost方法之后，该方法之前所绘制的图形还处于缓冲之中，下一次lockCanvas方法锁定的区域可能会遮挡它 可以为SurfaceHolder添加一个Callback实例，该Callback中定义了如下三个方法 void surfaceChanged(SurfaceHolder holder, int format, int width, int height) void surfaceCreated(SurfaceHolder holder) void surfaceDestroyed(SurfaceHolder holder) Android 的数据存储和IO8.1 使用SharedPreferencesSharedPreferences 保存的数据主要是类似于配置信息格式的数据，因此它保存的数据主要是简单类型的key-value对。SharedPreferences接口主要负责读取应用程序的Preferences数据，它提供了如下常用方法来访问SharedPreferences中的key-value对 boolean contains(String key):判断是否包含特定key的数据 abstract Map&lt;String, ?&gt; getAll():获取SharedPreference数据里全部的key-value对 boolean getXxx(String key, xxx defValue):获取数据里指定key对应的value，如果该key不存在，则返回默认值defValue SharedPreferences 接口本身没有提供写入数据的能力，而是通过SharedPreferences的内部接口，SharedPreferences调用edit()方法即可获取它所对应的Editor对象。Editor提供了如下方法来向SharedPreferences写入数据 SharedPreferences.Editor clear();清空SharedPreferences里所有数据 SharedPreferences.Editor putXxx(String key, xxx value);向SharedPreferences存入指定key对应的数据 SharedPreferences.Editor remove(String key);删除SharedPreferences里指定key对应的数据项 boolean commit();当Editor编辑完成后，调用该方法提交修改 SharedPreferences本身是一个接口，程序无法直接创建SharedPreferences实例，只能通过Context提供的getSharedPreferences(String name, int mode)方法来获取SharedPreferences实例，该方法的第二个参数可以指定如下几个值 Context.MODE_PRIVATE:指定该SharedPreferences数据只能被本应用程序读写Context.MODE_WORLD_READABLE:指定该SharedPreferences能被其他应用程序读，但不能写Context.MODE_WORLD_WRITEABLE:指定该SharedPreferences能被其他应用程序读、写 SharedPreferences数据总是保存在/data/data/&lt;package_name&gt;/shared_prefs目录下，SharedPreferences数据总是以XML格式保存。通过File Explorer面板的导出文件按钮将该XML文件导出到XML文档，打开该XML文档可以看到如下内容 &lt;?xml version=1.0 encoding=&apos;utf-8&apos; standalone=&apos;yes&apos; ?&gt; &lt;map&gt; &lt;int name=&quot;random&quot; value=&quot;2&quot;/&gt; &lt;string name=&quot;time&quot; value=&quot;2018年&quot;/&gt; &lt;/map&gt; 要读、写其他应用的SharedPreferences，前提是创建该SharedPreferences的应用程序指定相应的访问权限，例如指定了MODE_WORLD_READABLE，然后按照如下步骤进行： 需要创建其他应用程序对应的Context context = createPackageContext(&quot;org.crazyit.io&quot;, Context.CONTEXT_IGNORE_SECURITY) 调用其他应用程序的Context的getSharedPreferences(String name, int mode)获取相应的SharedPreferences对象 如果需要获取数据，直接getXxx(String key, xxx defValue)，如果需要写入数据，则调用SharedPreferences的edit方法 事实上，如果开发者不通过先获取其他应用程序的Context，再获取SharedPreferences的方式也可以读取SharedPreferences的数据，开发者完全可以使用以IO流的方式先读取SharedPreferences对应的XML文件，再通过XML解析来获取数据也是可行的，只是这种方式过于繁琐，而使用SharedPreferences来读取数据则简单的多 8.2 File存储读者学习JavaSE的时候都知道Java提供了一套完整的IO流体系，包括FileInputStream、FileOutputStream等，通过这些IO流可以非常方便地访问磁盘上的内容文件。Android同样支持以这种方式来访问手机存储器上的文件 本应用程序的数据文件夹总是保存在/data/data/&lt;package_name&gt;/files目录下，Context提供了如下两个方法来打开本应用程序的数据文件夹里的文件IO流 FileInputStream openFileInput(String name):打开应用程序的数据文件夹下的name文件对应输入流 FileOutputStream openFileOutput(String name, int mode):打开应用程序的数据文件夹下name文件对应输出流 上面两个方法分别用于打开文件输入流、输出流，其中第二个方法的第二个参数指定打开文件的模式，该模式支持如下值： MODE_PRIVATE:该文件只能被当前程序读写 MODE_APPEND:以追加方式打开该文件，应用程序可以向该文件中追加内容 MODE_WORLD_READABLE:该文件的内容可以被其他程序读取 MODE_WORLD_WRITEABLE:该文件的内容可以被其他程序读、写 除此之外，Context还提供了如下几个方法来访问应用程序的数据文件夹 getDir(String name, int mode):在应用程序的数据文件夹下获取或创建name对应的子目录 File getFilesDir():获取该应用程序的数据文件夹的绝对路径 String[] fileList():获取该应用程序的数据文件夹下的全部文件 deleteFile(String name):删除该应用程序的数据文件夹下的指定文件 当程序通过Context的openFileInput或openFileOutput来打开文件输入流、输出流时，程序所打开的都是应用程序的数据文件夹里的文件，这样存储的文件大小可能比较有限一点，毕竟手机内置的存储空间都是有限的。为了更好地存、取应用程序的大文件数据，应用程序需要读、写SD卡上的文件。SD卡大大扩充手机的存储能力。读、写SD卡上的文件请按照如下步骤进行： 调用Environment的getExternalStorageState()方法判断手机上是否插入了SD卡，并且应用程序具有读写SD卡的权限Environment.getExternalStorageState().equals(Environment.MEDIA_MOUTED) 调用Environment的getExternalStorageDirectory()方法来获取外部的存储器，也就是SD卡的目录 使用FileInputStream、FileOutputStream、FileReader或FileWriter读写SD卡里的文件 应用程序读、写SD卡的文件有如下两个注意点： 手机上应该已插入SD卡，对应模拟器来说，可通过mksdcard命令来创建虚拟存储卡 为了读、写SD卡上的数据，必须在应用程序的清单文件(AndroidManifest.xml)中添加读、写SD卡的权限&lt;use-permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot;&gt; &lt;use-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;&gt; 8.3 SQLite数据库Android系统集成了一个轻量级的数据库：SQLite，SQLite并不想成为像Oracle、MySQL那样的专业数据库。SQLite只是一个嵌入式的数据库引擎，专门适用于资源有限的设备上适量数据存取。虽然SQLite支持绝大部分SQL 92语法，也允许开发者使用SQL语句操作数据库的数据，但SQLite并不像Oracle、MySQL数据库那样需要安装、启动服务器进程、SQLite数据库只是一个文件 Android提供了SQLiteDatabase代表一个数据库(底层就是一个数据库文件)，一旦应用程序获得了代表指定数据库的SQLiteDatabase对象，接下来就可通过SQLiteDatabase对象来管理操作数据库了，SQLiteDatabase提供了如下静态方法来打开一个文件对应的数据库 static SQLiteDatabase openDatabase(String path, SQLiteDatabase.CursorFactory factory, int flags) static SQLiteDatabase openOrCreateDatabase(File file, SQLiteDatabase.CursorFactory factory) static SQLiteDatabase openOrCreateDatabase(String path, SQLiteDatabase.CursorFactory factory) 在程序中获取SQLiteDatabase对象之后，接下来就可以调用SQLiteDatabase的如下方法来操作数据库了execSQL/insert/update/delete/query/rawQuery/beginTransaction/endTransaction 查询数据的方法都是返回一个Cursor对象，Android中的Cursor类似于JDBC的ResultSet，同样提供了一些方法来移动查询结果的记录指针move/moveToFirst/moveToLast/moveToNext/moveToPosition/moveToPrevious，一旦将记录指针移动到指定行之后，接下来就可以调用Cursor的getXxx()方法获得该行的指定列的数据 总结起来，使用SQLiteDatabase进行数据库操作的步骤如下 获取SQLiteDatabase对象，它代表了与数据库的连接 调用SQLiteDatabase的方法来执行SQL语句 操作SQL语句的执行结果，比如遍历查询结果 Cursor 关闭SQLiteDatabase，回收资源 在Android SDK的tools目录下提供了一个sqlite3.exe工具，它是一个简单的SQLite数据库管理工具，类似于MySQL提供的命令行窗口，有些时候，开发者利用该工具来查询、管理数据库 sqlite3 f:/my.db3 最先指定操作哪个数据库 .databases: 查看当前数据库的信息 .tables: 查看当前数据库中的数据表 .help:查看sqlite3支持的命令 需要指出的是，SQLite内部只支持NULL、Integer、REAL(浮点数)、TEXT(文本)、和BLOB(大二进制对象)这五种数据类型，但它允许把各种类型的数据保存到任何类型字段中，开发者可以不用关心声明该字段所使用的数据类型。 如果开发者对于SQL语法不熟悉，甚至以前从未使用过任何数据库，Android的SQLiteDatabase提供了insert、update、delete或者query语句来操作数据库，具体的介绍见书本 SQLiteDatabase中包含如下两个方法来控制事务 beginTransaction(): endTransaction(): 除此之外，SQLiteDatabase还提供了如下方法来判断当前上下文是否处于事务环境中 inTransaction(): 当程序执行endTransaction()方法时将会结束事务—那到底是提交事务呢，还是回滚事务呢，这取决于SQLiteDatabase是否调用了setTransactionSuccessful()方法来设置事务标志，如果设置了，则提交事务，否则程序将会回滚事务。 SQLiteOpenHelper是Android提供的一个管理数据库的工具类，可用于管理数据库的创建和版本更新。一般的用法是创建SQLiteOpenHelper的子类，并扩展它的onCreate(SQLiteDatabase db)和onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)方法 SQLiteOpenHelper包含如下常用的方法： Constructor SQLiteOpenHelper(Context context, String name, int version):SQLiteOpenHelper的构造函数 synchronized SQLiteDatabase getReadableDatabase():以读、写的方式打开数据库对应的SQLiteDatabase对象 synchronized SQLiteDatabase getWritableDatabase():以写的方式打开数据库对应的SQLiteDatabase对象 abstract void onCreate(SQLiteDatabase db):当第一次创建数据库时回调该方法 abstract void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion):当数据库版本更新时回调该方法 synchronized void close():关闭所有打开的SQLiteDatabase 8.4 手势(Gesture)Android手势行为分为两种： 第一种手势是系统默认手势行为，Android为其提供了相应的监听器 第二种手势是系统没有的手势，Android允许开发者添加手势，并提供相应的API识别用户手势 Android为手势检测提供了一个GestureDetector类，GestureDetector实例代表了一个手势检测器，创建GestureDetector时需要传入一个GestureDetector.OnGestureListener实例，GestureDetector.OnGestureListener就是一个监听器，负责对用户的手势行为提供响应 GestureDetector.OnGestureListener里包含的事件处理方法如下： boolean onDown(MotionEvent e):当触碰事件按下时触发该方法 boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY)：当用户在触摸屏上“拖过”时触发该方法，其中velocityX、velocityY分别表示动作的速度 abstract void onLongPress(MotionEvent e)：当用户在屏幕上长按时触发该方法 boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY)：当用户在屏幕上“滚动”时触发该方法 void onShowPress(MotionEvent e)：当用户在触摸屏上按下、而且还未移动和松开时触发该方法 boolean onSingleTapUp(MotionEvent e)：当用户在触摸屏上的轻击事件将会触发该方法 使用Android的手势检测只需要两个步骤： 创建一个GestureDetector对象，创建该对象必须实现一个GestureDetector.OnGestureListener监听器实例 为应用程序的Activity(偶尔也可为特定组件)的TouchEvent事件绑定监听器，在事件处理中指定把Activity(或特定组件)上的TouchEvent事件就会交给GestureDetector处理，而GestureDetector就会检测是否触发了特定的手势动作 public class GestureDetectorTest extends Activity implements OnGestureListener { private GestureDetector detector; public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); detector = new GestureDetector(this); } public boolean onTouchEvent(MotionEvent e) { return detector.onTouchEvent(e); } public boolean onDown(MotionEvent e) {} ... } Android除了提供了手势检测以外，还允许应用程序把用户手势（多个持续的触摸事件在屏幕上形成特定形状）添加到指定文件中，以备以后使用，如果程序需要，当用户下次再次画出该手势时，系统将可识别该手势。Android使用GestureLibrary来代表手势库，并提供了GestureLibraries工具类来创建手势库，GestureLibraries提供了如下4个静态方法从不同位置加载手势库 static GestureLibrary fromFile(String path): static GestureLibrary fromFile(File path): static GestureLibrary fromPrivateFile(Context context, String name): static GestureLibrary fromRawResource(Context context, int resourceId) 一旦在程序中获得了GestureLibrary对象之后，该对象提供了如下方法来添加手势、识别手势 void addGesture(String entryName, Gesture gesture): Set getGestures(String entryName): ArrayList getGestures(String entryName): ArrayList recognize(Gesture gesture): void removeEntry(String entryName): void removeGesture(String entryName, Gesture gesture): boolean save(): GestureLibrary提供了recognize(Gesture gesture)方法来识别手势，该方法会返回该手势库中所有与ges匹配的手势，它的返回值为ArrayList，其中Prediction封装了手势的匹配信息，Prediction对象的name属性代表了匹配的手势名，score属性代表了手势的相似度。 &lt;android.getsture.GestureOverlayView android:id=&quot;@+id/gesture&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:gestureStrokeType=&quot;multiple&quot; /&gt;//该参数控制手势是否需要多笔完成 public class AddGesture extends Activity { private EditText editText; private GestureOverlayView gestureView; public void onCreate(Bundle savedInstanceState) { //super...bindView... //保存Gesture gestureView.addGesturePerformedListener( new OnGesturePerformedListener() { @override public void onGesturePerformed(GestureOverlayView overlay, final Gesture gesture) { GestureLibrary gestureLib = GestureLibraries.fromFile(&quot;/mnt/sdcard/geture&quot;); gestureLib.addGesture(editText.getText().toString(), gesture); gestureLib.save(); } } ); //识别Gesture GestureLibrary gestureLib = GestureLibraries.fromFile(&quot;/mnt/sdcard/geture&quot;); gestureLib.load(); gestureView.addGesturePerformedListener( new OnGesturePerformedListener() { @override public void onGesturePerformed(GestureOverlayView overlay, final Gesture gesture) { ArrayList&lt;Prediction&gt; predictions = gestureLibrary.recognize(gesture); for (Prediction pred : predictions) { if (pred.score &gt; 2.0) { print(&quot;此 pred 满足要求&quot;); } } } } ); } } 自动朗读TTSAndroid提供了自动朗读支持。自动朗读支持可以对指定文本内容进行朗读，从而发出声音；不仅如此，Android的自动朗读支持还允许把文本对应的音频录制成音频文件，方便以后播放。这种自动朗读支持的英文名称为TextToSpeech，简称TTS。Android的自动朗读支持主要通过TextToSpeech来完成，该类提供了如下一个构造器： TextToSpeech(Context context, TextToSpeech.OnInitListener listener) public class Speech extends Activity { TextToSpeech tts; public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); tts = new TextToSpeech(this, new OnInitListener( @override public void onInit(int status) { if (status == TextToSpeech.SUCCESS) { int reslut = tts.setLanguage(Locale.US); if (result != TextToSpeech.LANG_COUNTRY_AVAILABLE &amp;&amp; reslut != TextToSpeech.LANG_AVAILABLE) { print(&quot;TTS暂时不支持这种语言的朗读&quot;); } } } )); button1.onclick( //播放转换的音频，参数TextToSpeech.QUEUE_ADD表示添加到发音任务队列，还有一个值TextToSpeech.QUEUE_FLUSH则表示会中断当前的发音任务队列 tts.speak(editText.getText.toString(), TextToSpeech.QUEUE_ADD, null); ); button2.onclick( //保存转换的音频 tts.synthesizeToFile(editText.getText.toString(), null, &quot;/mnt/sdcard/sound.wav&quot;) ); } //最后关闭TTS，回收资源 public void onDestroy() { if (tts != null) { tts.shutdown(); tts = null; } } }]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[疯狂Android第一部分]]></title>
    <url>%2F2012%2F08%2F30%2F%E7%96%AF%E7%8B%82Android%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[Android应用与开发环境1.1 Android的发展和简介Android系统的底层建立在Linux系统之上，该平台由操作系统、中间件、用户界面和应用软件四层构成，它采用一种被称为软件叠层的方式进行构建。这种软件叠层结构使得层与层之间相互分离，明确各层的分工。更加具体的层叠构造内容请参考上一章的介绍。 1.2 搭建Android环境安装ADT后，在Android SDK的文件夹下主要有这么几个文件夹： add-ons：该目录下存放额外的附件软件 build-tools:该目录下存放每个版本编译apk时所需要的工具 platforms：该目录下存放不同版本的Android版本 tools：该目录存放了大量的Android开发调试工具 docs：该文件夹下存放了Android SDK开发文件的API文档等 platform-tools：该文件夹下存放了Android平台相关工具 samples：该文件夹下存放了不同Android平台的示例程序 1.3 Android常用开发工具的用法android命令位于tools目录下，如果配置了环境变量，就可以在命令行下直接输入android命令，常用的有： list: 列出机器上所有已经安装的Android版本和AVD设备 list avd: 列出机器上所有已经安装的AVD设备 list target: 列出机器上所有已经安装的Android版本 create/move/delete/update avd: 创建/移动/删除/升价一个AVD create/update project: 创建/升级一个Android项目 emulator命令位于tools目录下，如果配置了环境变量，就可以在命令行下直接输入emulator命令打开虚拟机，常用的有： -avd crazyit: 运行名称为crazyit的AVD设备 -data myfile: 以myfile作为镜像文件来运行AVD设备 DDMS是Android提供的一个非常强大的调试环境，它的全称是Dalvik Debug Monitor Service，DDMS命令位于tools目录下，如果配置了环境变量，就可以在命令行下直接输入ddms命令看到其强大的调试窗口Android Debug Bridge(ADB)是一个功能非常强大的工具，它位于Android SDK安装目录的platform-tools子目录下，ADB工具既可完成模拟器文件与电脑文件的相互复制，也可安装APK应用，甚至直接切换到Android系统中执行Linux命令。 adb -devices: 查看当前运行的模拟器 adb push d:/abc.txt /sdcard/ 电脑与模拟器之间的相互复制 adb pull /sdcard/xyz.txt d:/ 电脑与模拟器之间的相互复制 adb shell：Android平台的内核是基于Linux的，有时希望直接打开Android平台的shell窗口，这样就可以在该窗口执行一些常用的Linux命令，如ls，mkdir，rm等 adb install text.apk/adb uninstall com.frand.text 安装/卸载应用程序 Dalvik虚拟机并不直接运行java二进制文件，而是运行它特有的.dex文件，因此我们需要通过DX工具将Android应用中的.class文件转换为.dex文件，dx命令存放于build-tools文件夹下对应的平台文件夹下dx --dex [--dump-to=&lt;file&gt;] [--core-libraray] [&lt;file&gt;.class|&lt;file&gt;.{zip,jar,apk} | &lt;directory&gt;] [–dump-to=]指定生成的.dex文件的文件名 [–core-libraray]后是指定需要转换的.class .zip .jar文件或目录 使用Android Asset Packaging Tool(AAPT)打包资源aapt -A &lt;附件资源路径&gt; -S &lt;资源路径&gt; -M &lt;Android应用清单文件&gt; -I &lt;额外添加的包&gt; And -F &lt;目标文件的路径&gt; aapt -A assets -S res -M AndroidManifest.xml -I D:\android-sdk-windows\platforms\android-9\atforms\android-9\android.jar -F bin\res.ap_ 用apkBuilder打包资源res.ap_和dex文件组成*.apk文件 手动编译APK的流程如下： 生成资源文件：使用Android SDK提供的aapt.exe生成R.java类文件 编译本地库：使用Android SDK提供的aidl.exe把.aidl转成.java文件（如果没有aidl，则跳过这一步） 编译java代码：使用JDK提供的javac.exe编译.java类文件生成class文件 生成dex文件：使用Android SDK提供的dx.bat命令行脚本生成classes.dex文件 打包资源文件：使用Android SDK提供的aapt.exe生成资源包.ap_文件（包括res、assets、androidmanifest.xml等） 生成apk文件：使用Android SDK提供的apkbuilder.bat将.ap_文件与.dex文件合成生成未签名的apk安装文件 对apk文件进行签名：使用jdk的jarsigner.exe对未签名的包进行apk签名 1.4 开始第一个Android应用1.5 Android应用工程结构分析1.6 Android应用的基本组件介绍Activity是Android应用中负责与用户交互的组件，View组件是所有UI控件，容器控件的基类，View组件就是用户实实在在看到的部分。但是View组件需要放到容器组件中，或者使用Activity将它显示出来。 Service与Activity的地位是并列的，它也代表一个单独的Android组件。Service与Activity的区别在于：Service通常位于后台运行，它一般不需要与用户交互，因此Service组件没有图形用户界面。与Activity组件需要继承Activity基类相似，Service组件需要继承Service基类。一个Service组件被运行起来后，它将拥有独立的生命周期，Service组件通常用于为其他组件提供后台服务或监控其他组件的运行状态。 BroadcastReceiver是Android应用中另一个重要的组件，顾名思义，BroadcastReceiver代表广播消息接收器。从代码实现的角度来看，BroadcastReceiver非常类似编程中的监听器。与普通事件监听器不同的是：普通事件监听器监听的事件源是程序中的对象；而BroadcastReceiver监听的事件源是Android应用中的其他组件。 对于Android应用而言，它们必须相互独立，各自运行在自己的Dalvik虚拟机实例中，如果这些Android应用之间需要实现实时的数据交换，这时Android系统为其提供了一个标准：ContentProvider。 Intent是Android应用内不同组件之间通信的载体，它封装了当前组件需要启动或触发的目标组件信息。当一个组件通过Intent表示了启动或触发另一个组件的意图后，这个意图可分为两类 显式Intent：明确指定需要启动或者触发的组件的类名 隐式Intent：只是指定需要启动或者触发组件应满足怎样的条件 Android系统如何判断被调用组件是否满足隐式Intent呢，这就需要靠IntentFilter来实现了，被调用组件可通过IntentFilter来声明自己所满足的条件–也就是声明自己到底能处理哪些隐式Intent。 Android应用的界面编程2.1 界面编程与视图(View)组件Android界面组件分为视图组件与容器组件。可以用代码控制UI界面，也可以使用XML布局文件控制UI界面 2.2 布局管理器布局管理器包括： 线性布局LinearLayout 表格布局TableLayout 帧布局FrameLayout 相对布局RelativeLayout 绝对布局AbsoluteLayout 2.3 基本界面组件此章学习的基本界面组件包括： 文本框（TextView）与编辑框（EditText）的功能和用法 按钮（Button）与图片按钮（ImageButton）组件的功能和用法 单选按钮（RadioButton）和复选框（CheckBox）介绍与应用 状态开关按钮（ToggleButton）的功能与用法 模拟时钟和数字时钟（AnalogClock和DigitalClock）的功能和用法 图像视图（ImageView）的功能和用法 scaleType属性设置所显示的图片如何缩放或移动来适应ImageView的大小，其中包括了几个属性：matrix/fitXY/fitStart/fitCenter/fitEnd/center/centerCrop/centerInside 八个ScaleType，其实可以分为三个类型： 以FIT_开头的4种，它们的共同点是都会对图片进行缩放； 以CENTER_开头的3种，它们的共同点是居中显示，图片的中心点会与ImageView的中心点重叠； ScaleType.MATRIX，这种就直接翻到最后看内容吧； 2.4 高级界面组件 自动完成文本框（AutoCompleteTextView）的功能和用法 下拉框（Spinner）的功能和用法 日期、时间选择器（DatePicker和TimePicker）的功能和用法 进度条（ProgressBar）的功能和用法 拖动条（seekBar）的功能和用法 星级评分条（RatingBar）的功能和用法 选项卡（TabHost）的功能和用法 滚动视图（ScrollView）的功能和用法 列表视图（ListView和ListActivity） 可展开的列表组件（ExpandableListView） 网格视图（GridView）和图像切换器（ImageSwitcher） 画廊视图（Gallery）的功能和用法 2.5 对话框Android提供了丰富的对话框支持，它提供了如下4种常用的对话框： AlertDialog ProgressDialog DatePickerDialog TimePickerDialog PopupWindow 2.6 消息提示 使用Toast显示提示信息框 Notification的功能与用法 2.7 菜单 选项菜单和子菜单 使用监听器来监听菜单事件 创建复选框菜单和单选菜单项 设置与菜单项关联的Activity 上下文菜单 事件处理3.1 Android的事件处理Android提供了强大的事件处理机制，包括两套事件处理机制： 基于监听的事件处理机制 基于回调的事件处理机制 3.2 基于监听的事件处理机制在事件监听的处理模型中，主要涉及如下三类对象： Event Source(事件源)：事件发生的场所，如按钮，窗口等 Event(事件)：事件封装了界面组件上发生的特定事情 Event Listener(事件监听器)：负责监听事件源所发生的事件，并对事件做出相应的相应 Android的事件处理机制是一种委派式(Delegation)事件处理方式：普通组件(事件源)将整个事件处理委托给特定的对象(事件监听器)，当该事件源发生指定的事件时，就通知所委托的事件监听器，由事件监听器来处理这个事件 所谓的事件监听器，其实就是实现了特定接口的Java类的实例。在程序中实现事件监听器，通常有如下几种形式： 内部类形式 外部类形式 Activity本身作为事件监听器类 匿名内部类 直接绑定到标签(android:onClick=””) 3.3 基于回调的事件处理基于回调的事件处理机制要通过自定义View来实现，自定义View时重写该View的事件处理方法即可 对于基于监听的事件处理模型来说，事件源和事件监听器是分离的，当事件源上发生特定事件后，该事件交给事件监听器负责处理；对于基于回调的事件处理模型来说，事件源和监听器是统一的，当事件源发生特定事件之后，该事件还是由事件源本身负责 几乎所有基于回调的事件处理方法都有一个boolean类型的返回值，该返回值用于标识该处理方法是否能完全处理该事件： 如果处理事件的回调方法返回true，表明该处理方法已完全处理该事件，该事件不会传播出去 如果处理事件的回调方法返回false，表明该处理方法并未完全处理该事件，该事件会传播出去 当组件上触发一个事件时，Android系统最先触发的应该是该按键上绑定的事件监听器，接着才触发该组件提供的事件回调方法，然后还会传播到该组件所在的Activity—但是如果我们让任何一个事件处理方法返回了true，那么该事件将不会继续向外传播 对比Android提供的两种事件处理方式，不难发现基于监听的事件方式具有更大优势： 基于监听的事件模型分工更明确，事件源，事件监听由两个类分开实现，因此具有更好的可维护性 Android的事件处理机制保证基于监听的事件监听器会被优先触发 3.4 响应系统设置事件Configuration类专门用于描述手机设备上的配置信息，这些配置信息既包括用户特定的配置项，也包括系统的动态设备配置。Configuration cfg = getResources().getConfiguration(); 如果程序需要监听系统设置的更改，则可以考虑重写Activity的onConfigurationChanged(Configuration cgf)方法，该方法是一个基于回调的事件处理方法：当系统设置发生更改时，该方法会被自动触发。 3.5 Handler消息传递机制Android的消息传递机制是另一种形式的“事件处理”，这种机制主要是为了解决Android应用的多线程为题—Android平台不允许Activity新启动的线程访问该Activity里的界面组件，这样就会导致新启动的线程无法动态改变界面组件的属性值。Handler类的主要作用有两个： 在新启动的线程中发送消息 在主线程中获取，处理消息 深入理解ActivityActivity是Android应用的重要组成单位之一（另外三个是Service、BroadcastReceiver和ContentProvider），而Activity又是Android应用最常见的组件之一 4.1 建立、配置和使用Activity继承方式：Activity--ContextThemeWrapper--ContextWrapper--Context 配置方式：AndroidManifest中：&lt;activity android:name=&quot;.SampleActivity&quot;/&gt; 启动方式：startActivity(intent)/startActivityForResult(intent,requestCode) 关闭方式：finish()/finishActivity(requestCode) 传递数据：putExtras(Bundle data)/putXxx(String key, Xxx data)/putSerializable(String key, Serializable data) 4.2 Activity的回调机制对于Java的程序员来说，程序架构在某个点上留的空，可以以如下两种方式存在： 以接口形式存在：该接口由开发者实现，实现该接口时将会实现该接口的方法，那么通用的程序架构就会回调该方法来完成业务的相关处理 以抽象方法的形式存在：这就是Activity的实现形式 4.3 Activity的生命周期归纳起来Activity大致会经过如下4个状态： 活动状态 暂停状态 停止状态 销毁状态 在这四个状态之间进行切换的时候，如下方法会被系统回调： onCreate(Bundle savedStatus)/onStart()/onRestart()/onResume()/onPause()/onStop()/onDestroy() onRestart先于onStart调用]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发入门]]></title>
    <url>%2F2012%2F07%2F27%2FAndroid%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[做Android开发已有月余，今天将此前学到的东西整理一下，包括Android开发环境的简介、Android系统架构的详解、Android开发环境的搭建 Android开发环境Android开发环境从底层到上层分别有硬件层、操作体统、JAVA运行环境、开发工具和模拟器的安装 硬件首先，最底层到应该是硬件到部分，CPU，内存，主板，硬盘等。 cat /proc/cpuinfo :CPU用到的是Pentium(R) Dual-Core CPU E5200 @ 2.50GHz cat /proc/meminfo :内存到总大小MemTotal: 2041792 kB 操作系统然后往上层走就是操作系统了，操作系统用的是ubuntu操作系统，linux的一种 cat /proc/version:Linux version 3.2.0-26-generic (buildd@batsu) (gcc version 4.6.3 (Ubuntu/Linaro 4.6.3-1ubuntu5) ) #41-Ubuntu SMP Thu Jun 14 17:49:24 UTC 2012 Ubuntu 3.2.0-26.41-generic 3.2.19 cat /etc/issue :frandfeng@frandfeng-Founder-PC:~$ cat /etc/issue Ubuntu 12.04 LTS \n \l 从这里可以看出用到的ubuntu版本是12.04LTS。Ubuntu诞生于2012年4月26日，是第四个ubuntu长期支持版本，可以运用到2017年，LTS是指Long-Term Support，即长期支持版本。 linux系列中ubuntu操作系统只是其中一种，Ubuntu是一个以桌面应用为主的linux操作系统。Ubuntu基于Debian发行版和GNOME桌面环境，与Debian的不同在于它每6个月会发布一个新版本。Ubuntu的目标在于为一般用户提供一个最新的、同时又相当稳定的主要由自由软件构建而成的操作系统。GNOME即GNU网络对象模型环境 (The GNU Network Object Model Environment)，GNU计划的一部分，开放源码运动的一个重要组成部分。是一种让使用者容易操作和设定电脑环境的工具。 当然，linux系列中到操作系统不仅Ubuntu，还有Debian、RedHat、Slackware等。 JAVA运行环境操作系统装好了之后就应该装JAVA运行环境了，即JDK的安装，JDK(Java Development Kit)是Sun Microsystems针对Java开发员的产品。自从Java推出以来，JDK已经成为使用最广泛的Java SDK。JDK 是整个Java的核心，包括了Java运行环境，Java工具和Java基础的类库，我们装到JDK是Java SE1.6，即Java standard edition，标准版，还有Java EE，enterprise edition，企业版和Java ME，micro edition，主要用于移动设备、嵌入式设备上的java应用程序。 开发工具JAVA运行环境下来就应该再装基于JAVA的IDE了，即Eclipse，IDE(Integrated Development Environment,集成开发环境)。IDE集成开发环境（简称IDE）软件是用于程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形工具界面工具。该程序可以独立运行，也可以和其它程序并用Eclipse 是一个开放源代码的、基于Java的可扩展开发平台。就其本身而言，它只是一个框架和一组服务，用于通过插件组件构建开发环境。幸运的是，Eclipse 附带了一个标准的插件集，包括Java开发工具（Java Development Kit，JDK）。 虽然大多数用户很乐于将 Eclipse 当作 Java 集成开发环境（IDE）来使用，但 Eclipse 的目标却不仅限于此。Eclipse 还包括插件开发环境（Plug-in Development Environment，PDE），这个组件主要针对希望扩展 Eclipse 的软件开发人员，因为它允许他们构建与 Eclipse 环境无缝集成的工具。 Eclipse的设计思想是：一切皆插件。Eclipse核心很小，其它所有功能都以插件的形式附加于Eclipse核心之上。Eclipse基本内核包括：图形API (SWT/Jface)， Java开发环境插件(JDT )，插件开发环境(PDE)等。 我们装到Eclipse版本是Version: Juno Release版的，除过这个版本，还有Eclipse Indigo -&gt;3.7/Eclipse Helios -&gt;3.6/Eclipse Galileo -&gt;3.5/Eclipse Ganymede -&gt;3.4/Eclipse Europa -&gt;3.3。 IDE装好了JAVA的库和运行环境到此结束，开始装有关Android的开发工具和Android运行环境了。 Android模拟器首先装Android运行环境，为了开发android应用，还必须添加一个android操作系统，用于模拟器模拟你的应用程序。当然还有一些其他部件需要安装。其实就是通过SDK 工具包中的Android SDK and AVD Manager来完成。Android SDK 指的既是Android专属的软件开发工具包。AVD的全称为：Android Virtual Device，就是Android运行的虚拟设备，他是Android的模拟器识别。建立的Android要运行，必须创建AVD，每个AVD上可以配置很多的运行项目。我们常用到的AVD版本有1.6/2.2/4.0/4.1. 然后就是Android的开发工具安装了。这个开发工具主要靠Eclipse中到ADT（Android Development Tools）来管理，下载ADT Plugin，Eclipse会自动进行配置和更新。 到此为止，所有到框架都搭建完成。然后就可以进行基于Android平台的开发了。 Android系统架构Android系统架构从底层到上层共分为四层，每一层都是将底层实现封装，留一些接口供上层调用。架构如图所示： Linux Kernel由上图中可以看出，Android系统最底层是LINUX KERNEL,即linux内核，他是硬件与软件之间的抽象层，包括显示驱动，相机驱动，内存驱动，进程通讯驱动，键盘驱动，wifi启动，多媒体驱动和电源驱动等。 Libraries And Android Runtime中间件包括两部分：函数库和运行时(libraries &amp; Android runtime) 函数库包括 SurfaceManager 显示系统管理库，负责把2D或3D内容显示到屏幕的库； Media Framework 媒体库，负责支持图像，支持多种视频和音频的录制和回放； SQlite 数据库，一个功能强大的轻量级嵌入式关系数据库； OpenGL ES(open graphic libaray for embed system),针对嵌入式系统的开放式图形库，主要负责三维图形的显示 FreeType库,一个完全免费(开源)的、高质量的且可移植的字体引擎，它提供统一的接口来访问多种字体格式文件 WebKit 浏览器引擎 SGL，SSL，“Secure Sockets Layer”安全套阶层，还有一些基本的C库等。 Android 运行时由两部分组成:Android核心库和Dalvik虚拟机.其中核心库提供了Java语言核心库所能使用的绝大部分功能,而虚拟机则负责运行Android运行程序. 此处的ARE和JRE有点类似.JRE包括JVM和其他功能函数库,而此处的Android运行时则包括Dalvik虚拟机和核心库集. 由于Android应用程序的编程语言是Java,因此有些人会把Dalvik虚拟机和JVM搞混,但实际上Dalvik并未遵守JVM规范,两者也不兼容.实际上,JVM虚拟机运行的是Java字节码(通常就是.class文件),但Dalvik运行的是其专有的dex(Dalvik Executable)文件.JVM直接从.class文件或JAR包中加载字节码然后运行;而Dalvik则无法直接从.class文件或jar包中加载字节码,它需要通过DX工具将应用程序的所有.class文件编译成.dex文件,Dalvik运行该.dex文件.还有一点,Dalvik虚拟机中,每一个Android 应用程序都在它自己的进程中运行，都有一个属于自己的Dalvik 虚拟机，这一点可以让系统在运行时可以达到优化，程序间的影响大大降低。 Dalvik虚拟机非常适合在移动端上使用,相对于在PC或服务器上运行的虚拟机而言,Dalvik虚拟机不需要很快的CPU计算速度和大量的内存空间,它主要有两个特点 运行专有的.dex文件.专有的.dex文件减少了.class文件中的冗余信息,而且会把所有的.class文件整合到一个文件中,从而提高运行性能;而且DX工具还会对.dex文件进行一些性能的优化. 基于寄存器实现.大多数虚拟机包括JVM都是基于栈的,而Dalvik虚拟机则是基于寄存器的.一般来说,基于寄存器的虚拟机具有更好的性能表现,但在硬件通用性上略差. 应用程序框架(Application Framework) 丰富而又可扩展性的视图（Views），可以用来构建应用程序， 它包括列表（lists），网格（grids）， 文本框（text boxes），按钮（ buttons）， 可嵌入的web 浏览器。 内容提供者（Content Providers）使得应用程序可以访问另一个应用程序的数据（如联系人数据库）， 或者共享它们自己的数据。 资源管理器（Resource Manager）提供非代码资源的访问，如本地字符串，图形，和布局文件（ layoutfiles ）。 通知管理器（Notification Manager） 使得应用程序可以在状态栏中显示自定义的提示信息。 活动管理器（ Activity Manager） 用来管理应用程序生命周期并提供常用的导航回退功能。 应用程序 (Applications)Android 系统会内置一些应用程序包包括email 客户端，SMS 短消息程序，日历，地图，浏览器，联系人管理程序等。所有的应用程序都是使用JAVA 语言编写的。，还可以使用自己的程序或者在网上下载到的程序。 Android开发环境的搭建Android开发环境的搭建包括安装JDK、安装eclipse、下载安装Android SDK Starter Package、安装ADT（Android Development Tools）插件、配置ADT插件(将ADT用来管理Android SDK Starter Package)、添加Android操作系统和部件，最后写一个Hello World。 安装JDKJDK(Java Development Kit)是Sun Microsystems针对Java开发员的产品。自从Java推出以来，JDK已经成为使用最广泛的Java SDK。JDK 是整个Java的核心，包括了Java运行环境，Java工具和Java基础的类库。JDK是学好Java的第一步。 首先到oracle的官网上下载linux版本的JDK。 下载回来之后，当然是直接运行安装即可.先把这个文件cp到你的安装目录下，然后在你的安装目录直接执行：./jdk-6u33-linux-i586.bin(当然如果执行失败是因为没有执行权限，那么还需要加上执行权限：chmod +x ./jdk-6u26-linux-i586.bin) 安装程序会自动给你安装到当前目录的jdk1.6.0_26目录下。 程序安装好了，接着需要设置环境变量。 执行： sudo gedit /etc/profile 在配置文件中加入如下部分： export JAVA_HOME=/home/jackwong/jdk1.6.0_26 export JRE_HOME=/home/jackwong/jdk1.6.0_26/jre export PATH=/home/jackwong/jdk1.6.0_26/bin:$PATH export CLASSPATH=.:/home/jackwong/jdk1.6.0_26/lib:/home/jackwong/jdk1.6.0_26/jre/lib 保存，然后注销当前用户，重新登录，环境变量就生效了。 验证是否安装成功： 执行： java -version 如果出现: java version “1.6.0_26”Java(TM) SE Runtime Environment (build 1.6.0_26-b06)Java HotSpot(TM) Server VM (build 20.0-b11, mixed mode) 这样的信息，就说明OK了。 注意，ubuntu默认已经安装了openjdk，所以你就算不安装jdk，执行java -version也不会报错，但是报告的信息和安装了jdk是不一样的，请注意区分。 安装eclipseEclipse 是一个开放源代码的、基于Java的可扩展开发平台。就其本身而言，它只是一个框架和一组服务，用于通过插件组件构建开发环境。幸运的是，Eclipse 附带了一个标准的插件集，包括Java开发工具（Java Development Kit，JDK）。 Eclipse的设计思想是：一切皆插件。Eclipse核心很小，其它所有功能都以插件的形式附加于Eclipse核心之上。Eclipse基本内核包括：图形API (SWT/Jface)， Java开发环境插件(JDT )，插件开发环境(PDE)等。 Eclipse IDE for Java Developers下载，解压：tar zvxf eclipse-java-helios-SR1-linux-gtk.tar.gz 下载安装Android SDK Starter Package针对Android平台到软件开发包，里边有各种类，各种插件，还有Android到模拟器。 Android SDK Starter Package这个只是SDK的核心基本工具，有了它，再利用它的管理工具下载其他你需要到部分。看到这个目录中有个android脚本文件了吗？执行它，就会启动Android SDK and AVD Manager,这个工具可以帮你下载其他你需要的部分，还可以创建模拟机。 下载地址是：http://developer.android.com/sdk/index.html 下载下来到文件是：android-sdk_r11-linux_x86.tgz，大约26M。 接下来当然是解包了：tar zvxf android-sdk_r11-linux_x86.tgz 解包完毕，就会在当前目录下出现android-sdk-linux_x86目录了。这个目录下就是sdk的基本工具了。记住这个目录，因为以后你运行工具或者设置ADT的时候，会需要这个目录的！ 安装ADT（AndroidDevelopment Tools）插件目前Android开发所用的开发工具是Eclipse，在Eclipse编译IDE环境中，安装ADT，为Android开发提供开发工具的升级或者变更，简单理解为在Eclipse下开发工具的升级下载工具。 启动 Eclipse, 然后选择 Help&gt; Install NewSoftware…. 单击右上角的Add按钮 在弹出的 Add Repository 对话框中，Name一栏目填写 “ADT Plugin”,在Location一栏就有两个选择，一个是填入下载网址：https://dl-ssl.google.com/android/eclipse/，这样就可以网上下载安装。第二个选择是如果我已经下载了ADT Plugin，那么就单击旁边的Archive按钮，直接找到插件所在到包即可，比如我用的就是第二种，我已经下载下来了，文件名是ADT-11.0.0.zip,5.3M。不管那一种，最后选择OK，即可。 然后在下面的软件列表中，把Developer SDK Tools前面的checkbox选上，然后单击下面的next按钮，然后就等着安装进度条完成吧，其中会出现安装软件的列表，你单击Next即可，然后会出现license,你必须选择agree才行，然后单击finish就完成了（当然其中有个下载过程，可能需要花费一点时间)。安装完成之后，重启eclipse即可 配置ADT 插件配置的内容就是要修改在eclipse中到ADT插件的引用指向，需要指向前面安装好的Android SDK目录，还记得这个目录吗？ 启动eclipse,选择Window&gt; Preferences.. 在弹出的Preferences对话框中左边选择Android标签，右边SDK location选择你当初Android SDK的目录即可。比如我到目录是：/home/jackwong/android-sdk-linux_x86，然后单击apply,再单击ok即可。 在这个过程中会弹出一个对话框问你是否要参加google的满意度调查报告。你可以选择参加还是不参加。单击process按钮即可。 安装好之后，你可以常用Help&gt; Check for Updates选项来保持ADT保持最新。 添加Android操作系统和部件到目前为止，基本配置都差不多了，但是为了开发android应用，还必须添加一个android操作系统，用于模拟器模拟你的应用程序。当然还有一些其他部件需要安装。其实就是通过SDK 工具包中的Android SDK and AVD Manager来完成。当然在eclipse中可以直接启动这个程序：Window &gt; Android SDK and AVD Manager. 当然也可以直接运行sdk目录下的tools目录下的android脚本来启动。 推荐的部件一般是： SDK Tools，这个你安装了sdk starter package实际上已经装好了。 SDK Platform-tools，这个要装。 SDK platform，这个至少需要一个。也就是操作系统，你可以下载多个，比如2.2，3.1你可以都下载，但是至少必须一个，因为模拟器运行的时候是必须要的。所以，如果你想各种平台都模拟测试一下，那么你就需要各种版本的android都下载一个。 我下载了SDK Platform-tools 5和Android 3.1，Android Compatibility Package三个包。 下载完成之后，Android的开发环境就搭建好了。 写一个hello,android测试程序试试验证成果的时候到了，启动eclipse,选择File-&gt;New-&gt;Project… 然后选择Android下的Android project, 然后填写下面的信息： project name:HelloAndroid 这是项目名称,也就是包含文件的目录名称 Application name:Hello,Android 这是应用程序名字,也是程序运行的时候显示在屏幕上方的文字 Package Name：my.android 这个不用解释，学过java的都应该知道，这是类的包名 Create Activity：helloandroidactivity 这是activity的名字，android程序要显示都是以activity来启动的，也就是一个activity子类的名字 其他可以不用改动，就用默认值，然后单击Finish就完成了项目的创建。 进入项目，打开helloandroidactivity.java文件， 把里面的onCreate方法的代码更新如下： import android.widget.TextView; public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); TextView tv = new TextView(this); tv.setText(&quot;Hello, Android!=你好,安卓！&quot;); setContentView(tv); } 保存，准备运行。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大四毕业有感]]></title>
    <url>%2F2012%2F06%2F22%2F%E5%A4%A7%E5%9B%9B%E6%AF%95%E4%B8%9A%E6%9C%89%E6%84%9F%2F</url>
    <content type="text"><![CDATA[这些天忙着写毕业设计，一直没发博。。。 转眼间，都大四要毕业了，今天毕业倒计时了 回想大一时光，那时候学校还在南充，记得一个人去南充，坐汽车，转火车，再转火车，又转汽车，辗转来到南充校区，然后就在那里开始了我人生中前两年的大学时光。现在想起来，那时候才是一个真正上进的好学生，每天早上坚持上早读，坚持上课，然后吃午饭，吃完午饭午睡一觉，下午有课就去上课，没课就去上自习。那时候坚持每天写作业，积极参加一些素质拓展，社团活动，还参加了青志协和学宣部的面试什么的，但是说起面试，我面试好像都没有怎么成功过，可能是与人交流不咋地吧。所以就好好练习说话，练口才，整天进图书馆看各方面的书。但是效果不怎么样，脸皮太薄太追求完美可能就是我失败的原因吧，那时候整天想着如何出人头地，如何做个成功人士，如何改变我在别人心目中的形象之类的。 大二的时候，参加了勤工助学，有幸认识了一个同级的小女生，一直想追，不过等到有关她的消息打探清楚后，才知道她是有男朋友的，所以YY便成了我每天的必修课，好像从那时候起，我便学会了YY，整天在YY，YY着她分手了，YY着我和她在一起了，YY着把她带我家去了，从那以后，我便深深喜欢上了YY，干什么事情都要首先YY一番，满足一下我的虚荣心，然后再拿现实做比较，真是惨不忍睹，事情过去之后再YY当时应该怎么做，就这样，大二的时光被我YY完了。 转眼大三了，学校搬到成都了，一下子感觉自己老了许多，当一名老师在台上激情的讲如何创业，做一名成功人士等等的时候，我完全感到自己的心已经老了，没有精力去听这些东西，没有心情听这些东西，要知道如果是两年前刚入校的我是肯定不会错过这次机会的，而现在的我呢，满不在乎，I don’t care。而那时候我care的是什么东西呢，我care的是奖学金，是钱，是班长，是权，是证书，是荣誉。还清楚的记得我为了拿奖学金，如何半夜11点多都还在背什么是影像图，什么是元数据，为了当上班长，如何拉票，如何请他们吃饭，为了证书，如何花掉自己很多时间去学习，如何连暑假都不回家，每天早上7点起的奋斗。 大四了，开始出去实习了，先去川师，然后去北师，最后又回到成都，辗转多处，大公司小公司去了不少，却没有几家合适的，当时脑子里想的都是工资、努力和前程。其他的什么东西都是浮云，就连一次导员通知我去领全国大学生英语竞赛的证书和奖品，我都没去，因为在我大四的眼界里，钱是最好的东西。每天坚持上班，不到迫不得已，绝不请假，学校也没回几次，就这样忙碌忙碌，终于，现在的我，才坚持了半年时间就疲了，这是我真正追求的东西吗，我的一生难道就只是在给钱做奴隶么。。。现在的我，快想通了，钱不是我唯一的追求，努力也不是成功的唯一要素。 现在要毕业了，回想大学四年间所追求的东西。。。 大一的被人认同感，大二的YY感，大三的权钱欲，好像都是有一种无形的虚荣心在作怪，它好像是我奋斗的动力，也是我变态心态的根源。大四了，好像对什么都毫不在乎了，好像觉得什么都是浮云，于是破罐子破摔，什么也不顾忌，于是发现这也是一种生活态度，只不过没有什么可追求的东西而已，除了钱，但是钱赚了，太低调又有谁能知道呢，没有对你肯定，太高调，惹来嫉妒，也没人给你肯定。。。 人生到底追求的是什么东西呢，星云大师说过，人之所以痛苦，是因为在追求错误的东西，也就是说，如果我们追求的是对的东西，我们就会感觉到快乐，可是，追求了这么多之后，我怎么没快乐过呢。。。]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法]]></title>
    <url>%2F2012%2F05%2F25%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(%E6%9C%AA%E5%AE%8C%E6%88%90)%2F</url>
    <content type="text"><![CDATA[树和二叉树]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构第二部分]]></title>
    <url>%2F2012%2F04%2F27%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86(%E6%9C%AA%E5%AE%8C%E6%88%90)%2F</url>
    <content type="text"><![CDATA[树和二叉树]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构第一部分]]></title>
    <url>%2F2012%2F03%2F30%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[绪论 数据(data)：是对客观事物的符号表示，在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称。 数据元素(data element)：是数据的基本单位，在计算机程序中经常作为一个整体进行考虑和处理。 数据对象(data object)：是性质相同的数据元素的集合，是数据的一个子集。 数据结构(data structure)：是相互之间存在一种或多种特定关系的数据元素的集合。 结构(structure)：数据源是都不是孤立存在的，而是它们之间存在着某种关系，这种关系就是结构。 根据数据元素之间的关系不同的特性，通常有下列4类基本结构：（逻辑结构） 集合：结构中的数据元素之间除了“同属一个集合”的关系之外，别无其他关系 线性结构：结构中的数据元素之间存在一个对一个的关系 树形结构：结构中的数据元素之间存在一个对多个的关系 图状结构或网状结构：结构中的数据元素之间存在多个对多个的关系 数据结构的形式定义为：数据结构是一个二元组 Data Structure = (D, S)；其中：D是数据元素的有限集，S是D上关系的有限集。 数据结构在计算机中的表示(又称映像)称为数据的物理结构，又称存储结构。 在计算机中表示信息的最小单位是二进制数的一位，叫做位(bit)。 在计算机中可以用一个由若干位组合起来形成一个位串表示一个数据元素，通常称这个位串为元素或结点。 当数据元素由若干个位串组成时，位串中对应于各个数据项的子位串称为数据域(data field)。 数据元素之间的关系在计算机中有两种不同的表示方法：顺序映像和非顺序映像，并由此得到两种不同的存储结构：顺序存储结构和链式存储结构。链式存储结构的特点是借助指示元素存储地址的指针来表示数据元素之间的逻辑关系。 数据类型(data type)是和数据结构密切相关的一个概念，它是一个值的集合和定义在这个值集合上的一组操作的总称。例如C语言中的整形变量，其值为一个整形集合和定义在这些值上的操作如加减乘除。 按“值”的不同特性，高级程序语言中的数据类型可分为两类：一类是非结构的原子类型，另一类是结构类型。 抽象数据类型(Abstract Data Type，简称ADT)是指一个数学模型以及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关，即不论其内部结构如何变化，只要它的数学特性不变，都不影响其外部的使用。 原子类型(atomic data type)：属原子类型的变量的值是不可分解的。 固定聚合类型(fixed-aggregate data type)：属该类型的变量，其值由确定数目的成分，按某种结构组成。 可变聚合类型(variable-aggregate data type):和固定聚合类型相比较，构成可变聚合类型“值”的成分的数目不确定。 和数据结构的形式定义相对应，抽象数据类型可用以下三元组表示(D, S, P)，其中D是数据对象，S是D上的关系集，P是对D的基本操作集本书采用如下格式定义抽象数据类型 ADT 抽象数据类型名 { 数据对象：&lt;数据对象的定义&gt; 数据关系：&lt;数据关系的定义&gt; 基本操作：&lt;基本操作的定义&gt; } ADT 抽象数据类型名； 多型数据类型(polymorphic data type):是指其值的成分不确定的数据类型，例如JAVA中的泛型。然而，不论其元素具有何种特性，元素之间的关系相同，基本操作也相同。从抽象数据类型的角度看，具有相同的数学抽象特性，故称之为多型数据类型。 算法(algorithm)是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或多个操作，此外，算法还具有5个重要特性：有穷性、确定性、可行性、有输入、有输出。 一个好的算法应考虑达到以下几个目标：正确性、可读性、健壮性、效率与低存储量需求。 为了便于比较同一问题的不同算法，通常的做法是，从算法中选取一种对于所研究的问题(或算法类型)来说是基本操作的原操作，以该基本操作重复执行的次数作为算法的时间量度。一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数f(n)，算法的时间度量记作:`T(n)=O(f(n))，它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度(asymoptotic time ecomplexity)，简称时间复杂度。 类似于时间复杂度，本书以空间复杂度(space complexity)作为算法所需存储空间的量度，记作S(n)=O(f(n))，其中n为问题的规模。 因为所占时间和空间都是依赖于特定的输入，本书的时间和空间的复杂度讨论都是基于最坏的情况来分析的。 线性表线性结构的特点是：在数据元素的非空有限集中： 存在唯一的一个被称作“第一个”的数据元素 存在唯一的一个被称作“最后一个”的数据元素 除第一个之外，集合中的每个数据元素均只有一个前驱 除最后一个之外，集合中的每个数据元素均只有一个后继 线性表(linear-list)是最常用且最简单的一种数据结构。简言之，一个线性表是n个数据元素的有限序列。 在稍微复杂的线性表中，一个数据元素可以由若干个数据项(item)组成，在这种情况下，常把数据元素称为记录(record)。含有大量记录的线性表又称为文件(file)。 线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素。假设线性表的每个元素需占用l个存储单元，并以所占的第一个单元的存储地址作为数据元素数据元素的存储位置。则线性表中第i+1个数据元素的存储位置LOC(ai+1)和第i个数据元素的存储位置LOC(ai)之间满足下列关系LOC(ai+1)=LOC(ai)+l，一般来说，线性表的第i个数据元素ai的存储位置为LOC(ai)=LOC(a1)+l*(i-1)。线性表的这种机内表示称作线性表的顺序存储结构或顺序映像(sequential mapping)，通常称这种存储结构的线性表为顺序表。也就是说，在计算机内用“物理位置相邻”来表示线性表中数据元素之间的逻辑关系。 typedef struct { ElemType *elem;//存储空间基址 int length;//当前长度 int listsize;//当前分配的存储容量 } SqList; 线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）。因此为了表示每个数据元素ai与其直接后继数据元素ai+1之间的逻辑关系，对数据元素ai来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。这两部分信息组成数据元素ai的存储映像，称为结点(node)。它包括两个域：其中存储数据元素信息的域称为数据域；存储直接后继存储位置的域称为指针域。指针域中存储的信息称作指针或链。n个结点链成一个链表，即为线性表的链式存储结构。 又由于此链表的每个结点中只包含一个指针域，故又称线性链表或单链表。单链表的整个链表的存取必须从头指针开始进行，头指针指示链表中第一个结点的存储位置。同时，由于最后一个数据元素没有直接后继，则线性链表中最后一个结点的指针为空NULL。 typedef struct LNode { ElemType data; struct LNode *next; } LNode, *LinkList; 有时，也可借用一维数组来描述线性链表，数组的一个分量表示一个结点，同时用游标(指示器cur)代替指针只是结点在数组中的相对位置。数组的第零分量可看成头结点，其指针域指示链表的第一个结点。为了和指针型描述的线性链表相区别，我们给这种用数组描述的链表起名为“静态链表”。 typedef struct { ElemType data; int cur; } 循环链表(circle linked list)是另一种形式的链式存储结构。它的特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环。由此，从表中任一结点厨房均可找到表中其他结点。循环链表的操作和线性链表基本一致，差别仅在于算法中的循环条件不是p或p-&gt;next是否为空，而是它们是否等于头指针。 双向链表：顾名思义，在双向链表的结点中有两个指针域，其一指向直接后继，另一指向直接前驱，在C语言中可描述如下： typedef struct DuLNode { ElemType data; struct DuLNode *prior; struct DuLNode *next; } 和单链的循环表类似，双向链表也可以有循环表。 栈和队列从数据结构的角度看，栈和队列也是线性表，其特殊性在于栈和队列的基本操作是线性表操作的子集，它们是操作受限的线性表，因此，可称为限定性的数据结构。 栈(stack)是限定仅在表尾进行插入或删除操作的线性表。因此对栈来说，表尾端有特殊含义，称为栈顶(top)，相应的，表头端称为栈底(bottom)。不含元素的空表称为空栈。栈的修改是按照后进先出的原则进行的，因此，栈又称后进先出的线性表(first in last out)。 和线性表类似，栈也有两种存储表示方法。 顺序栈，即栈的顺序存储结构是利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，同时附设指针top指示栈顶元素在顺序栈中的位置。栈的链式表示易于操作和实现，在此不作详细讨论。 和栈相反，队列(queue)是一种先进先出(first in first out)的线性表。它只允许在表的一端进行插入，而在另一端删除元素。在队列中，允许插入的一端叫做队尾(rear)，允许删除的一端称为对头(front)。栈也有顺序表示和链式表示两种。用链表示的队列简称为链队列。 和顺序栈相类似，在队列的顺序存储结构中，除了用一组地址连续的存储单元依次存放从队列头到队列尾的元素之外，尙需附设两个指针front和rear分别指示队列头元素及队列尾元素的位置。为了在C语言中描述方便起见，在此我们约定：初始化建空队列时令front=rear=0，每当插入新的队列尾元素时，尾指针增1，每当删除队列头元素时，头指针增1，因此在非空队列中，头指针始终指向队列头元素，而尾指针始终指向队列尾元素的下一个位置。在顺序队列中，当队尾指针到达分配的最大空间时不可再继续插入新的队列元素，否则会因为数组越界而遭致程序代码被破坏。 除了栈和队列以外，还有一种限定性数据结构是双端队列(deque)。双端队列是限定插入和删除操作在表的两端进行的线性表。 串计算机上的非数值处理的对象基本上是字符串数据。在较早的程序设计语言中，字符串是作为输入和输出的常量出现的。随着语言加工程序的发展，产生了字符串处理。这样，字符串也就作为一种变量类型出现在越来越多的程序设计语言中，同时也产生了一系列字符串的操作。字符串一般简称为串。 在不同类型的应用中，所处理的字符串具有不同的特点，要有效地实现字符串的处理，就必须根据具体情况使用合适的存储结构。这一章中会讨论一些基本的串处理操作和几种不同的存储结构。 串(string)(或字符串)是由零个或者多个字符组成的有限序列，一般记为s=&#39;a1a2...an&#39;(n&gt;=0)，其中，s是串的名，用单引号括起来的字符序列是串的值;ai(1&lt;=i&lt;=n)可以是字母、数字或其他字符;串中字符的数目n称为串的长度。零个字符的串称为空串(null string)，它的长度为0。 串中任意个连续的字符组成的子序列称为该串的子串。包含子串的串相应地称为主串。通常称字符在序列中的序号为该字符在串中的位置。子串在主串中的位置则以子串的第一个字符在主串中的位置来表示。 当切仅当两个串的值相等，才会称两个串是相等的。 值得一提的是，串值必须用一对单引号括起来，但单引号本身不属于串，它的作用只是为了避免与变量名或数的常量混淆而已。 在各种应用中，空格常常是串的字符集合中的一个元素，因而可以出现在其他字符中间。由一个或多个空格组成的串’ ‘称为空格串(blank string)，它的长度位串中空格字符的个数。 如果在程序设计语言中，串只是作为输入或输出的常量出现，则只需存储此串的串值，即字符序列即可。但在多数非数值处理的程序中，串也以变量的形式出现。串有3种机内表示方法，分别介绍如下： 定长顺序存储表示 类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。在串的定长顺序存储结构中，按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区，则可用定长数组如下描述之： #define MAXSTRLEN 255 typedef unsigned char SString[MAXSTRLEN+1]; 堆分配存储表示 这种存储表示的特点是，仍以一组地址连续的存储单元存放串值字符序列，但它们的存储空间时在程序执行过程中动态分配而得。在C语言中，存在一个称之为堆的自由存储区，并由C语言的动态分配函数malloc()和free()来管理。利用函数malloc()为每个新产生的串分配一块实际串长所需的存储空间，若分配成功，则返回一个指向起始地址的指针，作为串的基址，同时，为了以后方便处理，约定串长也作为存储结构的一部分 typedef struct { char *ch; int length; }HString; 以上两种存储表示通常为高级程序设计语言所采用。由于堆分配存储结构的串既有顺序存储结构的特点，处理方便，操作中对串长又没有任何限制，更显灵活，因此在串处理的应用程序中也常被选用。 块链存储表示 和线性表的链式存储结构相类似，也可以采用链表方式存储串值。由于串结构的特殊性-结构中的每个数据元素是一个字符，则用链表存储串值时，存在一个“结点大小”的问题，即每个结点可以存放一个字符，也可以存放多个字符。为了便于进行串的操作，当以链表存储串值时，除头指针外还可以附设一个尾指针指示链表中的最后一个结点，并给出当前串的长度。称如此定义的串存储结构为块链结构。设尾指针的目的是为了便于进行联结操作，但应注意联结时需处理第一个串尾的无效字符。 #define CHUNKSIZE 80 typedef struct Chunk { char ch[CHUNKSIZE]; struct Chunk *next; }Chunk; typedef struct { Chunk *head, *tail; int curlen; }LString; 在链式存储方式中，结点大小的选择和顺序存储方式的格式选择一样都很重要，它直接影响着串处理的效率。在各种串处理系统中，所处理的串往往很长或很多，这就要求我们考虑串值的存储密度：存储密度=串值所占的存储位/实际分配的存储位。显然，存储密度小(如结点大小为1时)，运算处理方便，然而存储占用量大。 串值的链式存储结构对某些串操作，如连接操作等有一定方便之处，但总的来说不如另外两种存储结构灵活，它占用存储量大且操作复杂。 子串的定位操作通常称作串的模式匹配，是各种串处理系统中最重要的操作之一。 数组和广义表前几章讨论的线性结构中的数据元素都是非结构的原子类型，元素的值是不再分解的。本章讨论的两种数据结构–数组和广义表可以看成是线性表在下述含义上的扩展，表中的数据元素本身也是一个数据结构。 我们可以把二维数组看成是这样一个定长线性表，它的每个数据元素也是一个定长的线性表。数组一旦被定义，它的维数和维界就不再改变。因此，除了结构的初始化和销毁之外，数组只有存取元素和修改元素值的操作。由于数组一般不作插入或删除操作，也就是说，一旦建立了数组，则结构中的数据元素和元素之间的关系就不再发生变动。因此，采用顺序存储结构表示数组时自然的事了。 由于存储单元是一维的结构，而数组是多维的结构，则用一组连续存储单元存放数组的数据元素就有个次序约定问题。相应的，对二维数组可有两种存储方式，一种以列序为主序的存储方式，一种是以行序为主序的存储方式。 由此，对于数组，一旦规定了它的维数和各维的长度，便可为它分配存储空间。反之，只要给出一组下标便可求得相应数组元素的存储位置。假设每个数据元素占L个存储单元，则二维数组A中任一元素aij的存储位置可由下式确定 LOC(i, j)=LOC(0, 0)+(b2xi+j)L，式中，LOC(i, j)是aij的存储位置；LOC(0, 0)是a00的存储位置，即二维数组A的起始存储地址，也称为基地址或基址。 在数值分析中经常出现一些阶数很高的矩阵，同事在矩阵中有许多值相同的元素或者是零元素。有时为了节省存储空间，可以对这类矩阵进行压缩存储。所谓压缩存储是指：为多个值相同的元只分配一个存储空间，对零元不分配空间 假若值相同的元素或者零元素在矩阵中的分布有一定规律，则我们称此类矩阵为特殊矩阵，反之称为稀疏矩阵。 顾名思义，广义表是线性表的推广。也有人称其为列表(lists,用复数形式以示与统称的表list的区别)。广泛地用于人工智能等领域的表处理语言LISP语言，把广义表作为基本的数据结构，就连程序也表示为一系列的广义表。广义表一般记作 LS = (a1, a2… an)，其中LS是广义表的名称，n是它的长度。在线性表的定义中，ai只限于是单个元素。而在广义表的定义中，ai可以是单个元素，可以是广义表，分别称为广义表LS的原子和子表。习惯上，用大写字母表示广义表的名称，用小写字母表示原子。当广义表LS非空时，称第一个元素a1为LS的表头(HEAD)，称其余元素组成的表时LS的表尾(TAIL)。 由于广义表中的数据元素可以具有不同的结构(或是原子，或是列表)，因此难以用顺序存储结构表示，通常采用链式存储结构，每个数据元素可用一个结点表示。由于列表中的元素可能为原子或列表，由此需要两种结构的结点，一种是表结点，用以表示列表，另一种是原子结点，用以表示原子。若列表不空，则可分解成表头和表尾，反之，一堆确定的表头和表尾可唯一确定列表。由此，一个表结点可由3个域组成：标志域、指示表头的指针域和指示表尾的指针域；而原子结点只需两个域：标志域和值域。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言程序设计教程2]]></title>
    <url>%2F2012%2F02%2F24%2FC%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%95%99%E7%A8%8B2%2F</url>
    <content type="text"><![CDATA[函数程序员在设计一个复杂的应用程序时，往往也就是把整个程序划分为若干功能较为单一的程序模块，然后分别予以实现，最后再把所有的程序模块像搭积木一样装配起来，这种策略被称为模块化程序设计方法。 每个C源程序都是由一个主函数和若干个其他函数组成的。函数时程序的基本组成单位，因此可以很方便地用函数作为程序模块来实现C语言程序。从函数的定义角度，函数可以分为库函数和用户自定义函数两种；从兼有其他语言功能角度分类，函数分有返回值函数和无返回值函数两种；从函数间传送的角度分类，函数分为无参函数和有参函数两种； 返回值类型 函数名(参数表) { 函数体; } 在主调函数中调用某函数之前应对该被调函数进行原型说明，这与使用变量之前要先进行变量说明是一样的。在主调函数中对被调函数作说明的目的是使编译器程序知道被调函数的返回值类型，以便在主调函数中按此种类型值做相应的处理类型说明符 被调用函数名(类型1 形参1, 类型2 形参2);或类型说明符 被调用函数名(类型1, 类型2);。函数的调用方法如下函数名(实际参数表); 一般来说，有两种方法可以把参数传递给函数，一种方法叫做传值调用，另一种方法是传址调用。 传值调用：把实参的值复制到函数的形参中 传址调用：将实参的存储地址作为参数传递给形参 数组也可以作为函数的参数使用，进行数据传送。数组用作函数参数有两种形式：一种是把数组元素(下标变量)作为实参使用；另一种是把数组名作为函数的形参和实参使用 在变量做函数参数时，所进行的值传递是单向的，即只能从实参传向形参，不能从形参传回实参。 函数的传值调用可以通过参数使用调用环境中变量的值，但不能改变那里的变量值。想要改变那里的变量值，就得利用指针机制：在调用时把变量的地址通过指针参数传进被调函数，在被调用函数里对参数指针间接访问，就能完成对变量的各种操作，包括对变量赋值。 在C语言中允许一个函数的返回值是一个指针(即地址)，这种返回指针值的函数称为指针型函数。定义指针型函数的一般形式为： 类型说明符 *函数名(形参表) { ...;//函数体 } 在C语言中一个函数总是占用一段连续的内存区，而函数名就是该函数所占内存区的首地址。我们可以给函数的首地址赋予一个指针变量，使该指针变量指向该函数，然后，通过指针变量就可以找到并调用这个函数。我们把这种指向函数的指针变量称为“函数指针变量”。函数指针变量定义的一般格式为：类型说明符 (*指针变量名)();。其中”类型说明符”表示被指函数的返回值的返回值类型，(*指针变量名)表示*后边的变量是定义的指针变量，空括号表示指针变量所指的是一个函数。调用函数的一般形式为(*指针变量名) (实参表) 在ANSI C标准中允许用结构变量作函数参数进行整体传送。但是这种传送要将全部的成员逐个传送，特别是成员为数组时将会使传送的时间和空间开销很大，严重地降低程序的效率，因此，最好的办法就是使用指针，即用指针变量作函数参数进行传送。这时由实参传向形参的只是地址，从而减少了时间和空间的开销。结构型函数是指返回值为结构变量的函数。返回指向结构变量指针的函数称为结构指针型函数，结构型函数返回的是结构变量，函数返回时要带回结构变量的各成员值，影响执行效率，而采用返回结构型指针的函数可以避免这一点。 函数的递归调用是指在调用一个函数的过程中，直接或间接地调用函数自身，这种函数称为递归函数。C语言允许函数的递归调用。在递归调用中，主调函数又是被调函数。 变量的存储类型C语言中的变量具有两个属性：数据类型和存储类型。数据类型确定了变量在内存中分配存储单元的大小，存储类型指数据在内存中的存储方式。变量的存储类型决定了变量的作用域和生命周期。存储方式分为静态存储和动态存储。 静态存储方式指在程序运行期间分配固定存储空间，在整个程序运行期间保持不变，直到程序运行结束才释放所占有的存储空间。动态存储方式指在程序运行的过程中，根据需要，使用时才分配存储空间，使用结束后立即释放。典型的例子是函数的形式参数。 在C程序中，函数之间的参数传送主要有两种方式：传值和传地址。 C程序中的每个变量都要经历 分配存储空间，用以存放该变量的值，然后在程序中使用变量，使用结束后释放所占有的存储空间的过程。这个过程称为变量的生命期。在变量的生存期内，该变量可以使用的范围称为变量的作用域。在变量作用域内引用变量，称变量在此作用域内可见。 变量的作用域是一个空间的概念，由定义变量语句的位置决定，根据变量定义语句的位置的不同，变量分为局部变量和全局变量。 C语言中的四种类型的变量： 自动变量：自动变量定义时，前面可以加关键字auto，其格式为auto 类型说明符 变量名表;。在函数内定义的变量称为内部变量，由于内部变量的作用域仅局限于其所在的函数，因此内部变量也称为“局部变量”。内部变量分为自动变量和静态局部变量。 外部变量：所有在函数外部定义的变量称为外部变量，外部变量是全局变量，外部变量可以被本源程序文件中的其他函数使用。外部变量的作用域从其定义的位置开始，一直到本源程序结束。由于外部变量在程序执行过程中，占有固定的存储单元，其生存期为整个程序。在C语言中，可以使用关键字extern，将外部变量的作用域扩展到外部变量定义之前或其他源程序文件中。也可以使用extern关键字进行引用性声明，引用性声明不分配存储空间extern 类型标识符 变量名表; 静态变量：定义变量时，前面加关键字static，则定义的变量就是静态变量。在编译时，系统分配固定的存储单元，并在程序运行过程中始终存在，直到源程序运行结束，因此静态变量的生存期为整个源程序。静态变量根据位置不同分为静态局部变量和静态全局变量。全局变量和静态全局变量的存储方式均为静态存储方式，两者的区别在于作用域扩展上的不同，静态全局变量的作用域为其所在的源程序文件，即只能被该源程序中的函数使用，而全局变量可以通过extern关键字将作用域扩展到其他源程序文件。所以在由多个源文件组成的C程序中，如要限制外部变量不能再其他源程序文件中使用，可以将其定义为静态外部变量。 寄存器变量：寄存器变量是指将局部变量的值存放在CPU的寄存器中的变量。由于寄存器的存钱速度远高于对内存的存取速度，因此，可以将使用频繁的局部变量定义为寄存器变量，可以提高程序的运算效率，寄存器变量定义形式如下：register 数据类型 变量名表; C程序在运行时使用的存储空间分为三个部分 程序区：用于存放程序代码 静态存储区：用于存放程序的全局数据和静态数据 动态存储区：用于存放自动变量、函数的形式参数、函数调用时的现场保护和返回地址 动态内存分配是指在程序运行过程中，根据需要而分配内存空间的方式，这种就可以解决有时分配过大或过小的问题。在C系统的函数库中提供的动态分配和释放内存空间的函数主要有： malloc函数：void *malloc(unsigned int size)在内存动态存储区分配一段长度为size个字节的连续空间，如果分配成功，函数返回一个指向该区域起始地址的指针，否则返回NULL指针 calloc函数：void *calloc(unsigned int n, unsigned int size);在内存动态存储区分配n个长度为size的连续空间，如果分配成功，函数返回一个指向该区域起始地址的指针，否则返回NULL指针 free函数：void free(void *p);释放指针p指向的存储空间，free函数无返回值 realloc函数：void *realloc(void *p, unsigned int size);将p所指向的存储空间，重新分配改变为size的字节，并将原存储空间存放的数据拷贝到新分配的存储空间，如果分配成功，函数返回一个指向该区域起始地址的指针，否则返回NULL指针。注意：为了增加或减少存储空间，系统新分配的起始地址不一定与原来的地址相同 位域、联合、枚举、定义类型及预处理功能8.1 位域及结构嵌套为了节省空间，C语言允许定义具有可变长度位的结构成员，这种成员称为位域。通过位域可以方便地用成员名访问小于一个字节的存储区。位域是结构成员的特殊形式，它需要定义位的长度。位域定义的一般形式是： //冒号表示使用的是位域，其后的长度表示需要分配的存储单元的位数 struct 结构名 { 类型 变量名1:长度; 类型 变量名2:长度; } //内存分配情况是位域变量总共占用2个字节其余位未用 //注意：在不同的机器里，位域变量从左到右还是从右到左的规则不同 struct { unsigned bit0:1; unsigned bit1:1; } 与结构成员的访问方式一样，位域可以用结构成员运算符”.”来访问。若位域是由指针访问的，必须使用箭头运算符。位域变量有某些限制，比如，不能取一个位域变量的地址；不允许超越整形量边界。 在C语言中，结构成员不仅可以是位数可变的位域变量，而且可以是另一个结构类型变量。这种情况被称为嵌套式结构。 8.2 联合联合是一种与结构相类似的构造类型，联合与结构一样，可以包括不同类型和长度的数据。联合与结构的主要区别在于，联合类型变量所占内存空间不是各个成员所需存储空间字节数的总和，而是联合成员中需要存储空间最大的成员所要求的字节数。这是因为C编译程序规定联合的各个成员共享一个公共存储空间。在任何给定的时刻，只能允许一个成员驻留在联合中，而对结构而言，则是所有成员一直都驻留在结构中。 union 联合名 { 类型 变量名; 类型 变量名; }联合变量; 使用联合不仅比使用结构更能节省一些存储空间，而且增加了处理数据的灵活性。 8.3 枚举通过列举一系列由用户自己确定的有序标识符所定义的类型叫枚举类型。标识符名称代表一个数据值，其间有先后次序，可以进行比较，通常把标识符称为枚举类型的元素。 枚举和结构一样，都是自定义的一种数据类型，枚举用关键字enum表示，定义枚举型的一般形式为：enum 枚举名{枚举表}; enum color {white, black, red}; enum color col; col = black; 枚举的作用域与变量一致，即在一个函数中定义的枚举型数据只限于在该函数中使用。而在程序中任何函数之外定义的外部枚举型数据可以为所有函数共用。 8.4 定义类型名-typedefC语言允许用户使用关键字typedef，为已有的类型定义一个新的名字，定义类型的一般形式为：typedef 类型 定义名;，例如 typedef int integer;，在这里，类型是任一种合法的数据类型，定义名是为这种类型新取的名字。 必须强调指出，typedef的作用，在任何意义上讲都不是创建一种新的数据类型，它仅仅为现有的类型赋给一个新的名字，也没有任何新语义。 8.5 预处理功能C语言的预处理程序负责分析和处理以“#”为首字符的预处理控制行。预处理控制行主要有宏替换、文件包含和条件编译。 用#define作为标志的预处理命令不仅可以定义符号常量及字符串，而且也可定义带参数的宏。宏替换命令#define用来定义一个宏标识符和一个字符串，在程序中每次遇到该标识符时，就用所定义的字符串替换，这个标识符也叫宏替换名，替换过程称为宏替换，宏替换命令的一般形式是：#define 宏标识符 字符串。注意#define、宏标识符、字符串各部分之间用空格分隔，其末尾不带分号，以换行结束。 宏标识符像函数一样可以带有形式参数。在程序中用到宏标识符时，实际参数将代替这些形式参数，使用更为灵活。带参数宏定义的一般形式是：#define 宏标识符(参数表) 表达式。标识符就是带参数宏的名字，参数表中的参数类似函数中的形式参数，宏标识符与左圆括号之间不能有空格；表达式是用于替换的表达式。宏调用的一般形式是宏标识符(参数表)，此处的宏标识符是已经被定义的宏标识符，参数表中的参数类似于函数中的实参数。 宏一旦被定义，在其所在的文件中均是存在和可见的，这一点很像外部变量。如果要对某一个宏定义撤销，可用如下预处理命令:#undef 宏标识符。 包含文件处理是用#include命令把给定的包含文件内容嵌入到另一个源程序文件中。其一般形式是：#include 文件名 或 #include &lt;文件名&gt;。#include预处理命令的实质是，告诉预处理程序将包含文件的内容嵌入到源文件中#include出现的地方。 需要嵌入的包含文件的存放地点，必须由文件的路径和文件名指定，并且被放在双引号内，系统约定先在引用包含文件的源文件所在的目录中查找，若找不到，再按系统指定的标准方式向外查找，如果已经知道被包含文件不在当前工作目录，可以使用尖括号形式查找标准目录。因此，从使用角度上看，在包含文件中使用双引号比使用尖括号更靠谱。 输入、输出及文件管理C语言的文件系统分为“缓冲型文件系统(buffered file system)”和“非缓冲型文件系统(unbuffered file system)”。通常把缓冲型文件系统提供的函数称为流式I/O函数，把非缓冲型文件系统提供的函数称为低级I/O函数。 fopen：打开文件函数 File *fp=fopen(filename, mode)其中fp定义为指向FILE类型的指针，filename表示要打开的文件名，mode表示使用该文件的模式，如可读r、可写w和可添加a。若要打开的文件不存在，fopen函数返回NULL指针，也就是0 fclose:关闭文件函数int fclose(File fp)其中fp是一个调用fopen函数所返回的文件指针。文件关闭成功返回0，返回其他值说明关闭出错。文件处理结束后，必须关闭文件。文件未关闭会引起很多问题，如数据丢失，文件损坏及其他一些错误。 stdin、stdout、stderr：当一个C程序开始执行时，系统首先自动打开预定义的三个流式文件：标准输入stdin，标准输出stdout和标准错误stderr。当程序运行结束后，系统又自动将这些标准文件关闭。用户则不能控制它们的打开和关闭。通常stdin被指定为键盘，用于从控制台读，stdout和stderr被指定为显示终端，用于向控制台写。但是用户在执行某个程序时，可以临时性地改变系统的设定，把标准设备文件指定为其他设备文件。 getc、putc简单字符输入输出：这两个函数时用于从一个打开的文件中读取一个字符或向打开的文件写入一个字符的函数。调用方式为int getc(FILE *fp);或int putc(int ch, FILE *fp)，这里，fp是由fopen函数打开文件时返回的文件指针。fp指针告诉这两个函数应该从哪一个磁盘文件去读字符或写入字符。 fgets、fputs行输入输出：fgets和fputs是用来从文件中读取字符串，或向文件中写字符串的函数，其调用方式是：char *fgets(char *str, int length, FILE *fp);和char *fputs(char *str, FILE *fp);，函数fgets从fp指向的文件读出字符串，一直读至换行符或第(length-1)个字符为止。 fread、fwrite数据块的输入输出：这是两个读写数据块的函数，其调用方式是int fread(void *buffer, int size, int n, FILE *fp);或int fwrite(void *buffer, int size, int n, FILE *fp);buffer是一个指向数据存储区的指针。在fread函数中，buffer接收从文件中读取的数据。在fwrite函数中，buffer中的数据向文件写入。读写的字段数用n表示（每个字段是size个字节），fp是已打开文件的文件指针。 fprintf、fscanf流式文件数据的格式化输入输出：这两个函数的操作对象是磁盘文件，以上的操作对象都不是磁盘文件，调用这两个函数的方式分别是fprintf(fp, &quot;控制字符串&quot;, &quot;参量表&quot;)和fscanf(fp, &quot;控制字符串&quot;, &quot;参量表&quot;)，其中，fp是由fopen函数返回的文件指针，fprintf函数将格式化的数据写入到fp指向的文本文件中，fscanf函数从fp指向的文本文件中读取格式化数据，两个函数的操作方法与printf和scanf函数完全相同。 fseek文件的随机访问：fseek函数可以改变文件的位置指针，以实现文件的随机访问。调用方式为：int fseek(FILE *stream, long offset, int origin);，即按偏移量offset和起始位置origin的值，设置与stream相连的文件位置指示器。操作成功返回值为0，否则返回值为非0。偏移量offset是从起始位置origin到要确定的新位置之间的的字节数目，当文件是结构类型时，可用sizeof()函数确定便宜量。起始位置用0，1，2表示，0表示从文件头开始，1表示从当前位置开始，2则表示从文件末端开始。 C高级程序应用10.1 链表链表是由链指针构成的一种动态数据结构。链表分为单向链表、双向链表和循环链表。单向链表只用一个链指针指向下一个结点。双向链表用两个链指针分别指向前一个结点和后一个结点。循环链表最后一个数据项的指针指向第一个数据项，因此循环链表是一个无表头和表尾的链表。 10.2 与操作系统密切相关的库函数在Windows操作系统中，用户可以通过图形化界面方便地完成操作系统的各种功能。而在DOS磁盘操作系统环境下，是通过在命令行输入命令并回车来完成相应的功能，目前在嵌入式系统编程等方面仍大量采用这种工作方式。 Turbo C库函数的一个重要特色就是设置有与操作系统密切相关的一些函数。这些函数包括： BIOS接口调用函数 DOS系统调用函数 时间和日期函数 10.3 图形程序Turbo C提供了非常丰富的图形函数，所有图形函数的原型均在graphics.h中，本节注意介绍图形模式的初始化、独立图形程序的建立、基本图形功能、图形窗口以及图形模式写的文本输出等函数。 10.4 声音程序Turbo C中提供了几个队扬声器操作的库函数： 接通扬声器：sound(int frequence);按照参数要求的频率发音 关闭扬声器：nosound(); Outportb(int port, char byte)/Inportb(int port)：通过对端口的直接操作函数来控制扬声器的发音。扬声器的端口地址为0x42，对端口的操作方式一般分两步：初始化端口、向端口传送频率值。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言程序设计教程1]]></title>
    <url>%2F2012%2F01%2F27%2FC%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%95%99%E7%A8%8B1%2F</url>
    <content type="text"><![CDATA[C语言概述1.1 计算机信息社会与C语言到目前为止，计算机语言大致可分为五代，第一代是机器语言，第二代是汇编语言，第三代是面向过程程序设计语言，第四代是面向对象程序设计语言，第五代是基于Web的语言。 高级语言源程序在计算机中有编译和解释两种执行方式 在解释方式下，源程序由解释程序边解释边执行，不生成目标程序，其执行程序速度较慢 在编译方式下，源程序首先必须经过编译程序的编译处理，产生相应的目标程序，然后再通过连接和装配，才能生成可执行程序 1.2 C语言简史及其特点ALGOL(1960)–CPL(1963)–BCPL(1967)–B(1970)–C(1972)–发表(1978)–ANSIC标准(1983)–ANSIC标准补充(1987)–获得ISO认证(1997) 1980年开始，贝尔实验室将Simula67中‘类’的概念引入C语言，1993年将其正式命名为C++ C语言不仅具有高级语言的特点，并且还有汇编语言的功能，同时具有极强的兼容性和良好的用户界面 1.3 基本程序结构C程序是一种结构化程序，程序由顺序、循环、分支三种结构组成 C程序中有三种类型的函数 主函数main 编译程序提供的函数 程序员自己设计的函数 一个函数由两部分构成 函数说明部分 和 函数体部分 1.4 基本语法单位在C语言中使用的词汇分为6类：关键字、标识符、操作符、分隔符、常量、注释符等 关键字：C语言规定的具有特定意义的字符串，通常也称保留字，用户定义的标识符不应与关键字相同。C语言的关键字分为以下几类：类型说明符(int) 语句定义符(if else) 预处理命令符(include) 标识符：用来表示变量名、数组名、函数名、指针名、结构名、联合名、枚举常量名、用户自定义的数据类型名及语句标号等的字符序列统称为标识符 操作符：在C语言中含有相当丰富的操作符。操作符与变量、函数一起组成表达方式，以表示各种运算功能 分隔符：在C语言中的分隔符有逗号和空格两种 常量：包括数值常数、字符常数、字符串常数以及枚举常数 C语句是组成C程序的基本单位，具有可执行的功能 函数时构成C程序的必不可少的一部分，它是一个相对独立的程序或模块 1.5 C程序的编写和运行步骤 程序编辑：程序员用任一编辑器将编写好的C程序输入计算机，并以文本文件的形式保存在计算机硬盘上 程序编译：编译是指将编译好的源文件翻译成二进制目标代码的过程 连接程序：编译后产生的目标文件是可重定位的程序模块，不能直接运行。这就需要把目标文件、其他分别进行编译生成的目标程序模块和系统提供的标准函数库连接在一起，以生成可运行的可执行文件 程序运行：生成可执行文件后，就可以在操作系统控制下运行。 总结起来，C程序的过程如下: .c文件–.cpp文件–.obj文件–.exe文件 1.6 算法表示方法程序 = 数据结构 + 算法 数据结构是程序中用到的数据的构造形式及其类型。对于面向对象程序设计，强调的是数据结构，而对于面向过程的程序设计语言，主要关注的是算法。算法是程序的核心，也是面向对象程序设计的基础。 所谓结构化编码时指任何复杂的程序皆可由顺序、分支、循环三种基本结构组成。对复杂的程序进行自顶向下、逐步细化的分析，进行模块化的划分。 程序设计的步骤是 设计算法–描述算法–编写程序–检查程序–编译调试和运行。 算法的描述方法有自然语言描述、伪代码、流程图、N-S图、PAD图等 基本数据类型及运算2.1 基本数据类型数据类型是数据的基本属性，描述的是数据的存储格式和运算规则。不同数据类型的数据，在内存中所需的存储空间大小、存储格式均有所不同、能支持的运算以及相应的运算规则也会有所不同 数据类型分为： 基本类型 整形：基本类型符为int，根据数据范围又可分为普通整形(int)、短整形(short)和长整形(long) 浮点类型：浮点类型分为单精度浮点数(float)，双精度浮点数(double)和长双精度浮点数(long double) 字符型：字符的基本类型符为char，可在其前面加修饰符前缀signed和unsigned，都是用1个字节来存放 构造类型 数组类型 结构类型 联合类型 枚举类型 指针类型 空类型 2.2 常量常量是在程序执行过程中其值不能改变的量。在C语言中有不同类型的常量，如整形常量、浮点型常量、字符型常量、字符串常量和符号常量。 整形常量也称作整常量，在C语言中整常量可以用以下3种形式表示：十进制、八进制(以0开头)和十六进制(以0x或0X开头) 浮点型常量如同一般语言中的实数(real number)，它有两种表示形式： 十进制数形式：由数字和小数点组成 指数形式：由十进制小数、阶码标志e或E以及指数(只能为整数，可以带符号)组成，6.5E-2 字符型常量是用单引号括起来的一个字符，如’A’,’a’等 字符串常量是用一对双引号括起来的零个或多个字符组成的序列，如“hello”等，其存储于字符常量的存储不同，字符串常量都会自动在其末尾加上’\0’作为字符串结束标志 符号常量出现的形式一般有两种，一种是在程序中直接使用给定的值(如圆周率)，另一种是用一个常量相关的标识符来替代常量出现在程序中(const修饰) 2.3 变量变量是在程序执行过程中其值可以改变的量，其定义格式为：类型说明符 变量名表;，C语言允许在定义变量的同时对变量进行初始化，初始化不是在编译阶段完成的，而是在程序运行时执行本函数时赋予初值的，相当于有一个赋值语句。定义时的变量名其实是一个符号地址，它指出了变量在内存中的存放位置，而变量值就是在相应内存单元中存放的数据。 2.4 运算符与表达式按运算符在表达式中的作用，C语言的运算符可分为算术运算符(加减乘除取余等)、赋值运算符、关系运算符(&gt;=、!=等)、逻辑运算符(!、&amp;&amp;、||)、位运算符(&lt;&lt;、&gt;&gt;、&amp;等)、条件运算符(?:)、逗号运算符以及一些特殊的运算符(地址运算符&amp;、sizeof运算符、强制类型转换运算符())。 2.5 混合运算与类型转换在计算表达式时，不但要考虑运算符的优先级和结合性，还要分析运算对象的数据类型。一个运算符对不同数据类型的数据的计算结果有可能不同。不同类型的数据在一起运算时，需要转换为相同的数据类型。转换的方式有两种：自动类型转换和强制类型转换。自动类型转换又称为隐式转换，而强制类型转换又称为显示转换。 自动类型转换是指系统根据规则，自动将两个不同数据类型的运算对象转换成同一数据类型的过程，转换的原则是为两个运算对象的计算结果尽可能提供多的存储空间 强制类型转换的格式为(数据类型名)(表达式名) 2.6 运算的优先级与结合性表达式的计算是与运算符的语义以及它们的优先级和结合性规则有关 运算符高的运算符先算，优先级低的运算符后算 优先级相同的运算符、根据结合性决定计算顺序(i/j*k从左至右，*p–从右至左) 不相关子表达式的计算顺序不确定(i++)+(i+j)由于不同环境的编译配置有肯能从左至右，也有可能从右至左计算，所以会导致计算结果不一致 有特殊规则的运算符（注意一下 &amp; 和 || 的中断处理） 2.7 数据的输入输出C语言中没有提供专门的输入/输出(I/O)语句，所有的I/O操作都必须通过函数调用来实现，如前面程序中用到的printf()，scanf()等都是系统提供的标准I/O库函数。标准C定义了15个标准库函数和相应的头文件。 字符输出函数putchar() 格式输出函数printf()printf(格式控制串, 参数1， 参数2，...) 字符输入函数getchar() 格式输入函数scanf()scanf(格式控制串, 参数1， 参数2，...) cincin&gt;&gt;i&gt;&gt;j从键盘拾入i和j的值 coutcout&lt;&lt;How are you输出字符串 控制语句C语言有三种基本语句： 顺序结构 选择结构 if(表达式) { ...; } else if (表达式) { ...; } else { ...; } switch(表达式) { case c1: S1; break; case c2: S2; break; ... default: Sn+1; break; } 循环结构 do { 语句(即循环体部分) } while (表达式); while(表达式) { 语句(即循环体部分); } for (表达式1; 表达式2; 表达式3) { 语句(即循环体部分); } C语言中的break，continue语句是专门用于跳出循环或终止一次循环过程的语句，被称为条件转向语句，而goto语句是用来跳转到通过’标号’指明的某条语句上去执行的语句，被称为无条件转向语句。 数组和结构数组是具有相同数据类型的数据的有序集合，他们有相同的标识符和数据类型，用一个统一的数组名及数组下标来唯一确定数组中的元素，它的声明格式如下类型说明符 数组名[常量表达式] 仿照用一维数组表示多个有序变量，则可用二维数组表示多个有序的一维数组，这时可将每个一维数组看做一个元素，以此构成一个更大的数组，这个数组就是一个二维数组，它的声明格式如下类型说明符 数组名[常量表达式1][常量表达式2]，其中常量表达式1规定了一维数组的个数，常量表达式2规定了一维数组中元素的个数。 在对数组的全部元素赋初值时，C语言规定可以省略第一维的长度，但不能省略第二维的长度，例如可以把int a[2][2]={1，2，3，4}写成int a[][2]={1，2，3，4}，但不能写成int a[2][]={1，2，3，4} 在C语言里，没有提供专门的字符串类型，所以需要使用字符数组来处理字符串。可以使用scanf函数和gets函数获得输入字符串，如scanf(&quot;%s&quot;, word);`gets(word)。可以使用printf函数和puts函数输出字符串，如prinft(“%s”, word);puts(word)` 在C语言里，字符串的应用非常广泛，为了简化用户的程序设计，C语言提供了丰富的字符串处理函数，这样可以大大减轻编程的工作量。其中主要包括有： 字符串长度测量函数strlen:strlen(字符数组名) 字符串复制函数strcpy:strcpy(字符数组名1，字符数组名2)将2复制到1中去 字符串连接函数strcat:strcat(字符数组名1，字符串2) 字符串比较函数strcmp:strcmp(字符数组名1，字符数组名2) 结构是具有不同数据类型的数据的集合，结构与数组相似，但其成员的数据类型可以不同，使用结构名及成员名来唯一确定结构中的成员。 struct 结构类型名 { 类型名1 成员名1; 类型名2 成员名2; ... 类型名n 成员名n; }; struct student { int age; char[20] name; } //定义 struct student stu1, stu2; //访问 stu1.age; stu2.name; 数组元素的类型可以是任何类型，当然也可以是结构类型，这种就被称为结构数组。结构数组与其他类型的数组一样，只是它的元素是结构类型。 指针指针变量与普通变量一样，在程序中需要先定义，再使用。指针变量定义的一般形式是：类型定义符 *指针变量名，其中，类型定义符是指针变量所指向的目标变量的数据类型，可以是C语言中规定的基本类型或用户自定义的数组、结构、联合等。*是一个说明符，仅向编译器说明其后所定义的是指针变量而不是一般变量。除0以外的整数值是不允许赋值给指针变量的p=0，因为指针变量中存放的是内存地址，而不是任何整数。 &amp;：取地址运算符 *：间接运算符：注意，在变量说明语句中的*意味着‘指向。。。的指针’，而在表达式中的*表示访问指针指向的目标变量 其实，数组名是一个指向该数组的指针。数组名是一个地址常量，不能被修改，在整个程序运行期间，其值是固定不变的。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C和OC的内存分配]]></title>
    <url>%2F2011%2F12%2F31%2FC%E5%92%8COC%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%2F</url>
    <content type="text"><![CDATA[在以前上课时经常死记硬背内存都有哪些区，自从参加工作后，从应用启动的过程可以明显的区分出内存的几个分区而不用死记硬背。由于OC是继承C来的，所以其内存分配方式基本相同，只不过iOS系统为每个app分配了一定额度的沙盒空间来供每一个app正常存储和运行。 不管是C程序还是iOS程序（为了简单，我们一iOS APP为例），当APP没有打开时，ipa或者app文件都是存在于ROM中，即我们说的iPhone16G的16G当中某一个叫Application的文件夹中，在其启动的时候iOS系统会先为app从RAM中分配一个独立的内存空间（即沙盒），app所有的内存操作都在这个独立的沙盒中进行。首先系统会加载二进制代码到内存中，然后加载常量区中的常量，接着加载全局区和静态区（初始化过的静态区和没有初始化过的静态区是分开的），之后程序会找main入口函数开始执行代码，在执行代码的过程中，会创建对象和一些局部变量，其中对象存放在堆中，变量存放在栈上，以上五个区中只有堆是由程序员自己创建和销毁，而其他四个都是系统自己管理。 由此可见，从低地址到高地址的的内存区域分别是代码区、常量区、全局区、堆区和栈区。 概念程序代码区代码区用来存放函数体的二进制代码，程序结束后由系统释放 常量区常量区用来存放常量字符串等，程序结束后由系统释放 全局区/静态区全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后有系统释放 全局变量和静态变量要尽量少用。因为这些变量在程序的生命周期中不会变释放，比较容易占用内存空间，不适合存储比较大量的数据。 堆区一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式类似于链表。堆区的变量地址是由下往上分配的，所以在同一线程中先声明的变量地址要比后声明的变量地址小。 堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 首先应该知道操作系统有一个记录空闲内存地址的链表。 当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。 由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中 堆是函数库内部数据结构，不一定唯一。 不同堆分配的内存无法互相操作。 堆空间的分配总是动态的 虽然程序结束时所有的数据空间都会被释放回系统，但是精确的申请内存，释放内存匹配是良好程序的基本要素。 栈区栈区用来存放局部变量，先进后出，一旦出了作用域就会被销毁。程序员不需要管理栈区变量的内存。栈区变量的大小是由上到下分配的，所以先声明的变量地址比后声明的变量地址要大。栈区存储在应用程序允许的内存空间的最上面。 栈是向低地址扩展的数据结构，是一块连续的内存的区域。是栈顶的地址和栈的最大容量是系统预先规定好的，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数 ) ,如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 存储每一个函数在执行的时候都会向操作系统索要资源，栈区就是函数运行时的内存，栈区中的变量由编译器负责分配和释放，内存随着函数的运行分配，随着函数的结束而释放，由系统自动完成。 静态分配是编译器完成的，比如自动变量(auto)的分配。 动态分配由alloca函数完成。 栈的动态分配无需释放(是自动的)，也就没有释放函数。 为可移植的程序起见，栈的动态分配操作是不被鼓励的！ 详解代码1：#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;iostream&gt; #include&lt;string.h&gt; static int a=1;//全局初始化区 int b=2;//全局初始化区 char *p;//全局未初始化区 char *p2;//全局未初始化区 int *p3;//全局未初始化区 int *p4;//全局未初始化区 char *p5={&quot;555555555&quot;};//全局初始化区 int main(){ static int c=3;//全局初始化区 int d=4;//内存栈 int e=7;//内存栈 char *p6={&quot;555555555&quot;};//内存栈 p=(char*)malloc(sizeof(char)*10);//内存堆 p2=(char*)malloc(sizeof(char)*10);//内存堆 p3=(int*)malloc(sizeof(int));//内存堆 p4=(int*)malloc(sizeof(int)*10);//内存堆 for(int i=0;i&lt;=9;i++)p4[i]=0x1;//内存栈 *p3=0x123; strcpy(p,&quot;123456789&quot;);//文字常量区 strcpy(p2,&quot;987654321&quot;); strcpy(p2,&quot;123456789&quot;); } 全局初始化区与静态初始化区是在同一段内存 连续分配的，按内存地址增长方向分配 全局初始化区与全局未初始化区不在同一段内存区，全局初始化区按内存地址增长方向分配，全局未初始化区没有规律 栈空间也是同一段内存 连续分配的，按内存地址减小方向分配 堆空间也是同一段内存 连续分配的，按内存地址增大方向分配 文字常量区在自己特有的内存段内，且有机制控制字符常量不被修改（当字符串相同的时候，系统有时还会将两个指针指向同一处） 代码2：在A.m里定义一个全局变量int i =1， 在B.m里直接访问。A中的任意方法都能访问i，但B中方法访问i时预编译不能通过，报use of undeclared identifier _i错误 在A.m里定义一个全局变量int i =1， 在B.m里 extern int i。A中的任意方法都能访问i，B中的方法对i也是可读可写。他们用的是同一个i 在A.m里定义一个静态全局变量static int i =1，在B.m里直接访问。A中的任意方法都能访问i，但B中方法访问i时预编译不能通过，报use of undeclared identifier _i错误 在A.m里定义一个静态全局变量static int i =1，在B.m里 extern int i;A中的任意方法都能访问i，但B中方法访问i时编译不能通过，报Undefined symbols i 错误 在A.m和B.m里分别定义静态全局变量static int i=200; static int i =300;则互不影响，有两个同名但不同存储位置的i，各源文件里的方法访问各自源文件里的i。 在A.m和B.m里分别定义静态全局变量static int i=200; 和全局变量 int i =300;仍然互不影响。如果我在A里extern int i了，A中方法访问的i仍然是200那个，而不是B中那个i 在A.m和B.m里分别定义全局变量int i=200; 和 int i =300;则编译不通过，报duplicate symbol _i错误同样在A.m和B.m里分别定义全局常量const int i =200;和全局变量int i =300 也编译不通过同样的上面7条都适用于全局常量。const int i = 11;和 static const int i =1不同的只是不加const可写，加了const只可读。 在A.h里声明全局变量extern int i;在A.m里定义全局变量int i = 1;在其他源文件里import “A.h”即可访问A中定义的i 全局变量加了static有内部之意，全局不加static则表示真正的全局 非静态全局变量具有全局作用域。 其只需在一个源文件中定义，就可以作用于所有的源文件。 其他不包括全局变量定义的源文件可以通过extern的方式引用。]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>OC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jekyll的使用详解]]></title>
    <url>%2F2011%2F11%2F25%2FJekyll%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[上一章介绍了如何在GitHub Pages中搭建Jekyll，参照Jekyll官网给出的使用文档，这一章我们详细解读一下Jekyll，这是我后边找到的中文文档，可供参考 快速指南上一章简单说了，这是一个简单的静态网页生成器，具体的安装和使用方式请如下： ~ $ gem install jekyll ~ $ jekyll new myblog/. --force ~ $ cd myblog ~/myblog $ bundle install ~/myblog $ bundle exec jekyll serve =&gt; Now browse to http://localhost:4000 目录结构打开Jekyll生成的文件夹后，通过资源管理器可以观察到已经自动生成的目录结构，比较重要的几个如下： _config.yml :存储配置数据。把配置写在这个文件里面，可以让你不用在命令行中写 _drafts:草稿，格式是:没有日期.md _includes:包含一些模板，可以重复利用 _layouts:里面的文件通过{ content }包含_posts里面的文章 _posts:存放你要发表的文章。格式YEAR-MONTH-DAY-title.MARKUP _data:保存数据的。jekyll会自动加载这里的所有的YAML文件，如.yml、.yaml、.json、.csv等结尾的文件，比如你有一个members.yml。那么你可以通过site.data.members访问该文件里的数据 _site：jekyll生成的网站会放在该文件夹下，最好把它放到.gitignore文件里面，这样git就不会管理它了 .jekyll-metadata：这个文件帮助Jekyll记录网站文件的修改日志，在下一次生成网页的时候，只生成那些修改过的文件，这个文件可以加入到.gitignore文件中 index.html：网站首页，jekyll会自动转换并生成它 配置Jekyll有自带的默认配置，如果需要手动修改配置，则需要配置参考文档 头信息通过这个可以设置一些变量（甚至可以自定义变量），比如layout和title --- layout: post title: Blogging Like a Hacker --- 设置好变量以后，你就可以在当前页面或者你的页面依赖的_layouts或者_includes里的文件通过Liquid 标记，比如{page.title}访问了 撰写博客jekyll有一个最好的特性就是：你写文章并发表他们只是意味着你只要管理一些文本文件即可。而不需要配置和维护数据库以及良好的CMS系统 文章文件夹里面都是些md或者testile文件。只要有yaml front matter，它们就会被转换为html格式的静态页面 创建文章的文件创建一个文件YEAR-MONTH-DAY-title.md，YEAR是4位数，month和day是两位数 内容格式所有的文章都必须要有yaml front matter头 注意字符编码：将&lt;meta charset=&quot;utf-8&quot;&gt;包含在head标签里面来保证中文编码的正确性 引用图片和其它资源在根目录下创建文件夹比如assets和downloads，然后markdown语法访问通过这种形式：![截屏](/assets/screenshot.jpg) 说明：截屏链接的文字，（）里面的东西不会显示，是链接到的地址。site.url可以访问你配置的（_config.yml）的网站url 文章的目录 文章摘要 高亮代码片段通过Pygments or Rouge，Jekyll具有内建的语法高亮能力 使用草稿drafts里面的文章是你暂时不想发表的，并且可以没有日期前缀 jekyll serve –drafts 预览 jekyll build –drafts 编译 这两个方法可以使drafts中的草稿文章移动到posts中去，并且自动为其文件名加上当期日期的前缀 创建页面作为写文章的补充，Jekyll 还可以创建静态页面。利用 Jekyll 带来的便利，你只需要复制文件或文件夹，就是这么简单 主页像任何网站的配置一样，需要按约定在站点的根目录下找到 index.html 文件，这个文件将被做为主页显示出来。除非你的站点设置了其它的文件作为默认文件，这个文件就将是你的 Jekyll 生成站点的主页 其它的页面的位置将 HTML 文件或者 Markdown 放在哪里取决于你想让它们如何工作。有两种方式可以创建页面 将为页面准备的命名好的 HTML 文件或者 Markdown 文件放在站点的根目录下 在站点的根目录下为每一个页面创建一个文件夹，并把 index.html 文件或者 index.md 放在每个文件夹里 一般方式： |– _config.yml|– _includes/|– _layouts/|– _posts/|– _site/|– about.html # =&gt; http://example.com/about.html|– index.html # =&gt; http://example.com/└── contact.html # =&gt; http://example.com/contact.html 干净的url方式（不带有文件后缀） ├── _config.yml├── _includes/├── _layouts/├── _posts/├── _site/├── about/| └── index.html # =&gt; http://example.com/about/├── contact/| └── index.html # =&gt; http://example.com/contact/└── index.html # =&gt; http://example.com/ 静态文件为了渲染或转换内容，Jekyll提供了静态文件，静态文件中不包括YAML front matter，而是包括images，PDFs和一些没有被渲染的内容如果要访问这些静态内容，就需要用site.static_files中的metadata，如file.path/modified_time/extname 变量Jekyll会遍历带yaml front matter头的所有文件，然后都可以通过Liquid模板系统访问一些变量 全局变量 site：包含了网站信息和_config.yml里面的信息 page:在yaml front matter的自定义的变量通过page访问 layout:在yaml front matter的自定义的变量通过layout访问 content:_layouts里面，不定义在_post和其他页面中。包含了post和其他页面里面的文章内容 paginator:paginate在_config_yml里面配置以后，这个变量就可以用了 site变量 site.time:当前运行jekyll的时间 site.pages:所有的页面 site.posts:以时间逆序排序的所有的文章 site.data：包含从目录_data里面加载的数据列表 page变量 page.content:页面内容 page.title:文章标题 page.urL:页面地址：比如/2008/12/14/my-post.html page.date:页面的日期。可以在front matter重写：2008-12-14 10:30:00 +0900或者YYYY-MM-DD HH:MM:SS page.id:页面id。比如/2008/12/14/my-post 在RSS feeds里面有用 front matter里面可以自己定义变量：比如custom_css: true,然后你可以通过page.custom_css访问 Paginator变量 paginator.per_page：每一页的文章数 paginator.posts：那一页可用的文章 paginator.page：当前页的值 Paginator只在index.html(或者/blog/index.html)中有效 集合(Collections)并非所有的都会是文章或页面。也许您想要记录您开源项目中涉及的各种解决方案，团队成员，或是某次会议记录。集合（Collection）允许您定义一种新的文档类型，它既可以像页面和文章那样工作，也可以拥有它们特有的属性和命名空间 使用集合 让 Jekyll 读取您的集合:将下面的代码加入您的 _config.yml 文件，将my_collection 替换为您集合的名字 collections: my_collection: foo: bar 加入您的内容 选择性渲染你的集合文件为独立文件 Liquid 属性每个集合均可访问 Liquid 的site变量,每个集合都具有一个他本身的文档数组 数据文件除了 Jekyll 的内建变量之外，你还可以指定用于 Liquid 模板系统 的自定义数据。Jekyll 支持从 data 目录下的 YAML、JSON 和 CSV 载入数据，注意 CSV 文件必须包含表头行。这个强大的特性可以帮你避免模板中的重复，并能在不修改 _config.yml 的情况下设置网站特定的选项。 正如在目录结构中所描述的，_data 目录用于存储供 Jekyll 生成网站的附加数据。这些文件可以使用 .yml、.yaml、.json、csv 扩展名，并可通过 site.data 访问 资源Jekyll 提供了对 Sass 的内建支持，还能通过安装相应的 Ruby gem 支持 CoffeeScript。使用时只需创建以 .sass、.scss 或 .coffee 为扩展名的文件，并以两行 — 开头即可 博客迁移如果你要从其他博客迁移到 Jekyll，Jekyll 导入器可以帮助你]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Jekyll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在GitHubPages上搭建Jekyll]]></title>
    <url>%2F2011%2F10%2F28%2F%E5%9C%A8GitHubPages%E4%B8%8A%E6%90%AD%E5%BB%BAJekyll%2F</url>
    <content type="text"><![CDATA[在GitHub Pages上搭建blog，使我们既拥有绝对权限管理，又享受github带来的便利 Jekyll是一个静态站点生成器，提供了模板、变量、插件等功能，来生成整个网站 GitHub Pages是什么GITHUB是一种分布式的代码仓库管理工具，在GITHUB上每个项目都有一个主页，列出了项目的源文件。但是对于一个新手来说，看到一大堆源码，只会让人头晕脑涨，不知何处入手。他希望看到的是，一个简明易懂的网页，说明每一步应该怎么做。因此，github就设计了Pages功能，允许用户自定义项目首页，用来替代默认的源码列表。所以，github Pages可以被认为是用户编写的、托管在github上的静态网页。github提供模板，允许站内生成网页，但也允许用户自己编写网页，然后上传。有意思的是，这种上传并不是单纯的上传，而是会经过Jekyll程序的再处理。 Jekyll是什么Jekyll（发音/‘dʒiːk əl/，”杰克尔”）是一个静态站点生成器，它会根据网页源码生成静态文件。它提供了模板、变量、插件等功能，所以实际上可以用来编写整个网站整个思路到这里就很明显了。你先在本地编写符合Jekyll规范的网站源码，然后上传到github，由github生成并托管整个网站。 如何实现 注册登录GIT账号 在账号下添加新的git仓库（用户名+github+io） 安装jekyll并创建jekyll目录 安装jekyll目录需要的bundle包 创建Markdown或HTML页面 启动jekyll服务，通过http://localhost:4000访问并验证 将代码上传至github，通过域名来访问]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Jekyll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法的使用]]></title>
    <url>%2F2011%2F09%2F30%2FMarkdown%E8%AF%AD%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[从今天开始，坚持写博客，一般博客中会用到Markdown语法，先找一篇文章来学习总结一下其语法 Markdown语法的目标是实现易写易读，下边的内容就是介绍如何使用Markdown语法 嵌套HTMLMarkdown的语法在HTML标签中无效，但是HTML标签在Markdown语法中是可以直接使用的 特殊字符自动转换在HTML中，有两个字符需要特殊处理:&lt;和&amp;，如「AT&amp;T」 ，你必须要写成「AT&amp;T」，但是在Markdown中，他们可以进行自动转换，不需要特殊处理 段落和换行在Markdown中如果需要换行，则在行尾加上两个以上的空格，然后按回车键 标题Markdown支持两种标题语法，Setext和atx形式 Setex形式是用底线的形式，利用=(大标题)和-(小标题) Atx形式是在行首插入1到6个#，对应标题的大小 引言如果需要在文章中插入引言，则需要在每行的最前面加上&gt;，在引言中可以插入引言和其它的Markdown语法 列表Markdown支持有序的列表和无序的列表，列表中可以嵌套其它的Markdown语法，如引言或代码块 有序列表使用数字接着一个英文句号开头，然后一个空格或制表符 无序的列表使用星号／加号／减号作为列表标记，然后一个空格或制表符 程序块HTML会用&lt;pre&gt;和&lt;code&gt;标签把程序块包起来，Markdown直接简单地缩排4个空格或1个Tab就可以，这样就会转化成HTML的格式 分隔线可以在一行中用三个或以上的*,-,_来建立一个分隔线，行内不能有其他东西 链接Markdown支持两种形式的链接语法，行内和参考，不管用哪一种，链接的文字都是用[方括号]来标记 行内：在方括号的后面马上接着圆括号并插入网址链接即可 参考：在方括号的后面再跟一个方括号，方括号里边填入链接的标签，在文件的任意处，把标签的链接内容定义出来，定义形式为：[foo]: http://example.com/ “Optional Title Here” 强调Markdown使用星号(*)和下划线(_)作为标记强调的标记，被他们包围的文本会转化成斜体文本，用两个包围起来的话，则会被转化成加粗文本，如果要在蚊子前后直接插入普通的星号或下划线，可以用反斜线转义 程序码如果要标记行内一小段程序，可以用反引号把它包围起来 图片Markdown使用一种和链接很相似的语法来标记图片，同样允许两种样式：行内和参考 自动链接只要用方括号扩起来的字符，Markdown就会自动生成链接，链接的文字和链接位置一样，如&lt;http://example.com/&gt; 转义字符如果需要在Markdown中插入一些语法已标记字符，可以在前边加反斜线进行专义]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIS的一些基本概念]]></title>
    <url>%2F2011%2F08%2F26%2FGIS%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[前些天无聊至极，就翻阅了超图公司的 GIS Deskpro 相关产品的帮助文档，感觉对了解他们公司产品和服务没有多大的帮助，反倒觉得那帮助文档是一个很好的全面学习GIS专业知识的好帮手，现在把自己这几天学习到的东西整理一下下： 各桌面产品与功能模块:各桌面产品与功能模块包括： 桌面集成环境 地图模块 标准图幅图框模块 编辑模块 属性模块 配准模块 布局模块 三维模块 栅格分析模块 网络分析模块 工作空间工作空间用于保存用户的工作环境，包括： 当前打开的数据源（位置、别名和打开方式） 底图 专题地图 布局 符号库 线型库等 数据源数据源是由各种类型的数据集（如点、线、面类型数据，TIN、GRID、NetWork）组成的数据集集合, 数据源的属性包括数据源的基本信息和数据源的投影信息 数据集数据集是由同种类型数据组成的数据集合,包括十六种： 纯属性数据集 点数据集 线数据集 面数据集 文本数据集 网络数据集 三维点数据集(文本文件\属性生成或点数据集转换) 三维线数据集 CAD数据集 TIN数据集 路由数据集(存放线类型的数据，线对象的每个节点除了有地理坐标值，还有一个M坐标值，代表该节点到起点的距离) 影像数据集 DEM数据集 Grid数据集 MrSID数据集 ECW数据集 SDB 数据源一个SDB数据源文件包括SDB和SDD两个文件，由SDB文件存储空间数据，由SDD存储管理属性数据。SDD文件其实就是一个Access数据库，它管理着数据源中各数据集对应的属性表。一个数据集对应连接一个属性表，系统通过唯一标识SmID将数据集的每一个对象与对应属性表中的记录进行连接，建立起一一对应的关系。 地图的属性地图的属性，包括地图的信息以及地图上对象的设置信息 TININ是不规则三角网（Triangulated Irregular Network）的缩写，它是采用不规则三角形拟合地表。TIN数据集由存储有Z值的点组成，通过边相连形成连续的不重叠的三角面。主要用来描述数字高程表面。 TIN 的创建TIN通常可以由多种类型矢量数据集来创建, SuperMap 桌面产品提供了把点/三维点/线数据集转换成TIN数据的功能。 DEMDEM（Digital Elevation Modals，数字高程模型）是地面特性为高程和海拔高程的数字地面模型（DTM）。 DEM数据集可以通过线数据集、点线数据集联合以及TIN数据集来生成。 布局布局就是地图（包括专题图）、图例、地图比例尺、方向标图片、文本等各种不同地图内容的混合排版与布置，主要用于电子地图和打印地图。 创建布局创建一个布局就是将所需的布局元素添加到布局窗口中加以整理与修饰，以达到地图所要表示的用途。而布局元素包括了一些地图元素（地图、比例尺、方向标、图例、专题图图例）、绘制元素（点、直线、折线、矩形、圆角矩形、椭圆和多边形）、标注元素（文本和艺术字）和其他相关元素（表格和图片）。 DirectXDirectX加强3d图形和声音效果，并提供设计人员一个共同的硬件驱动标准，让游戏开发者不必为每一品牌的硬件来写不同的驱动程序，也降低用户安装及设置硬件的复杂度。 SuperMap SDX+SuperMap SDX+是SuperMap的空间引擎技术，它提供了一种通用的访问机制（或模式）来访问存储在不同引擎里的数据。这些引擎类型有数据库引擎、文件引擎和 Web 引擎. 引擎优化: 选择合适的硬件平台内存、硬盘、网络 选择使用文件缓存功能 为Layer设置合适的MinVisibleGeometrySize属性值 建立空间索引 建立空间索引 影像数据的优化 SuperMap SDX+ 空间索引 R树索引：R树空间索引方法是通过设计虚拟的矩形目标，将一些空间位置相近的目标对象，包含在这个矩形内，把这些矩形作为空间索引，它含有所包含的空间对象的指针。 四叉树索引： 图库索引 ：根据数据集的某一属性字段或根据给定的一个范围（图幅的长和宽），将空间对象进行分类，通过索引进行管理已分类的空间对象，以此提高查询检索速度。 动态索引：将数据集按照一定的规则划分成相等或不相等的网格，记录每一个地理对象所占的网格位置。在GIS中常用的是规则网格。当用户进行空间查询时，首先计算出用户查询对象所在的网格，通过该网格快速查询所选地理对象。可以优化查询操作。 事务的四个属性在数据库应用程序中，事务是一个比较常见的概念，它是作为单个逻辑工作单元执行的一系列操作。一个逻辑工作单元必须有四个属性，称为ACID（原子性、一致性、隔离性和持久性）属性，只有具备这些属性才能成为一个事务。 原子性:原子性决定事务不可分割，事务必须是原子工作单元，对于其数据所作的修改必须是全执行或全不执行。 一致性:事务在完成时必须使所有的数据都保持一致状态。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。事务结束时所有的内部数据结构（如B树索引或双向链表）都必须是正确的。 隔离性:由并发事务所作的修改必须与其它并发事务所作的修改隔离。事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据，这称为可串行性，因为它能够重新装载起始数据，并且回滚一系列事务，以使数据结束时的状态与原始事务执行的状态相同。 持久性:事务完成之后，它对于系统的影响是永久性的，即使出现系统故障，事务所作的修改也将一直保持。 地图投影的目的地图投影的目的：地球椭球体表面是曲面，而地图通常要绘制在平面图纸上，因此制图时首先要把曲面展为平面。然而球面是个不可展的曲面，所以必须采用特殊的方法将曲面展开，使其成为没有破裂或褶皱的平面，于是就出现了地图投影理论。 地球椭球体地球椭球体（Sphere/Spheroid）由于地球形状的不规则性，不同国家在不同的历史时期对地球进行过无数次测量，导致出现了大量的椭球体，但是由于没有一个椭球体能够准确的描述地球的整体形状，所以在应用时应该根据各个国家或地区的具体情况选择合适的地球椭球体。 大地参照系大地参照系（Datum）大地参照系确定了地球椭球体相对于地球球心的位置，为地表地物的测量提供了一个参照框架，确定了地表经纬网线的原点和方向 地理坐标系地理坐标系（Geographic Coordinate System）一般情况下，一个地理坐标系由三部分组成：大地参照系（Datum），本初子午线（Prime Meridian），角度单位（Angular Units）。 投影坐标系投影坐标系（Projected Coordinate System）投影坐标系是与地理坐标系相对的一个概念，是将椭球面上的点通过地图投影的方式投影到（地图）平面上，分为平面极坐标系和平面直角坐标系。平面直角坐标系按照直角坐标原理确定一点的平面位置，由原点及通过原点的两个垂直相交轴组成，这种坐标也叫笛卡尔坐标或直角坐标。测绘中的直角坐标系与数学中的不同点是，X轴和Y轴互换。 一般情况下，一个投影坐标系包含以下几部分，投影坐标系的名称，坐标单位，投影方式，地理坐标系，投影参数。投影参数常用的有以下几种:地图投影的方法： 几何透视法:以平面、圆柱面、圆锥面为承影面，将曲面（地球椭球体面）转绘到平面（地图）上的一种古老方法 数学解析法:是建立地球椭球体面上的经纬网与平面上相应经纬网之间对应关系的方法。实质就是直接确定球面上某点的地理坐标与平面上对应点的直角坐标之间的函数关系。当前绝大多数地图投影都采用这种方法。 地图投影分类 按投影变形性质分类:按照投影的变形性质可以分为以下几类：等角投影、等积投影、任意投影（等距投影是其中特例）。 按投影构成方式分类:根据投影构成方式可以分为两类：几何投影和解析投影。 几何投影包括方位投影、圆锥投影和圆柱投影。根据投影面与球面的位置关系的不同又可将其划分为：正轴投影、横轴投影、斜轴投影解析投影是不借助于辅助几何面，直接用解析法得到经纬网的一种投影。主要包括：伪圆锥投影，伪圆柱投影，伪方位投影，多圆锥投影。 投影方法目前常用的投影方法有莫卡托投影（正轴等角圆柱投影）、高斯-克吕格投影（等角横切圆柱投影）、UTM 投影（等角横轴割圆柱投影）、Lambert投影（等角正割圆锥投影）等。 莫卡托投影是一种“等角正切圆柱投影” 高斯-克吕格(Gauss-Kruger)投影，是一种“等角横切圆柱投影” UTM投影全称为“通用横轴墨卡托投影”，是一种“等角横轴割圆柱投影” 兰勃托(Lambert)投影，又名“”等角正割圆锥投影”， 坐标系分类数据的坐标系分为三类：平面坐标系、地理坐标系、投影坐标系。 ##数据编码数据编码：是数据在计算机中的存储方式。通常用来减少数据所占的存储空间以及提高数据的安全性，或者作为一种数据交换的格式。GIS数据分为有编码与无编码两种，而采用编码的主要目的，是用一定的压缩方法减少海量数据的存储，大大提高磁盘读写和网络传输的效率，显著提高性能。数据编码是一个压缩的概念，类似于ZIP，RAR等，矢量数据集有多种编码方式，典型的有SDC和SWC两种。 SWC，WORD编码类型，应用于矢量数据集（线、面类型）的一种编码方式，对点数据集不起作用。压缩比为4倍。精度损失为1/216。数据集中对象大小比较平均的情况下，推荐使用此种编码方式。SDC，DWORD编码类型，应用于矢量数据集（线、面类型）的一种编码方式，对点数据集不起作用。压缩比为2倍。精度损失为1/232，按照全球大小的对象估计，精度损失在毫米级。总结其优势：压缩速度快，损失小，原图和编码后的图对比浏览时，基本看不到差别。可以说SDC是几乎接近无损的一种编码方式，一般的数据推荐使用SDC。对一些在空间上相邻，有公共边的面状数据，用SDC编码完全没有问题，但用SWC，在放大很大时会有缝隙显现。数据压缩的代价：压缩之后的数据不可逆，即不可以返回数据压缩之前的状态，此外在精度上有一定的损失，对查询和分析有影响，如果进行非常精确的查询和空间分析等，SWC会导致一些结果上的误差，但SDC不会有影响，其产生的精度损失在空间分析的容限范围之内。 地图缓存地图缓存是一种用于改善地图浏览用户体验的优化策略。服务器端创建了地图缓存之后，客户端用户的每一次地图浏览，比如平移、放大、缩小地图，都会向服务器端发送一个URL请求，此时，服务器端按照匹配的条件，将已缓存的图片返回到客户端。通常将服务器端在发布地图服务之前，已经创建的地图缓存称为预缓存。 为什么使用地图缓存只需要付出一次缓存的代价，就可以提供给客户端地图显示以快速的响应速度。地图缓存是以一系列不同比例尺下地图图片形式提供的，因此不受矢量地图显示上的约束，比如地图信息量的大小、地物的复杂程度、是否带有标注、所使用的地图符号等限制。因为，一般情况下，地图渲染的细节越多，承载的信息量越丰富，同等环境下，绘制矢量地图就越慢，但使用了地图缓存，客户端在获得了同样分辨率显示效果的同时，等待时间却大大缩短，增强了用户的体验，满足系统对快速地图响应的要求。 GIS一般出现的问题与优化方法： 地图反走样 交叉线优化 图层顺序调整 文本层叠优化 地图显示速度优化 反走样 (antialiasing)：在光栅图形显示器上绘制非水平且非垂直的直线或多边形边界时，或多或少会呈现锯齿状或台阶状外观。这是因为直线、多边形、色彩边界等是连续的，而光栅则是由离散的点组成，在光栅显示设备上表现直线、多边形等，必须在离散位置采样。由于采样不充分重建后造成的信息失真，就叫走样(aliasing)。而用于减少或消除这种效果的技术，就称为反走样(antialiasing)。通过地图优化可以去除一些呈现锯齿状或台阶状的显示，提高地图的美观性：一般提高显示速度最好的方法就是减少地图中图层和显示对象，这样将减少系统更新，达到提供显示速度的目的。 地图显示速度优化 对象过滤显示过滤对象尺寸、过滤显示条件、文本字高过滤显示 图层过滤显示 层是否可显示、图层比例尺过滤显示 地图缓存用“地图缓存”功能对当前地图按照设置的比例尺和缓存范围生成一系列的缓存图片。在浏览此地图时可以直接读取缓存中的图片，从而提高地图显示的速度 建立索引提高矢量数据的查询、访问、排序、浏览等操作，提供了多种文件索引，包括字段索引、四叉树索引、R树索引、动态索引和图库索引（原三级索引） 创建影像金字塔 金字塔是栅格数据集的简化分辨率（reduced resolution）图像的集合。影像金字塔技术通过影像重采样方法，建立一系列不同分辨率的影像图层，每个图层分割存储，并建立相应的空间索引机制，从而提高缩放浏览影像时的显示速度。 无地图缩放动画效果 专题图种类SuperMap总共提供了七种专题图以供选择。从图中可以看出，单值专题图，范围分段专题图，统计专题图都具有专题图标签，它们在地图中显示为多种风格，在此称为多元风格专题图。而其他的等级符号专题图、点密度专题图、标签专题图和自定义专题图仅有一个专题图项，没有专题图标签，它们在地图中显示为单一风格，在此称为单一风格专题图。 多元风格专题图这些图都有配色方案，都有标签，都可以设置多个字段（值），在地图中显示可以用多种符号（线型、填充）来表达字段（值）信息，地图画面较为丰富。 单一风格专题图：只能设置一个字段通过一种符号（线型、填充）来表达字段值的信息 地图分类地图一般分为普通地图和专题地图，根据功能的不同又从专题地图里划分了统计地图。 普通地图是以相对均衡的详细程度表示制图区域内各种自然和社会经济现象的地图。其内容包含全地图要素 题地图是以普通地图为地理基础，着重表示制图区域内某一种或几种自然或社会经济现象的地图。这类地图的显著特点是，作为该图主题的专题要素予以详尽表示，其地理基础内容则视主题而异 常用的颜色模式： RGB 模式：RGB 是Red（红色）、Green（绿色）、Blue（蓝色）的缩写。由红、绿、蓝相叠加可以产生其它颜色，因此该模式也叫加色模式 CMYK 模式：CMYK 是Cyan（青）、Magenta（洋红）、Yellow（黄色）以及Black（黑色）的缩写。与RGB模式不同的是它的颜色合成方式不是颜色相加，而是颜色相减 HLS 模式：HLS 是Hue(色调)、Luminance(亮度)、Saturation(饱和度)的缩写。 色调色调是颜色的一种属性，它实质上是色彩的基本颜色，即我们经常讲的红、橙、黄、绿、青、蓝、紫七种，每一种代表一种色调。色调的调整也就是改变它的颜色。 亮度亮度就是各种颜色的图形原色（如RGB的原色为R、G、B三种或各种自的色调）的明暗度，亮度调整也就是明暗度的调整。而我们通常讲的灰度图像，就是在纯白色和纯黑色之间划分了多个级别的亮度，也就是从白到灰，再转黑。同理，在RGB 模式中则代表个原色的明暗度，即红绿蓝三原色的明暗度，从浅到深。 饱和度饱和度是指图像颜色的彩度.对于每一种颜色都有一种人为规定的标准颜色，饱和度就是用描述颜色与标准颜色之间的相近程度的物理量。调整饱和度就是调整图像的彩度。将一个图像的饱和度条为零时，图像则变成一个灰度图像。 地理空间数据交换格式地理空间数据交换格式（Geo-spatial data transfer format）分为矢量、影像和格网三类。其中矢量交换格式，是以VCT为扩展名。 对象（object）：即几何对象，在GIS中对离散空间实体的数字化表示。一个对象具有自己的属性和行为。单一对象（Single Object）：子对象（part）：简单对象（Simple Object）：复杂对象（Complex Object）：复合对象（Compound Object）：参数化对象：对象类型：绘制对象类型 对象运算对象运算主要包含了合并、求交、交集取反、擦除、擦除外部、组合、分解和保护性分解共8中对象运算方式。合并是同类型融合起来，组合是CAD图中的图形组合起来。参与操作的对象为非岛洞多边形的复杂面对象，则分解与保护性分解效果相同。 空间数据的查询和分析空间数据的查询和分析在GIS工程项目中处于核心地位，在使用GIS数据时，我们经常需要从已有的数据中查询出部分满足特定条件的数据。GIS 中的查询类型一般可以分为以下三种：单纯的属性查询、单纯的空间查询、以及与空间位置和属性同时相关的综合查询 SQL语句SQL语句是标准的计算机查询语句，SuperMap中的许多查询功能都是通过构建SQL语句来完成的,SQL表达式的语法为“Select …（需要输出的字段名） from … （数据集名）where…（查询条件）(order by …ascending/descending)（结果排序字段，可选）”。 对数值的查询 :对数值的查询可以使用＝, &lt;&gt;, &gt;, &lt;, &lt;=, &gt;=, Between 等等 模糊查询:模糊查询使用like，而且不同类型的数据源使用的匹配符不尽相同 查询特定值 :使用in，确定表达式的值是否等于指定列表内若干值中的任意一个值 查询某个字段值是否为空 ,使用is NULL (is not NULL) 通过构造语句进行查询 组合语句 :使用and，将两个或者多个查询语句组合起来 比较运算符在字符型字段中的应用 日期型字段的查询 :World_countries.dat = #08/10/94# 派生字段(Pop_2000-Pop_1990)/Pop_1990 as Growth_Rate SQL特殊 系统中提供的SQL查询条件运算符除了常用的数学运算符和逻辑运算符外，还提供了一些比较特殊的运算符 聚合函数对一组值执行计算并得到单一的值。除 COUNT 函数之外，聚合函数忽略空值。聚合函数经常与 SELECT 语句的 GROUP BY 子句一同使用。所有聚合函数都具有确定性。任何时候用一组给定的输入值调用它们时，都得到相同的值。除 COUNT() 外，其它聚合函数均不能对文本数据类型使用. 数学函数对数字表达式进行数学运算并返回运算结果。 数学函数在 SuperMap 中的表达式一般采用属性表的字段名或字段名构成的表达式，如Cos(Slope）、Ceiling(Pop/Area)等 字符串函数用于对字符和二进制字符串进行各种操作，它们返回对字符数据进行操作时通常所需要的值 日期函数用来显示关于日期的信息。这些函数适用于日期类型字段值，并对这些值执行算术运算。可将日期函数用于可使用表达式的任何地方。 空间查询空间查询是通过几何对象之间的空间位置关系来构建过滤条件的一种查询方式。相对于完全由属性过滤条件构建的基于属性的查询，基于空间位置关系且同时可以应用属性过滤条件的称为空间查询。 查询模式22种空间查询模式，其中有9种为基本算子，3种常用算子，10种为组合算子。空间查询涉及三个要素，分别是：搜索对象、被搜索图层及结果记录集]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>GIS</tag>
        <tag>SuperMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构在GIS中的应用]]></title>
    <url>%2F2011%2F07%2F29%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9C%A8GIS%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[计算机是一门研究用计算机进行信息表示和处理的科学。数据结构是数据在计算机中的逻辑和存储结构，GIS是地理信息系统的缩写，地理信息在计算机中的存储和应用非常普遍，所以，本篇文章将会探讨如何利用数据结构的知识，方便而快速的保存和处理地理信息。 这里面涉及到两个问题：信息表示、信息处理，信息表示会影响信息处理 数据结构研究的是信息表示的问题 算法研究的是信息处理的问题 信息表示直接关系到信息处理的算法与效率。信息 （数据）之间往往是有重要的结构关系，数据结构就是对数据表示以及其上操作或功能的封装，分逻辑结构和存储结构两个层面。 逻辑结构逻辑结构定义了数据之间的逻辑结构关系。 数据元素相互之间的关系称为结构，有四类基本结构：集合、线性结构、树形结构、图状结构（网状结构）。 集合结构中的数据元素除了同属于一种类型外，别无其它关系 线性结构中元素之间存在一对一关系 树形结构中元素之间存在一对多关系 图形结构中元素之间存在多对多关系 存储结构存储结构定义了数据实际在计算机中存储结构关系，是某种逻辑结构在计算机上的具体实现，分顺序存储结构和链式存储结构。 顺序存储方法：它是把逻辑上相邻的结点存储在物理位置相邻的存储单元里，结点间的逻辑关系由存储单元的邻接关系来体现，由此得到的存储表示称为顺序存储结构。顺序存储结构是一种最基本的存储表示方法，通常借助于程序设计语言中的数组来实现。 链接存储方法：它不要求逻辑上相邻的结点在物理位置上亦相邻，结点间的逻辑关系是由附加的指针字段表示的。由此得到的存储表示称为链式存储结构，链式存储结构通常借助于程序设计语言中的指针类型来实现。 索引存储方法：除建立存储结点信息外，还建立附加的索引表来标识结点的地址。 散列存储方法：就是根据结点的关键字直接计算出该结点的存储地址。 在GIS开发实现中，空间索引、空间数据存储、地图管理、地图符号化及渲染、空间分析等都会用到很多的数据结构，下面作一些简要介绍，仅供参考，读者可以有不同的实现，效率也会有一些差异。 数组和链表数组或链表，在GIS中应用最为广泛，几乎到处可见其身影。比如，线或多边形就是Point类型的数组，读shapefile文件时，文件已经记录下该要素包含的点数，数组的长度就被确定了，如果添加节点，最好采用封装好的动态数组或链表来存储；网格索引，用二维数组表示，每个数组元素记录下该网格范围所对应的数据存储地址，方便空间数据的检索；图层管理，一张地图是由若干个图层叠加而成，用数组或链表来存储这些图层信息，图层顺序调的整转化为数组或链表的删除和插入。 堆栈和队列堆栈和队列，也属于线性结构，只是比数组和链表多了一些限制，堆栈是先进后出，队列是先进先出。比如，线性四叉树索引，用中序遍历的方法降四叉树线性化，其中树的中序遍历，非递归算法就需要用到堆栈；GPS轨迹跟踪，随着GPS点的增加，轨迹会越来越长，在实时跟踪过程中，可能只需要保留当前最近一段时间的点，更早之前的点被保存到数据库中，不再绘制，所以，采用循环队列来存储GPS当前一些点，利用了GPS时间顺序先进先出的特点，同时能循环利用队列；客户端图片瓦片缓存池，也可以采用循环队列，当前可视范围内获取到的新瓦片插入到队列中，当队列满的时候，淘汰最早存放在队列中的瓦片，同时保持队列缓存池的容量。 优先队列优先队列，是不同于先进先出队列的另一种队列，每次从队列中取出的是具有最高优先权的元素，二叉堆就是优先队列，分最大堆和最小堆，它能快速地从一个集合中找出最大（小）的元素。最优路径，算法中经常执行一步就是从后继节点中找出最优的节点，采用的就是最小堆，它能迅速地找出到当前节点权值最小的节点。 树树，是一种递归定义的数据结构，一对多的关系，树是没有回路的连通图。四叉树索引，就是典型的树结构，按MBR（Minimum Bounding Rectangle 最小外包矩形）相交条件从树根一步步往下查找，筛选出要素子集；OGC中XML解析，XML（GML）结构本身也是树状结构；等高线，嵌套关系的表达，是树结构；属性数据词典库，采用Trie数据结构，多叉树的形式，建立属性词典库，通过字符串的匹配实现属性查询。 图图，是一种数据元素间为多对多关系的数据结构，通常采用邻接矩阵或邻接表的方式来存储。道路网或管网的拓扑构建，道路网或管网属于网状结构，用图来描述节点与弧段之间的拓扑关系，便于最优路径、最大流最小割通路、爆管、旅行商等网络分析。 哈希哈希，设计Hash函数代入key算出地址，存储value值，哈希查找效率高，但可能存在冲突，对内存空间占用相对较大一点。道路网或管网构建，以节点的node_id为key，以后继节点的集合为value；GML引擎，以图层编号为key，属于该图层的要素集合为value；线标注，线被裁减后，通过统一的key来拼接，以不同裁减路段集合为value。 以上简要介绍了GIS常用数据结构，但应用远远不止这些。数据结构＋算法＝程序，在数据表示和处理上，具体采用哪种逻辑结构，需要分析数据元素之间的逻辑关系，而确定了逻辑结构，还要考虑采用什么存储结构来实现，也是需要根据实际情况来分析的，数据结构直接关系到算法的具体实现及效率，在GIS开发实现中应用非常广泛。]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>GIS</tag>
      </tags>
  </entry>
</search>
